{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","path":"js/jquery.autocomplete.min.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"498a3af0d346b9a07d5b83e13344df33f9d804c3","modified":1538410841780},{"_id":"source/SUMMARY.md","hash":"d571158308b02b02f2a5b83b1167e9b2dc7fce14","modified":1538464240296},{"_id":"themes/3-hexo/.gitignore","hash":"5e85fe97e87211619c1db29fd3f3b0dbf16be4a7","modified":1538390542769},{"_id":"themes/3-hexo/README.md","hash":"794c03ffd0399d55d11b9dce610f8419c7106078","modified":1538390542769},{"_id":"themes/3-hexo/_config.yml","hash":"5acbcc26e61abfaaf52db9f89359359edbceda68","modified":1538390542769},{"_id":"source/_posts/.DS_Store","hash":"0e0d3472df35cc3205b83e866d4e625b9abfc4e1","modified":1538460058954},{"_id":"source/_posts/git.md","hash":"b04cfd5e4bd60e6d9747ba8bbe936585742d66ce","modified":1538465198550},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1538389072727},{"_id":"source/_posts/mysqlchang-yong-yu-ju.md","hash":"4e376fd43cb0e864d6326482cbd7b58fd70a77c7","modified":1538448917805},{"_id":"themes/3-hexo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1538390542763},{"_id":"themes/3-hexo/.git/config","hash":"024eec43f4595faf3e671b7491a8685bbe82c293","modified":1538390542765},{"_id":"themes/3-hexo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1538390503410},{"_id":"themes/3-hexo/.git/index","hash":"c75205b9430b067cb0e5eab329b080563a2ee739","modified":1538390542795},{"_id":"themes/3-hexo/.git/packed-refs","hash":"879e9a6bc45f96cec0a215a7550487cca90514ea","modified":1538390542761},{"_id":"themes/3-hexo/layout/index.ejs","hash":"61842de9bda3f9a354d1f88d4289dfd0968320dd","modified":1538390542774},{"_id":"themes/3-hexo/layout/indexs.md","hash":"e98b27005c0fb0d7618ae3815654ac33f8c02313","modified":1538390542774},{"_id":"themes/3-hexo/layout/post.ejs","hash":"810f046277fc49f523a72d1552eab1e39d3c299c","modified":1538390542775},{"_id":"source/_posts/PHP/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1536733675836},{"_id":"source/_posts/iOS/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1536733675830},{"_id":"source/_posts/CShape/CShape不重复启动窗口.md","hash":"d2b8e3abebe63d0eeb7dd84549cfa5e1c46db393","modified":1538456875319},{"_id":"source/_posts/CShape/CShape中的委托和事件.md","hash":"474c035adfcf4531714066a614e19e229f434c41","modified":1538456879702},{"_id":"source/_posts/CShape/CShape使用Mutex实现程序单实例运行.md","hash":"d783f81205a136f70b699abd732b86d7f78a2a4c","modified":1538456882775},{"_id":"source/_posts/CShape/iis发布含有视频的网站.md","hash":"393695578ea6aa6ea538d6dbc1fd91173fe96c49","modified":1538456886123},{"_id":"source/_posts/CShape/vs发布网站中允许更新此预编译站点和网站安全首次速度的关系.md","hash":"47106857821583ce5cd549cbd112b9fece8e76fe","modified":1538456889660},{"_id":"source/_posts/C++/CPPFormat的用法总结.md","hash":"72038104e30c5152e0e97647dabc7f4ae7d27cac","modified":1538460318789},{"_id":"source/_posts/C++/CPPpragmaonce与ifndef的区别.md","hash":"48047972c6e9cca3f84d88a7a2a31a4bdbfee884","modified":1538456708283},{"_id":"source/_posts/C++/CPP处理JSON数据交换格式.md","hash":"e166dfd3c2a243564a43d4ed53b0a306bf21ec4e","modified":1538456718291},{"_id":"source/_posts/C++/CPP的list和vector有什么区别.md","hash":"82c0a61214953a044d26eee3a52a044520599444","modified":1538456697086},{"_id":"source/_posts/C++/CPP识别不同的运行平台linux和win32.md","hash":"9c8a49c6e9b8f4e09fca8c7a7f522a0e9250c742","modified":1538456725479},{"_id":"source/_posts/C++/UTF-8带签名和无签名的区别.md","hash":"4c871ee7ff8049d4822d0a375f8ecb16d83045f3","modified":1538456731283},{"_id":"source/_posts/Hadoop/MacHadoop安裝.md","hash":"324070ab5e4922754b6f6ecab3a0f0dcf193c002","modified":1538446156004},{"_id":"source/_posts/Hadoop/macbian-yi-hadoop.md","hash":"3c58a191ac4fff34f6703617a8059b83a438fefe","modified":1538446143343},{"_id":"source/_posts/Java/Java引用.md","hash":"c56c6ec61dc9d107b16c631e51594c4e4c6d640e","modified":1538460386845},{"_id":"source/_posts/Java/Java生态.md","hash":"97db84793b46d3821298e75c9a1978c550a1d924","modified":1538460434164},{"_id":"source/_posts/Java/intellij-idea.md","hash":"46a1638f5598f7e9711324c41501c51759eb4e0f","modified":1538446344549},{"_id":"source/_posts/Java/java.md","hash":"52dc34f0924dbdde525acff1f557df68d75ca789","modified":1538457059267},{"_id":"source/_posts/Java/javaa-li-gui-fan.md","hash":"f07c61164b6d0170c582e70e9e3d0fc2983b5ec7","modified":1538446351844},{"_id":"source/_posts/Java/javagooglestyle.md","hash":"4edd5d5fc081f3eddc4bf9194dc258967608c7a6","modified":1538446360899},{"_id":"source/_posts/Java/javatui-jian-de-dan-li-xie-fa.md","hash":"a6d416a55efe4cddb6924fea8fc478f8bba75203","modified":1538460269506},{"_id":"source/_posts/Java/ubuntupei-zhi-tomcat.md","hash":"f9b7f91b9923c10053d550954d88c5c8b5659e19","modified":1538461538309},{"_id":"source/_posts/PHP/cong_0_kai_shi_php.md","hash":"cce82f876f0a2fee143379b8ce9a685390ac60ac","modified":1538446419661},{"_id":"source/_posts/PHP/laravel.md","hash":"7402818373e6e4fb783e6bf8cc7cd421ee57ff23","modified":1538448900510},{"_id":"source/_posts/PHP/php_chang_yong.md","hash":"e45a0e7b735328c5cd8a16e1436e0ee207256307","modified":1538446430328},{"_id":"source/_posts/PHP/phppan_duan_wei_kong.md","hash":"5dd52643fa8075fb76f4eb326e08ff660141ba89","modified":1538446439862},{"_id":"source/_posts/ReactNative/.DS_Store","hash":"2b701b97bd3db560545422b921061d9a0fd17fa4","modified":1538451289019},{"_id":"source/_posts/ReactNative/RN代码风格.md","hash":"6862dc032d481a536ec674300e54b60efb7ef827","modified":1538461486877},{"_id":"source/_posts/ReactNative/ReactNativeHTML标签.md","hash":"b417f252ddcf9589c81b1c5d6958e9e393af71cb","modified":1538446644045},{"_id":"source/_posts/ReactNative/ReactNative中的尺寸.md","hash":"2e775d7967f936ca316386a5a05ed80dcbeb0eab","modified":1538446656428},{"_id":"source/_posts/ReactNative/ReactNative处理触摸事件.md","hash":"5ca670ab6e38ce0de012fcb01dd75b506dbd4c7e","modified":1538446674788},{"_id":"source/_posts/ReactNative/android-recat-native.md","hash":"e21c455fe2a46d60c8d8a08ed11df336b164d499","modified":1538447485636},{"_id":"source/_posts/ReactNative/android.md","hash":"c2566384247363f86abaf923c2c48fc4e1bc8067","modified":1538446504414},{"_id":"source/_posts/ReactNative/exports-module.exports.md","hash":"1189b1d2ea58a36e9bc196ed42573fd92fe5b1f0","modified":1538446513504},{"_id":"source/_posts/ReactNative/headless-js.md","hash":"dc4216370d51c155023e84243c75f74cbc4b2ccc","modified":1538446524803},{"_id":"source/_posts/ReactNative/javascript-es6exportexport-default.md","hash":"b3dc3023e36e9c0cb2c0ef4628016be667e85522","modified":1538446542797},{"_id":"source/_posts/ReactNative/javascriptimageview.md","hash":"bfc75ccd4dc4d938803bf339773d69b296cebd12","modified":1538446566124},{"_id":"source/_posts/ReactNative/react-native.md","hash":"3d88a420e5b2fe0052a0f0ac6ad871e14b79efad","modified":1538446592828},{"_id":"source/_posts/ReactNative/react-native图片处理.md","hash":"eb0e6afddd365a310fd21cce6a1500695c7bc09e","modified":1538446610731},{"_id":"source/_posts/ReactNative/reactnative-navigator.md","hash":"431e9aa050a7a6711cc09815516e6e4670a718e0","modified":1538446629272},{"_id":"source/_posts/ReactNative/reacttemp.md","hash":"16813a719608611cac5455ebfa0de3e0239a4626","modified":1538446704773},{"_id":"source/_posts/ReactNative/处理耗时业务事件.md","hash":"68533aa902439cc3da228b22b02a8d81755f2bf9","modified":1538451266653},{"_id":"source/_posts/flutter/flutter-jian-jie.md","hash":"db1e81caf0859f9c1881e2b637328cbf5748aa80","modified":1538446103849},{"_id":"source/_posts/flutter/flutter-kai-fa-bi-ji.md","hash":"a2cbacda2b2424efd2c86017be88c3ebb4a908b9","modified":1538446107621},{"_id":"source/_posts/android/andoridgong-gong-library-shi-xian-fang-fa.md","hash":"fa2efd98ec5f09d4dd9fff20490aeed05adf04c9","modified":1538448764250},{"_id":"source/_posts/android/android-activity-guan-li-985e5d28-android-android-activity-guan-li-985e-md.md","hash":"42f090fff442e7803f5d11a77a7379f36f0e46df","modified":1538448764250},{"_id":"source/_posts/android/android-adbcha-kan-jin-cheng-xin-606f5d28-android-andorid-adb-cha-kan-jin-cheng-xin-606f-md.md","hash":"42f090fff442e7803f5d11a77a7379f36f0e46df","modified":1538448764251},{"_id":"source/_posts/android/android-audiorecordpei-zhi.md","hash":"6c89341e0581ff7685593226aad1e2112cce4f44","modified":1538448764251},{"_id":"source/_posts/android/android.md","hash":"053045d1243fd9b1ac55384922d74a3fee11416c","modified":1538448764251},{"_id":"source/_posts/android/android-studio-tui-jian-cha-jian.md","hash":"5e6d7d340ae5c0d6b945e38b26b240efe5eb8f57","modified":1538448764251},{"_id":"source/_posts/android/androidcomparatorshi-75285d28-android-android-comparator-shi-7528-md.md","hash":"0698f042d019fde7df4afaa87c37756031b62bcd","modified":1538448764251},{"_id":"source/_posts/android/androidcan-kao-gui-fan.md","hash":"b2bb22111ad555736235dd4db647588d591029bd","modified":1538448764251},{"_id":"source/_posts/android/androidshou-shi-chu-li.md","hash":"71dca6c8338164365f81e8173f72aaf37594b43c","modified":1538448764251},{"_id":"source/_posts/android/androidstudioandc++.md","hash":"597836453347ad663249d152cb66273a04a36d2f","modified":1538448764251},{"_id":"source/_posts/android/androidyi-lai-xiang-chong-tu-chu-li.md","hash":"1c8821cf1cd8392957c4649ac1c5443df78a00de","modified":1538448764251},{"_id":"source/_posts/android/androidyin-pin-kai-fa.md","hash":"1534f9fbab1d8813db54760fbc7751b8c549c3c8","modified":1538448764251},{"_id":"source/_posts/android/gradle.md","hash":"f8616a470616448d5e893f431f0a03d2a6135ea6","modified":1538448793419},{"_id":"source/_posts/hybrid/note.md","hash":"f3c3e70db179303d268cabe9e4f9263c45e56529","modified":1538465166127},{"_id":"source/_posts/hybrid/yi-dong-duan-hun-he-kai-fa.md","hash":"a247e8d38d723d8cc9f4a793bfdaa288244c35f4","modified":1538449588500},{"_id":"source/_posts/iOS/iOS Note.md","hash":"153d3568b57ef3f4dc1cd1a2da91b85d3ea24cea","modified":1538446169230},{"_id":"source/_posts/iOS/ios-noteiosios-notemd.md","hash":"168ef862f7a531487c325316834d8b805c3f05de","modified":1538446178502},{"_id":"source/_posts/iOS/ios-shu-ju-cun-chu.md","hash":"79be67c36b76cc7db7834fc00b5f8405ace0ff5f","modified":1538446193804},{"_id":"source/_posts/iOS/ios-swiftsheng-chan-ban-ben-kong-zhi.md","hash":"132a5964b87747cc411de31ac20b17fa36176e6e","modified":1538446275003},{"_id":"source/_posts/iOS/ios-tips.md","hash":"63e987a466f4c00a17a720c4d7b83e52fe14c438","modified":1538451801986},{"_id":"source/_posts/iOS/ios下homebrew基本使用.md","hash":"c8ab3531c1cd35055ab245f96f64f30d5cfc33cd","modified":1538446303014},{"_id":"source/_posts/jQuery/jQuery常用API.md","hash":"02efef1644dd2f03cd567f4477d779e600b9c19d","modified":1538446391934},{"_id":"source/_posts/jQuery/jQuery选择器.md","hash":"3979e6506f946ee3ecb95b707b07a5098f2b76bf","modified":1538446399548},{"_id":"source/_posts/jQuery/jquery_note.md","hash":"4db693035c754734c3173beef3e1fa66cff413a5","modified":1538446380570},{"_id":"source/_posts/python/jekyll.md","hash":"73b0363bb3902f6a8b332ddcba1e098cd9b85c89","modified":1538461347789},{"_id":"source/_posts/python/pythonpa-chong.md","hash":"9424f40d63812335be643beb4cece95e70907caa","modified":1538465073097},{"_id":"source/_posts/python/pythonru-men.md","hash":"af1891de3fc9ac03b06fc0f8b053a208061e1856","modified":1538449319817},{"_id":"source/_posts/xamarin/xarmarinchu-bu-le-jie.md","hash":"541420f9cffd55a1e30dae4610a79a79f429afe4","modified":1538451109497},{"_id":"source/_posts/xamarin/xiang-mu-jie-gou.md","hash":"f9f47a1025bb4c6cc04c1d177154cbaf95236a1d","modified":1538451091190},{"_id":"themes/3-hexo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1538390503411},{"_id":"themes/3-hexo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1538390503411},{"_id":"themes/3-hexo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1538390503412},{"_id":"themes/3-hexo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1538390503412},{"_id":"themes/3-hexo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1538390503411},{"_id":"themes/3-hexo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1538390503413},{"_id":"themes/3-hexo/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1538390503411},{"_id":"themes/3-hexo/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1538390503411},{"_id":"themes/3-hexo/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1538390503412},{"_id":"themes/3-hexo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1538390503413},{"_id":"themes/3-hexo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1538390503410},{"_id":"themes/3-hexo/.git/logs/HEAD","hash":"810b856bb4b78421c52387028db7d8f21b4d2212","modified":1538390542764},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"864251708dac507bb041899d57e9a48759916476","modified":1538390542769},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"5701b04252f113cc78dfde69bd6393fff6b1cce2","modified":1538390542770},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"5507b4dfab2032345e012a0c5356f63b01395157","modified":1538390542770},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"99ae7e411f8d24bed54a27be30bb71ef2041ff7b","modified":1538390542771},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"a6714eed28ede8a50c186ef76798b410c2fb4f31","modified":1538390542772},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"27ad82343ca09685b1a5adea2f3ead70a030a37e","modified":1538390542772},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"7a31274da81c076021692ff7c80a1be3bbf6fa4c","modified":1538390542772},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"7e6c50b6c24de864e0d6a106e6a8e423e312454a","modified":1538390542772},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"866bb0d3964f2938dc5b5a22c24b05d32870820c","modified":1538390542773},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"c2e5cef2377884cd79e5f686fe4f74b082744306","modified":1538390542773},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"1bba114fd5685dadc595a4fdd9ac326c08d48244","modified":1538390542773},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"5f5015bfc77c013f92395a4ac3464d28ab40a2a6","modified":1538390542773},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"55042bba47352551e16add7ecb679b4a59da2b9f","modified":1538390542773},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"da40cb48b6b1f24cbd7107f7c97b04f063e9c299","modified":1538390542774},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"6406251dabda66ef686d4c15edbc3061b6d828b8","modified":1538390542774},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1538390542781},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"83e5569a58663f9322dda64d263a80153790ad68","modified":1538390542786},{"_id":"themes/3-hexo/source/css/style.styl","hash":"c7285882370f522c3bb17055cdf615cf92f48cd0","modified":1538390542787},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"e457d1d3dfefbbd824d154cf756a2c6d10b812a2","modified":1538390542788},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1538390542788},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1538390542789},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1538390542789},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1538390542794},{"_id":"themes/3-hexo/source/js/script.js","hash":"311beeda0e450fc34943616c02da54e2229700a5","modified":1538390542794},{"_id":"themes/3-hexo/source/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1538390542794},{"_id":"source/_posts/C++/CPP入门基础.md","hash":"5fc1873b1267dd836c5451d1ed6501c80d5e97eb","modified":1538456714837},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"8dafb22561698d0758fba9ea2a45abf6ad3512a2","modified":1538390542790},{"_id":"source/_posts/public/image/5572c6821a076_middle.jpg","hash":"623e6698b739197c3b28e63049620891d85be47c","modified":1536733675837},{"_id":"source/_posts/public/image/79341078.jpg","hash":"c3283999951d4cbff4912b986e0a63c5d3dc3ea9","modified":1536733675839},{"_id":"source/_posts/public/image/wps2CAE.tmp1413ad32-b57d-4e91-94cc-3435504accbe.png","hash":"b29eee0e963644a0000a64ec8cc4e65d9822d699","modified":1536733675841},{"_id":"source/_posts/public/image/wps2D5A.tmpa4cb573d-9b6c-4b6f-857f-4f4b2946e583.png","hash":"5bc558621decb05b08e3d2b8b4b2c9cdce443654","modified":1536733675841},{"_id":"source/_posts/public/image/wps2D6B.tmpb8eb001d-3880-41e5-9fae-7514c03a2dbd.png","hash":"6f3030503db7d7d134b4089d5fadd8f31f9bddca","modified":1536733675842},{"_id":"source/_posts/public/image/wps2D6C.tmp76dcd0fb-0178-466e-b8ee-ad7bf53d2c3d.png","hash":"9d90d145083162bd40db1d3ac320be5e94ec2b20","modified":1536733675842},{"_id":"source/_posts/public/image/wps2D8C.tmp49e31cf6-2818-4c6d-b9d9-b564aa5dab26.png","hash":"982548781cd4b27888c1e128792934bcfbd5498c","modified":1536733675843},{"_id":"source/_posts/public/image/wps2D8D.tmp869f0c82-0035-4c9a-864c-2c156624dade.png","hash":"a9c338c953846094091441dfff92312e3a1540dc","modified":1536733675843},{"_id":"source/_posts/public/image/wps2D9E.tmpb9096f0c-b640-4382-994d-7821d13f01d3.png","hash":"fcfb11fc5a74fadfed10bcdf989437d54d163ee6","modified":1536733675844},{"_id":"source/_posts/public/image/wps2D9F.tmp46c8dfa1-c066-44bd-b51f-147c7bdac651.png","hash":"3545cfc5b7c15aa6685056b9b1788a9342b58909","modified":1536733675844},{"_id":"source/_posts/public/image/wps2DAF.tmp977a6924-622b-4c6e-97e4-35dc6da04008.png","hash":"065b5e7ebafd2f1d148a29b2c7a1ceaae7e0f629","modified":1536733675845},{"_id":"source/_posts/public/image/wps2DB0.tmpe9d78a22-69ec-4507-a437-30f45e48907e.png","hash":"aa844f0971881e0e49640be9650281f52b44eb1b","modified":1536733675845},{"_id":"source/_posts/public/image/wps2DC1.tmp00904f12-8ddd-4804-a1e2-938f05776529.png","hash":"54c4e1ed50f96ea84641af6ac14a64ce136a2d2a","modified":1536733675846},{"_id":"themes/3-hexo/.git/objects/pack/pack-6a7947460b294cb67b15a2cd22552cdb623263f7.idx","hash":"09d81b1cc0bd953a80d21fae29f3477560622011","modified":1538390542748},{"_id":"themes/3-hexo/.git/refs/heads/master","hash":"8e0af13ee7441fc51351f60e99c0cc477bc1b072","modified":1538390542764},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"359f73329b9821f3ca3554d306a04d6766110a5a","modified":1538390542770},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"cd0022ce7e6d6efb07a00e87477cdf791f7f6703","modified":1538390542771},{"_id":"themes/3-hexo/layout/_partial/comments/gentie.ejs","hash":"1d6eacdadeb247e3b349ca7168f797beae8ff4c5","modified":1538390542771},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"fad1fcafef7a15f8fa486e87a7c28d5bcd7e1b86","modified":1538390542771},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"f8f9b49c7c7a00d16bd41bb72b90cca3d320d73e","modified":1538390542771},{"_id":"themes/3-hexo/source/css/_partial/autocomplete.styl","hash":"f6847a2c6d35dbd6d06dc591bd34ed2019784048","modified":1538390542775},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"cc0a862b31359a85d12579e49d2eca58d128275c","modified":1538390542775},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f6447a2ac407228e1d53e3455db2919ac0e9f094","modified":1538390542775},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"4f687cbc74caf8a0887f5e89250284a9bce8b5c1","modified":1538390542776},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"6c94d274b11553a982283b16770e0d54405a7bd5","modified":1538390542776},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"0ba318911afbbbffbd2473b472aedf2d3900e978","modified":1538390542776},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"c27f65e1ee2521b4eebf81242369a0825ce5cd6e","modified":1538390542776},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"b600536ee237936c9f09609d96bb0dbb4adfb59b","modified":1538390542777},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"65efbddd23a264e7d1e85f4073228526770e833c","modified":1538390542777},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"4b996440bba8ec755aa70bc6d074d7dbba55ec0c","modified":1538390542777},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"06d0b7a12ccc71cb693f5d07720602fb514c24eb","modified":1538390542778},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1538390542778},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"37ac1ef28b03f46bf3ad2606c86f0e1ec3e4405f","modified":1538390542779},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1538390542779},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1538390542780},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"57c7f100019d57b512aab509185cb0a6eb9aa4c8","modified":1538390542780},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1538390542781},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"69d184a682bcaeba2b180b437dc4431bc3be38aa","modified":1538390542782},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1538390542782},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1538390542782},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1538390542783},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1538390542783},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1538390542783},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1538390542783},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1538390542784},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1538390542784},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1538390542784},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1538390542785},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1538390542785},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1538390542785},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1538390542786},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"933a3b196d01254dea5e6f48105ea15e210ae000","modified":1538390542786},{"_id":"source/_posts/public/image/wps56A9.tmpbc538b65-a399-4d45-b88e-f4c4f9c2a79d.png","hash":"7d27ccd15ab322ab28b78686ccd56a5c7f4b4089","modified":1536733675848},{"_id":"source/_posts/public/image/wps2DC2.tmp403a5b08-3877-475a-9b7d-b215f06ce4ee.png","hash":"8baa3a1a7071b29407eeb1afeb5589bc9d176c71","modified":1536733675847},{"_id":"themes/3-hexo/.git/logs/refs/heads/master","hash":"810b856bb4b78421c52387028db7d8f21b4d2212","modified":1538390542764},{"_id":"themes/3-hexo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1538390542763},{"_id":"source/_posts/public/image/6f86a134-1022-4077-88d1-a300f5c2552c.jpg","hash":"2acba33067b17e8e6d6e62fe63c13659e22bf492","modified":1536733675838},{"_id":"source/_posts/public/image/image001.jpg","hash":"a0d5951805265262d37a7fe875cbe7a39c7ebd72","modified":1536733675840},{"_id":"source/_posts/public/image/isset.png","hash":"aa0fd648b526f00cbf823f9a36c45c64851b90a1","modified":1536733675840},{"_id":"source/_posts/public/image/wps2DE2.tmpcacd9c78-00fa-4071-a6d9-0ca3fbdf0771.png","hash":"fef21ecb7fc86dab5c89d390fe4ae6235a92b6c2","modified":1536733675847},{"_id":"themes/3-hexo/.git/logs/refs/remotes/origin/HEAD","hash":"810b856bb4b78421c52387028db7d8f21b4d2212","modified":1538390542762},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"b864356fbd31b5d694ccc46db97ea78455daf84d","modified":1538390542793},{"_id":"themes/3-hexo/.git/objects/pack/pack-6a7947460b294cb67b15a2cd22552cdb623263f7.pack","hash":"7067a62525da60b2feac1949854c7a4af55f3ab3","modified":1538390542747}],"Category":[{"name":"git","_id":"cjmren4kn0003ntnbpm5ec6bt"},{"name":"MySQL","_id":"cjmren4kq0005ntnbtzjclkzu"},{"name":"CShape","_id":"cjmren4lt000cntnbufzuqfgc"},{"name":"cpp","_id":"cjmren4m4000ontnbkpvjwmo2"},{"name":"Hadoop","_id":"cjmren4mi0019ntnbr3zkkl9l"},{"name":"Java","_id":"cjmren4ml001hntnbp86w2owe"},{"name":"php","_id":"cjmren4n1002dntnbdg1tcvbb"},{"name":"ReactNative","_id":"cjmren4n9002untnb5zbuslc5"},{"name":"es6","_id":"cjmren4ns003qntnbr9910jwy"},{"name":"flutter","_id":"cjmren4o00047ntnbbtoikehg"},{"name":"Android","_id":"cjmren4o1004bntnbipn4punl"},{"name":"hybrid","_id":"cjmren4o7004xntnbi4nomcmb"},{"name":"iOS","_id":"cjmren4o70050ntnbsp0wr6fq"},{"name":"jQuery","_id":"cjmren4oa005bntnb7bkpsmdk"},{"name":"python","_id":"cjmren4od005hntnbqd6y5nud"},{"name":"xamarin","_id":"cjmren4of005nntnb6oi7e8ra"}],"Data":[],"Page":[{"_content":"# Summary\n\n* [Introduction](README.md)\n* [Android](android.md)\n  * [Android Recat Native](android-recat-native.md)\n  * [AndroidStudio&C++](androidstudioandc++.md)\n  * [Android GoogleMap与ScrollView冲突](Android/AndroidGoogleMap与ScrollView冲突.md)\n  * [Android Fresco Note](Android/AndroidFrescoNote.md)\n  * [Android OnLowMemory和OnTrimMemory](Android/AndroidOnLowMemory和OnTrimMemory.md)\n  * [Android L 权限](Android/AndroidPermissionWithVersionL.md)\n  * [Android RecyclerView Note](Android/AndroidRecyclerViewNote.md)\n  * [Android Version](Android/AndroidVersion.md)\n  * [Android关于Post数组到PHP](Android/Android关于Post数组到PHP.md)\n  * [Android關於Edittext的一些軟鍵盤監聽事件](Android/Android關於Edittext的一些軟鍵盤監聽事件.md)\n  * [Android關於webview使用InputFile](Android/Android關於webview使用InputFile.md)\n  * [Android關於動畫](Android/Android關於動畫.md)\n  * [Android繪製圖形shape和selector和layer-list的详细说明](Android/Android繪製圖形shape和selector和layer-list的详细说明.md)\n  * [Android获取图片转角](Android/Android获取图片转角.md)\n  * [Android获取文件大小工具类](Android/Android获取文件大小工具类.md)\n  * [Android开发规范](Android/Android开发规范.md)\n  * [Android屏幕适配](Android/Android屏幕适配.md)\n  * [Android刪除文件](Android/Android刪除文件.md)\n  * [Android使用FacebookSDK](Android/Android使用FacebookSDK.md)\n  * [Android优化笔记--腾讯移动性能评测专家叶方正](Android/Android优化笔记--腾讯移动性能评测专家叶方正.md)\n  * [Android解决Crashlytics下载失败](Android/Android解决Crashlytics下载失败.md)\n  * [Android Selector和Shape的用法](Android/Android-Selector和Shape的用法.md)\n  * [Android关于TextView的使用](Android/Android關於TextView的使用.md)\n  * [Android Activity 管理類](Android/Android Activity管理類.md)\n  * [Android广播](Android/Android广播.md)\n  * [AndroidComparator使用](Android/Android Comparator使用.md)\n  * [Android Notification](Android/AndroidNotification.md)\n  * [Android adb查看进程信息](Android/Andorid Adb查看进程信息.md)\n  * [SDK FOR USERS ON ANDROID](Android/SDK_DFP.md)\n  * [GoogleAnalytics](Android/GoogleAnalytics.md)\n  * [Android Accessibility开发笔记](Android/AndroidAccessibility开发笔记.md)\n  * [Android通过url唤醒app](/Android/AndroidURL唤醒app.md)\n  * [Android Speex](Android/AndroidSpeex.md)\n  * [Android依賴項衝突處理](androidyi-lai-xiang-chong-tu-chu-li.md)\n  * [Android Studio 推薦插件](android-studio-tui-jian-cha-jian.md)\n  * [Android音頻開發](androidyin-pin-kai-fa.md)\n  * [Android手势处理](androidshou-shi-chu-li.md)\n  * [Gradle](gradle.md)\n* [iOS](ios.md)\n  * [MAC下Homebrew基本使用](iOS/ios下homebrew基本使用.md)\n  * [iOS Note](iOS/iOS Note.md)\n  * [iOS tips](iOS/ios-tips.md)\n  * [iOS Swift生產版本控制](iOS/ios-swiftsheng-chan-ban-ben-kong-zhi.md)\n  * [iOS 數據存儲](iOS/ios-shu-ju-cun-chu.md)\n* [ReactNative](reactnative.md)\n  * [初涉Recat Native](Android/AndroidRecatNavite/初涉ReactNative.md)\n  * [React Native中的尺寸和布局](ReactNative/ReactNative中的尺寸.md)\n  * [React使用HTML标签](ReactNative/ReactNativeHTML标签.md)\n  * [React Native图片处理](ReactNative/react-native图片处理.md)\n  * [处理触摸事件](ReactNative/ReactNative处理触摸事件.md)\n  * [处理耗时业务事件](ReactNative/处理耗时业务事件.md)\n  * [ReactNative代码风格](ReactNative/RN代码风格.md)\n  * [Headless JS（后台任务）](ReactNative/headless-js.md)\n  * [exports 和 module.exports 的区别](ReactNative/exports-module.exports.md)\n  * [JavaScript ES6中export及export default的区别](ReactNative/javascript-es6exportexport-default.md)\n  * [Android原生模块](ReactNative/android.md)\n  * [Android ui组件模块](ReactNative/javascriptimageview.md)\n  * [ReactNative Navigator](ReactNative/reactnative-navigator.md)\n  * [ReactTemp](ReactNative/reacttemp.md)\n* C++\n  * [CPPFormat的用法总结](C++/CPPFormat的用法总结.md)\n  * [CPPpragmaonce与ifndef的区别](C++/CPPpragmaonce与ifndef的区别.md)\n  * [CPP处理JSON数据交换格式](C++/CPP处理JSON数据交换格式.md)\n  * [CPP的list和vector有什么区别](C++/CPP的list和vector有什么区别.md)\n  * [CPP入门基础](C++/CPP入门基础.md)\n  * [CPP识别不同的运行平台linux和win32](C++/CPP识别不同的运行平台linux和win32.md)\n  * [UTF-8带签名和无签名的区别](C++/UTF-8带签名和无签名的区别.md)\n* C\\#\n  * [CShape不重复启动窗口](CShape/CShape不重复启动窗口.md)\n  * [CShape使用Mutex实现程序单实例运行](CShape/CShape使用Mutex实现程序单实例运行.md)\n  * [CShape中的委托和事件](CShape/CShape中的委托和事件.md)\n  * [iis发布含有视频的网站](CShape/iis发布含有视频的网站.md)\n  * [vs发布网站中允许更新此预编译站点和网站安全首次速度的关系](CShape/vs发布网站中允许更新此预编译站点和网站安全首次速度的关系.md)\n* jQuery\n  * [jQuery Note](jQuery/jquery_note.md)\n  * [jQuery常用API](jQuery/jQuery常用API.md)\n  * [jQuery选择器](jQuery/jQuery选择器.md)\n* PHP\n  * [从0开始PHP](PHP/cong_0_kai_shi_php.md)\n* [Hadoop](hadoop.md)\n  * [MacHadoop笔记](Hadoop/MacHadoop安裝.md)\n  * [Mac编译Hadoop](Hadoop/macbian-yi-hadoop.md)\n* [ReactNative](reactnative.md)\n  * [初涉Recat Native](Android/AndroidRecatNavite/初涉ReactNative.md)\n  * [React Native中的尺寸和布局](ReactNative/ReactNative中的尺寸.md)\n  * [React使用HTML标签](ReactNative/ReactNativeHTML标签.md)\n  * [React Native图片处理](ReactNative/react-native图片处理.md)\n  * [处理触摸事件](ReactNative/ReactNative处理触摸事件.md)\n  * [处理耗时业务事件](ReactNative/处理耗时业务事件.md)\n  * [ReactNative代码风格](ReactNative/RN代码风格.md)\n  * [Headless JS（后台任务）](ReactNative/headless-js.md)\n  * [exports 和 module.exports 的区别](ReactNative/exports-module.exports.md)\n  * [JavaScript ES6中export及export default的区别](ReactNative/javascript-es6exportexport-default.md)\n  * [Android原生模块](ReactNative/android.md)\n  * [Android ui组件模块](ReactNative/javascriptimageview.md)\n  * [ReactNative Navigator](ReactNative/reactnative-navigator.md)\n  * [ReactTemp](ReactNative/reacttemp.md)\n* Python\n  * [Python爬蟲](pythonpa-chong.md)\n* Xarmarin\n  * [Xarmarin初步了解](xarmarinchu-bu-le-jie.md)\n  * [項目結構](xiang-mu-jie-gou.md)\n* [Jekyll](jekyll.md)\n* [app混合開發方案](yi-dong-duan-hun-he-kai-fa.md)\n* [note](note.md)\n* [git](git.md)\n* [flutter](flutter.md)\n  * [flutter 简介](flutter/flutter-jian-jie.md)\n  * [flutter 开发笔记](flutter/flutter-kai-fa-bi-ji.md)\n\n","source":"SUMMARY.md","raw":"# Summary\n\n* [Introduction](README.md)\n* [Android](android.md)\n  * [Android Recat Native](android-recat-native.md)\n  * [AndroidStudio&C++](androidstudioandc++.md)\n  * [Android GoogleMap与ScrollView冲突](Android/AndroidGoogleMap与ScrollView冲突.md)\n  * [Android Fresco Note](Android/AndroidFrescoNote.md)\n  * [Android OnLowMemory和OnTrimMemory](Android/AndroidOnLowMemory和OnTrimMemory.md)\n  * [Android L 权限](Android/AndroidPermissionWithVersionL.md)\n  * [Android RecyclerView Note](Android/AndroidRecyclerViewNote.md)\n  * [Android Version](Android/AndroidVersion.md)\n  * [Android关于Post数组到PHP](Android/Android关于Post数组到PHP.md)\n  * [Android關於Edittext的一些軟鍵盤監聽事件](Android/Android關於Edittext的一些軟鍵盤監聽事件.md)\n  * [Android關於webview使用InputFile](Android/Android關於webview使用InputFile.md)\n  * [Android關於動畫](Android/Android關於動畫.md)\n  * [Android繪製圖形shape和selector和layer-list的详细说明](Android/Android繪製圖形shape和selector和layer-list的详细说明.md)\n  * [Android获取图片转角](Android/Android获取图片转角.md)\n  * [Android获取文件大小工具类](Android/Android获取文件大小工具类.md)\n  * [Android开发规范](Android/Android开发规范.md)\n  * [Android屏幕适配](Android/Android屏幕适配.md)\n  * [Android刪除文件](Android/Android刪除文件.md)\n  * [Android使用FacebookSDK](Android/Android使用FacebookSDK.md)\n  * [Android优化笔记--腾讯移动性能评测专家叶方正](Android/Android优化笔记--腾讯移动性能评测专家叶方正.md)\n  * [Android解决Crashlytics下载失败](Android/Android解决Crashlytics下载失败.md)\n  * [Android Selector和Shape的用法](Android/Android-Selector和Shape的用法.md)\n  * [Android关于TextView的使用](Android/Android關於TextView的使用.md)\n  * [Android Activity 管理類](Android/Android Activity管理類.md)\n  * [Android广播](Android/Android广播.md)\n  * [AndroidComparator使用](Android/Android Comparator使用.md)\n  * [Android Notification](Android/AndroidNotification.md)\n  * [Android adb查看进程信息](Android/Andorid Adb查看进程信息.md)\n  * [SDK FOR USERS ON ANDROID](Android/SDK_DFP.md)\n  * [GoogleAnalytics](Android/GoogleAnalytics.md)\n  * [Android Accessibility开发笔记](Android/AndroidAccessibility开发笔记.md)\n  * [Android通过url唤醒app](/Android/AndroidURL唤醒app.md)\n  * [Android Speex](Android/AndroidSpeex.md)\n  * [Android依賴項衝突處理](androidyi-lai-xiang-chong-tu-chu-li.md)\n  * [Android Studio 推薦插件](android-studio-tui-jian-cha-jian.md)\n  * [Android音頻開發](androidyin-pin-kai-fa.md)\n  * [Android手势处理](androidshou-shi-chu-li.md)\n  * [Gradle](gradle.md)\n* [iOS](ios.md)\n  * [MAC下Homebrew基本使用](iOS/ios下homebrew基本使用.md)\n  * [iOS Note](iOS/iOS Note.md)\n  * [iOS tips](iOS/ios-tips.md)\n  * [iOS Swift生產版本控制](iOS/ios-swiftsheng-chan-ban-ben-kong-zhi.md)\n  * [iOS 數據存儲](iOS/ios-shu-ju-cun-chu.md)\n* [ReactNative](reactnative.md)\n  * [初涉Recat Native](Android/AndroidRecatNavite/初涉ReactNative.md)\n  * [React Native中的尺寸和布局](ReactNative/ReactNative中的尺寸.md)\n  * [React使用HTML标签](ReactNative/ReactNativeHTML标签.md)\n  * [React Native图片处理](ReactNative/react-native图片处理.md)\n  * [处理触摸事件](ReactNative/ReactNative处理触摸事件.md)\n  * [处理耗时业务事件](ReactNative/处理耗时业务事件.md)\n  * [ReactNative代码风格](ReactNative/RN代码风格.md)\n  * [Headless JS（后台任务）](ReactNative/headless-js.md)\n  * [exports 和 module.exports 的区别](ReactNative/exports-module.exports.md)\n  * [JavaScript ES6中export及export default的区别](ReactNative/javascript-es6exportexport-default.md)\n  * [Android原生模块](ReactNative/android.md)\n  * [Android ui组件模块](ReactNative/javascriptimageview.md)\n  * [ReactNative Navigator](ReactNative/reactnative-navigator.md)\n  * [ReactTemp](ReactNative/reacttemp.md)\n* C++\n  * [CPPFormat的用法总结](C++/CPPFormat的用法总结.md)\n  * [CPPpragmaonce与ifndef的区别](C++/CPPpragmaonce与ifndef的区别.md)\n  * [CPP处理JSON数据交换格式](C++/CPP处理JSON数据交换格式.md)\n  * [CPP的list和vector有什么区别](C++/CPP的list和vector有什么区别.md)\n  * [CPP入门基础](C++/CPP入门基础.md)\n  * [CPP识别不同的运行平台linux和win32](C++/CPP识别不同的运行平台linux和win32.md)\n  * [UTF-8带签名和无签名的区别](C++/UTF-8带签名和无签名的区别.md)\n* C\\#\n  * [CShape不重复启动窗口](CShape/CShape不重复启动窗口.md)\n  * [CShape使用Mutex实现程序单实例运行](CShape/CShape使用Mutex实现程序单实例运行.md)\n  * [CShape中的委托和事件](CShape/CShape中的委托和事件.md)\n  * [iis发布含有视频的网站](CShape/iis发布含有视频的网站.md)\n  * [vs发布网站中允许更新此预编译站点和网站安全首次速度的关系](CShape/vs发布网站中允许更新此预编译站点和网站安全首次速度的关系.md)\n* jQuery\n  * [jQuery Note](jQuery/jquery_note.md)\n  * [jQuery常用API](jQuery/jQuery常用API.md)\n  * [jQuery选择器](jQuery/jQuery选择器.md)\n* PHP\n  * [从0开始PHP](PHP/cong_0_kai_shi_php.md)\n* [Hadoop](hadoop.md)\n  * [MacHadoop笔记](Hadoop/MacHadoop安裝.md)\n  * [Mac编译Hadoop](Hadoop/macbian-yi-hadoop.md)\n* [ReactNative](reactnative.md)\n  * [初涉Recat Native](Android/AndroidRecatNavite/初涉ReactNative.md)\n  * [React Native中的尺寸和布局](ReactNative/ReactNative中的尺寸.md)\n  * [React使用HTML标签](ReactNative/ReactNativeHTML标签.md)\n  * [React Native图片处理](ReactNative/react-native图片处理.md)\n  * [处理触摸事件](ReactNative/ReactNative处理触摸事件.md)\n  * [处理耗时业务事件](ReactNative/处理耗时业务事件.md)\n  * [ReactNative代码风格](ReactNative/RN代码风格.md)\n  * [Headless JS（后台任务）](ReactNative/headless-js.md)\n  * [exports 和 module.exports 的区别](ReactNative/exports-module.exports.md)\n  * [JavaScript ES6中export及export default的区别](ReactNative/javascript-es6exportexport-default.md)\n  * [Android原生模块](ReactNative/android.md)\n  * [Android ui组件模块](ReactNative/javascriptimageview.md)\n  * [ReactNative Navigator](ReactNative/reactnative-navigator.md)\n  * [ReactTemp](ReactNative/reacttemp.md)\n* Python\n  * [Python爬蟲](pythonpa-chong.md)\n* Xarmarin\n  * [Xarmarin初步了解](xarmarinchu-bu-le-jie.md)\n  * [項目結構](xiang-mu-jie-gou.md)\n* [Jekyll](jekyll.md)\n* [app混合開發方案](yi-dong-duan-hun-he-kai-fa.md)\n* [note](note.md)\n* [git](git.md)\n* [flutter](flutter.md)\n  * [flutter 简介](flutter/flutter-jian-jie.md)\n  * [flutter 开发笔记](flutter/flutter-kai-fa-bi-ji.md)\n\n","date":"2018-10-02T07:10:40.296Z","updated":"2018-10-02T07:10:40.296Z","path":"SUMMARY.html","title":"","comments":1,"layout":"page","_id":"cjmren4jc0000ntnbr9ha2ap4","content":"<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ul>\n<li><a href=\"README.md\">Introduction</a></li>\n<li><a href=\"android.md\">Android</a><ul>\n<li><a href=\"android-recat-native.md\">Android Recat Native</a></li>\n<li><a href=\"androidstudioandc++.md\">AndroidStudio&amp;C++</a></li>\n<li><a href=\"Android/AndroidGoogleMap与ScrollView冲突.md\">Android GoogleMap与ScrollView冲突</a></li>\n<li><a href=\"Android/AndroidFrescoNote.md\">Android Fresco Note</a></li>\n<li><a href=\"Android/AndroidOnLowMemory和OnTrimMemory.md\">Android OnLowMemory和OnTrimMemory</a></li>\n<li><a href=\"Android/AndroidPermissionWithVersionL.md\">Android L 权限</a></li>\n<li><a href=\"Android/AndroidRecyclerViewNote.md\">Android RecyclerView Note</a></li>\n<li><a href=\"Android/AndroidVersion.md\">Android Version</a></li>\n<li><a href=\"Android/Android关于Post数组到PHP.md\">Android关于Post数组到PHP</a></li>\n<li><a href=\"Android/Android關於Edittext的一些軟鍵盤監聽事件.md\">Android關於Edittext的一些軟鍵盤監聽事件</a></li>\n<li><a href=\"Android/Android關於webview使用InputFile.md\">Android關於webview使用InputFile</a></li>\n<li><a href=\"Android/Android關於動畫.md\">Android關於動畫</a></li>\n<li><a href=\"Android/Android繪製圖形shape和selector和layer-list的详细说明.md\">Android繪製圖形shape和selector和layer-list的详细说明</a></li>\n<li><a href=\"Android/Android获取图片转角.md\">Android获取图片转角</a></li>\n<li><a href=\"Android/Android获取文件大小工具类.md\">Android获取文件大小工具类</a></li>\n<li><a href=\"Android/Android开发规范.md\">Android开发规范</a></li>\n<li><a href=\"Android/Android屏幕适配.md\">Android屏幕适配</a></li>\n<li><a href=\"Android/Android刪除文件.md\">Android刪除文件</a></li>\n<li><a href=\"Android/Android使用FacebookSDK.md\">Android使用FacebookSDK</a></li>\n<li><a href=\"Android/Android优化笔记--腾讯移动性能评测专家叶方正.md\">Android优化笔记–腾讯移动性能评测专家叶方正</a></li>\n<li><a href=\"Android/Android解决Crashlytics下载失败.md\">Android解决Crashlytics下载失败</a></li>\n<li><a href=\"Android/Android-Selector和Shape的用法.md\">Android Selector和Shape的用法</a></li>\n<li><a href=\"Android/Android關於TextView的使用.md\">Android关于TextView的使用</a></li>\n<li><a href=\"Android/Android Activity管理類.md\">Android Activity 管理類</a></li>\n<li><a href=\"Android/Android广播.md\">Android广播</a></li>\n<li><a href=\"Android/Android Comparator使用.md\">AndroidComparator使用</a></li>\n<li><a href=\"Android/AndroidNotification.md\">Android Notification</a></li>\n<li><a href=\"Android/Andorid Adb查看进程信息.md\">Android adb查看进程信息</a></li>\n<li><a href=\"Android/SDK_DFP.md\">SDK FOR USERS ON ANDROID</a></li>\n<li><a href=\"Android/GoogleAnalytics.md\">GoogleAnalytics</a></li>\n<li><a href=\"Android/AndroidAccessibility开发笔记.md\">Android Accessibility开发笔记</a></li>\n<li><a href=\"/Android/AndroidURL唤醒app.md\">Android通过url唤醒app</a></li>\n<li><a href=\"Android/AndroidSpeex.md\">Android Speex</a></li>\n<li><a href=\"androidyi-lai-xiang-chong-tu-chu-li.md\">Android依賴項衝突處理</a></li>\n<li><a href=\"android-studio-tui-jian-cha-jian.md\">Android Studio 推薦插件</a></li>\n<li><a href=\"androidyin-pin-kai-fa.md\">Android音頻開發</a></li>\n<li><a href=\"androidshou-shi-chu-li.md\">Android手势处理</a></li>\n<li><a href=\"gradle.md\">Gradle</a></li>\n</ul>\n</li>\n<li><a href=\"ios.md\">iOS</a><ul>\n<li><a href=\"iOS/ios下homebrew基本使用.md\">MAC下Homebrew基本使用</a></li>\n<li><a href=\"iOS/iOS Note.md\">iOS Note</a></li>\n<li><a href=\"iOS/ios-tips.md\">iOS tips</a></li>\n<li><a href=\"iOS/ios-swiftsheng-chan-ban-ben-kong-zhi.md\">iOS Swift生產版本控制</a></li>\n<li><a href=\"iOS/ios-shu-ju-cun-chu.md\">iOS 數據存儲</a></li>\n</ul>\n</li>\n<li><a href=\"reactnative.md\">ReactNative</a><ul>\n<li><a href=\"Android/AndroidRecatNavite/初涉ReactNative.md\">初涉Recat Native</a></li>\n<li><a href=\"ReactNative/ReactNative中的尺寸.md\">React Native中的尺寸和布局</a></li>\n<li><a href=\"ReactNative/ReactNativeHTML标签.md\">React使用HTML标签</a></li>\n<li><a href=\"ReactNative/react-native图片处理.md\">React Native图片处理</a></li>\n<li><a href=\"ReactNative/ReactNative处理触摸事件.md\">处理触摸事件</a></li>\n<li><a href=\"ReactNative/处理耗时业务事件.md\">处理耗时业务事件</a></li>\n<li><a href=\"ReactNative/RN代码风格.md\">ReactNative代码风格</a></li>\n<li><a href=\"ReactNative/headless-js.md\">Headless JS（后台任务）</a></li>\n<li><a href=\"ReactNative/exports-module.exports.md\">exports 和 module.exports 的区别</a></li>\n<li><a href=\"ReactNative/javascript-es6exportexport-default.md\">JavaScript ES6中export及export default的区别</a></li>\n<li><a href=\"ReactNative/android.md\">Android原生模块</a></li>\n<li><a href=\"ReactNative/javascriptimageview.md\">Android ui组件模块</a></li>\n<li><a href=\"ReactNative/reactnative-navigator.md\">ReactNative Navigator</a></li>\n<li><a href=\"ReactNative/reacttemp.md\">ReactTemp</a></li>\n</ul>\n</li>\n<li>C++<ul>\n<li><a href=\"C++/CPPFormat的用法总结.md\">CPPFormat的用法总结</a></li>\n<li><a href=\"C++/CPPpragmaonce与ifndef的区别.md\">CPPpragmaonce与ifndef的区别</a></li>\n<li><a href=\"C++/CPP处理JSON数据交换格式.md\">CPP处理JSON数据交换格式</a></li>\n<li><a href=\"C++/CPP的list和vector有什么区别.md\">CPP的list和vector有什么区别</a></li>\n<li><a href=\"C++/CPP入门基础.md\">CPP入门基础</a></li>\n<li><a href=\"C++/CPP识别不同的运行平台linux和win32.md\">CPP识别不同的运行平台linux和win32</a></li>\n<li><a href=\"C++/UTF-8带签名和无签名的区别.md\">UTF-8带签名和无签名的区别</a></li>\n</ul>\n</li>\n<li>C#<ul>\n<li><a href=\"CShape/CShape不重复启动窗口.md\">CShape不重复启动窗口</a></li>\n<li><a href=\"CShape/CShape使用Mutex实现程序单实例运行.md\">CShape使用Mutex实现程序单实例运行</a></li>\n<li><a href=\"CShape/CShape中的委托和事件.md\">CShape中的委托和事件</a></li>\n<li><a href=\"CShape/iis发布含有视频的网站.md\">iis发布含有视频的网站</a></li>\n<li><a href=\"CShape/vs发布网站中允许更新此预编译站点和网站安全首次速度的关系.md\">vs发布网站中允许更新此预编译站点和网站安全首次速度的关系</a></li>\n</ul>\n</li>\n<li>jQuery<ul>\n<li><a href=\"jQuery/jquery_note.md\">jQuery Note</a></li>\n<li><a href=\"jQuery/jQuery常用API.md\">jQuery常用API</a></li>\n<li><a href=\"jQuery/jQuery选择器.md\">jQuery选择器</a></li>\n</ul>\n</li>\n<li>PHP<ul>\n<li><a href=\"PHP/cong_0_kai_shi_php.md\">从0开始PHP</a></li>\n</ul>\n</li>\n<li><a href=\"hadoop.md\">Hadoop</a><ul>\n<li><a href=\"Hadoop/MacHadoop安裝.md\">MacHadoop笔记</a></li>\n<li><a href=\"Hadoop/macbian-yi-hadoop.md\">Mac编译Hadoop</a></li>\n</ul>\n</li>\n<li><a href=\"reactnative.md\">ReactNative</a><ul>\n<li><a href=\"Android/AndroidRecatNavite/初涉ReactNative.md\">初涉Recat Native</a></li>\n<li><a href=\"ReactNative/ReactNative中的尺寸.md\">React Native中的尺寸和布局</a></li>\n<li><a href=\"ReactNative/ReactNativeHTML标签.md\">React使用HTML标签</a></li>\n<li><a href=\"ReactNative/react-native图片处理.md\">React Native图片处理</a></li>\n<li><a href=\"ReactNative/ReactNative处理触摸事件.md\">处理触摸事件</a></li>\n<li><a href=\"ReactNative/处理耗时业务事件.md\">处理耗时业务事件</a></li>\n<li><a href=\"ReactNative/RN代码风格.md\">ReactNative代码风格</a></li>\n<li><a href=\"ReactNative/headless-js.md\">Headless JS（后台任务）</a></li>\n<li><a href=\"ReactNative/exports-module.exports.md\">exports 和 module.exports 的区别</a></li>\n<li><a href=\"ReactNative/javascript-es6exportexport-default.md\">JavaScript ES6中export及export default的区别</a></li>\n<li><a href=\"ReactNative/android.md\">Android原生模块</a></li>\n<li><a href=\"ReactNative/javascriptimageview.md\">Android ui组件模块</a></li>\n<li><a href=\"ReactNative/reactnative-navigator.md\">ReactNative Navigator</a></li>\n<li><a href=\"ReactNative/reacttemp.md\">ReactTemp</a></li>\n</ul>\n</li>\n<li>Python<ul>\n<li><a href=\"pythonpa-chong.md\">Python爬蟲</a></li>\n</ul>\n</li>\n<li>Xarmarin<ul>\n<li><a href=\"xarmarinchu-bu-le-jie.md\">Xarmarin初步了解</a></li>\n<li><a href=\"xiang-mu-jie-gou.md\">項目結構</a></li>\n</ul>\n</li>\n<li><a href=\"jekyll.md\">Jekyll</a></li>\n<li><a href=\"yi-dong-duan-hun-he-kai-fa.md\">app混合開發方案</a></li>\n<li><a href=\"note.md\">note</a></li>\n<li><a href=\"git.md\">git</a></li>\n<li><a href=\"flutter.md\">flutter</a><ul>\n<li><a href=\"flutter/flutter-jian-jie.md\">flutter 简介</a></li>\n<li><a href=\"flutter/flutter-kai-fa-bi-ji.md\">flutter 开发笔记</a></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h1><ul>\n<li><a href=\"README.md\">Introduction</a></li>\n<li><a href=\"android.md\">Android</a><ul>\n<li><a href=\"android-recat-native.md\">Android Recat Native</a></li>\n<li><a href=\"androidstudioandc++.md\">AndroidStudio&amp;C++</a></li>\n<li><a href=\"Android/AndroidGoogleMap与ScrollView冲突.md\">Android GoogleMap与ScrollView冲突</a></li>\n<li><a href=\"Android/AndroidFrescoNote.md\">Android Fresco Note</a></li>\n<li><a href=\"Android/AndroidOnLowMemory和OnTrimMemory.md\">Android OnLowMemory和OnTrimMemory</a></li>\n<li><a href=\"Android/AndroidPermissionWithVersionL.md\">Android L 权限</a></li>\n<li><a href=\"Android/AndroidRecyclerViewNote.md\">Android RecyclerView Note</a></li>\n<li><a href=\"Android/AndroidVersion.md\">Android Version</a></li>\n<li><a href=\"Android/Android关于Post数组到PHP.md\">Android关于Post数组到PHP</a></li>\n<li><a href=\"Android/Android關於Edittext的一些軟鍵盤監聽事件.md\">Android關於Edittext的一些軟鍵盤監聽事件</a></li>\n<li><a href=\"Android/Android關於webview使用InputFile.md\">Android關於webview使用InputFile</a></li>\n<li><a href=\"Android/Android關於動畫.md\">Android關於動畫</a></li>\n<li><a href=\"Android/Android繪製圖形shape和selector和layer-list的详细说明.md\">Android繪製圖形shape和selector和layer-list的详细说明</a></li>\n<li><a href=\"Android/Android获取图片转角.md\">Android获取图片转角</a></li>\n<li><a href=\"Android/Android获取文件大小工具类.md\">Android获取文件大小工具类</a></li>\n<li><a href=\"Android/Android开发规范.md\">Android开发规范</a></li>\n<li><a href=\"Android/Android屏幕适配.md\">Android屏幕适配</a></li>\n<li><a href=\"Android/Android刪除文件.md\">Android刪除文件</a></li>\n<li><a href=\"Android/Android使用FacebookSDK.md\">Android使用FacebookSDK</a></li>\n<li><a href=\"Android/Android优化笔记--腾讯移动性能评测专家叶方正.md\">Android优化笔记–腾讯移动性能评测专家叶方正</a></li>\n<li><a href=\"Android/Android解决Crashlytics下载失败.md\">Android解决Crashlytics下载失败</a></li>\n<li><a href=\"Android/Android-Selector和Shape的用法.md\">Android Selector和Shape的用法</a></li>\n<li><a href=\"Android/Android關於TextView的使用.md\">Android关于TextView的使用</a></li>\n<li><a href=\"Android/Android Activity管理類.md\">Android Activity 管理類</a></li>\n<li><a href=\"Android/Android广播.md\">Android广播</a></li>\n<li><a href=\"Android/Android Comparator使用.md\">AndroidComparator使用</a></li>\n<li><a href=\"Android/AndroidNotification.md\">Android Notification</a></li>\n<li><a href=\"Android/Andorid Adb查看进程信息.md\">Android adb查看进程信息</a></li>\n<li><a href=\"Android/SDK_DFP.md\">SDK FOR USERS ON ANDROID</a></li>\n<li><a href=\"Android/GoogleAnalytics.md\">GoogleAnalytics</a></li>\n<li><a href=\"Android/AndroidAccessibility开发笔记.md\">Android Accessibility开发笔记</a></li>\n<li><a href=\"/Android/AndroidURL唤醒app.md\">Android通过url唤醒app</a></li>\n<li><a href=\"Android/AndroidSpeex.md\">Android Speex</a></li>\n<li><a href=\"androidyi-lai-xiang-chong-tu-chu-li.md\">Android依賴項衝突處理</a></li>\n<li><a href=\"android-studio-tui-jian-cha-jian.md\">Android Studio 推薦插件</a></li>\n<li><a href=\"androidyin-pin-kai-fa.md\">Android音頻開發</a></li>\n<li><a href=\"androidshou-shi-chu-li.md\">Android手势处理</a></li>\n<li><a href=\"gradle.md\">Gradle</a></li>\n</ul>\n</li>\n<li><a href=\"ios.md\">iOS</a><ul>\n<li><a href=\"iOS/ios下homebrew基本使用.md\">MAC下Homebrew基本使用</a></li>\n<li><a href=\"iOS/iOS Note.md\">iOS Note</a></li>\n<li><a href=\"iOS/ios-tips.md\">iOS tips</a></li>\n<li><a href=\"iOS/ios-swiftsheng-chan-ban-ben-kong-zhi.md\">iOS Swift生產版本控制</a></li>\n<li><a href=\"iOS/ios-shu-ju-cun-chu.md\">iOS 數據存儲</a></li>\n</ul>\n</li>\n<li><a href=\"reactnative.md\">ReactNative</a><ul>\n<li><a href=\"Android/AndroidRecatNavite/初涉ReactNative.md\">初涉Recat Native</a></li>\n<li><a href=\"ReactNative/ReactNative中的尺寸.md\">React Native中的尺寸和布局</a></li>\n<li><a href=\"ReactNative/ReactNativeHTML标签.md\">React使用HTML标签</a></li>\n<li><a href=\"ReactNative/react-native图片处理.md\">React Native图片处理</a></li>\n<li><a href=\"ReactNative/ReactNative处理触摸事件.md\">处理触摸事件</a></li>\n<li><a href=\"ReactNative/处理耗时业务事件.md\">处理耗时业务事件</a></li>\n<li><a href=\"ReactNative/RN代码风格.md\">ReactNative代码风格</a></li>\n<li><a href=\"ReactNative/headless-js.md\">Headless JS（后台任务）</a></li>\n<li><a href=\"ReactNative/exports-module.exports.md\">exports 和 module.exports 的区别</a></li>\n<li><a href=\"ReactNative/javascript-es6exportexport-default.md\">JavaScript ES6中export及export default的区别</a></li>\n<li><a href=\"ReactNative/android.md\">Android原生模块</a></li>\n<li><a href=\"ReactNative/javascriptimageview.md\">Android ui组件模块</a></li>\n<li><a href=\"ReactNative/reactnative-navigator.md\">ReactNative Navigator</a></li>\n<li><a href=\"ReactNative/reacttemp.md\">ReactTemp</a></li>\n</ul>\n</li>\n<li>C++<ul>\n<li><a href=\"C++/CPPFormat的用法总结.md\">CPPFormat的用法总结</a></li>\n<li><a href=\"C++/CPPpragmaonce与ifndef的区别.md\">CPPpragmaonce与ifndef的区别</a></li>\n<li><a href=\"C++/CPP处理JSON数据交换格式.md\">CPP处理JSON数据交换格式</a></li>\n<li><a href=\"C++/CPP的list和vector有什么区别.md\">CPP的list和vector有什么区别</a></li>\n<li><a href=\"C++/CPP入门基础.md\">CPP入门基础</a></li>\n<li><a href=\"C++/CPP识别不同的运行平台linux和win32.md\">CPP识别不同的运行平台linux和win32</a></li>\n<li><a href=\"C++/UTF-8带签名和无签名的区别.md\">UTF-8带签名和无签名的区别</a></li>\n</ul>\n</li>\n<li>C#<ul>\n<li><a href=\"CShape/CShape不重复启动窗口.md\">CShape不重复启动窗口</a></li>\n<li><a href=\"CShape/CShape使用Mutex实现程序单实例运行.md\">CShape使用Mutex实现程序单实例运行</a></li>\n<li><a href=\"CShape/CShape中的委托和事件.md\">CShape中的委托和事件</a></li>\n<li><a href=\"CShape/iis发布含有视频的网站.md\">iis发布含有视频的网站</a></li>\n<li><a href=\"CShape/vs发布网站中允许更新此预编译站点和网站安全首次速度的关系.md\">vs发布网站中允许更新此预编译站点和网站安全首次速度的关系</a></li>\n</ul>\n</li>\n<li>jQuery<ul>\n<li><a href=\"jQuery/jquery_note.md\">jQuery Note</a></li>\n<li><a href=\"jQuery/jQuery常用API.md\">jQuery常用API</a></li>\n<li><a href=\"jQuery/jQuery选择器.md\">jQuery选择器</a></li>\n</ul>\n</li>\n<li>PHP<ul>\n<li><a href=\"PHP/cong_0_kai_shi_php.md\">从0开始PHP</a></li>\n</ul>\n</li>\n<li><a href=\"hadoop.md\">Hadoop</a><ul>\n<li><a href=\"Hadoop/MacHadoop安裝.md\">MacHadoop笔记</a></li>\n<li><a href=\"Hadoop/macbian-yi-hadoop.md\">Mac编译Hadoop</a></li>\n</ul>\n</li>\n<li><a href=\"reactnative.md\">ReactNative</a><ul>\n<li><a href=\"Android/AndroidRecatNavite/初涉ReactNative.md\">初涉Recat Native</a></li>\n<li><a href=\"ReactNative/ReactNative中的尺寸.md\">React Native中的尺寸和布局</a></li>\n<li><a href=\"ReactNative/ReactNativeHTML标签.md\">React使用HTML标签</a></li>\n<li><a href=\"ReactNative/react-native图片处理.md\">React Native图片处理</a></li>\n<li><a href=\"ReactNative/ReactNative处理触摸事件.md\">处理触摸事件</a></li>\n<li><a href=\"ReactNative/处理耗时业务事件.md\">处理耗时业务事件</a></li>\n<li><a href=\"ReactNative/RN代码风格.md\">ReactNative代码风格</a></li>\n<li><a href=\"ReactNative/headless-js.md\">Headless JS（后台任务）</a></li>\n<li><a href=\"ReactNative/exports-module.exports.md\">exports 和 module.exports 的区别</a></li>\n<li><a href=\"ReactNative/javascript-es6exportexport-default.md\">JavaScript ES6中export及export default的区别</a></li>\n<li><a href=\"ReactNative/android.md\">Android原生模块</a></li>\n<li><a href=\"ReactNative/javascriptimageview.md\">Android ui组件模块</a></li>\n<li><a href=\"ReactNative/reactnative-navigator.md\">ReactNative Navigator</a></li>\n<li><a href=\"ReactNative/reacttemp.md\">ReactTemp</a></li>\n</ul>\n</li>\n<li>Python<ul>\n<li><a href=\"pythonpa-chong.md\">Python爬蟲</a></li>\n</ul>\n</li>\n<li>Xarmarin<ul>\n<li><a href=\"xarmarinchu-bu-le-jie.md\">Xarmarin初步了解</a></li>\n<li><a href=\"xiang-mu-jie-gou.md\">項目結構</a></li>\n</ul>\n</li>\n<li><a href=\"jekyll.md\">Jekyll</a></li>\n<li><a href=\"yi-dong-duan-hun-he-kai-fa.md\">app混合開發方案</a></li>\n<li><a href=\"note.md\">note</a></li>\n<li><a href=\"git.md\">git</a></li>\n<li><a href=\"flutter.md\">flutter</a><ul>\n<li><a href=\"flutter/flutter-jian-jie.md\">flutter 简介</a></li>\n<li><a href=\"flutter/flutter-kai-fa-bi-ji.md\">flutter 开发笔记</a></li>\n</ul>\n</li>\n</ul>\n"}],"Post":[{"title":"git 操作","date":"2018-10-02T01:09:09.000Z","_content":"git 添加子模塊\n\ngit submodule add git://github.com/chneukirchen/rack.git rack\n\n","source":"_posts/git.md","raw":"---\ntitle: git 操作\ndate: 2018-10-02 09:09:09\ncategories: git\n---\ngit 添加子模塊\n\ngit submodule add git://github.com/chneukirchen/rack.git rack\n\n","slug":"git","published":1,"updated":"2018-10-02T07:26:38.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4ki0001ntnbbilee5pu","content":"<p>git 添加子模塊</p>\n<p>git submodule add git://github.com/chneukirchen/rack.git rack</p>\n","site":{"data":{}},"excerpt":"","more":"<p>git 添加子模塊</p>\n<p>git submodule add git://github.com/chneukirchen/rack.git rack</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-10-01T10:17:52.727Z","updated":"2018-10-01T10:17:52.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4kl0002ntnbscswxnmq","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"MySQL","date":"2018-10-02T01:09:09.000Z","_content":"1.創建時間和修改時間\n\n    CREATE TABLE `tb_user` (\n      `id` int(11) NOT NULL AUTO_INCREMENT,\n      `name` varchar(45) COLLATE utf8_bin DEFAULT NULL,\n      `password` varchar(45) COLLATE utf8_bin DEFAULT NULL,\n      `isDelete` int(11) DEFAULT NULL,\n      `createDate` datetime DEFAULT CURRENT_TIMESTAMP,\n      `modifyDate` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n      PRIMARY KEY (`id`)\n    ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;\n\n\n\n\n","source":"_posts/mysqlchang-yong-yu-ju.md","raw":"---\ntitle: MySQL\ndate: 2018-10-02 09:09:09\ncategories: MySQL\n---\n1.創建時間和修改時間\n\n    CREATE TABLE `tb_user` (\n      `id` int(11) NOT NULL AUTO_INCREMENT,\n      `name` varchar(45) COLLATE utf8_bin DEFAULT NULL,\n      `password` varchar(45) COLLATE utf8_bin DEFAULT NULL,\n      `isDelete` int(11) DEFAULT NULL,\n      `createDate` datetime DEFAULT CURRENT_TIMESTAMP,\n      `modifyDate` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n      PRIMARY KEY (`id`)\n    ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;\n\n\n\n\n","slug":"mysqlchang-yong-yu-ju","published":1,"updated":"2018-10-02T02:55:17.805Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4kp0004ntnbqy2n7trx","content":"<p>1.創建時間和修改時間</p>\n<pre><code>CREATE TABLE `tb_user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(45) COLLATE utf8_bin DEFAULT NULL,\n  `password` varchar(45) COLLATE utf8_bin DEFAULT NULL,\n  `isDelete` int(11) DEFAULT NULL,\n  `createDate` datetime DEFAULT CURRENT_TIMESTAMP,\n  `modifyDate` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>1.創建時間和修改時間</p>\n<pre><code>CREATE TABLE `tb_user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(45) COLLATE utf8_bin DEFAULT NULL,\n  `password` varchar(45) COLLATE utf8_bin DEFAULT NULL,\n  `isDelete` int(11) DEFAULT NULL,\n  `createDate` datetime DEFAULT CURRENT_TIMESTAMP,\n  `modifyDate` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;\n</code></pre>"},{"_content":"","source":"_posts/PHP/README.md","raw":"","slug":"PHP/README","published":1,"date":"2018-09-12T06:27:55.836Z","updated":"2018-09-12T06:27:55.836Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4l60008ntnbfj7hvp7s","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"","source":"_posts/iOS/README.md","raw":"","slug":"iOS/README","published":1,"date":"2018-09-12T06:27:55.830Z","updated":"2018-09-12T06:27:55.830Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4l80009ntnbw2iqxhsx","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"C#不重复启动窗口","date":"2018-10-02T01:09:09.000Z","_content":"# C#不重复启动窗口\n\n只启动一个窗体,如果再次启动则激活该窗体 \n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Windows.Forms;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\nnamespace TEST\n{\n    static class Program\n    {\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        \n        [DllImport(\"User32.dll\")]\n        private static extern bool ShowWindowAsync(IntPtr hWnd, int cmdShow);\n        [DllImport(\"User32.dll\")]\n        private static extern bool SetForegroundWindow(IntPtr hWnd);\n        private const int WS_SHOWNORMAL = 1;\n        [STAThread]\n        static void Main()\n        {\n            //得到正在运行的例程\n            Process instance = RunningInstance();\n            if (instance == null)\n            {\n                //如果没有其它例程，就新建一个窗体\n                Application.EnableVisualStyles();\n                Application.SetCompatibleTextRenderingDefault(false);\n                Application.Run(new Form1());\n            }\n            else\n            {\n                //处理发现的例程\n                HandleRunningInstance(instance);\n            }\n        }\n        /// <summary>\n        /// 得到正在运行的进程\n        /// </summary>\n        /// <returns></returns>\n        public static Process RunningInstance()\n        {\n            Process current = Process.GetCurrentProcess();\n            Process[] processes = Process.GetProcessesByName(current.ProcessName);\n            //遍历正在有相同名字运行的进程\n            foreach (Process process in processes)\n            {\n                //忽略现有的进程\n                if (process.Id != current.Id)\n                {\n                    //确保进程从EXE文件运行\n                    if (process.MainModule.FileName == current.MainModule.FileName)\n                    {\n                        // 返回另一个进程实例\n                        return process;\n                    }\n                }\n            }\n            //没有其它的进程，返回Null\n            return null;\n        }\n        /// <summary>\n        /// 处理正在运行的进程,也就是将其激活\n        /// </summary>\n        /// <param name=\"instance\">要处理的进程</param>\n        public static void HandleRunningInstance(Process instance)\n        {\n            //确保窗口没有被最小化或最大化\n            ShowWindowAsync(instance.MainWindowHandle, WS_SHOWNORMAL);\n            //设置真实进程为foreground window\n            SetForegroundWindow(instance.MainWindowHandle);\n        }\n    }\n}\n```\n>来源：\n>[1]: <http://blog.csdn.net/xiefuzhen/article/details/4095683>\n ","source":"_posts/CShape/CShape不重复启动窗口.md","raw":"---\ntitle: C#不重复启动窗口\ndate: 2018-10-02 09:09:09\ncategories: CShape\n---\n# C#不重复启动窗口\n\n只启动一个窗体,如果再次启动则激活该窗体 \n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Windows.Forms;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\nnamespace TEST\n{\n    static class Program\n    {\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        \n        [DllImport(\"User32.dll\")]\n        private static extern bool ShowWindowAsync(IntPtr hWnd, int cmdShow);\n        [DllImport(\"User32.dll\")]\n        private static extern bool SetForegroundWindow(IntPtr hWnd);\n        private const int WS_SHOWNORMAL = 1;\n        [STAThread]\n        static void Main()\n        {\n            //得到正在运行的例程\n            Process instance = RunningInstance();\n            if (instance == null)\n            {\n                //如果没有其它例程，就新建一个窗体\n                Application.EnableVisualStyles();\n                Application.SetCompatibleTextRenderingDefault(false);\n                Application.Run(new Form1());\n            }\n            else\n            {\n                //处理发现的例程\n                HandleRunningInstance(instance);\n            }\n        }\n        /// <summary>\n        /// 得到正在运行的进程\n        /// </summary>\n        /// <returns></returns>\n        public static Process RunningInstance()\n        {\n            Process current = Process.GetCurrentProcess();\n            Process[] processes = Process.GetProcessesByName(current.ProcessName);\n            //遍历正在有相同名字运行的进程\n            foreach (Process process in processes)\n            {\n                //忽略现有的进程\n                if (process.Id != current.Id)\n                {\n                    //确保进程从EXE文件运行\n                    if (process.MainModule.FileName == current.MainModule.FileName)\n                    {\n                        // 返回另一个进程实例\n                        return process;\n                    }\n                }\n            }\n            //没有其它的进程，返回Null\n            return null;\n        }\n        /// <summary>\n        /// 处理正在运行的进程,也就是将其激活\n        /// </summary>\n        /// <param name=\"instance\">要处理的进程</param>\n        public static void HandleRunningInstance(Process instance)\n        {\n            //确保窗口没有被最小化或最大化\n            ShowWindowAsync(instance.MainWindowHandle, WS_SHOWNORMAL);\n            //设置真实进程为foreground window\n            SetForegroundWindow(instance.MainWindowHandle);\n        }\n    }\n}\n```\n>来源：\n>[1]: <http://blog.csdn.net/xiefuzhen/article/details/4095683>\n ","slug":"CShape/CShape不重复启动窗口","published":1,"updated":"2018-10-02T05:07:55.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4lr000antnbnuross5e","content":"<h1 id=\"C-不重复启动窗口\"><a href=\"#C-不重复启动窗口\" class=\"headerlink\" title=\"C#不重复启动窗口\"></a>C#不重复启动窗口</h1><p>只启动一个窗体,如果再次启动则激活该窗体 </p>\n<pre><code class=\"c#\">using System;\nusing System.Collections.Generic;\nusing System.Windows.Forms;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\nnamespace TEST\n{\n    static class Program\n    {\n        /// &lt;summary&gt;\n        /// 应用程序的主入口点。\n        /// &lt;/summary&gt;\n\n        [DllImport(&quot;User32.dll&quot;)]\n        private static extern bool ShowWindowAsync(IntPtr hWnd, int cmdShow);\n        [DllImport(&quot;User32.dll&quot;)]\n        private static extern bool SetForegroundWindow(IntPtr hWnd);\n        private const int WS_SHOWNORMAL = 1;\n        [STAThread]\n        static void Main()\n        {\n            //得到正在运行的例程\n            Process instance = RunningInstance();\n            if (instance == null)\n            {\n                //如果没有其它例程，就新建一个窗体\n                Application.EnableVisualStyles();\n                Application.SetCompatibleTextRenderingDefault(false);\n                Application.Run(new Form1());\n            }\n            else\n            {\n                //处理发现的例程\n                HandleRunningInstance(instance);\n            }\n        }\n        /// &lt;summary&gt;\n        /// 得到正在运行的进程\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static Process RunningInstance()\n        {\n            Process current = Process.GetCurrentProcess();\n            Process[] processes = Process.GetProcessesByName(current.ProcessName);\n            //遍历正在有相同名字运行的进程\n            foreach (Process process in processes)\n            {\n                //忽略现有的进程\n                if (process.Id != current.Id)\n                {\n                    //确保进程从EXE文件运行\n                    if (process.MainModule.FileName == current.MainModule.FileName)\n                    {\n                        // 返回另一个进程实例\n                        return process;\n                    }\n                }\n            }\n            //没有其它的进程，返回Null\n            return null;\n        }\n        /// &lt;summary&gt;\n        /// 处理正在运行的进程,也就是将其激活\n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;instance&quot;&gt;要处理的进程&lt;/param&gt;\n        public static void HandleRunningInstance(Process instance)\n        {\n            //确保窗口没有被最小化或最大化\n            ShowWindowAsync(instance.MainWindowHandle, WS_SHOWNORMAL);\n            //设置真实进程为foreground window\n            SetForegroundWindow(instance.MainWindowHandle);\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<p>来源：<br>[1]: <a href=\"http://blog.csdn.net/xiefuzhen/article/details/4095683\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/xiefuzhen/article/details/4095683</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C-不重复启动窗口\"><a href=\"#C-不重复启动窗口\" class=\"headerlink\" title=\"C#不重复启动窗口\"></a>C#不重复启动窗口</h1><p>只启动一个窗体,如果再次启动则激活该窗体 </p>\n<pre><code class=\"c#\">using System;\nusing System.Collections.Generic;\nusing System.Windows.Forms;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\nnamespace TEST\n{\n    static class Program\n    {\n        /// &lt;summary&gt;\n        /// 应用程序的主入口点。\n        /// &lt;/summary&gt;\n\n        [DllImport(&quot;User32.dll&quot;)]\n        private static extern bool ShowWindowAsync(IntPtr hWnd, int cmdShow);\n        [DllImport(&quot;User32.dll&quot;)]\n        private static extern bool SetForegroundWindow(IntPtr hWnd);\n        private const int WS_SHOWNORMAL = 1;\n        [STAThread]\n        static void Main()\n        {\n            //得到正在运行的例程\n            Process instance = RunningInstance();\n            if (instance == null)\n            {\n                //如果没有其它例程，就新建一个窗体\n                Application.EnableVisualStyles();\n                Application.SetCompatibleTextRenderingDefault(false);\n                Application.Run(new Form1());\n            }\n            else\n            {\n                //处理发现的例程\n                HandleRunningInstance(instance);\n            }\n        }\n        /// &lt;summary&gt;\n        /// 得到正在运行的进程\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static Process RunningInstance()\n        {\n            Process current = Process.GetCurrentProcess();\n            Process[] processes = Process.GetProcessesByName(current.ProcessName);\n            //遍历正在有相同名字运行的进程\n            foreach (Process process in processes)\n            {\n                //忽略现有的进程\n                if (process.Id != current.Id)\n                {\n                    //确保进程从EXE文件运行\n                    if (process.MainModule.FileName == current.MainModule.FileName)\n                    {\n                        // 返回另一个进程实例\n                        return process;\n                    }\n                }\n            }\n            //没有其它的进程，返回Null\n            return null;\n        }\n        /// &lt;summary&gt;\n        /// 处理正在运行的进程,也就是将其激活\n        /// &lt;/summary&gt;\n        /// &lt;param name=&quot;instance&quot;&gt;要处理的进程&lt;/param&gt;\n        public static void HandleRunningInstance(Process instance)\n        {\n            //确保窗口没有被最小化或最大化\n            ShowWindowAsync(instance.MainWindowHandle, WS_SHOWNORMAL);\n            //设置真实进程为foreground window\n            SetForegroundWindow(instance.MainWindowHandle);\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<p>来源：<br>[1]: <a href=\"http://blog.csdn.net/xiefuzhen/article/details/4095683\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/xiefuzhen/article/details/4095683</a></p>\n</blockquote>\n"},{"title":"C#使用Mutex实现程序单实例运行","date":"2018-10-02T01:09:09.000Z","_content":"# C#使用Mutex实现程序单实例运行\n\n大家在开发程序的时候，有时需要限制程序，只能同时运行一个实例，实现此功能，对于VB.NET是非常容易的，只要指定一个属性即可，但是C#实现起来，就稍微繁琐了。\nC#实现单实例运行的方法，也有多种，比如利用 Process 查找进程的方式，利用 API findwindow 查找窗体的方式，还有就是 利用 Mutex 原子操作，上面几种方法中， 综合考虑利用 Mutex 的方式是较好的选择。\n下面给出使用 Mutex 实现单实例运行的例子：\nC# 中，找到 program.cs ，这里面的 \n\n```c#\n[STAThread]\n \nstatic\nvoid Main()\n \n{\n \n    //……\n \n}\n```\n\n是程序运行的入口点，默认情况下，里面的代码大致如下： \n```c#\n[STAThread]\nstatic void Main()\n{\n    Application.EnableVisualStyles();\n    Application.SetCompatibleTextRenderingDefault(false);\n    Application.Run(new Form1());\n}\n```\n复制代码\n加入单实例限制后的代码如下： \n```c#\n[STAThread]\nstatic void Main()\n{\n    bool isAppRunning = false;\n    System.Threading.Mutex mutex = new System.Threading.Mutex(\n        true,\n        System.Diagnostics.Process.GetCurrentProcess().ProcessName,\n        out isAppRunning);\n    if (!isAppRunning)\n    {\n        MessageBox.Show(\"本程序已经在运行了，请不要重复运行！\");\n        Environment.Exit(1);\n    }\n    else\n    {\n        Application.EnableVisualStyles();\n        Application.SetCompatibleTextRenderingDefault(false);\n        Application.Run(new Form1());\n    }\n}\n```\n另一个利用Mutex实现互斥的类\n```c#\nusing System; \nusing System.Collections.Generic; \nusing System.Linq; \nusing System.Text; \nusing System.Threading ; \n \nnamespace 多线程 \n{ \n    class Mutex互斥类 \n    { \n        public static void Main() \n        { \n            //Mutex互斥类主要特点就是进程间共享，进程间互相排斥，抢锁,用名称做标识。 \n            bool createdNew ; \n            Mutex mutex = new Mutex( false , \"Aladdin\" , out createdNew ) ; \n \n            if( mutex.WaitOne(1000,false ) ) \n            { \n                try \n                { \n                    Console.WriteLine( \"正常启动。。。。。\" ) ; \n                    Console.ReadLine() ; \n                } \n                finally \n                { \n                    mutex.ReleaseMutex() ; \n                } \n            } \n            else \n            { \n                Console.WriteLine( \"你已经启动了一个了，不要再闹了\" ) ; \n                Console.Read() ; \n            } \n \n            //注，如果单纯判断一个互斥线程是不是已经存在，可以直接用createdNew out参数来判断 \n        } \n    } \n}\n```\n>来源：\n>[1]: <http://hi.baidu.com/szhesh/item/c3c28b27ebf5423394f62b01>\n ","source":"_posts/CShape/CShape使用Mutex实现程序单实例运行.md","raw":"---\ntitle: C#使用Mutex实现程序单实例运行\ndate: 2018-10-02 09:09:09\ncategories: CShape\n---\n# C#使用Mutex实现程序单实例运行\n\n大家在开发程序的时候，有时需要限制程序，只能同时运行一个实例，实现此功能，对于VB.NET是非常容易的，只要指定一个属性即可，但是C#实现起来，就稍微繁琐了。\nC#实现单实例运行的方法，也有多种，比如利用 Process 查找进程的方式，利用 API findwindow 查找窗体的方式，还有就是 利用 Mutex 原子操作，上面几种方法中， 综合考虑利用 Mutex 的方式是较好的选择。\n下面给出使用 Mutex 实现单实例运行的例子：\nC# 中，找到 program.cs ，这里面的 \n\n```c#\n[STAThread]\n \nstatic\nvoid Main()\n \n{\n \n    //……\n \n}\n```\n\n是程序运行的入口点，默认情况下，里面的代码大致如下： \n```c#\n[STAThread]\nstatic void Main()\n{\n    Application.EnableVisualStyles();\n    Application.SetCompatibleTextRenderingDefault(false);\n    Application.Run(new Form1());\n}\n```\n复制代码\n加入单实例限制后的代码如下： \n```c#\n[STAThread]\nstatic void Main()\n{\n    bool isAppRunning = false;\n    System.Threading.Mutex mutex = new System.Threading.Mutex(\n        true,\n        System.Diagnostics.Process.GetCurrentProcess().ProcessName,\n        out isAppRunning);\n    if (!isAppRunning)\n    {\n        MessageBox.Show(\"本程序已经在运行了，请不要重复运行！\");\n        Environment.Exit(1);\n    }\n    else\n    {\n        Application.EnableVisualStyles();\n        Application.SetCompatibleTextRenderingDefault(false);\n        Application.Run(new Form1());\n    }\n}\n```\n另一个利用Mutex实现互斥的类\n```c#\nusing System; \nusing System.Collections.Generic; \nusing System.Linq; \nusing System.Text; \nusing System.Threading ; \n \nnamespace 多线程 \n{ \n    class Mutex互斥类 \n    { \n        public static void Main() \n        { \n            //Mutex互斥类主要特点就是进程间共享，进程间互相排斥，抢锁,用名称做标识。 \n            bool createdNew ; \n            Mutex mutex = new Mutex( false , \"Aladdin\" , out createdNew ) ; \n \n            if( mutex.WaitOne(1000,false ) ) \n            { \n                try \n                { \n                    Console.WriteLine( \"正常启动。。。。。\" ) ; \n                    Console.ReadLine() ; \n                } \n                finally \n                { \n                    mutex.ReleaseMutex() ; \n                } \n            } \n            else \n            { \n                Console.WriteLine( \"你已经启动了一个了，不要再闹了\" ) ; \n                Console.Read() ; \n            } \n \n            //注，如果单纯判断一个互斥线程是不是已经存在，可以直接用createdNew out参数来判断 \n        } \n    } \n}\n```\n>来源：\n>[1]: <http://hi.baidu.com/szhesh/item/c3c28b27ebf5423394f62b01>\n ","slug":"CShape/CShape使用Mutex实现程序单实例运行","published":1,"updated":"2018-10-02T05:08:02.775Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4ls000bntnb3asqrn05","content":"<h1 id=\"C-使用Mutex实现程序单实例运行\"><a href=\"#C-使用Mutex实现程序单实例运行\" class=\"headerlink\" title=\"C#使用Mutex实现程序单实例运行\"></a>C#使用Mutex实现程序单实例运行</h1><p>大家在开发程序的时候，有时需要限制程序，只能同时运行一个实例，实现此功能，对于VB.NET是非常容易的，只要指定一个属性即可，但是C#实现起来，就稍微繁琐了。<br>C#实现单实例运行的方法，也有多种，比如利用 Process 查找进程的方式，利用 API findwindow 查找窗体的方式，还有就是 利用 Mutex 原子操作，上面几种方法中， 综合考虑利用 Mutex 的方式是较好的选择。<br>下面给出使用 Mutex 实现单实例运行的例子：<br>C# 中，找到 program.cs ，这里面的 </p>\n<pre><code class=\"c#\">[STAThread]\n\nstatic\nvoid Main()\n\n{\n\n    //……\n\n}\n</code></pre>\n<p>是程序运行的入口点，默认情况下，里面的代码大致如下： </p>\n<pre><code class=\"c#\">[STAThread]\nstatic void Main()\n{\n    Application.EnableVisualStyles();\n    Application.SetCompatibleTextRenderingDefault(false);\n    Application.Run(new Form1());\n}\n</code></pre>\n<p>复制代码<br>加入单实例限制后的代码如下： </p>\n<pre><code class=\"c#\">[STAThread]\nstatic void Main()\n{\n    bool isAppRunning = false;\n    System.Threading.Mutex mutex = new System.Threading.Mutex(\n        true,\n        System.Diagnostics.Process.GetCurrentProcess().ProcessName,\n        out isAppRunning);\n    if (!isAppRunning)\n    {\n        MessageBox.Show(&quot;本程序已经在运行了，请不要重复运行！&quot;);\n        Environment.Exit(1);\n    }\n    else\n    {\n        Application.EnableVisualStyles();\n        Application.SetCompatibleTextRenderingDefault(false);\n        Application.Run(new Form1());\n    }\n}\n</code></pre>\n<p>另一个利用Mutex实现互斥的类</p>\n<pre><code class=\"c#\">using System; \nusing System.Collections.Generic; \nusing System.Linq; \nusing System.Text; \nusing System.Threading ; \n\nnamespace 多线程 \n{ \n    class Mutex互斥类 \n    { \n        public static void Main() \n        { \n            //Mutex互斥类主要特点就是进程间共享，进程间互相排斥，抢锁,用名称做标识。 \n            bool createdNew ; \n            Mutex mutex = new Mutex( false , &quot;Aladdin&quot; , out createdNew ) ; \n\n            if( mutex.WaitOne(1000,false ) ) \n            { \n                try \n                { \n                    Console.WriteLine( &quot;正常启动。。。。。&quot; ) ; \n                    Console.ReadLine() ; \n                } \n                finally \n                { \n                    mutex.ReleaseMutex() ; \n                } \n            } \n            else \n            { \n                Console.WriteLine( &quot;你已经启动了一个了，不要再闹了&quot; ) ; \n                Console.Read() ; \n            } \n\n            //注，如果单纯判断一个互斥线程是不是已经存在，可以直接用createdNew out参数来判断 \n        } \n    } \n}\n</code></pre>\n<blockquote>\n<p>来源：<br>[1]: <a href=\"http://hi.baidu.com/szhesh/item/c3c28b27ebf5423394f62b01\" target=\"_blank\" rel=\"noopener\">http://hi.baidu.com/szhesh/item/c3c28b27ebf5423394f62b01</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C-使用Mutex实现程序单实例运行\"><a href=\"#C-使用Mutex实现程序单实例运行\" class=\"headerlink\" title=\"C#使用Mutex实现程序单实例运行\"></a>C#使用Mutex实现程序单实例运行</h1><p>大家在开发程序的时候，有时需要限制程序，只能同时运行一个实例，实现此功能，对于VB.NET是非常容易的，只要指定一个属性即可，但是C#实现起来，就稍微繁琐了。<br>C#实现单实例运行的方法，也有多种，比如利用 Process 查找进程的方式，利用 API findwindow 查找窗体的方式，还有就是 利用 Mutex 原子操作，上面几种方法中， 综合考虑利用 Mutex 的方式是较好的选择。<br>下面给出使用 Mutex 实现单实例运行的例子：<br>C# 中，找到 program.cs ，这里面的 </p>\n<pre><code class=\"c#\">[STAThread]\n\nstatic\nvoid Main()\n\n{\n\n    //……\n\n}\n</code></pre>\n<p>是程序运行的入口点，默认情况下，里面的代码大致如下： </p>\n<pre><code class=\"c#\">[STAThread]\nstatic void Main()\n{\n    Application.EnableVisualStyles();\n    Application.SetCompatibleTextRenderingDefault(false);\n    Application.Run(new Form1());\n}\n</code></pre>\n<p>复制代码<br>加入单实例限制后的代码如下： </p>\n<pre><code class=\"c#\">[STAThread]\nstatic void Main()\n{\n    bool isAppRunning = false;\n    System.Threading.Mutex mutex = new System.Threading.Mutex(\n        true,\n        System.Diagnostics.Process.GetCurrentProcess().ProcessName,\n        out isAppRunning);\n    if (!isAppRunning)\n    {\n        MessageBox.Show(&quot;本程序已经在运行了，请不要重复运行！&quot;);\n        Environment.Exit(1);\n    }\n    else\n    {\n        Application.EnableVisualStyles();\n        Application.SetCompatibleTextRenderingDefault(false);\n        Application.Run(new Form1());\n    }\n}\n</code></pre>\n<p>另一个利用Mutex实现互斥的类</p>\n<pre><code class=\"c#\">using System; \nusing System.Collections.Generic; \nusing System.Linq; \nusing System.Text; \nusing System.Threading ; \n\nnamespace 多线程 \n{ \n    class Mutex互斥类 \n    { \n        public static void Main() \n        { \n            //Mutex互斥类主要特点就是进程间共享，进程间互相排斥，抢锁,用名称做标识。 \n            bool createdNew ; \n            Mutex mutex = new Mutex( false , &quot;Aladdin&quot; , out createdNew ) ; \n\n            if( mutex.WaitOne(1000,false ) ) \n            { \n                try \n                { \n                    Console.WriteLine( &quot;正常启动。。。。。&quot; ) ; \n                    Console.ReadLine() ; \n                } \n                finally \n                { \n                    mutex.ReleaseMutex() ; \n                } \n            } \n            else \n            { \n                Console.WriteLine( &quot;你已经启动了一个了，不要再闹了&quot; ) ; \n                Console.Read() ; \n            } \n\n            //注，如果单纯判断一个互斥线程是不是已经存在，可以直接用createdNew out参数来判断 \n        } \n    } \n}\n</code></pre>\n<blockquote>\n<p>来源：<br>[1]: <a href=\"http://hi.baidu.com/szhesh/item/c3c28b27ebf5423394f62b01\" target=\"_blank\" rel=\"noopener\">http://hi.baidu.com/szhesh/item/c3c28b27ebf5423394f62b01</a></p>\n</blockquote>\n"},{"title":"iis发布含有视频的网站","date":"2018-10-02T01:09:09.000Z","_content":"# iis发布含有视频的网站\n\n\nwin2003下\n打开IIS，然后在 mypc（本地计算机） 上面点击右键属性（很多帮助文件都没有说这一点，很多人以为是在站点上面点击右键，却发现找不到MIME类型，其中mypc是你的计算机名）\n图片点击可在新窗口打开查看\n然后点击“MIME类型”，接着点击新建，\nflv格式是加入关联扩展名：.flv，内容类型：application/octet-stream\nf4v格式是扩展名：.f4v，内容类型：application/octet-stream\nmp4格式是扩展名：.mp4，内容类型：video/mp4\n要注意的是，内容类型并不是跟扩展名配套的，你起别的名称一要，只是做个说明而已\n确定以后，服务器就可以支持FLV,f4v,mp4视频播放了，如果依然不可以的话，可以尝试重新启动IIS！\nwin7的iis里\n默认支持flv文件 调用使用时路径用绝对路径就可以了，比如你的视频在video/a.flv的，请直接用/video/a.flv，如果需要支持f4v,mp4请参考2003的设置\n\n ![](image001.jpg)\n \n转载:ckplayer.com\n ","source":"_posts/CShape/iis发布含有视频的网站.md","raw":"---\ntitle: iis发布含有视频的网站\ndate: 2018-10-02 09:09:09\ncategories: CShape\n---\n# iis发布含有视频的网站\n\n\nwin2003下\n打开IIS，然后在 mypc（本地计算机） 上面点击右键属性（很多帮助文件都没有说这一点，很多人以为是在站点上面点击右键，却发现找不到MIME类型，其中mypc是你的计算机名）\n图片点击可在新窗口打开查看\n然后点击“MIME类型”，接着点击新建，\nflv格式是加入关联扩展名：.flv，内容类型：application/octet-stream\nf4v格式是扩展名：.f4v，内容类型：application/octet-stream\nmp4格式是扩展名：.mp4，内容类型：video/mp4\n要注意的是，内容类型并不是跟扩展名配套的，你起别的名称一要，只是做个说明而已\n确定以后，服务器就可以支持FLV,f4v,mp4视频播放了，如果依然不可以的话，可以尝试重新启动IIS！\nwin7的iis里\n默认支持flv文件 调用使用时路径用绝对路径就可以了，比如你的视频在video/a.flv的，请直接用/video/a.flv，如果需要支持f4v,mp4请参考2003的设置\n\n ![](image001.jpg)\n \n转载:ckplayer.com\n ","slug":"CShape/iis发布含有视频的网站","published":1,"updated":"2018-10-02T05:08:06.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4lu000dntnb26hnbsav","content":"<h1 id=\"iis发布含有视频的网站\"><a href=\"#iis发布含有视频的网站\" class=\"headerlink\" title=\"iis发布含有视频的网站\"></a>iis发布含有视频的网站</h1><p>win2003下<br>打开IIS，然后在 mypc（本地计算机） 上面点击右键属性（很多帮助文件都没有说这一点，很多人以为是在站点上面点击右键，却发现找不到MIME类型，其中mypc是你的计算机名）<br>图片点击可在新窗口打开查看<br>然后点击“MIME类型”，接着点击新建，<br>flv格式是加入关联扩展名：.flv，内容类型：application/octet-stream<br>f4v格式是扩展名：.f4v，内容类型：application/octet-stream<br>mp4格式是扩展名：.mp4，内容类型：video/mp4<br>要注意的是，内容类型并不是跟扩展名配套的，你起别的名称一要，只是做个说明而已<br>确定以后，服务器就可以支持FLV,f4v,mp4视频播放了，如果依然不可以的话，可以尝试重新启动IIS！<br>win7的iis里<br>默认支持flv文件 调用使用时路径用绝对路径就可以了，比如你的视频在video/a.flv的，请直接用/video/a.flv，如果需要支持f4v,mp4请参考2003的设置</p>\n<p> <img src=\"image001.jpg\" alt=\"\"></p>\n<p>转载:ckplayer.com</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iis发布含有视频的网站\"><a href=\"#iis发布含有视频的网站\" class=\"headerlink\" title=\"iis发布含有视频的网站\"></a>iis发布含有视频的网站</h1><p>win2003下<br>打开IIS，然后在 mypc（本地计算机） 上面点击右键属性（很多帮助文件都没有说这一点，很多人以为是在站点上面点击右键，却发现找不到MIME类型，其中mypc是你的计算机名）<br>图片点击可在新窗口打开查看<br>然后点击“MIME类型”，接着点击新建，<br>flv格式是加入关联扩展名：.flv，内容类型：application/octet-stream<br>f4v格式是扩展名：.f4v，内容类型：application/octet-stream<br>mp4格式是扩展名：.mp4，内容类型：video/mp4<br>要注意的是，内容类型并不是跟扩展名配套的，你起别的名称一要，只是做个说明而已<br>确定以后，服务器就可以支持FLV,f4v,mp4视频播放了，如果依然不可以的话，可以尝试重新启动IIS！<br>win7的iis里<br>默认支持flv文件 调用使用时路径用绝对路径就可以了，比如你的视频在video/a.flv的，请直接用/video/a.flv，如果需要支持f4v,mp4请参考2003的设置</p>\n<p> <img src=\"image001.jpg\" alt=\"\"></p>\n<p>转载:ckplayer.com</p>\n"},{"title":"vs发布网站中 \"允许更新此预编译站点\"和网站安全、首次速度的关系","date":"2018-10-02T01:09:09.000Z","_content":"# vs发布网站中 \"允许更新此预编译站点\"和网站安全、首次速度的关系\n\n对于使用VS2008（包括vs2005,vs2010）开发的网站，想要发布后上传到网站空间中，是否理解了：“允许更新此预编译站点”？下边详细介绍了它的区别：\n\n“生成 ”→“发布网站 ”；弹出对话框！\n  \n在打开的对话框中，有一个选项是至关重要的，那就是“允许更新此预编译站点 ”；\n\n“允许更新此预编译站点”这一项，默认情况下，前面是打上一个√的，至于要不要打上一个√，是可选的，那么，打勾与不打勾，有何区别呢？\n\n也许大家都曾经发布过net网站，一般情况下，网站项目中的所有CS文件，会自动生成一个DLL动态链接库，这就能够很好的保护网站的源代码，因为代码一般都是放在CS文件里面的，既然都生成了DLL文件，那么，上传到虚拟空间，别人就不能打开来看了！\n\n但是，其它的文件，诸如ashx、aspx等文件，里面原来有什么，就是什么，别人可以打开这些文件来查看，尽管别人看不见CS代码，但是仍然能够看见ASPX文件里面的HTML代码或部分服务器控件及相关的属性；\n\n还有，ashx这样的文件，就相当于一个cs文件，里面的代码也是能够看见的。\n\n因此，cs文件倒是安全了，但是网站中的ASPX、asxh等文件，是不安全的；对于整个网站而言，只有局部的安全，而没有整体的安全。\n\n那么，到底有没有一种办法，让上传到虚拟空间的网站文件，都安全呢？方法是有的，通过“允许更新此预编译站点”这一项前面的√，就能实现；\n\n①给“允许更新此预编译站点”打√\n\n如果您给此项打勾，然后发布网站，那么，结果是这样的，整个网站文件，除了所有的CS文件编译成为一个DLL文件之外，其它的文件，和原来的没有任何变化，里面是什么，还是什么，只要别人通过记事本一打开，里面的代码、HTML代码等，都可以让别人一览无余。\n\n除此之外，通过此种方式发布的网站，当用户第一次访问某个页面的时候，需要经过编译，查找BUG，之后，如果没有任何错误，才能正常访问，因此，速度会变得比较慢。(第二次、第三次……访问，速度就正常了)\n\n②取消“允许更新此预编译站点”前面的√\n\n如果您在发布网站的时候，取消了“允许更新此预编译站点”前面的勾，那么，结果是这样的：\n\n１、网站里面的所有CS文件，都被编译成为一个DLL文件；\n\n２、除了cs文件，其它的文件，诸如ASPX、ASHX等文件，也一同被编译起来，每个文件都在BIN目录里面生成一个对应的\\*.compiled文件；\n允许更新此预编译站点DLL\n\n之后，如果您通过记事本查看ASPX、ASHX等文件，里面不会看到任何的代码，就连HTML代码标记都看不见，打开这样的文件，里面只有一行文字，内容为“这是预编译工具生成的标记文件，不应被删除!”\n允许更新此预编译站点ASPX\n\n但是，网站的访问却是正常的，不会出现任何不良的问题。\n\n所以呢，使用这种方式发布网站，什么文件都不能通过记事本打开，里面显示的都是一行文字，因此，网站文件就非常安全了。\n\n此外，通过此种方法发布的网站，所有内容都编译好了，打开的速度是很快的。\n\n>来源： \n>[1]:<http://www.camnpr.com/archives/640.html>\n ","source":"_posts/CShape/vs发布网站中允许更新此预编译站点和网站安全首次速度的关系.md","raw":"---\ntitle: vs发布网站中 \"允许更新此预编译站点\"和网站安全、首次速度的关系\ndate: 2018-10-02 09:09:09\ncategories: CShape\n---\n# vs发布网站中 \"允许更新此预编译站点\"和网站安全、首次速度的关系\n\n对于使用VS2008（包括vs2005,vs2010）开发的网站，想要发布后上传到网站空间中，是否理解了：“允许更新此预编译站点”？下边详细介绍了它的区别：\n\n“生成 ”→“发布网站 ”；弹出对话框！\n  \n在打开的对话框中，有一个选项是至关重要的，那就是“允许更新此预编译站点 ”；\n\n“允许更新此预编译站点”这一项，默认情况下，前面是打上一个√的，至于要不要打上一个√，是可选的，那么，打勾与不打勾，有何区别呢？\n\n也许大家都曾经发布过net网站，一般情况下，网站项目中的所有CS文件，会自动生成一个DLL动态链接库，这就能够很好的保护网站的源代码，因为代码一般都是放在CS文件里面的，既然都生成了DLL文件，那么，上传到虚拟空间，别人就不能打开来看了！\n\n但是，其它的文件，诸如ashx、aspx等文件，里面原来有什么，就是什么，别人可以打开这些文件来查看，尽管别人看不见CS代码，但是仍然能够看见ASPX文件里面的HTML代码或部分服务器控件及相关的属性；\n\n还有，ashx这样的文件，就相当于一个cs文件，里面的代码也是能够看见的。\n\n因此，cs文件倒是安全了，但是网站中的ASPX、asxh等文件，是不安全的；对于整个网站而言，只有局部的安全，而没有整体的安全。\n\n那么，到底有没有一种办法，让上传到虚拟空间的网站文件，都安全呢？方法是有的，通过“允许更新此预编译站点”这一项前面的√，就能实现；\n\n①给“允许更新此预编译站点”打√\n\n如果您给此项打勾，然后发布网站，那么，结果是这样的，整个网站文件，除了所有的CS文件编译成为一个DLL文件之外，其它的文件，和原来的没有任何变化，里面是什么，还是什么，只要别人通过记事本一打开，里面的代码、HTML代码等，都可以让别人一览无余。\n\n除此之外，通过此种方式发布的网站，当用户第一次访问某个页面的时候，需要经过编译，查找BUG，之后，如果没有任何错误，才能正常访问，因此，速度会变得比较慢。(第二次、第三次……访问，速度就正常了)\n\n②取消“允许更新此预编译站点”前面的√\n\n如果您在发布网站的时候，取消了“允许更新此预编译站点”前面的勾，那么，结果是这样的：\n\n１、网站里面的所有CS文件，都被编译成为一个DLL文件；\n\n２、除了cs文件，其它的文件，诸如ASPX、ASHX等文件，也一同被编译起来，每个文件都在BIN目录里面生成一个对应的\\*.compiled文件；\n允许更新此预编译站点DLL\n\n之后，如果您通过记事本查看ASPX、ASHX等文件，里面不会看到任何的代码，就连HTML代码标记都看不见，打开这样的文件，里面只有一行文字，内容为“这是预编译工具生成的标记文件，不应被删除!”\n允许更新此预编译站点ASPX\n\n但是，网站的访问却是正常的，不会出现任何不良的问题。\n\n所以呢，使用这种方式发布网站，什么文件都不能通过记事本打开，里面显示的都是一行文字，因此，网站文件就非常安全了。\n\n此外，通过此种方法发布的网站，所有内容都编译好了，打开的速度是很快的。\n\n>来源： \n>[1]:<http://www.camnpr.com/archives/640.html>\n ","slug":"CShape/vs发布网站中允许更新此预编译站点和网站安全首次速度的关系","published":1,"updated":"2018-10-02T05:08:09.660Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4lw000entnbpv54phw8","content":"<h1 id=\"vs发布网站中-“允许更新此预编译站点”和网站安全、首次速度的关系\"><a href=\"#vs发布网站中-“允许更新此预编译站点”和网站安全、首次速度的关系\" class=\"headerlink\" title=\"vs发布网站中 “允许更新此预编译站点”和网站安全、首次速度的关系\"></a>vs发布网站中 “允许更新此预编译站点”和网站安全、首次速度的关系</h1><p>对于使用VS2008（包括vs2005,vs2010）开发的网站，想要发布后上传到网站空间中，是否理解了：“允许更新此预编译站点”？下边详细介绍了它的区别：</p>\n<p>“生成 ”→“发布网站 ”；弹出对话框！</p>\n<p>在打开的对话框中，有一个选项是至关重要的，那就是“允许更新此预编译站点 ”；</p>\n<p>“允许更新此预编译站点”这一项，默认情况下，前面是打上一个√的，至于要不要打上一个√，是可选的，那么，打勾与不打勾，有何区别呢？</p>\n<p>也许大家都曾经发布过net网站，一般情况下，网站项目中的所有CS文件，会自动生成一个DLL动态链接库，这就能够很好的保护网站的源代码，因为代码一般都是放在CS文件里面的，既然都生成了DLL文件，那么，上传到虚拟空间，别人就不能打开来看了！</p>\n<p>但是，其它的文件，诸如ashx、aspx等文件，里面原来有什么，就是什么，别人可以打开这些文件来查看，尽管别人看不见CS代码，但是仍然能够看见ASPX文件里面的HTML代码或部分服务器控件及相关的属性；</p>\n<p>还有，ashx这样的文件，就相当于一个cs文件，里面的代码也是能够看见的。</p>\n<p>因此，cs文件倒是安全了，但是网站中的ASPX、asxh等文件，是不安全的；对于整个网站而言，只有局部的安全，而没有整体的安全。</p>\n<p>那么，到底有没有一种办法，让上传到虚拟空间的网站文件，都安全呢？方法是有的，通过“允许更新此预编译站点”这一项前面的√，就能实现；</p>\n<p>①给“允许更新此预编译站点”打√</p>\n<p>如果您给此项打勾，然后发布网站，那么，结果是这样的，整个网站文件，除了所有的CS文件编译成为一个DLL文件之外，其它的文件，和原来的没有任何变化，里面是什么，还是什么，只要别人通过记事本一打开，里面的代码、HTML代码等，都可以让别人一览无余。</p>\n<p>除此之外，通过此种方式发布的网站，当用户第一次访问某个页面的时候，需要经过编译，查找BUG，之后，如果没有任何错误，才能正常访问，因此，速度会变得比较慢。(第二次、第三次……访问，速度就正常了)</p>\n<p>②取消“允许更新此预编译站点”前面的√</p>\n<p>如果您在发布网站的时候，取消了“允许更新此预编译站点”前面的勾，那么，结果是这样的：</p>\n<p>１、网站里面的所有CS文件，都被编译成为一个DLL文件；</p>\n<p>２、除了cs文件，其它的文件，诸如ASPX、ASHX等文件，也一同被编译起来，每个文件都在BIN目录里面生成一个对应的*.compiled文件；<br>允许更新此预编译站点DLL</p>\n<p>之后，如果您通过记事本查看ASPX、ASHX等文件，里面不会看到任何的代码，就连HTML代码标记都看不见，打开这样的文件，里面只有一行文字，内容为“这是预编译工具生成的标记文件，不应被删除!”<br>允许更新此预编译站点ASPX</p>\n<p>但是，网站的访问却是正常的，不会出现任何不良的问题。</p>\n<p>所以呢，使用这种方式发布网站，什么文件都不能通过记事本打开，里面显示的都是一行文字，因此，网站文件就非常安全了。</p>\n<p>此外，通过此种方法发布的网站，所有内容都编译好了，打开的速度是很快的。</p>\n<blockquote>\n<p>来源：<br>[1]:<a href=\"http://www.camnpr.com/archives/640.html\" target=\"_blank\" rel=\"noopener\">http://www.camnpr.com/archives/640.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"vs发布网站中-“允许更新此预编译站点”和网站安全、首次速度的关系\"><a href=\"#vs发布网站中-“允许更新此预编译站点”和网站安全、首次速度的关系\" class=\"headerlink\" title=\"vs发布网站中 “允许更新此预编译站点”和网站安全、首次速度的关系\"></a>vs发布网站中 “允许更新此预编译站点”和网站安全、首次速度的关系</h1><p>对于使用VS2008（包括vs2005,vs2010）开发的网站，想要发布后上传到网站空间中，是否理解了：“允许更新此预编译站点”？下边详细介绍了它的区别：</p>\n<p>“生成 ”→“发布网站 ”；弹出对话框！</p>\n<p>在打开的对话框中，有一个选项是至关重要的，那就是“允许更新此预编译站点 ”；</p>\n<p>“允许更新此预编译站点”这一项，默认情况下，前面是打上一个√的，至于要不要打上一个√，是可选的，那么，打勾与不打勾，有何区别呢？</p>\n<p>也许大家都曾经发布过net网站，一般情况下，网站项目中的所有CS文件，会自动生成一个DLL动态链接库，这就能够很好的保护网站的源代码，因为代码一般都是放在CS文件里面的，既然都生成了DLL文件，那么，上传到虚拟空间，别人就不能打开来看了！</p>\n<p>但是，其它的文件，诸如ashx、aspx等文件，里面原来有什么，就是什么，别人可以打开这些文件来查看，尽管别人看不见CS代码，但是仍然能够看见ASPX文件里面的HTML代码或部分服务器控件及相关的属性；</p>\n<p>还有，ashx这样的文件，就相当于一个cs文件，里面的代码也是能够看见的。</p>\n<p>因此，cs文件倒是安全了，但是网站中的ASPX、asxh等文件，是不安全的；对于整个网站而言，只有局部的安全，而没有整体的安全。</p>\n<p>那么，到底有没有一种办法，让上传到虚拟空间的网站文件，都安全呢？方法是有的，通过“允许更新此预编译站点”这一项前面的√，就能实现；</p>\n<p>①给“允许更新此预编译站点”打√</p>\n<p>如果您给此项打勾，然后发布网站，那么，结果是这样的，整个网站文件，除了所有的CS文件编译成为一个DLL文件之外，其它的文件，和原来的没有任何变化，里面是什么，还是什么，只要别人通过记事本一打开，里面的代码、HTML代码等，都可以让别人一览无余。</p>\n<p>除此之外，通过此种方式发布的网站，当用户第一次访问某个页面的时候，需要经过编译，查找BUG，之后，如果没有任何错误，才能正常访问，因此，速度会变得比较慢。(第二次、第三次……访问，速度就正常了)</p>\n<p>②取消“允许更新此预编译站点”前面的√</p>\n<p>如果您在发布网站的时候，取消了“允许更新此预编译站点”前面的勾，那么，结果是这样的：</p>\n<p>１、网站里面的所有CS文件，都被编译成为一个DLL文件；</p>\n<p>２、除了cs文件，其它的文件，诸如ASPX、ASHX等文件，也一同被编译起来，每个文件都在BIN目录里面生成一个对应的*.compiled文件；<br>允许更新此预编译站点DLL</p>\n<p>之后，如果您通过记事本查看ASPX、ASHX等文件，里面不会看到任何的代码，就连HTML代码标记都看不见，打开这样的文件，里面只有一行文字，内容为“这是预编译工具生成的标记文件，不应被删除!”<br>允许更新此预编译站点ASPX</p>\n<p>但是，网站的访问却是正常的，不会出现任何不良的问题。</p>\n<p>所以呢，使用这种方式发布网站，什么文件都不能通过记事本打开，里面显示的都是一行文字，因此，网站文件就非常安全了。</p>\n<p>此外，通过此种方法发布的网站，所有内容都编译好了，打开的速度是很快的。</p>\n<blockquote>\n<p>来源：<br>[1]:<a href=\"http://www.camnpr.com/archives/640.html\" target=\"_blank\" rel=\"noopener\">http://www.camnpr.com/archives/640.html</a></p>\n</blockquote>\n"},{"title":"C++ Format的用法总结","date":"2018-10-02T01:09:09.000Z","_content":"# C++ Format的用法总结\n\n##函数声明 \n  function Format(const Format: string; const Args: array of const): string; overload; \n  \n##函数功能 \n  事实上Format方法有两个种形式，另外一种是三个参数的，主要区别在于它是线程安全的， 但并不多用，所以这里只对第一个介绍。Format参数是一个格式字符串，用于格式化Args里面的值的。Args是一个变体数组，即它里面可以有多个参数，而且每个参数可以不同。 例如： \n```c++\nFormat(\"my name is %6s\",\"wind\");   返回的是：my name is wind \n```\n##函数参数 \n  Format里面可以写普通的字符串，比如\"my name is\" ，但有些格式指令字符具有特殊意义，比如\"%6s\" \n  格式指令具有以下的形式： \"%\" \\[index \":\"] \\[\"-\"] [width] \\[\".\" prec] type \n  它是以\"%\"开始,而以type结束，type表示一个具体的类型。中间是用来格式化type类型的指令字符，是可选的。各个参数的含义与用途如下；   [type] \ntype参数可选的类型有d，u，f，e，g，n，m，p，s，x. \n\n(1) d 十进制数，表示一个整型值，u 和d一样是整型值，但它是无符号的，而如果它对应的值是负的，则返回时是一个2的32次方减去这个负数的绝对值 。\n\n例如：\n\n`Format(\"this is %u\",-2);`   \n\n返回的是：\n\n`this is 4294967294   `\n\n(2)f 对应浮点数 \n\n(3)e科学表示法，对应整型数和浮点数   \n例如：\n\n`Format(\"this is %e\",-2.22);`  \n\n返回的是：\n\n`this is -2.220000E+000 `\n\n(4)g 这个只能对应浮点型，且它会将值中多余的数去掉   \n例如：\n\n`Format(\"this is %g\",02.200); ` \n\n返回的是：\n\n`this is 2.2 `\n\n(5)n 只能对应浮点型，将值转化为号码的形式，看一个例子就明白了   \n\n例如：\n\n`Format(\"this is %n\",4552.2176); `  \n\n返回的是：\n\n`this is 4,552.22  `\n\n注意：一是，只表示到小数后两位;二是，即使小数没有被截断，它也不会也像整数部分一样有逗号来分开的 \n\n(6)m 钱币类型，但关于货币类型有更好的格式化方法，这里只是简单的格式化，另外它只对应于浮点值 \n  例如：\n```c++\nFormat(\"this is %m\",9552.21); \n```\n\n","source":"_posts/C++/CPPFormat的用法总结.md","raw":"---\ntitle: C++ Format的用法总结\ndate: 2018-10-02 09:09:09\ncategories: cpp\n---\n# C++ Format的用法总结\n\n##函数声明 \n  function Format(const Format: string; const Args: array of const): string; overload; \n  \n##函数功能 \n  事实上Format方法有两个种形式，另外一种是三个参数的，主要区别在于它是线程安全的， 但并不多用，所以这里只对第一个介绍。Format参数是一个格式字符串，用于格式化Args里面的值的。Args是一个变体数组，即它里面可以有多个参数，而且每个参数可以不同。 例如： \n```c++\nFormat(\"my name is %6s\",\"wind\");   返回的是：my name is wind \n```\n##函数参数 \n  Format里面可以写普通的字符串，比如\"my name is\" ，但有些格式指令字符具有特殊意义，比如\"%6s\" \n  格式指令具有以下的形式： \"%\" \\[index \":\"] \\[\"-\"] [width] \\[\".\" prec] type \n  它是以\"%\"开始,而以type结束，type表示一个具体的类型。中间是用来格式化type类型的指令字符，是可选的。各个参数的含义与用途如下；   [type] \ntype参数可选的类型有d，u，f，e，g，n，m，p，s，x. \n\n(1) d 十进制数，表示一个整型值，u 和d一样是整型值，但它是无符号的，而如果它对应的值是负的，则返回时是一个2的32次方减去这个负数的绝对值 。\n\n例如：\n\n`Format(\"this is %u\",-2);`   \n\n返回的是：\n\n`this is 4294967294   `\n\n(2)f 对应浮点数 \n\n(3)e科学表示法，对应整型数和浮点数   \n例如：\n\n`Format(\"this is %e\",-2.22);`  \n\n返回的是：\n\n`this is -2.220000E+000 `\n\n(4)g 这个只能对应浮点型，且它会将值中多余的数去掉   \n例如：\n\n`Format(\"this is %g\",02.200); ` \n\n返回的是：\n\n`this is 2.2 `\n\n(5)n 只能对应浮点型，将值转化为号码的形式，看一个例子就明白了   \n\n例如：\n\n`Format(\"this is %n\",4552.2176); `  \n\n返回的是：\n\n`this is 4,552.22  `\n\n注意：一是，只表示到小数后两位;二是，即使小数没有被截断，它也不会也像整数部分一样有逗号来分开的 \n\n(6)m 钱币类型，但关于货币类型有更好的格式化方法，这里只是简单的格式化，另外它只对应于浮点值 \n  例如：\n```c++\nFormat(\"this is %m\",9552.21); \n```\n\n","slug":"C++/CPPFormat的用法总结","published":1,"updated":"2018-10-02T06:05:18.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4lx000fntnbmrozbwu6","content":"<h1 id=\"C-Format的用法总结\"><a href=\"#C-Format的用法总结\" class=\"headerlink\" title=\"C++ Format的用法总结\"></a>C++ Format的用法总结</h1><p>##函数声明<br>  function Format(const Format: string; const Args: array of const): string; overload; </p>\n<p>##函数功能<br>  事实上Format方法有两个种形式，另外一种是三个参数的，主要区别在于它是线程安全的， 但并不多用，所以这里只对第一个介绍。Format参数是一个格式字符串，用于格式化Args里面的值的。Args是一个变体数组，即它里面可以有多个参数，而且每个参数可以不同。 例如： </p>\n<pre><code class=\"c++\">Format(&quot;my name is %6s&quot;,&quot;wind&quot;);   返回的是：my name is wind \n</code></pre>\n<p>##函数参数<br>  Format里面可以写普通的字符串，比如”my name is” ，但有些格式指令字符具有特殊意义，比如”%6s”<br>  格式指令具有以下的形式： “%” [index “:”] [“-“] [width] [“.” prec] type<br>  它是以”%”开始,而以type结束，type表示一个具体的类型。中间是用来格式化type类型的指令字符，是可选的。各个参数的含义与用途如下；   [type]<br>type参数可选的类型有d，u，f，e，g，n，m，p，s，x. </p>\n<p>(1) d 十进制数，表示一个整型值，u 和d一样是整型值，但它是无符号的，而如果它对应的值是负的，则返回时是一个2的32次方减去这个负数的绝对值 。</p>\n<p>例如：</p>\n<p><code>Format(&quot;this is %u&quot;,-2);</code>   </p>\n<p>返回的是：</p>\n<p><code>this is 4294967294</code></p>\n<p>(2)f 对应浮点数 </p>\n<p>(3)e科学表示法，对应整型数和浮点数<br>例如：</p>\n<p><code>Format(&quot;this is %e&quot;,-2.22);</code>  </p>\n<p>返回的是：</p>\n<p><code>this is -2.220000E+000</code></p>\n<p>(4)g 这个只能对应浮点型，且它会将值中多余的数去掉<br>例如：</p>\n<p><code>Format(&quot;this is %g&quot;,02.200);</code> </p>\n<p>返回的是：</p>\n<p><code>this is 2.2</code></p>\n<p>(5)n 只能对应浮点型，将值转化为号码的形式，看一个例子就明白了   </p>\n<p>例如：</p>\n<p><code>Format(&quot;this is %n&quot;,4552.2176);</code>  </p>\n<p>返回的是：</p>\n<p><code>this is 4,552.22</code></p>\n<p>注意：一是，只表示到小数后两位;二是，即使小数没有被截断，它也不会也像整数部分一样有逗号来分开的 </p>\n<p>(6)m 钱币类型，但关于货币类型有更好的格式化方法，这里只是简单的格式化，另外它只对应于浮点值<br>  例如：</p>\n<pre><code class=\"c++\">Format(&quot;this is %m&quot;,9552.21); \n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C-Format的用法总结\"><a href=\"#C-Format的用法总结\" class=\"headerlink\" title=\"C++ Format的用法总结\"></a>C++ Format的用法总结</h1><p>##函数声明<br>  function Format(const Format: string; const Args: array of const): string; overload; </p>\n<p>##函数功能<br>  事实上Format方法有两个种形式，另外一种是三个参数的，主要区别在于它是线程安全的， 但并不多用，所以这里只对第一个介绍。Format参数是一个格式字符串，用于格式化Args里面的值的。Args是一个变体数组，即它里面可以有多个参数，而且每个参数可以不同。 例如： </p>\n<pre><code class=\"c++\">Format(&quot;my name is %6s&quot;,&quot;wind&quot;);   返回的是：my name is wind \n</code></pre>\n<p>##函数参数<br>  Format里面可以写普通的字符串，比如”my name is” ，但有些格式指令字符具有特殊意义，比如”%6s”<br>  格式指令具有以下的形式： “%” [index “:”] [“-“] [width] [“.” prec] type<br>  它是以”%”开始,而以type结束，type表示一个具体的类型。中间是用来格式化type类型的指令字符，是可选的。各个参数的含义与用途如下；   [type]<br>type参数可选的类型有d，u，f，e，g，n，m，p，s，x. </p>\n<p>(1) d 十进制数，表示一个整型值，u 和d一样是整型值，但它是无符号的，而如果它对应的值是负的，则返回时是一个2的32次方减去这个负数的绝对值 。</p>\n<p>例如：</p>\n<p><code>Format(&quot;this is %u&quot;,-2);</code>   </p>\n<p>返回的是：</p>\n<p><code>this is 4294967294</code></p>\n<p>(2)f 对应浮点数 </p>\n<p>(3)e科学表示法，对应整型数和浮点数<br>例如：</p>\n<p><code>Format(&quot;this is %e&quot;,-2.22);</code>  </p>\n<p>返回的是：</p>\n<p><code>this is -2.220000E+000</code></p>\n<p>(4)g 这个只能对应浮点型，且它会将值中多余的数去掉<br>例如：</p>\n<p><code>Format(&quot;this is %g&quot;,02.200);</code> </p>\n<p>返回的是：</p>\n<p><code>this is 2.2</code></p>\n<p>(5)n 只能对应浮点型，将值转化为号码的形式，看一个例子就明白了   </p>\n<p>例如：</p>\n<p><code>Format(&quot;this is %n&quot;,4552.2176);</code>  </p>\n<p>返回的是：</p>\n<p><code>this is 4,552.22</code></p>\n<p>注意：一是，只表示到小数后两位;二是，即使小数没有被截断，它也不会也像整数部分一样有逗号来分开的 </p>\n<p>(6)m 钱币类型，但关于货币类型有更好的格式化方法，这里只是简单的格式化，另外它只对应于浮点值<br>  例如：</p>\n<pre><code class=\"c++\">Format(&quot;this is %m&quot;,9552.21); \n</code></pre>\n"},{"title":"C++ \\#pragma once与 \\#ifndef的区别","date":"2018-10-02T01:09:09.000Z","_content":"# C++ #pragma once与 #ifndef的区别\n\n\\#pragma once与 #ifndef的区别\n\n为了避免同一个文件被include多次\n```c++\n#ifndef方式\n#pragma once方式\n```\n在能够支持这两种方式的编译器上，二者并没有太大的区别，但是两者仍然还是有一些细微的区别。\n方式一：\n```c++\n#ifndef __SOMEFILE_H__\n#define __SOMEFILE_H__\n... ... // 一些声明语句\n#endif\n方式二：\n#pragma once\n... ... // 一些声明语句\n```\n\\#ifndef的方式依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。当然，缺点就是如果不同头文件的宏名不小心“撞车”，可能就会导致头文件明明存在，编译器却硬说找不到声明的状况\n\n\\#pragma once则由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。带来的好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，重复包含更容易被发现并修正。\n\n方式一由语言支持所以移植性好，方式二 可以避免名字冲突\n\n>来源：\n>\n> [1]:http://www.cppblog.com/szhoftuncun/archive/2009/09/01/35356.html>\n ","source":"_posts/C++/CPPpragmaonce与ifndef的区别.md","raw":"---\ntitle: C++ \\#pragma once与 \\#ifndef的区别\ndate: 2018-10-02 09:09:09\ncategories: cpp\n---\n# C++ #pragma once与 #ifndef的区别\n\n\\#pragma once与 #ifndef的区别\n\n为了避免同一个文件被include多次\n```c++\n#ifndef方式\n#pragma once方式\n```\n在能够支持这两种方式的编译器上，二者并没有太大的区别，但是两者仍然还是有一些细微的区别。\n方式一：\n```c++\n#ifndef __SOMEFILE_H__\n#define __SOMEFILE_H__\n... ... // 一些声明语句\n#endif\n方式二：\n#pragma once\n... ... // 一些声明语句\n```\n\\#ifndef的方式依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。当然，缺点就是如果不同头文件的宏名不小心“撞车”，可能就会导致头文件明明存在，编译器却硬说找不到声明的状况\n\n\\#pragma once则由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。带来的好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，重复包含更容易被发现并修正。\n\n方式一由语言支持所以移植性好，方式二 可以避免名字冲突\n\n>来源：\n>\n> [1]:http://www.cppblog.com/szhoftuncun/archive/2009/09/01/35356.html>\n ","slug":"C++/CPPpragmaonce与ifndef的区别","published":1,"updated":"2018-10-02T05:05:08.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4m0000hntnbz9fv2inv","content":"<h1 id=\"C-pragma-once与-ifndef的区别\"><a href=\"#C-pragma-once与-ifndef的区别\" class=\"headerlink\" title=\"C++ #pragma once与 #ifndef的区别\"></a>C++ #pragma once与 #ifndef的区别</h1><p>#pragma once与 #ifndef的区别</p>\n<p>为了避免同一个文件被include多次</p>\n<pre><code class=\"c++\">#ifndef方式\n#pragma once方式\n</code></pre>\n<p>在能够支持这两种方式的编译器上，二者并没有太大的区别，但是两者仍然还是有一些细微的区别。<br>方式一：</p>\n<pre><code class=\"c++\">#ifndef __SOMEFILE_H__\n#define __SOMEFILE_H__\n... ... // 一些声明语句\n#endif\n方式二：\n#pragma once\n... ... // 一些声明语句\n</code></pre>\n<p>#ifndef的方式依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。当然，缺点就是如果不同头文件的宏名不小心“撞车”，可能就会导致头文件明明存在，编译器却硬说找不到声明的状况</p>\n<p>#pragma once则由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。带来的好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，重复包含更容易被发现并修正。</p>\n<p>方式一由语言支持所以移植性好，方式二 可以避免名字冲突</p>\n<blockquote>\n<p>来源：</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C-pragma-once与-ifndef的区别\"><a href=\"#C-pragma-once与-ifndef的区别\" class=\"headerlink\" title=\"C++ #pragma once与 #ifndef的区别\"></a>C++ #pragma once与 #ifndef的区别</h1><p>#pragma once与 #ifndef的区别</p>\n<p>为了避免同一个文件被include多次</p>\n<pre><code class=\"c++\">#ifndef方式\n#pragma once方式\n</code></pre>\n<p>在能够支持这两种方式的编译器上，二者并没有太大的区别，但是两者仍然还是有一些细微的区别。<br>方式一：</p>\n<pre><code class=\"c++\">#ifndef __SOMEFILE_H__\n#define __SOMEFILE_H__\n... ... // 一些声明语句\n#endif\n方式二：\n#pragma once\n... ... // 一些声明语句\n</code></pre>\n<p>#ifndef的方式依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。当然，缺点就是如果不同头文件的宏名不小心“撞车”，可能就会导致头文件明明存在，编译器却硬说找不到声明的状况</p>\n<p>#pragma once则由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。带来的好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，重复包含更容易被发现并修正。</p>\n<p>方式一由语言支持所以移植性好，方式二 可以避免名字冲突</p>\n<blockquote>\n<p>来源：</p>\n</blockquote>\n"},{"title":"C++ 处理 JSON 数据交换格式","date":"2018-10-02T01:09:09.000Z","_content":"# C++ 处理 JSON 数据交换格式\n\n---\n\n\n使用 C++ 处理 JSON 数据交换格式\n \n\n---\n\n\n##一、摘要\nJSON 的全称为：JavaScript Object Notation，顾名思义，JSON 是用于标记 Javascript 对象的，JSON 官方的解释为：JSON 是一种轻量级的数据传输格式。\n本文并不详细介绍 JSON 本身的细节，旨在讨论如何使用 C++ 语言来处理 JSON。关于 JSON更具体的信息，可参见 JSON 官网：http://www.json.org。\n \n\n---\n\n\n##二、本文选择处理 JSON的 C++ 库\n本文选择一个第三方库 jsoncpp 来解析 JSON。jsoncpp 是比较出名的 C++ JSON 解析库。在 JSON官网也是首推的。\n下载地址为：http://sourceforge.net/projects/jsoncpp。本文使用的 jsoncpp 版本为：0.5.0。\n \n\n---\n\n\n##三、jsoncpp 在 Windows 下的编译\n要使用第三方源码库，第一步少不了的就是编译，将源码文件编译成我们方便使用的动态链接库、静态链接库或者静态导入库[1]。\njsconcpp 进行 JSON 解析的源码文件分布在 include/json、src/lib_json 下。其实 jsoncpp 源码并不多，为了方便产品管理，此处没必要将其编译为动态链接库或者静态导入库，所以我们选择使用静态链接库[2]。\njsoncpp 已经处理的很完善了，所有编译选项都已经配置好，打开makefiles/vs71/jsoncpp.sln 便可以开始编译（默认是使用 VS2003 编译器的，打开时直接按照 VS2005 提示转换即可）。\n \n\n---\n\n\n##四、jsoncpp 使用详解\njsoncpp 主要包含三种类型的 class：Value、Reader、Writer。jsoncpp 中所有对象、类名都在namespace Json 中，包含 json.h 即可。\n\nJson::Value 只能处理 ANSI 类型的字符串，如果 C++ 程序是用 Unicode 编码的，最好加一个 Adapt类来适配。\n###1、Value\nJson::Value 是jsoncpp 中最基本、最重要的类，用于表示各种类型的对象，jsoncpp 支持的对象类型可见 Json::ValueType 枚举值。\n可如下是用 Json::Value 类：\n```c++\nJson::Value json_temp;      // 临时对象，供如下代码使用\njson_temp[\"name\"] = Json::Value(\"huchao\");\njson_temp[\"age\"] = Json::Value(26);\n \nJson::Value root;  // 表示整个 json 对象\nroot[\"key_string\"] = Json::Value(\"value_string\");         // 新建一个 Key（名为：key_string），赋予字符串值：\"value_string\"。\nroot[\"key_number\"] = Json::Value(12345);            // 新建一个 Key（名为：key_number），赋予数值：12345。\nroot[\"key_boolean\"] = Json::Value(false);              // 新建一个 Key（名为：key_boolean），赋予bool值：false。\nroot[\"key_double\"] = Json::Value(12.345);            // 新建一个 Key（名为：key_double），赋予 double值：12.345。\nroot[\"key_object\"] = Json_temp;                           // 新建一个 Key（名为：key_object），赋予json::Value 对象值。\nroot[\"key_array\"].append(\"array_string\");             // 新建一个 Key（名为：key_array），类型为数组，对第一个元素赋值为字符串：\"array_string\"。\nroot[\"key_array\"].append(1234);                           // 为数组 key_array 赋值，对第二个元素赋值为：1234。\nJson::ValueType type = root.type();// 获得 root 的类型，此处为 objectValue 类型。\n```\n注：跟C++ 不同，JavaScript 数组可以为任意类型的值，所以 jsoncpp 也可以。\n    如上几个用法已经可以满足绝大部分 json 应用了，当然 jsoncpp 还有一些其他同能，比如说设置注释、比较 json 大小、交换 json 对象等，都很容易使用，大家自己尝试吧。\n \n###2、Writer\n如上说了 Json::Value 的使用方式，现在到了该查看刚才赋值内容的时候了，查看 json 内容，使用 Writer 类即可。\nJsoncpp 的 Json::Writer 类是一个纯虚类，并不能直接使用。在此我们使用 Json::Writer 的子类：Json::FastWriter、Json::StyledWriter、Json::StyledStreamWriter。\n顾名思义，用 Json::FastWriter 来处理 json 应该是最快的，下面我们来试试。\n```c++\nJson::FastWriter fast_writer;\nstd::cout << fast_writer.write(root) << std::endl;\n```\n输出结果为：\n```json\n{\"key_array\":[\"array_string\",1234],\"key_boolean\":false,\"key_double\":12.3450,\"key_number\":12345,\"key_object\":{\"age\":26,\"name\":\"huchao\"},\"key_string\":\"value_string\"}\n```\n再次顾名思义，用 Json::StyledWriter 是格式化后的 json，下面我们来看看 Json::StyledWriter 是怎样格式化的。\n```c++\nJson::StyledWriter styled_writer;\nstd::cout << styled_writer.write(root) << std::endl;\n```\n输出结果为：\n```json\n{\n   \"key_array\" : [ \"array_string\", 1234 ],\n   \"key_boolean\" : false,\n   \"key_double\" : 12.3450,\n   \"key_number\" : 12345,\n   \"key_object\" : {\n      \"age\" : 26,\n      \"name\" : \"huchao\"\n   },\n   \"key_string\" : \"value_string\"\n}\n```\n###3、Reader\nJson::Reader 是用于读取的，说的确切点，是用于将字符串转换为 Json::Value 对象的，下面我们来看个简单的例子。\n```c++\n  Json::Reader reader;\n  Json::Value json_object;\n  const char* json_document = \"{/\"age/\" : 26,/\"name/\" : /\"huchao/\"}\";\n  if (!reader.parse(json_document, json_object))\n    return 0;\n   \n  std::cout << json_object[\"name\"] << std::endl;\n  std::cout << json_object[\"age\"] << std::endl;\n```\n输出结果为：\n```json\n\"huchao\"\n```\n \n可见，上述代码已经解析出了 json 字符串。\n \n>[1]：使用第三方源码最简单的方法是直接将文件加入工程，但这样不利于源码、软件产品管理，对于一般软件开发来说，不建议使用。\n \n>[2]：如果真需要编译成动态链接库、静态导入库的话，可以使用 VS 新建一个工程属性，然后在Project --> Properties中进行相应的设置即可。\n>\n>来源：\n>[1]: <http://blog.csdn.net/xt_xiaotian/article/details/5648388>\n \n","source":"_posts/C++/CPP处理JSON数据交换格式.md","raw":"---\ntitle: C++ 处理 JSON 数据交换格式\ndate: 2018-10-02 09:09:09\ncategories: cpp\n---\n# C++ 处理 JSON 数据交换格式\n\n---\n\n\n使用 C++ 处理 JSON 数据交换格式\n \n\n---\n\n\n##一、摘要\nJSON 的全称为：JavaScript Object Notation，顾名思义，JSON 是用于标记 Javascript 对象的，JSON 官方的解释为：JSON 是一种轻量级的数据传输格式。\n本文并不详细介绍 JSON 本身的细节，旨在讨论如何使用 C++ 语言来处理 JSON。关于 JSON更具体的信息，可参见 JSON 官网：http://www.json.org。\n \n\n---\n\n\n##二、本文选择处理 JSON的 C++ 库\n本文选择一个第三方库 jsoncpp 来解析 JSON。jsoncpp 是比较出名的 C++ JSON 解析库。在 JSON官网也是首推的。\n下载地址为：http://sourceforge.net/projects/jsoncpp。本文使用的 jsoncpp 版本为：0.5.0。\n \n\n---\n\n\n##三、jsoncpp 在 Windows 下的编译\n要使用第三方源码库，第一步少不了的就是编译，将源码文件编译成我们方便使用的动态链接库、静态链接库或者静态导入库[1]。\njsconcpp 进行 JSON 解析的源码文件分布在 include/json、src/lib_json 下。其实 jsoncpp 源码并不多，为了方便产品管理，此处没必要将其编译为动态链接库或者静态导入库，所以我们选择使用静态链接库[2]。\njsoncpp 已经处理的很完善了，所有编译选项都已经配置好，打开makefiles/vs71/jsoncpp.sln 便可以开始编译（默认是使用 VS2003 编译器的，打开时直接按照 VS2005 提示转换即可）。\n \n\n---\n\n\n##四、jsoncpp 使用详解\njsoncpp 主要包含三种类型的 class：Value、Reader、Writer。jsoncpp 中所有对象、类名都在namespace Json 中，包含 json.h 即可。\n\nJson::Value 只能处理 ANSI 类型的字符串，如果 C++ 程序是用 Unicode 编码的，最好加一个 Adapt类来适配。\n###1、Value\nJson::Value 是jsoncpp 中最基本、最重要的类，用于表示各种类型的对象，jsoncpp 支持的对象类型可见 Json::ValueType 枚举值。\n可如下是用 Json::Value 类：\n```c++\nJson::Value json_temp;      // 临时对象，供如下代码使用\njson_temp[\"name\"] = Json::Value(\"huchao\");\njson_temp[\"age\"] = Json::Value(26);\n \nJson::Value root;  // 表示整个 json 对象\nroot[\"key_string\"] = Json::Value(\"value_string\");         // 新建一个 Key（名为：key_string），赋予字符串值：\"value_string\"。\nroot[\"key_number\"] = Json::Value(12345);            // 新建一个 Key（名为：key_number），赋予数值：12345。\nroot[\"key_boolean\"] = Json::Value(false);              // 新建一个 Key（名为：key_boolean），赋予bool值：false。\nroot[\"key_double\"] = Json::Value(12.345);            // 新建一个 Key（名为：key_double），赋予 double值：12.345。\nroot[\"key_object\"] = Json_temp;                           // 新建一个 Key（名为：key_object），赋予json::Value 对象值。\nroot[\"key_array\"].append(\"array_string\");             // 新建一个 Key（名为：key_array），类型为数组，对第一个元素赋值为字符串：\"array_string\"。\nroot[\"key_array\"].append(1234);                           // 为数组 key_array 赋值，对第二个元素赋值为：1234。\nJson::ValueType type = root.type();// 获得 root 的类型，此处为 objectValue 类型。\n```\n注：跟C++ 不同，JavaScript 数组可以为任意类型的值，所以 jsoncpp 也可以。\n    如上几个用法已经可以满足绝大部分 json 应用了，当然 jsoncpp 还有一些其他同能，比如说设置注释、比较 json 大小、交换 json 对象等，都很容易使用，大家自己尝试吧。\n \n###2、Writer\n如上说了 Json::Value 的使用方式，现在到了该查看刚才赋值内容的时候了，查看 json 内容，使用 Writer 类即可。\nJsoncpp 的 Json::Writer 类是一个纯虚类，并不能直接使用。在此我们使用 Json::Writer 的子类：Json::FastWriter、Json::StyledWriter、Json::StyledStreamWriter。\n顾名思义，用 Json::FastWriter 来处理 json 应该是最快的，下面我们来试试。\n```c++\nJson::FastWriter fast_writer;\nstd::cout << fast_writer.write(root) << std::endl;\n```\n输出结果为：\n```json\n{\"key_array\":[\"array_string\",1234],\"key_boolean\":false,\"key_double\":12.3450,\"key_number\":12345,\"key_object\":{\"age\":26,\"name\":\"huchao\"},\"key_string\":\"value_string\"}\n```\n再次顾名思义，用 Json::StyledWriter 是格式化后的 json，下面我们来看看 Json::StyledWriter 是怎样格式化的。\n```c++\nJson::StyledWriter styled_writer;\nstd::cout << styled_writer.write(root) << std::endl;\n```\n输出结果为：\n```json\n{\n   \"key_array\" : [ \"array_string\", 1234 ],\n   \"key_boolean\" : false,\n   \"key_double\" : 12.3450,\n   \"key_number\" : 12345,\n   \"key_object\" : {\n      \"age\" : 26,\n      \"name\" : \"huchao\"\n   },\n   \"key_string\" : \"value_string\"\n}\n```\n###3、Reader\nJson::Reader 是用于读取的，说的确切点，是用于将字符串转换为 Json::Value 对象的，下面我们来看个简单的例子。\n```c++\n  Json::Reader reader;\n  Json::Value json_object;\n  const char* json_document = \"{/\"age/\" : 26,/\"name/\" : /\"huchao/\"}\";\n  if (!reader.parse(json_document, json_object))\n    return 0;\n   \n  std::cout << json_object[\"name\"] << std::endl;\n  std::cout << json_object[\"age\"] << std::endl;\n```\n输出结果为：\n```json\n\"huchao\"\n```\n \n可见，上述代码已经解析出了 json 字符串。\n \n>[1]：使用第三方源码最简单的方法是直接将文件加入工程，但这样不利于源码、软件产品管理，对于一般软件开发来说，不建议使用。\n \n>[2]：如果真需要编译成动态链接库、静态导入库的话，可以使用 VS 新建一个工程属性，然后在Project --> Properties中进行相应的设置即可。\n>\n>来源：\n>[1]: <http://blog.csdn.net/xt_xiaotian/article/details/5648388>\n \n","slug":"C++/CPP处理JSON数据交换格式","published":1,"updated":"2018-10-02T05:05:18.291Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4m1000intnbbhmu5luc","content":"<h1 id=\"C-处理-JSON-数据交换格式\"><a href=\"#C-处理-JSON-数据交换格式\" class=\"headerlink\" title=\"C++ 处理 JSON 数据交换格式\"></a>C++ 处理 JSON 数据交换格式</h1><hr>\n<p>使用 C++ 处理 JSON 数据交换格式</p>\n<hr>\n<p>##一、摘要<br>JSON 的全称为：JavaScript Object Notation，顾名思义，JSON 是用于标记 Javascript 对象的，JSON 官方的解释为：JSON 是一种轻量级的数据传输格式。<br>本文并不详细介绍 JSON 本身的细节，旨在讨论如何使用 C++ 语言来处理 JSON。关于 JSON更具体的信息，可参见 JSON 官网：<a href=\"http://www.json.org。\" target=\"_blank\" rel=\"noopener\">http://www.json.org。</a></p>\n<hr>\n<p>##二、本文选择处理 JSON的 C++ 库<br>本文选择一个第三方库 jsoncpp 来解析 JSON。jsoncpp 是比较出名的 C++ JSON 解析库。在 JSON官网也是首推的。<br>下载地址为：<a href=\"http://sourceforge.net/projects/jsoncpp。本文使用的\" target=\"_blank\" rel=\"noopener\">http://sourceforge.net/projects/jsoncpp。本文使用的</a> jsoncpp 版本为：0.5.0。</p>\n<hr>\n<p>##三、jsoncpp 在 Windows 下的编译<br>要使用第三方源码库，第一步少不了的就是编译，将源码文件编译成我们方便使用的动态链接库、静态链接库或者静态导入库[1]。<br>jsconcpp 进行 JSON 解析的源码文件分布在 include/json、src/lib_json 下。其实 jsoncpp 源码并不多，为了方便产品管理，此处没必要将其编译为动态链接库或者静态导入库，所以我们选择使用静态链接库[2]。<br>jsoncpp 已经处理的很完善了，所有编译选项都已经配置好，打开makefiles/vs71/jsoncpp.sln 便可以开始编译（默认是使用 VS2003 编译器的，打开时直接按照 VS2005 提示转换即可）。</p>\n<hr>\n<p>##四、jsoncpp 使用详解<br>jsoncpp 主要包含三种类型的 class：Value、Reader、Writer。jsoncpp 中所有对象、类名都在namespace Json 中，包含 json.h 即可。</p>\n<p>Json::Value 只能处理 ANSI 类型的字符串，如果 C++ 程序是用 Unicode 编码的，最好加一个 Adapt类来适配。</p>\n<p>###1、Value<br>Json::Value 是jsoncpp 中最基本、最重要的类，用于表示各种类型的对象，jsoncpp 支持的对象类型可见 Json::ValueType 枚举值。<br>可如下是用 Json::Value 类：</p>\n<pre><code class=\"c++\">Json::Value json_temp;      // 临时对象，供如下代码使用\njson_temp[&quot;name&quot;] = Json::Value(&quot;huchao&quot;);\njson_temp[&quot;age&quot;] = Json::Value(26);\n\nJson::Value root;  // 表示整个 json 对象\nroot[&quot;key_string&quot;] = Json::Value(&quot;value_string&quot;);         // 新建一个 Key（名为：key_string），赋予字符串值：&quot;value_string&quot;。\nroot[&quot;key_number&quot;] = Json::Value(12345);            // 新建一个 Key（名为：key_number），赋予数值：12345。\nroot[&quot;key_boolean&quot;] = Json::Value(false);              // 新建一个 Key（名为：key_boolean），赋予bool值：false。\nroot[&quot;key_double&quot;] = Json::Value(12.345);            // 新建一个 Key（名为：key_double），赋予 double值：12.345。\nroot[&quot;key_object&quot;] = Json_temp;                           // 新建一个 Key（名为：key_object），赋予json::Value 对象值。\nroot[&quot;key_array&quot;].append(&quot;array_string&quot;);             // 新建一个 Key（名为：key_array），类型为数组，对第一个元素赋值为字符串：&quot;array_string&quot;。\nroot[&quot;key_array&quot;].append(1234);                           // 为数组 key_array 赋值，对第二个元素赋值为：1234。\nJson::ValueType type = root.type();// 获得 root 的类型，此处为 objectValue 类型。\n</code></pre>\n<p>注：跟C++ 不同，JavaScript 数组可以为任意类型的值，所以 jsoncpp 也可以。<br>    如上几个用法已经可以满足绝大部分 json 应用了，当然 jsoncpp 还有一些其他同能，比如说设置注释、比较 json 大小、交换 json 对象等，都很容易使用，大家自己尝试吧。</p>\n<p>###2、Writer<br>如上说了 Json::Value 的使用方式，现在到了该查看刚才赋值内容的时候了，查看 json 内容，使用 Writer 类即可。<br>Jsoncpp 的 Json::Writer 类是一个纯虚类，并不能直接使用。在此我们使用 Json::Writer 的子类：Json::FastWriter、Json::StyledWriter、Json::StyledStreamWriter。<br>顾名思义，用 Json::FastWriter 来处理 json 应该是最快的，下面我们来试试。</p>\n<pre><code class=\"c++\">Json::FastWriter fast_writer;\nstd::cout &lt;&lt; fast_writer.write(root) &lt;&lt; std::endl;\n</code></pre>\n<p>输出结果为：</p>\n<pre><code class=\"json\">{&quot;key_array&quot;:[&quot;array_string&quot;,1234],&quot;key_boolean&quot;:false,&quot;key_double&quot;:12.3450,&quot;key_number&quot;:12345,&quot;key_object&quot;:{&quot;age&quot;:26,&quot;name&quot;:&quot;huchao&quot;},&quot;key_string&quot;:&quot;value_string&quot;}\n</code></pre>\n<p>再次顾名思义，用 Json::StyledWriter 是格式化后的 json，下面我们来看看 Json::StyledWriter 是怎样格式化的。</p>\n<pre><code class=\"c++\">Json::StyledWriter styled_writer;\nstd::cout &lt;&lt; styled_writer.write(root) &lt;&lt; std::endl;\n</code></pre>\n<p>输出结果为：</p>\n<pre><code class=\"json\">{\n   &quot;key_array&quot; : [ &quot;array_string&quot;, 1234 ],\n   &quot;key_boolean&quot; : false,\n   &quot;key_double&quot; : 12.3450,\n   &quot;key_number&quot; : 12345,\n   &quot;key_object&quot; : {\n      &quot;age&quot; : 26,\n      &quot;name&quot; : &quot;huchao&quot;\n   },\n   &quot;key_string&quot; : &quot;value_string&quot;\n}\n</code></pre>\n<p>###3、Reader<br>Json::Reader 是用于读取的，说的确切点，是用于将字符串转换为 Json::Value 对象的，下面我们来看个简单的例子。</p>\n<pre><code class=\"c++\">  Json::Reader reader;\n  Json::Value json_object;\n  const char* json_document = &quot;{/&quot;age/&quot; : 26,/&quot;name/&quot; : /&quot;huchao/&quot;}&quot;;\n  if (!reader.parse(json_document, json_object))\n    return 0;\n\n  std::cout &lt;&lt; json_object[&quot;name&quot;] &lt;&lt; std::endl;\n  std::cout &lt;&lt; json_object[&quot;age&quot;] &lt;&lt; std::endl;\n</code></pre>\n<p>输出结果为：</p>\n<pre><code class=\"json\">&quot;huchao&quot;\n</code></pre>\n<p>可见，上述代码已经解析出了 json 字符串。</p>\n<blockquote>\n<p>[1]：使用第三方源码最简单的方法是直接将文件加入工程，但这样不利于源码、软件产品管理，对于一般软件开发来说，不建议使用。</p>\n</blockquote>\n<blockquote>\n<p>[2]：如果真需要编译成动态链接库、静态导入库的话，可以使用 VS 新建一个工程属性，然后在Project –&gt; Properties中进行相应的设置即可。</p>\n<p>来源：<br>[1]: <a href=\"http://blog.csdn.net/xt_xiaotian/article/details/5648388\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/xt_xiaotian/article/details/5648388</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C-处理-JSON-数据交换格式\"><a href=\"#C-处理-JSON-数据交换格式\" class=\"headerlink\" title=\"C++ 处理 JSON 数据交换格式\"></a>C++ 处理 JSON 数据交换格式</h1><hr>\n<p>使用 C++ 处理 JSON 数据交换格式</p>\n<hr>\n<p>##一、摘要<br>JSON 的全称为：JavaScript Object Notation，顾名思义，JSON 是用于标记 Javascript 对象的，JSON 官方的解释为：JSON 是一种轻量级的数据传输格式。<br>本文并不详细介绍 JSON 本身的细节，旨在讨论如何使用 C++ 语言来处理 JSON。关于 JSON更具体的信息，可参见 JSON 官网：<a href=\"http://www.json.org。\" target=\"_blank\" rel=\"noopener\">http://www.json.org。</a></p>\n<hr>\n<p>##二、本文选择处理 JSON的 C++ 库<br>本文选择一个第三方库 jsoncpp 来解析 JSON。jsoncpp 是比较出名的 C++ JSON 解析库。在 JSON官网也是首推的。<br>下载地址为：<a href=\"http://sourceforge.net/projects/jsoncpp。本文使用的\" target=\"_blank\" rel=\"noopener\">http://sourceforge.net/projects/jsoncpp。本文使用的</a> jsoncpp 版本为：0.5.0。</p>\n<hr>\n<p>##三、jsoncpp 在 Windows 下的编译<br>要使用第三方源码库，第一步少不了的就是编译，将源码文件编译成我们方便使用的动态链接库、静态链接库或者静态导入库[1]。<br>jsconcpp 进行 JSON 解析的源码文件分布在 include/json、src/lib_json 下。其实 jsoncpp 源码并不多，为了方便产品管理，此处没必要将其编译为动态链接库或者静态导入库，所以我们选择使用静态链接库[2]。<br>jsoncpp 已经处理的很完善了，所有编译选项都已经配置好，打开makefiles/vs71/jsoncpp.sln 便可以开始编译（默认是使用 VS2003 编译器的，打开时直接按照 VS2005 提示转换即可）。</p>\n<hr>\n<p>##四、jsoncpp 使用详解<br>jsoncpp 主要包含三种类型的 class：Value、Reader、Writer。jsoncpp 中所有对象、类名都在namespace Json 中，包含 json.h 即可。</p>\n<p>Json::Value 只能处理 ANSI 类型的字符串，如果 C++ 程序是用 Unicode 编码的，最好加一个 Adapt类来适配。</p>\n<p>###1、Value<br>Json::Value 是jsoncpp 中最基本、最重要的类，用于表示各种类型的对象，jsoncpp 支持的对象类型可见 Json::ValueType 枚举值。<br>可如下是用 Json::Value 类：</p>\n<pre><code class=\"c++\">Json::Value json_temp;      // 临时对象，供如下代码使用\njson_temp[&quot;name&quot;] = Json::Value(&quot;huchao&quot;);\njson_temp[&quot;age&quot;] = Json::Value(26);\n\nJson::Value root;  // 表示整个 json 对象\nroot[&quot;key_string&quot;] = Json::Value(&quot;value_string&quot;);         // 新建一个 Key（名为：key_string），赋予字符串值：&quot;value_string&quot;。\nroot[&quot;key_number&quot;] = Json::Value(12345);            // 新建一个 Key（名为：key_number），赋予数值：12345。\nroot[&quot;key_boolean&quot;] = Json::Value(false);              // 新建一个 Key（名为：key_boolean），赋予bool值：false。\nroot[&quot;key_double&quot;] = Json::Value(12.345);            // 新建一个 Key（名为：key_double），赋予 double值：12.345。\nroot[&quot;key_object&quot;] = Json_temp;                           // 新建一个 Key（名为：key_object），赋予json::Value 对象值。\nroot[&quot;key_array&quot;].append(&quot;array_string&quot;);             // 新建一个 Key（名为：key_array），类型为数组，对第一个元素赋值为字符串：&quot;array_string&quot;。\nroot[&quot;key_array&quot;].append(1234);                           // 为数组 key_array 赋值，对第二个元素赋值为：1234。\nJson::ValueType type = root.type();// 获得 root 的类型，此处为 objectValue 类型。\n</code></pre>\n<p>注：跟C++ 不同，JavaScript 数组可以为任意类型的值，所以 jsoncpp 也可以。<br>    如上几个用法已经可以满足绝大部分 json 应用了，当然 jsoncpp 还有一些其他同能，比如说设置注释、比较 json 大小、交换 json 对象等，都很容易使用，大家自己尝试吧。</p>\n<p>###2、Writer<br>如上说了 Json::Value 的使用方式，现在到了该查看刚才赋值内容的时候了，查看 json 内容，使用 Writer 类即可。<br>Jsoncpp 的 Json::Writer 类是一个纯虚类，并不能直接使用。在此我们使用 Json::Writer 的子类：Json::FastWriter、Json::StyledWriter、Json::StyledStreamWriter。<br>顾名思义，用 Json::FastWriter 来处理 json 应该是最快的，下面我们来试试。</p>\n<pre><code class=\"c++\">Json::FastWriter fast_writer;\nstd::cout &lt;&lt; fast_writer.write(root) &lt;&lt; std::endl;\n</code></pre>\n<p>输出结果为：</p>\n<pre><code class=\"json\">{&quot;key_array&quot;:[&quot;array_string&quot;,1234],&quot;key_boolean&quot;:false,&quot;key_double&quot;:12.3450,&quot;key_number&quot;:12345,&quot;key_object&quot;:{&quot;age&quot;:26,&quot;name&quot;:&quot;huchao&quot;},&quot;key_string&quot;:&quot;value_string&quot;}\n</code></pre>\n<p>再次顾名思义，用 Json::StyledWriter 是格式化后的 json，下面我们来看看 Json::StyledWriter 是怎样格式化的。</p>\n<pre><code class=\"c++\">Json::StyledWriter styled_writer;\nstd::cout &lt;&lt; styled_writer.write(root) &lt;&lt; std::endl;\n</code></pre>\n<p>输出结果为：</p>\n<pre><code class=\"json\">{\n   &quot;key_array&quot; : [ &quot;array_string&quot;, 1234 ],\n   &quot;key_boolean&quot; : false,\n   &quot;key_double&quot; : 12.3450,\n   &quot;key_number&quot; : 12345,\n   &quot;key_object&quot; : {\n      &quot;age&quot; : 26,\n      &quot;name&quot; : &quot;huchao&quot;\n   },\n   &quot;key_string&quot; : &quot;value_string&quot;\n}\n</code></pre>\n<p>###3、Reader<br>Json::Reader 是用于读取的，说的确切点，是用于将字符串转换为 Json::Value 对象的，下面我们来看个简单的例子。</p>\n<pre><code class=\"c++\">  Json::Reader reader;\n  Json::Value json_object;\n  const char* json_document = &quot;{/&quot;age/&quot; : 26,/&quot;name/&quot; : /&quot;huchao/&quot;}&quot;;\n  if (!reader.parse(json_document, json_object))\n    return 0;\n\n  std::cout &lt;&lt; json_object[&quot;name&quot;] &lt;&lt; std::endl;\n  std::cout &lt;&lt; json_object[&quot;age&quot;] &lt;&lt; std::endl;\n</code></pre>\n<p>输出结果为：</p>\n<pre><code class=\"json\">&quot;huchao&quot;\n</code></pre>\n<p>可见，上述代码已经解析出了 json 字符串。</p>\n<blockquote>\n<p>[1]：使用第三方源码最简单的方法是直接将文件加入工程，但这样不利于源码、软件产品管理，对于一般软件开发来说，不建议使用。</p>\n</blockquote>\n<blockquote>\n<p>[2]：如果真需要编译成动态链接库、静态导入库的话，可以使用 VS 新建一个工程属性，然后在Project –&gt; Properties中进行相应的设置即可。</p>\n<p>来源：<br>[1]: <a href=\"http://blog.csdn.net/xt_xiaotian/article/details/5648388\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/xt_xiaotian/article/details/5648388</a></p>\n</blockquote>\n"},{"title":"C++的list和vector有什么区别","date":"2018-10-02T01:09:09.000Z","_content":"# C++的list和vector有什么区别\n\n---\n\n\n\n总结：list链结构存储 vector是连续内存空间存储，当后者内存空间不够会影响效率\n前者由于是链结构，遍历时会影响搜索效率，但很好支持插入删除的操作\n\nvector和数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随机存取（即使用[]操作符访问其中的元素），但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝（复杂度是O(n)），另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。\n\nlist是由数据结构中的双向链表实现的，因此它的内存空间可以是不连续的。因此只能通过指针来进行数据的访问，这个特点使得它的随机存取变的非常没有效率，需要遍历中间的元素，搜索复杂度O(n)，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。\n由于list和vector上面的这些区别，因此list::iterator与vector::iterator也有一些不同。请看下面的例子：\n```c++\n#include <iostream>\n#include <vector>\n#include <list>\nusing namespace std;\n\nint main( void )\n{\n        vector<int> v; \n        list<int> l;\n\n        for (int i=0; i<8; i++)     //往v和l中分别添加元素\n        {\n                v.push_back(i);\n                l.push_back(i);\n        }\n\n        cout << \"v[2] = \" << v[2] << endl;\n        //cout << \"l[2] = \" << l[2] << endl;       //编译错误,list没有重载[]\n        cout << (v.begin() < v.end()) << endl;\n        //cout << (l.begin() < l.end()) << endl;   //编译错误,list::iterator没有重载<或>\n        cout << *(v.begin() + 1) << endl;\n\n        vector<int>::iterator itv = v.begin();\n        list<int>::iterator itl = l.begin();\n        itv = itv + 2;\n        //itl = itl + 2;                  //编译错误,list::iterator没有重载+\n        itl++;itl++;                    //list::iterator中重载了++，只能使用++进行迭代访问。\n        cout << *itv << endl;\n        cout << *itl << endl;\n\n        return 0;\n}\n```\n由于vector拥有一段连续的内存空间，能非常好的支持随机存取，因此vector<int>::iterator支持“+”、“+=”、“<”等操作符。\n而list的内存空间可以是不连续，它不支持随机访问，因此list<int>::iterator则不支持“+”、“+=”、“<”等操作符运算，因此代码20、26行会有编译错误。只能使用“++”进行迭代，例如代码27行，使用两次itl++来移动itl。还有list也不支持[]运算符，因此代码18行出现编译错误。总之，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector；如果需要大量的插入和删除，而不关心随即存取，则应使用list。\n\n答案： vector拥有一段连续的内存空间，因此支持随机存取，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector。list拥有一段不连续的内存空间，因此支持随机存取，如果需要大量的插入和删除，而不关心随即存取，则应使用list。\n\n>来源：\n>[1]: <http://genwoxuevc.blog.51cto.com/1852984/503337>\n ","source":"_posts/C++/CPP的list和vector有什么区别.md","raw":"---\ntitle: C++的list和vector有什么区别\ndate: 2018-10-02 09:09:09\ncategories: cpp\n---\n# C++的list和vector有什么区别\n\n---\n\n\n\n总结：list链结构存储 vector是连续内存空间存储，当后者内存空间不够会影响效率\n前者由于是链结构，遍历时会影响搜索效率，但很好支持插入删除的操作\n\nvector和数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随机存取（即使用[]操作符访问其中的元素），但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝（复杂度是O(n)），另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。\n\nlist是由数据结构中的双向链表实现的，因此它的内存空间可以是不连续的。因此只能通过指针来进行数据的访问，这个特点使得它的随机存取变的非常没有效率，需要遍历中间的元素，搜索复杂度O(n)，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。\n由于list和vector上面的这些区别，因此list::iterator与vector::iterator也有一些不同。请看下面的例子：\n```c++\n#include <iostream>\n#include <vector>\n#include <list>\nusing namespace std;\n\nint main( void )\n{\n        vector<int> v; \n        list<int> l;\n\n        for (int i=0; i<8; i++)     //往v和l中分别添加元素\n        {\n                v.push_back(i);\n                l.push_back(i);\n        }\n\n        cout << \"v[2] = \" << v[2] << endl;\n        //cout << \"l[2] = \" << l[2] << endl;       //编译错误,list没有重载[]\n        cout << (v.begin() < v.end()) << endl;\n        //cout << (l.begin() < l.end()) << endl;   //编译错误,list::iterator没有重载<或>\n        cout << *(v.begin() + 1) << endl;\n\n        vector<int>::iterator itv = v.begin();\n        list<int>::iterator itl = l.begin();\n        itv = itv + 2;\n        //itl = itl + 2;                  //编译错误,list::iterator没有重载+\n        itl++;itl++;                    //list::iterator中重载了++，只能使用++进行迭代访问。\n        cout << *itv << endl;\n        cout << *itl << endl;\n\n        return 0;\n}\n```\n由于vector拥有一段连续的内存空间，能非常好的支持随机存取，因此vector<int>::iterator支持“+”、“+=”、“<”等操作符。\n而list的内存空间可以是不连续，它不支持随机访问，因此list<int>::iterator则不支持“+”、“+=”、“<”等操作符运算，因此代码20、26行会有编译错误。只能使用“++”进行迭代，例如代码27行，使用两次itl++来移动itl。还有list也不支持[]运算符，因此代码18行出现编译错误。总之，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector；如果需要大量的插入和删除，而不关心随即存取，则应使用list。\n\n答案： vector拥有一段连续的内存空间，因此支持随机存取，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector。list拥有一段不连续的内存空间，因此支持随机存取，如果需要大量的插入和删除，而不关心随即存取，则应使用list。\n\n>来源：\n>[1]: <http://genwoxuevc.blog.51cto.com/1852984/503337>\n ","slug":"C++/CPP的list和vector有什么区别","published":1,"updated":"2018-10-02T05:04:57.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4m2000lntnbbkf7k1li","content":"<h1 id=\"C-的list和vector有什么区别\"><a href=\"#C-的list和vector有什么区别\" class=\"headerlink\" title=\"C++的list和vector有什么区别\"></a>C++的list和vector有什么区别</h1><hr>\n<p>总结：list链结构存储 vector是连续内存空间存储，当后者内存空间不够会影响效率<br>前者由于是链结构，遍历时会影响搜索效率，但很好支持插入删除的操作</p>\n<p>vector和数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随机存取（即使用[]操作符访问其中的元素），但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝（复杂度是O(n)），另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。</p>\n<p>list是由数据结构中的双向链表实现的，因此它的内存空间可以是不连续的。因此只能通过指针来进行数据的访问，这个特点使得它的随机存取变的非常没有效率，需要遍历中间的元素，搜索复杂度O(n)，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。<br>由于list和vector上面的这些区别，因此list::iterator与vector::iterator也有一些不同。请看下面的例子：</p>\n<pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;list&gt;\nusing namespace std;\n\nint main( void )\n{\n        vector&lt;int&gt; v; \n        list&lt;int&gt; l;\n\n        for (int i=0; i&lt;8; i++)     //往v和l中分别添加元素\n        {\n                v.push_back(i);\n                l.push_back(i);\n        }\n\n        cout &lt;&lt; &quot;v[2] = &quot; &lt;&lt; v[2] &lt;&lt; endl;\n        //cout &lt;&lt; &quot;l[2] = &quot; &lt;&lt; l[2] &lt;&lt; endl;       //编译错误,list没有重载[]\n        cout &lt;&lt; (v.begin() &lt; v.end()) &lt;&lt; endl;\n        //cout &lt;&lt; (l.begin() &lt; l.end()) &lt;&lt; endl;   //编译错误,list::iterator没有重载&lt;或&gt;\n        cout &lt;&lt; *(v.begin() + 1) &lt;&lt; endl;\n\n        vector&lt;int&gt;::iterator itv = v.begin();\n        list&lt;int&gt;::iterator itl = l.begin();\n        itv = itv + 2;\n        //itl = itl + 2;                  //编译错误,list::iterator没有重载+\n        itl++;itl++;                    //list::iterator中重载了++，只能使用++进行迭代访问。\n        cout &lt;&lt; *itv &lt;&lt; endl;\n        cout &lt;&lt; *itl &lt;&lt; endl;\n\n        return 0;\n}\n</code></pre>\n<p>由于vector拥有一段连续的内存空间，能非常好的支持随机存取，因此vector<int>::iterator支持“+”、“+=”、“&lt;”等操作符。<br>而list的内存空间可以是不连续，它不支持随机访问，因此list<int>::iterator则不支持“+”、“+=”、“&lt;”等操作符运算，因此代码20、26行会有编译错误。只能使用“++”进行迭代，例如代码27行，使用两次itl++来移动itl。还有list也不支持[]运算符，因此代码18行出现编译错误。总之，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector；如果需要大量的插入和删除，而不关心随即存取，则应使用list。</int></int></p>\n<p>答案： vector拥有一段连续的内存空间，因此支持随机存取，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector。list拥有一段不连续的内存空间，因此支持随机存取，如果需要大量的插入和删除，而不关心随即存取，则应使用list。</p>\n<blockquote>\n<p>来源：<br>[1]: <a href=\"http://genwoxuevc.blog.51cto.com/1852984/503337\" target=\"_blank\" rel=\"noopener\">http://genwoxuevc.blog.51cto.com/1852984/503337</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C-的list和vector有什么区别\"><a href=\"#C-的list和vector有什么区别\" class=\"headerlink\" title=\"C++的list和vector有什么区别\"></a>C++的list和vector有什么区别</h1><hr>\n<p>总结：list链结构存储 vector是连续内存空间存储，当后者内存空间不够会影响效率<br>前者由于是链结构，遍历时会影响搜索效率，但很好支持插入删除的操作</p>\n<p>vector和数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随机存取（即使用[]操作符访问其中的元素），但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝（复杂度是O(n)），另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。</p>\n<p>list是由数据结构中的双向链表实现的，因此它的内存空间可以是不连续的。因此只能通过指针来进行数据的访问，这个特点使得它的随机存取变的非常没有效率，需要遍历中间的元素，搜索复杂度O(n)，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。<br>由于list和vector上面的这些区别，因此list::iterator与vector::iterator也有一些不同。请看下面的例子：</p>\n<pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;list&gt;\nusing namespace std;\n\nint main( void )\n{\n        vector&lt;int&gt; v; \n        list&lt;int&gt; l;\n\n        for (int i=0; i&lt;8; i++)     //往v和l中分别添加元素\n        {\n                v.push_back(i);\n                l.push_back(i);\n        }\n\n        cout &lt;&lt; &quot;v[2] = &quot; &lt;&lt; v[2] &lt;&lt; endl;\n        //cout &lt;&lt; &quot;l[2] = &quot; &lt;&lt; l[2] &lt;&lt; endl;       //编译错误,list没有重载[]\n        cout &lt;&lt; (v.begin() &lt; v.end()) &lt;&lt; endl;\n        //cout &lt;&lt; (l.begin() &lt; l.end()) &lt;&lt; endl;   //编译错误,list::iterator没有重载&lt;或&gt;\n        cout &lt;&lt; *(v.begin() + 1) &lt;&lt; endl;\n\n        vector&lt;int&gt;::iterator itv = v.begin();\n        list&lt;int&gt;::iterator itl = l.begin();\n        itv = itv + 2;\n        //itl = itl + 2;                  //编译错误,list::iterator没有重载+\n        itl++;itl++;                    //list::iterator中重载了++，只能使用++进行迭代访问。\n        cout &lt;&lt; *itv &lt;&lt; endl;\n        cout &lt;&lt; *itl &lt;&lt; endl;\n\n        return 0;\n}\n</code></pre>\n<p>由于vector拥有一段连续的内存空间，能非常好的支持随机存取，因此vector<int>::iterator支持“+”、“+=”、“&lt;”等操作符。<br>而list的内存空间可以是不连续，它不支持随机访问，因此list<int>::iterator则不支持“+”、“+=”、“&lt;”等操作符运算，因此代码20、26行会有编译错误。只能使用“++”进行迭代，例如代码27行，使用两次itl++来移动itl。还有list也不支持[]运算符，因此代码18行出现编译错误。总之，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector；如果需要大量的插入和删除，而不关心随即存取，则应使用list。</int></int></p>\n<p>答案： vector拥有一段连续的内存空间，因此支持随机存取，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector。list拥有一段不连续的内存空间，因此支持随机存取，如果需要大量的插入和删除，而不关心随即存取，则应使用list。</p>\n<blockquote>\n<p>来源：<br>[1]: <a href=\"http://genwoxuevc.blog.51cto.com/1852984/503337\" target=\"_blank\" rel=\"noopener\">http://genwoxuevc.blog.51cto.com/1852984/503337</a></p>\n</blockquote>\n"},{"title":"UTF-8带签名和无签名的区别","date":"2018-10-02T01:09:09.000Z","_content":"# UTF-8带签名和无签名的区别\n在VS中编码保存时，文件编码的选择里的UTF-8有带签名和无签名2种，那么到底有什么区别呢？ \n带签名即文件头含BOM信息，不带则没有。 \n带了的好处是，只要支持多编码的编辑器都能正确识别出文件编码。 \n不带的话，就不一定了，就有可能识别错别。 \n总之呢，这个BOM信息也就那么三字节，没必要省这么一点点空间，要用UFT-8就选带签名，这样就不会错了。\n\n另外，VS2008似乎不能设置默认的编码格式，中文版的默认编码格式是gb2312，英文版的是utf-8。如果要想保存成其他的编码格式，可以在“文件”-〉“高级保存选项”中更改\n>来源：\n>[1]: <http://blog.csdn.net/crystal_ooo/article/details/8077141>\n \n","source":"_posts/C++/UTF-8带签名和无签名的区别.md","raw":"---\ntitle: UTF-8带签名和无签名的区别\ndate: 2018-10-02 09:09:09\ncategories: cpp\n---\n# UTF-8带签名和无签名的区别\n在VS中编码保存时，文件编码的选择里的UTF-8有带签名和无签名2种，那么到底有什么区别呢？ \n带签名即文件头含BOM信息，不带则没有。 \n带了的好处是，只要支持多编码的编辑器都能正确识别出文件编码。 \n不带的话，就不一定了，就有可能识别错别。 \n总之呢，这个BOM信息也就那么三字节，没必要省这么一点点空间，要用UFT-8就选带签名，这样就不会错了。\n\n另外，VS2008似乎不能设置默认的编码格式，中文版的默认编码格式是gb2312，英文版的是utf-8。如果要想保存成其他的编码格式，可以在“文件”-〉“高级保存选项”中更改\n>来源：\n>[1]: <http://blog.csdn.net/crystal_ooo/article/details/8077141>\n \n","slug":"C++/UTF-8带签名和无签名的区别","published":1,"updated":"2018-10-02T05:05:31.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4m3000nntnb4v12d779","content":"<h1 id=\"UTF-8带签名和无签名的区别\"><a href=\"#UTF-8带签名和无签名的区别\" class=\"headerlink\" title=\"UTF-8带签名和无签名的区别\"></a>UTF-8带签名和无签名的区别</h1><p>在VS中编码保存时，文件编码的选择里的UTF-8有带签名和无签名2种，那么到底有什么区别呢？<br>带签名即文件头含BOM信息，不带则没有。<br>带了的好处是，只要支持多编码的编辑器都能正确识别出文件编码。<br>不带的话，就不一定了，就有可能识别错别。<br>总之呢，这个BOM信息也就那么三字节，没必要省这么一点点空间，要用UFT-8就选带签名，这样就不会错了。</p>\n<p>另外，VS2008似乎不能设置默认的编码格式，中文版的默认编码格式是gb2312，英文版的是utf-8。如果要想保存成其他的编码格式，可以在“文件”-〉“高级保存选项”中更改</p>\n<blockquote>\n<p>来源：<br>[1]: <a href=\"http://blog.csdn.net/crystal_ooo/article/details/8077141\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/crystal_ooo/article/details/8077141</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"UTF-8带签名和无签名的区别\"><a href=\"#UTF-8带签名和无签名的区别\" class=\"headerlink\" title=\"UTF-8带签名和无签名的区别\"></a>UTF-8带签名和无签名的区别</h1><p>在VS中编码保存时，文件编码的选择里的UTF-8有带签名和无签名2种，那么到底有什么区别呢？<br>带签名即文件头含BOM信息，不带则没有。<br>带了的好处是，只要支持多编码的编辑器都能正确识别出文件编码。<br>不带的话，就不一定了，就有可能识别错别。<br>总之呢，这个BOM信息也就那么三字节，没必要省这么一点点空间，要用UFT-8就选带签名，这样就不会错了。</p>\n<p>另外，VS2008似乎不能设置默认的编码格式，中文版的默认编码格式是gb2312，英文版的是utf-8。如果要想保存成其他的编码格式，可以在“文件”-〉“高级保存选项”中更改</p>\n<blockquote>\n<p>来源：<br>[1]: <a href=\"http://blog.csdn.net/crystal_ooo/article/details/8077141\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/crystal_ooo/article/details/8077141</a></p>\n</blockquote>\n"},{"title":"C++识别不同的运行平台linux和win32","date":"2018-10-02T01:09:09.000Z","_content":"# C++识别不同的运行平台linux和win32\n\n![](/public/image/79341078.jpg)\n\n","source":"_posts/C++/CPP识别不同的运行平台linux和win32.md","raw":"---\ntitle: C++识别不同的运行平台linux和win32\ndate: 2018-10-02 09:09:09\ncategories: cpp\n---\n# C++识别不同的运行平台linux和win32\n\n![](/public/image/79341078.jpg)\n\n","slug":"C++/CPP识别不同的运行平台linux和win32","published":1,"updated":"2018-10-02T05:05:25.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4m4000qntnbtb2jvgrg","content":"<h1 id=\"C-识别不同的运行平台linux和win32\"><a href=\"#C-识别不同的运行平台linux和win32\" class=\"headerlink\" title=\"C++识别不同的运行平台linux和win32\"></a>C++识别不同的运行平台linux和win32</h1><p><img src=\"/public/image/79341078.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C-识别不同的运行平台linux和win32\"><a href=\"#C-识别不同的运行平台linux和win32\" class=\"headerlink\" title=\"C++识别不同的运行平台linux和win32\"></a>C++识别不同的运行平台linux和win32</h1><p><img src=\"/public/image/79341078.jpg\" alt=\"\"></p>\n"},{"title":"Hadoop筆記","date":"2018-10-02T01:09:09.000Z","_content":"### Mac Hadoop筆記\n\nwww.linuxidc.com\\/Linux\\/2016-10\\/136188.htm\n\nmac 启动sshd\n\nsudo launchctl load -w \\/System\\/Library\\/LaunchDaemons\\/ssh.plist\n\n查看启动\n\nsudo launchctl list \\| grep ssh\n\n输出- 0 com.openssh.sshd 表示启动成功\n\n停止sshd服务\n\nsudo launchctl unload -w \\/System\\/Library\\/LaunchDaemons\\/ssh.plist\n\n命令查找java home\n\n\\/usr\\/libexec\\/java\\_home\n\n1. sudo .\\/configure\n2. sudo make\n3. sudo make check\n4. sudo make install\n5. protoc --version\n\n### mvn\n\n打包：mvn package\n\n编译：mvn compile\n\n编译测试程序：mvn test-compile\n\n清空：mvn clean\n\n运行测试：mvn test\n\n生成站点目录: mvn site\n\n生成站点目录并发布：mvn site-deploy\n\n安装当前工程的输出文件到本地仓库: mvn install\n\nmvn compile：编译源代码,生成对应的CLASS文件，执行流程可见流程如图3\n\nmvn test-compile：编译**[测试](http://lib.csdn.net/base/softwaretest \"软件测试知识库\")**代码,生成对应的CLASS文件，执行流程可见流程如图3\n\nmvn test：运行测试,生成对应的CLASS文件，执行流程可见流程如图3\n\nmvn package：打包,生成JAR文件，只能本程序用，或者拷贝到其它项目使用，执行流程可见流程如图3\n\nmvn install ：打包,生成JAR文件，并在本地仓库生成JAR和POM文件，供其它Maven项目共享,，执行流程可见流程如图3；\n\nmvn clean ：清除产生的项目\n\n* $ mvn -version\n* $ mvn clean\n* $ mvn install -DskipTests\n* $ mvn compile -DskipTests\n* $ mvn package -DskipTests\n* $ mvn package -Pdist -DskipTests -Dtar\n\nmvn package -Pdist,native,docs,src -DskipTests -Dtar\n\n### Mac系统的环境变量，加载顺序为：\n\n\\/etc\\/profile \\/etc\\/paths ~\\/.bash\\_profile ~\\/.bash\\_login ~\\/.profile ~\\/.bashrc\n\n### Mac命令\n\nrm -r -f 文件夹名\n\n### Hadoop localhost\n\nhttp:\\/\\/localhost:9870\\/\n\nhttp:\\/\\/localhost:8088\\/cluster\n\n","source":"_posts/Hadoop/MacHadoop安裝.md","raw":"---\ntitle: Hadoop筆記\ndate: 2018-10-02 09:09:09\ncategories: Hadoop\n---\n### Mac Hadoop筆記\n\nwww.linuxidc.com\\/Linux\\/2016-10\\/136188.htm\n\nmac 启动sshd\n\nsudo launchctl load -w \\/System\\/Library\\/LaunchDaemons\\/ssh.plist\n\n查看启动\n\nsudo launchctl list \\| grep ssh\n\n输出- 0 com.openssh.sshd 表示启动成功\n\n停止sshd服务\n\nsudo launchctl unload -w \\/System\\/Library\\/LaunchDaemons\\/ssh.plist\n\n命令查找java home\n\n\\/usr\\/libexec\\/java\\_home\n\n1. sudo .\\/configure\n2. sudo make\n3. sudo make check\n4. sudo make install\n5. protoc --version\n\n### mvn\n\n打包：mvn package\n\n编译：mvn compile\n\n编译测试程序：mvn test-compile\n\n清空：mvn clean\n\n运行测试：mvn test\n\n生成站点目录: mvn site\n\n生成站点目录并发布：mvn site-deploy\n\n安装当前工程的输出文件到本地仓库: mvn install\n\nmvn compile：编译源代码,生成对应的CLASS文件，执行流程可见流程如图3\n\nmvn test-compile：编译**[测试](http://lib.csdn.net/base/softwaretest \"软件测试知识库\")**代码,生成对应的CLASS文件，执行流程可见流程如图3\n\nmvn test：运行测试,生成对应的CLASS文件，执行流程可见流程如图3\n\nmvn package：打包,生成JAR文件，只能本程序用，或者拷贝到其它项目使用，执行流程可见流程如图3\n\nmvn install ：打包,生成JAR文件，并在本地仓库生成JAR和POM文件，供其它Maven项目共享,，执行流程可见流程如图3；\n\nmvn clean ：清除产生的项目\n\n* $ mvn -version\n* $ mvn clean\n* $ mvn install -DskipTests\n* $ mvn compile -DskipTests\n* $ mvn package -DskipTests\n* $ mvn package -Pdist -DskipTests -Dtar\n\nmvn package -Pdist,native,docs,src -DskipTests -Dtar\n\n### Mac系统的环境变量，加载顺序为：\n\n\\/etc\\/profile \\/etc\\/paths ~\\/.bash\\_profile ~\\/.bash\\_login ~\\/.profile ~\\/.bashrc\n\n### Mac命令\n\nrm -r -f 文件夹名\n\n### Hadoop localhost\n\nhttp:\\/\\/localhost:9870\\/\n\nhttp:\\/\\/localhost:8088\\/cluster\n\n","slug":"Hadoop/MacHadoop安裝","published":1,"updated":"2018-10-02T02:09:16.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4m5000rntnbhdlzlbq6","content":"<h3 id=\"Mac-Hadoop筆記\"><a href=\"#Mac-Hadoop筆記\" class=\"headerlink\" title=\"Mac Hadoop筆記\"></a>Mac Hadoop筆記</h3><p><a href=\"http://www.linuxidc.com\\/Linux\\/2016-10\\/136188.htm\" target=\"_blank\" rel=\"noopener\">www.linuxidc.com\\/Linux\\/2016-10\\/136188.htm</a></p>\n<p>mac 启动sshd</p>\n<p>sudo launchctl load -w \\/System\\/Library\\/LaunchDaemons\\/ssh.plist</p>\n<p>查看启动</p>\n<p>sudo launchctl list | grep ssh</p>\n<p>输出- 0 com.openssh.sshd 表示启动成功</p>\n<p>停止sshd服务</p>\n<p>sudo launchctl unload -w \\/System\\/Library\\/LaunchDaemons\\/ssh.plist</p>\n<p>命令查找java home</p>\n<p>\\/usr\\/libexec\\/java_home</p>\n<ol>\n<li>sudo .\\/configure</li>\n<li>sudo make</li>\n<li>sudo make check</li>\n<li>sudo make install</li>\n<li>protoc –version</li>\n</ol>\n<h3 id=\"mvn\"><a href=\"#mvn\" class=\"headerlink\" title=\"mvn\"></a>mvn</h3><p>打包：mvn package</p>\n<p>编译：mvn compile</p>\n<p>编译测试程序：mvn test-compile</p>\n<p>清空：mvn clean</p>\n<p>运行测试：mvn test</p>\n<p>生成站点目录: mvn site</p>\n<p>生成站点目录并发布：mvn site-deploy</p>\n<p>安装当前工程的输出文件到本地仓库: mvn install</p>\n<p>mvn compile：编译源代码,生成对应的CLASS文件，执行流程可见流程如图3</p>\n<p>mvn test-compile：编译<strong><a href=\"http://lib.csdn.net/base/softwaretest\" title=\"软件测试知识库\" target=\"_blank\" rel=\"noopener\">测试</a></strong>代码,生成对应的CLASS文件，执行流程可见流程如图3</p>\n<p>mvn test：运行测试,生成对应的CLASS文件，执行流程可见流程如图3</p>\n<p>mvn package：打包,生成JAR文件，只能本程序用，或者拷贝到其它项目使用，执行流程可见流程如图3</p>\n<p>mvn install ：打包,生成JAR文件，并在本地仓库生成JAR和POM文件，供其它Maven项目共享,，执行流程可见流程如图3；</p>\n<p>mvn clean ：清除产生的项目</p>\n<ul>\n<li>$ mvn -version</li>\n<li>$ mvn clean</li>\n<li>$ mvn install -DskipTests</li>\n<li>$ mvn compile -DskipTests</li>\n<li>$ mvn package -DskipTests</li>\n<li>$ mvn package -Pdist -DskipTests -Dtar</li>\n</ul>\n<p>mvn package -Pdist,native,docs,src -DskipTests -Dtar</p>\n<h3 id=\"Mac系统的环境变量，加载顺序为：\"><a href=\"#Mac系统的环境变量，加载顺序为：\" class=\"headerlink\" title=\"Mac系统的环境变量，加载顺序为：\"></a>Mac系统的环境变量，加载顺序为：</h3><p>\\/etc\\/profile \\/etc\\/paths ~\\/.bash_profile ~\\/.bash_login ~\\/.profile ~\\/.bashrc</p>\n<h3 id=\"Mac命令\"><a href=\"#Mac命令\" class=\"headerlink\" title=\"Mac命令\"></a>Mac命令</h3><p>rm -r -f 文件夹名</p>\n<h3 id=\"Hadoop-localhost\"><a href=\"#Hadoop-localhost\" class=\"headerlink\" title=\"Hadoop localhost\"></a>Hadoop localhost</h3><p>http:\\/\\/localhost:9870\\/</p>\n<p>http:\\/\\/localhost:8088\\/cluster</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Mac-Hadoop筆記\"><a href=\"#Mac-Hadoop筆記\" class=\"headerlink\" title=\"Mac Hadoop筆記\"></a>Mac Hadoop筆記</h3><p><a href=\"http://www.linuxidc.com\\/Linux\\/2016-10\\/136188.htm\" target=\"_blank\" rel=\"noopener\">www.linuxidc.com\\/Linux\\/2016-10\\/136188.htm</a></p>\n<p>mac 启动sshd</p>\n<p>sudo launchctl load -w \\/System\\/Library\\/LaunchDaemons\\/ssh.plist</p>\n<p>查看启动</p>\n<p>sudo launchctl list | grep ssh</p>\n<p>输出- 0 com.openssh.sshd 表示启动成功</p>\n<p>停止sshd服务</p>\n<p>sudo launchctl unload -w \\/System\\/Library\\/LaunchDaemons\\/ssh.plist</p>\n<p>命令查找java home</p>\n<p>\\/usr\\/libexec\\/java_home</p>\n<ol>\n<li>sudo .\\/configure</li>\n<li>sudo make</li>\n<li>sudo make check</li>\n<li>sudo make install</li>\n<li>protoc –version</li>\n</ol>\n<h3 id=\"mvn\"><a href=\"#mvn\" class=\"headerlink\" title=\"mvn\"></a>mvn</h3><p>打包：mvn package</p>\n<p>编译：mvn compile</p>\n<p>编译测试程序：mvn test-compile</p>\n<p>清空：mvn clean</p>\n<p>运行测试：mvn test</p>\n<p>生成站点目录: mvn site</p>\n<p>生成站点目录并发布：mvn site-deploy</p>\n<p>安装当前工程的输出文件到本地仓库: mvn install</p>\n<p>mvn compile：编译源代码,生成对应的CLASS文件，执行流程可见流程如图3</p>\n<p>mvn test-compile：编译<strong><a href=\"http://lib.csdn.net/base/softwaretest\" title=\"软件测试知识库\" target=\"_blank\" rel=\"noopener\">测试</a></strong>代码,生成对应的CLASS文件，执行流程可见流程如图3</p>\n<p>mvn test：运行测试,生成对应的CLASS文件，执行流程可见流程如图3</p>\n<p>mvn package：打包,生成JAR文件，只能本程序用，或者拷贝到其它项目使用，执行流程可见流程如图3</p>\n<p>mvn install ：打包,生成JAR文件，并在本地仓库生成JAR和POM文件，供其它Maven项目共享,，执行流程可见流程如图3；</p>\n<p>mvn clean ：清除产生的项目</p>\n<ul>\n<li>$ mvn -version</li>\n<li>$ mvn clean</li>\n<li>$ mvn install -DskipTests</li>\n<li>$ mvn compile -DskipTests</li>\n<li>$ mvn package -DskipTests</li>\n<li>$ mvn package -Pdist -DskipTests -Dtar</li>\n</ul>\n<p>mvn package -Pdist,native,docs,src -DskipTests -Dtar</p>\n<h3 id=\"Mac系统的环境变量，加载顺序为：\"><a href=\"#Mac系统的环境变量，加载顺序为：\" class=\"headerlink\" title=\"Mac系统的环境变量，加载顺序为：\"></a>Mac系统的环境变量，加载顺序为：</h3><p>\\/etc\\/profile \\/etc\\/paths ~\\/.bash_profile ~\\/.bash_login ~\\/.profile ~\\/.bashrc</p>\n<h3 id=\"Mac命令\"><a href=\"#Mac命令\" class=\"headerlink\" title=\"Mac命令\"></a>Mac命令</h3><p>rm -r -f 文件夹名</p>\n<h3 id=\"Hadoop-localhost\"><a href=\"#Hadoop-localhost\" class=\"headerlink\" title=\"Hadoop localhost\"></a>Hadoop localhost</h3><p>http:\\/\\/localhost:9870\\/</p>\n<p>http:\\/\\/localhost:8088\\/cluster</p>\n"},{"title":"Mac安装protobuf","date":"2018-10-02T01:09:09.000Z","_content":"### Mac安装protobuf\n\n编译 Hadoop需要使用protobuf2.5.0\n\n> 参考：[http://www.jianshu.com/p/8e88c3ef47b3](http://www.jianshu.com/p/8e88c3ef47b3)\n\n```\ntar -zxf  protobuf-2.6.1.tar.gz\n./configure --prefix=/Users/don/tool/protobuf  这个目录记得更改为自己的//\nmake clean//不使用这个有可能会出现找不到protobuf/lib/libprotobuf.9.dylib\nmake\nmake install\nvi ~/.bash_profile\n\n//输入内容\nexport PROTOBUF=/Users/don/tool/protobuf\nexport PATH=$PROTOBUF/bin:$PATH\n\nsource ~/.bash_profile\nprotoc --version\n```\n\n```\nmvn package -e -X -Pdist,native -DskipTests -Dtar\n```\n\n编译错误\n\n```\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:1.7:run (make) on project hadoop-pipes: An Ant BuildException has occured: exec returned: 1\n[ERROR] around Ant part ...<exec failonerror=\"true\" dir=\"/Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/native\" executable=\"cmake\">... @ 5:131 in /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml\n[ERROR] -> [Help 1]\norg.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:1.7:run (make) on project hadoop-pipes: An Ant BuildException has occured: exec returned: 1\naround Ant part ...<exec failonerror=\"true\" dir=\"/Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/native\" executable=\"cmake\">... @ 5:131 in /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:212)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)\n    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)\n    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)\n    at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)\n    at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)\n    at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)\n    at org.apache.maven.cli.MavenCli.main(MavenCli.java:199)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)\nCaused by: org.apache.maven.plugin.MojoExecutionException: An Ant BuildException has occured: exec returned: 1\naround Ant part ...<exec failonerror=\"true\" dir=\"/Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/native\" executable=\"cmake\">... @ 5:131 in /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml\n    at org.apache.maven.plugin.antrun.AntRunMojo.execute(AntRunMojo.java:355)\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)\n    ... 20 more\nCaused by: /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml:5: exec returned: 1\n    at org.apache.tools.ant.taskdefs.ExecTask.runExecute(ExecTask.java:646)\n    at org.apache.tools.ant.taskdefs.ExecTask.runExec(ExecTask.java:672)\n    at org.apache.tools.ant.taskdefs.ExecTask.execute(ExecTask.java:498)\n    at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n    at sun.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n    at org.apache.tools.ant.Task.perform(Task.java:348)\n    at org.apache.tools.ant.Target.execute(Target.java:390)\n    at org.apache.tools.ant.Target.performTasks(Target.java:411)\n    at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n    at org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n    at org.apache.maven.plugin.antrun.AntRunMojo.execute(AntRunMojo.java:327)\n    ... 22 more\n[ERROR] \n[ERROR] \n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException\n[ERROR] \n[ERROR] After correcting the problems, you can resume the build with the command\n[ERROR]   mvn <goals> -rf :hadoop-pipes\n```\n\n检查提示中对应的buil-main.xml文件，找到该exec语句，在控制台中尝试执行\n\n```\ncmake /Users/lishengda/Downloads/hadoop-2.7.0-src/hadoop-tools/hadoop-pipes/src/ -DJVM_ARCH_DATA_MODEL=64\n```\n\n```\n-- The C compiler identification is AppleClang 8.1.0.8020038\n-- The CXX compiler identification is AppleClang 8.1.0.8020038\n-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc\n-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc -- works\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - done\n-- Detecting C compile features\n-- Detecting C compile features - done\n-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++\n-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++ -- works\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\nCMake Error at /usr/local/Cellar/cmake/3.7.2/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:138 (message):\n  Could NOT find OpenSSL, try to set the path to OpenSSL root folder in the\n  system variable OPENSSL_ROOT_DIR (missing: OPENSSL_INCLUDE_DIR)\nCall Stack (most recent call first):\n  /usr/local/Cellar/cmake/3.7.2/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:378 (_FPHSA_FAILURE_MESSAGE)\n  /usr/local/Cellar/cmake/3.7.2/share/cmake/Modules/FindOpenSSL.cmake:385 (find_package_handle_standard_args)\n  CMakeLists.txt:20 (find_package)\n\n\n-- Configuring incomplete, errors occurred!\n```\n\n提示显示没找到openssl,需要添加环境变量，于是添加\n\n命令行执行：vim ~/.bash\\_profile\n\n在打开的文件中添加如下两行（具体vim怎么用请另行查询）\n\nexport OPENSSL\\_ROOT\\_DIR=/usr/local/Cellar/openssl/1.0.2j\n\nexport OPENSSL\\_INCLUDE\\_DIR=/usr/local/Cellar/openssl/1.0.2j/include\n\n退出后执行source ~/.bash\\_profile使之生效\n\n","source":"_posts/Hadoop/macbian-yi-hadoop.md","raw":"---\ntitle: Mac安装protobuf\ndate: 2018-10-02 09:09:09\ncategories: Hadoop\n---\n### Mac安装protobuf\n\n编译 Hadoop需要使用protobuf2.5.0\n\n> 参考：[http://www.jianshu.com/p/8e88c3ef47b3](http://www.jianshu.com/p/8e88c3ef47b3)\n\n```\ntar -zxf  protobuf-2.6.1.tar.gz\n./configure --prefix=/Users/don/tool/protobuf  这个目录记得更改为自己的//\nmake clean//不使用这个有可能会出现找不到protobuf/lib/libprotobuf.9.dylib\nmake\nmake install\nvi ~/.bash_profile\n\n//输入内容\nexport PROTOBUF=/Users/don/tool/protobuf\nexport PATH=$PROTOBUF/bin:$PATH\n\nsource ~/.bash_profile\nprotoc --version\n```\n\n```\nmvn package -e -X -Pdist,native -DskipTests -Dtar\n```\n\n编译错误\n\n```\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:1.7:run (make) on project hadoop-pipes: An Ant BuildException has occured: exec returned: 1\n[ERROR] around Ant part ...<exec failonerror=\"true\" dir=\"/Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/native\" executable=\"cmake\">... @ 5:131 in /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml\n[ERROR] -> [Help 1]\norg.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:1.7:run (make) on project hadoop-pipes: An Ant BuildException has occured: exec returned: 1\naround Ant part ...<exec failonerror=\"true\" dir=\"/Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/native\" executable=\"cmake\">... @ 5:131 in /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:212)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)\n    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)\n    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)\n    at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)\n    at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)\n    at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)\n    at org.apache.maven.cli.MavenCli.main(MavenCli.java:199)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)\nCaused by: org.apache.maven.plugin.MojoExecutionException: An Ant BuildException has occured: exec returned: 1\naround Ant part ...<exec failonerror=\"true\" dir=\"/Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/native\" executable=\"cmake\">... @ 5:131 in /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml\n    at org.apache.maven.plugin.antrun.AntRunMojo.execute(AntRunMojo.java:355)\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)\n    ... 20 more\nCaused by: /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml:5: exec returned: 1\n    at org.apache.tools.ant.taskdefs.ExecTask.runExecute(ExecTask.java:646)\n    at org.apache.tools.ant.taskdefs.ExecTask.runExec(ExecTask.java:672)\n    at org.apache.tools.ant.taskdefs.ExecTask.execute(ExecTask.java:498)\n    at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n    at sun.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n    at org.apache.tools.ant.Task.perform(Task.java:348)\n    at org.apache.tools.ant.Target.execute(Target.java:390)\n    at org.apache.tools.ant.Target.performTasks(Target.java:411)\n    at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n    at org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n    at org.apache.maven.plugin.antrun.AntRunMojo.execute(AntRunMojo.java:327)\n    ... 22 more\n[ERROR] \n[ERROR] \n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException\n[ERROR] \n[ERROR] After correcting the problems, you can resume the build with the command\n[ERROR]   mvn <goals> -rf :hadoop-pipes\n```\n\n检查提示中对应的buil-main.xml文件，找到该exec语句，在控制台中尝试执行\n\n```\ncmake /Users/lishengda/Downloads/hadoop-2.7.0-src/hadoop-tools/hadoop-pipes/src/ -DJVM_ARCH_DATA_MODEL=64\n```\n\n```\n-- The C compiler identification is AppleClang 8.1.0.8020038\n-- The CXX compiler identification is AppleClang 8.1.0.8020038\n-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc\n-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc -- works\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - done\n-- Detecting C compile features\n-- Detecting C compile features - done\n-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++\n-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++ -- works\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\nCMake Error at /usr/local/Cellar/cmake/3.7.2/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:138 (message):\n  Could NOT find OpenSSL, try to set the path to OpenSSL root folder in the\n  system variable OPENSSL_ROOT_DIR (missing: OPENSSL_INCLUDE_DIR)\nCall Stack (most recent call first):\n  /usr/local/Cellar/cmake/3.7.2/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:378 (_FPHSA_FAILURE_MESSAGE)\n  /usr/local/Cellar/cmake/3.7.2/share/cmake/Modules/FindOpenSSL.cmake:385 (find_package_handle_standard_args)\n  CMakeLists.txt:20 (find_package)\n\n\n-- Configuring incomplete, errors occurred!\n```\n\n提示显示没找到openssl,需要添加环境变量，于是添加\n\n命令行执行：vim ~/.bash\\_profile\n\n在打开的文件中添加如下两行（具体vim怎么用请另行查询）\n\nexport OPENSSL\\_ROOT\\_DIR=/usr/local/Cellar/openssl/1.0.2j\n\nexport OPENSSL\\_INCLUDE\\_DIR=/usr/local/Cellar/openssl/1.0.2j/include\n\n退出后执行source ~/.bash\\_profile使之生效\n\n","slug":"Hadoop/macbian-yi-hadoop","published":1,"updated":"2018-10-02T02:09:03.343Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4m7000untnblyykao53","content":"<h3 id=\"Mac安装protobuf\"><a href=\"#Mac安装protobuf\" class=\"headerlink\" title=\"Mac安装protobuf\"></a>Mac安装protobuf</h3><p>编译 Hadoop需要使用protobuf2.5.0</p>\n<blockquote>\n<p>参考：<a href=\"http://www.jianshu.com/p/8e88c3ef47b3\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/8e88c3ef47b3</a></p>\n</blockquote>\n<pre><code>tar -zxf  protobuf-2.6.1.tar.gz\n./configure --prefix=/Users/don/tool/protobuf  这个目录记得更改为自己的//\nmake clean//不使用这个有可能会出现找不到protobuf/lib/libprotobuf.9.dylib\nmake\nmake install\nvi ~/.bash_profile\n\n//输入内容\nexport PROTOBUF=/Users/don/tool/protobuf\nexport PATH=$PROTOBUF/bin:$PATH\n\nsource ~/.bash_profile\nprotoc --version\n</code></pre><pre><code>mvn package -e -X -Pdist,native -DskipTests -Dtar\n</code></pre><p>编译错误</p>\n<pre><code>[ERROR] Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:1.7:run (make) on project hadoop-pipes: An Ant BuildException has occured: exec returned: 1\n[ERROR] around Ant part ...&lt;exec failonerror=&quot;true&quot; dir=&quot;/Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/native&quot; executable=&quot;cmake&quot;&gt;... @ 5:131 in /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml\n[ERROR] -&gt; [Help 1]\norg.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:1.7:run (make) on project hadoop-pipes: An Ant BuildException has occured: exec returned: 1\naround Ant part ...&lt;exec failonerror=&quot;true&quot; dir=&quot;/Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/native&quot; executable=&quot;cmake&quot;&gt;... @ 5:131 in /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:212)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)\n    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)\n    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)\n    at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)\n    at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)\n    at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)\n    at org.apache.maven.cli.MavenCli.main(MavenCli.java:199)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)\nCaused by: org.apache.maven.plugin.MojoExecutionException: An Ant BuildException has occured: exec returned: 1\naround Ant part ...&lt;exec failonerror=&quot;true&quot; dir=&quot;/Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/native&quot; executable=&quot;cmake&quot;&gt;... @ 5:131 in /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml\n    at org.apache.maven.plugin.antrun.AntRunMojo.execute(AntRunMojo.java:355)\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)\n    ... 20 more\nCaused by: /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml:5: exec returned: 1\n    at org.apache.tools.ant.taskdefs.ExecTask.runExecute(ExecTask.java:646)\n    at org.apache.tools.ant.taskdefs.ExecTask.runExec(ExecTask.java:672)\n    at org.apache.tools.ant.taskdefs.ExecTask.execute(ExecTask.java:498)\n    at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n    at sun.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n    at org.apache.tools.ant.Task.perform(Task.java:348)\n    at org.apache.tools.ant.Target.execute(Target.java:390)\n    at org.apache.tools.ant.Target.performTasks(Target.java:411)\n    at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n    at org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n    at org.apache.maven.plugin.antrun.AntRunMojo.execute(AntRunMojo.java:327)\n    ... 22 more\n[ERROR] \n[ERROR] \n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException\n[ERROR] \n[ERROR] After correcting the problems, you can resume the build with the command\n[ERROR]   mvn &lt;goals&gt; -rf :hadoop-pipes\n</code></pre><p>检查提示中对应的buil-main.xml文件，找到该exec语句，在控制台中尝试执行</p>\n<pre><code>cmake /Users/lishengda/Downloads/hadoop-2.7.0-src/hadoop-tools/hadoop-pipes/src/ -DJVM_ARCH_DATA_MODEL=64\n</code></pre><pre><code>-- The C compiler identification is AppleClang 8.1.0.8020038\n-- The CXX compiler identification is AppleClang 8.1.0.8020038\n-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc\n-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc -- works\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - done\n-- Detecting C compile features\n-- Detecting C compile features - done\n-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++\n-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++ -- works\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\nCMake Error at /usr/local/Cellar/cmake/3.7.2/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:138 (message):\n  Could NOT find OpenSSL, try to set the path to OpenSSL root folder in the\n  system variable OPENSSL_ROOT_DIR (missing: OPENSSL_INCLUDE_DIR)\nCall Stack (most recent call first):\n  /usr/local/Cellar/cmake/3.7.2/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:378 (_FPHSA_FAILURE_MESSAGE)\n  /usr/local/Cellar/cmake/3.7.2/share/cmake/Modules/FindOpenSSL.cmake:385 (find_package_handle_standard_args)\n  CMakeLists.txt:20 (find_package)\n\n\n-- Configuring incomplete, errors occurred!\n</code></pre><p>提示显示没找到openssl,需要添加环境变量，于是添加</p>\n<p>命令行执行：vim ~/.bash_profile</p>\n<p>在打开的文件中添加如下两行（具体vim怎么用请另行查询）</p>\n<p>export OPENSSL_ROOT_DIR=/usr/local/Cellar/openssl/1.0.2j</p>\n<p>export OPENSSL_INCLUDE_DIR=/usr/local/Cellar/openssl/1.0.2j/include</p>\n<p>退出后执行source ~/.bash_profile使之生效</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Mac安装protobuf\"><a href=\"#Mac安装protobuf\" class=\"headerlink\" title=\"Mac安装protobuf\"></a>Mac安装protobuf</h3><p>编译 Hadoop需要使用protobuf2.5.0</p>\n<blockquote>\n<p>参考：<a href=\"http://www.jianshu.com/p/8e88c3ef47b3\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/8e88c3ef47b3</a></p>\n</blockquote>\n<pre><code>tar -zxf  protobuf-2.6.1.tar.gz\n./configure --prefix=/Users/don/tool/protobuf  这个目录记得更改为自己的//\nmake clean//不使用这个有可能会出现找不到protobuf/lib/libprotobuf.9.dylib\nmake\nmake install\nvi ~/.bash_profile\n\n//输入内容\nexport PROTOBUF=/Users/don/tool/protobuf\nexport PATH=$PROTOBUF/bin:$PATH\n\nsource ~/.bash_profile\nprotoc --version\n</code></pre><pre><code>mvn package -e -X -Pdist,native -DskipTests -Dtar\n</code></pre><p>编译错误</p>\n<pre><code>[ERROR] Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:1.7:run (make) on project hadoop-pipes: An Ant BuildException has occured: exec returned: 1\n[ERROR] around Ant part ...&lt;exec failonerror=&quot;true&quot; dir=&quot;/Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/native&quot; executable=&quot;cmake&quot;&gt;... @ 5:131 in /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml\n[ERROR] -&gt; [Help 1]\norg.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:1.7:run (make) on project hadoop-pipes: An Ant BuildException has occured: exec returned: 1\naround Ant part ...&lt;exec failonerror=&quot;true&quot; dir=&quot;/Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/native&quot; executable=&quot;cmake&quot;&gt;... @ 5:131 in /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:212)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)\n    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)\n    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)\n    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)\n    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)\n    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)\n    at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)\n    at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)\n    at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)\n    at org.apache.maven.cli.MavenCli.main(MavenCli.java:199)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)\n    at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)\nCaused by: org.apache.maven.plugin.MojoExecutionException: An Ant BuildException has occured: exec returned: 1\naround Ant part ...&lt;exec failonerror=&quot;true&quot; dir=&quot;/Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/native&quot; executable=&quot;cmake&quot;&gt;... @ 5:131 in /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml\n    at org.apache.maven.plugin.antrun.AntRunMojo.execute(AntRunMojo.java:355)\n    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)\n    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)\n    ... 20 more\nCaused by: /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml:5: exec returned: 1\n    at org.apache.tools.ant.taskdefs.ExecTask.runExecute(ExecTask.java:646)\n    at org.apache.tools.ant.taskdefs.ExecTask.runExec(ExecTask.java:672)\n    at org.apache.tools.ant.taskdefs.ExecTask.execute(ExecTask.java:498)\n    at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n    at sun.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n    at org.apache.tools.ant.Task.perform(Task.java:348)\n    at org.apache.tools.ant.Target.execute(Target.java:390)\n    at org.apache.tools.ant.Target.performTasks(Target.java:411)\n    at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n    at org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n    at org.apache.maven.plugin.antrun.AntRunMojo.execute(AntRunMojo.java:327)\n    ... 22 more\n[ERROR] \n[ERROR] \n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException\n[ERROR] \n[ERROR] After correcting the problems, you can resume the build with the command\n[ERROR]   mvn &lt;goals&gt; -rf :hadoop-pipes\n</code></pre><p>检查提示中对应的buil-main.xml文件，找到该exec语句，在控制台中尝试执行</p>\n<pre><code>cmake /Users/lishengda/Downloads/hadoop-2.7.0-src/hadoop-tools/hadoop-pipes/src/ -DJVM_ARCH_DATA_MODEL=64\n</code></pre><pre><code>-- The C compiler identification is AppleClang 8.1.0.8020038\n-- The CXX compiler identification is AppleClang 8.1.0.8020038\n-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc\n-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc -- works\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - done\n-- Detecting C compile features\n-- Detecting C compile features - done\n-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++\n-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++ -- works\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\nCMake Error at /usr/local/Cellar/cmake/3.7.2/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:138 (message):\n  Could NOT find OpenSSL, try to set the path to OpenSSL root folder in the\n  system variable OPENSSL_ROOT_DIR (missing: OPENSSL_INCLUDE_DIR)\nCall Stack (most recent call first):\n  /usr/local/Cellar/cmake/3.7.2/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:378 (_FPHSA_FAILURE_MESSAGE)\n  /usr/local/Cellar/cmake/3.7.2/share/cmake/Modules/FindOpenSSL.cmake:385 (find_package_handle_standard_args)\n  CMakeLists.txt:20 (find_package)\n\n\n-- Configuring incomplete, errors occurred!\n</code></pre><p>提示显示没找到openssl,需要添加环境变量，于是添加</p>\n<p>命令行执行：vim ~/.bash_profile</p>\n<p>在打开的文件中添加如下两行（具体vim怎么用请另行查询）</p>\n<p>export OPENSSL_ROOT_DIR=/usr/local/Cellar/openssl/1.0.2j</p>\n<p>export OPENSSL_INCLUDE_DIR=/usr/local/Cellar/openssl/1.0.2j/include</p>\n<p>退出后执行source ~/.bash_profile使之生效</p>\n"},{"title":"Java  强引用、弱引用、软引用、虚引用","date":"2018-10-02T01:09:09.000Z","_content":"### Java  强引用、弱引用、软引用、虚引用\n\nhttp:\\/\\/blog.csdn.net\\/mazhimazh\\/article\\/details\\/19752475\n\n| **引用类型** | **被垃圾回收时间** | ** 用途** | ** 生存时间** |\n| --- | --- | --- | --- |\n| 强引用 | 从来不会 | 对象的一般状态 | JVM停止运行时终止 |\n| 软引用 | 在内存不足时 | 对象缓存 | 内存不足时终止 |\n| 弱引用 | 在垃圾回收时 | 对象缓存 | gc运行后终止 |\n| 虚引用 | Unknown | Unknown | Unknown |\n\n","source":"_posts/Java/Java引用.md","raw":"---\ntitle: Java  强引用、弱引用、软引用、虚引用\ndate: 2018-10-02 09:09:09\ncategories: Java\n---\n### Java  强引用、弱引用、软引用、虚引用\n\nhttp:\\/\\/blog.csdn.net\\/mazhimazh\\/article\\/details\\/19752475\n\n| **引用类型** | **被垃圾回收时间** | ** 用途** | ** 生存时间** |\n| --- | --- | --- | --- |\n| 强引用 | 从来不会 | 对象的一般状态 | JVM停止运行时终止 |\n| 软引用 | 在内存不足时 | 对象缓存 | 内存不足时终止 |\n| 弱引用 | 在垃圾回收时 | 对象缓存 | gc运行后终止 |\n| 虚引用 | Unknown | Unknown | Unknown |\n\n","slug":"Java/Java引用","published":1,"updated":"2018-10-02T06:06:26.845Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4m8000vntnbu6uza3mz","content":"<h3 id=\"Java-强引用、弱引用、软引用、虚引用\"><a href=\"#Java-强引用、弱引用、软引用、虚引用\" class=\"headerlink\" title=\"Java  强引用、弱引用、软引用、虚引用\"></a>Java  强引用、弱引用、软引用、虚引用</h3><p>http:\\/\\/blog.csdn.net\\/mazhimazh\\/article\\/details\\/19752475</p>\n<table>\n<thead>\n<tr>\n<th><strong>引用类型</strong></th>\n<th><strong>被垃圾回收时间</strong></th>\n<th><strong> 用途</strong></th>\n<th><strong> 生存时间</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>强引用</td>\n<td>从来不会</td>\n<td>对象的一般状态</td>\n<td>JVM停止运行时终止</td>\n</tr>\n<tr>\n<td>软引用</td>\n<td>在内存不足时</td>\n<td>对象缓存</td>\n<td>内存不足时终止</td>\n</tr>\n<tr>\n<td>弱引用</td>\n<td>在垃圾回收时</td>\n<td>对象缓存</td>\n<td>gc运行后终止</td>\n</tr>\n<tr>\n<td>虚引用</td>\n<td>Unknown</td>\n<td>Unknown</td>\n<td>Unknown</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Java-强引用、弱引用、软引用、虚引用\"><a href=\"#Java-强引用、弱引用、软引用、虚引用\" class=\"headerlink\" title=\"Java  强引用、弱引用、软引用、虚引用\"></a>Java  强引用、弱引用、软引用、虚引用</h3><p>http:\\/\\/blog.csdn.net\\/mazhimazh\\/article\\/details\\/19752475</p>\n<table>\n<thead>\n<tr>\n<th><strong>引用类型</strong></th>\n<th><strong>被垃圾回收时间</strong></th>\n<th><strong> 用途</strong></th>\n<th><strong> 生存时间</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>强引用</td>\n<td>从来不会</td>\n<td>对象的一般状态</td>\n<td>JVM停止运行时终止</td>\n</tr>\n<tr>\n<td>软引用</td>\n<td>在内存不足时</td>\n<td>对象缓存</td>\n<td>内存不足时终止</td>\n</tr>\n<tr>\n<td>弱引用</td>\n<td>在垃圾回收时</td>\n<td>对象缓存</td>\n<td>gc运行后终止</td>\n</tr>\n<tr>\n<td>虚引用</td>\n<td>Unknown</td>\n<td>Unknown</td>\n<td>Unknown</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"Java生态","date":"2018-10-02T01:09:09.000Z","_content":"Java、JDBC、SQL、HTML、DIV+CSS、JavaScript、JQuery、DOM、JQuery EasyUI、Servlet、JSP、Cookie、Session、AJAX、JSON、反射、注解、多线程、线程池、SoftReference、WeakReference、EL表达式、正则表达式、MD5、BASE64、DES、AES、序列化、泛型等技术Spring、SpringMVC、MVC架构XML、DOM4J、HTML5、Socket、ECharts、POI、FreeMarker、页面静态化、iText、WebService、Quartz、IO、HttpClient、JSONP、JavaBean、RESTFul、AOP、SQL语句、JMS、缓存、消息队列、集合、HTTP协议MongoDB、Redis、Memcached 都是NoSQL序列 Redis、Memcached，现在Redis很火Oracle、MySQL，互联网公司Oracle很少用，除非政府、银行等等会用到，一般互联网公司都是MySQL 数据库连接池工具：C3P0、DBCP、Druid （知道怎么样使用就可以）搜索引擎或者框架： Lucene、Solr、Elasticsearch , 目前Elasticsearch 比较火，Solr和Elasticsearch 都是基于LuceneIK中文分词器：会和 搜索引擎或者框架 整合，Struts2、SpringMVC，现在很多互联网公司都使用SpringMVC，但是，还有很多公司使用 Struts2Hibernate、MyBatis、iBatis，现在互联网公司都是用MyBatis（MyBatis的前身是iBatis），还有部分公司使用Hibernate、反射和注解（Annotation）、泛型 是Java领域的非常重要的技术，几乎所有框架都离不开反射和注解， 例如：Spring消息队列框架：ActiveMQ、ZeroMQ、RabbitMQ、RocketMQ， RabbitMQ 会用得稍微多一点Java领域常用的JSON框架： Jackson、FastJson、Gson 现在比较火的技术：微服务、面向服务（SOA）微服务:Spring Boot SOA：Dubbo（阿里开源），DubboX（当当网团队维护Dubbo的一个版本），还有360的，微博的MySQL集群：主从复制、一主多从，多主多从MySQL的中间件：MyCat， MyCat可以很简单地实现读写分离，分库分表（横向和纵向拆分）服务器或者服务器容器：Tomcat RPCNetty：Java领域当前最牛逼、最火爆 高性能网络通信框架， Dubbo底层、Hadoop、Spark、Storm等等大数据分布式框架或者平台，都是使用Netty实现网络通信分布式：把一个单一的系统拆成多个独立的服务或者微服务，实现分布式框架FastDFS：是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，目前主要用于图片存储比较多\n\n","source":"_posts/Java/Java生态.md","raw":"---\ntitle: Java生态\ndate: 2018-10-02 09:09:09\ncategories: Java\n---\nJava、JDBC、SQL、HTML、DIV+CSS、JavaScript、JQuery、DOM、JQuery EasyUI、Servlet、JSP、Cookie、Session、AJAX、JSON、反射、注解、多线程、线程池、SoftReference、WeakReference、EL表达式、正则表达式、MD5、BASE64、DES、AES、序列化、泛型等技术Spring、SpringMVC、MVC架构XML、DOM4J、HTML5、Socket、ECharts、POI、FreeMarker、页面静态化、iText、WebService、Quartz、IO、HttpClient、JSONP、JavaBean、RESTFul、AOP、SQL语句、JMS、缓存、消息队列、集合、HTTP协议MongoDB、Redis、Memcached 都是NoSQL序列 Redis、Memcached，现在Redis很火Oracle、MySQL，互联网公司Oracle很少用，除非政府、银行等等会用到，一般互联网公司都是MySQL 数据库连接池工具：C3P0、DBCP、Druid （知道怎么样使用就可以）搜索引擎或者框架： Lucene、Solr、Elasticsearch , 目前Elasticsearch 比较火，Solr和Elasticsearch 都是基于LuceneIK中文分词器：会和 搜索引擎或者框架 整合，Struts2、SpringMVC，现在很多互联网公司都使用SpringMVC，但是，还有很多公司使用 Struts2Hibernate、MyBatis、iBatis，现在互联网公司都是用MyBatis（MyBatis的前身是iBatis），还有部分公司使用Hibernate、反射和注解（Annotation）、泛型 是Java领域的非常重要的技术，几乎所有框架都离不开反射和注解， 例如：Spring消息队列框架：ActiveMQ、ZeroMQ、RabbitMQ、RocketMQ， RabbitMQ 会用得稍微多一点Java领域常用的JSON框架： Jackson、FastJson、Gson 现在比较火的技术：微服务、面向服务（SOA）微服务:Spring Boot SOA：Dubbo（阿里开源），DubboX（当当网团队维护Dubbo的一个版本），还有360的，微博的MySQL集群：主从复制、一主多从，多主多从MySQL的中间件：MyCat， MyCat可以很简单地实现读写分离，分库分表（横向和纵向拆分）服务器或者服务器容器：Tomcat RPCNetty：Java领域当前最牛逼、最火爆 高性能网络通信框架， Dubbo底层、Hadoop、Spark、Storm等等大数据分布式框架或者平台，都是使用Netty实现网络通信分布式：把一个单一的系统拆成多个独立的服务或者微服务，实现分布式框架FastDFS：是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，目前主要用于图片存储比较多\n\n","slug":"Java/Java生态","published":1,"updated":"2018-10-02T06:07:14.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4m9000yntnbi71wmxot","content":"<p>Java、JDBC、SQL、HTML、DIV+CSS、JavaScript、JQuery、DOM、JQuery EasyUI、Servlet、JSP、Cookie、Session、AJAX、JSON、反射、注解、多线程、线程池、SoftReference、WeakReference、EL表达式、正则表达式、MD5、BASE64、DES、AES、序列化、泛型等技术Spring、SpringMVC、MVC架构XML、DOM4J、HTML5、Socket、ECharts、POI、FreeMarker、页面静态化、iText、WebService、Quartz、IO、HttpClient、JSONP、JavaBean、RESTFul、AOP、SQL语句、JMS、缓存、消息队列、集合、HTTP协议MongoDB、Redis、Memcached 都是NoSQL序列 Redis、Memcached，现在Redis很火Oracle、MySQL，互联网公司Oracle很少用，除非政府、银行等等会用到，一般互联网公司都是MySQL 数据库连接池工具：C3P0、DBCP、Druid （知道怎么样使用就可以）搜索引擎或者框架： Lucene、Solr、Elasticsearch , 目前Elasticsearch 比较火，Solr和Elasticsearch 都是基于LuceneIK中文分词器：会和 搜索引擎或者框架 整合，Struts2、SpringMVC，现在很多互联网公司都使用SpringMVC，但是，还有很多公司使用 Struts2Hibernate、MyBatis、iBatis，现在互联网公司都是用MyBatis（MyBatis的前身是iBatis），还有部分公司使用Hibernate、反射和注解（Annotation）、泛型 是Java领域的非常重要的技术，几乎所有框架都离不开反射和注解， 例如：Spring消息队列框架：ActiveMQ、ZeroMQ、RabbitMQ、RocketMQ， RabbitMQ 会用得稍微多一点Java领域常用的JSON框架： Jackson、FastJson、Gson 现在比较火的技术：微服务、面向服务（SOA）微服务:Spring Boot SOA：Dubbo（阿里开源），DubboX（当当网团队维护Dubbo的一个版本），还有360的，微博的MySQL集群：主从复制、一主多从，多主多从MySQL的中间件：MyCat， MyCat可以很简单地实现读写分离，分库分表（横向和纵向拆分）服务器或者服务器容器：Tomcat RPCNetty：Java领域当前最牛逼、最火爆 高性能网络通信框架， Dubbo底层、Hadoop、Spark、Storm等等大数据分布式框架或者平台，都是使用Netty实现网络通信分布式：把一个单一的系统拆成多个独立的服务或者微服务，实现分布式框架FastDFS：是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，目前主要用于图片存储比较多</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Java、JDBC、SQL、HTML、DIV+CSS、JavaScript、JQuery、DOM、JQuery EasyUI、Servlet、JSP、Cookie、Session、AJAX、JSON、反射、注解、多线程、线程池、SoftReference、WeakReference、EL表达式、正则表达式、MD5、BASE64、DES、AES、序列化、泛型等技术Spring、SpringMVC、MVC架构XML、DOM4J、HTML5、Socket、ECharts、POI、FreeMarker、页面静态化、iText、WebService、Quartz、IO、HttpClient、JSONP、JavaBean、RESTFul、AOP、SQL语句、JMS、缓存、消息队列、集合、HTTP协议MongoDB、Redis、Memcached 都是NoSQL序列 Redis、Memcached，现在Redis很火Oracle、MySQL，互联网公司Oracle很少用，除非政府、银行等等会用到，一般互联网公司都是MySQL 数据库连接池工具：C3P0、DBCP、Druid （知道怎么样使用就可以）搜索引擎或者框架： Lucene、Solr、Elasticsearch , 目前Elasticsearch 比较火，Solr和Elasticsearch 都是基于LuceneIK中文分词器：会和 搜索引擎或者框架 整合，Struts2、SpringMVC，现在很多互联网公司都使用SpringMVC，但是，还有很多公司使用 Struts2Hibernate、MyBatis、iBatis，现在互联网公司都是用MyBatis（MyBatis的前身是iBatis），还有部分公司使用Hibernate、反射和注解（Annotation）、泛型 是Java领域的非常重要的技术，几乎所有框架都离不开反射和注解， 例如：Spring消息队列框架：ActiveMQ、ZeroMQ、RabbitMQ、RocketMQ， RabbitMQ 会用得稍微多一点Java领域常用的JSON框架： Jackson、FastJson、Gson 现在比较火的技术：微服务、面向服务（SOA）微服务:Spring Boot SOA：Dubbo（阿里开源），DubboX（当当网团队维护Dubbo的一个版本），还有360的，微博的MySQL集群：主从复制、一主多从，多主多从MySQL的中间件：MyCat， MyCat可以很简单地实现读写分离，分库分表（横向和纵向拆分）服务器或者服务器容器：Tomcat RPCNetty：Java领域当前最牛逼、最火爆 高性能网络通信框架， Dubbo底层、Hadoop、Spark、Storm等等大数据分布式框架或者平台，都是使用Netty实现网络通信分布式：把一个单一的系统拆成多个独立的服务或者微服务，实现分布式框架FastDFS：是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，目前主要用于图片存储比较多</p>\n"},{"title":"intellij idea","date":"2018-10-02T01:09:09.000Z","_content":"archetypeCatalog表示插件使用的archetype元数据，不加这个参数时默认为remote，local，即中央仓库archetype元数据，由于中央仓库的archetype太多了，所以导致很慢，指定internal来表示仅使用内部元数据。\n\n这里在Properties中添加一个参数\n\n`archetypeCatalog=internal`\n\n，不加这个参数，在maven生成骨架的时候将会非常慢，有时候会直接卡住\n\n","source":"_posts/Java/intellij-idea.md","raw":"---\ntitle: intellij idea\ndate: 2018-10-02 09:09:09\ncategories: Java\n---\narchetypeCatalog表示插件使用的archetype元数据，不加这个参数时默认为remote，local，即中央仓库archetype元数据，由于中央仓库的archetype太多了，所以导致很慢，指定internal来表示仅使用内部元数据。\n\n这里在Properties中添加一个参数\n\n`archetypeCatalog=internal`\n\n，不加这个参数，在maven生成骨架的时候将会非常慢，有时候会直接卡住\n\n","slug":"Java/intellij-idea","published":1,"updated":"2018-10-02T02:12:24.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4ma0010ntnb8dqcbvk5","content":"<p>archetypeCatalog表示插件使用的archetype元数据，不加这个参数时默认为remote，local，即中央仓库archetype元数据，由于中央仓库的archetype太多了，所以导致很慢，指定internal来表示仅使用内部元数据。</p>\n<p>这里在Properties中添加一个参数</p>\n<p><code>archetypeCatalog=internal</code></p>\n<p>，不加这个参数，在maven生成骨架的时候将会非常慢，有时候会直接卡住</p>\n","site":{"data":{}},"excerpt":"","more":"<p>archetypeCatalog表示插件使用的archetype元数据，不加这个参数时默认为remote，local，即中央仓库archetype元数据，由于中央仓库的archetype太多了，所以导致很慢，指定internal来表示仅使用内部元数据。</p>\n<p>这里在Properties中添加一个参数</p>\n<p><code>archetypeCatalog=internal</code></p>\n<p>，不加这个参数，在maven生成骨架的时候将会非常慢，有时候会直接卡住</p>\n"},{"title":"Java反射","date":"2018-10-02T01:09:09.000Z","_content":"\\/\\*\\*\n\n\\* 获取操作实体的类型\n\n\\*\\/\n\nClass&lt;? extends Object&gt; clazz = entity.getClass\\(\\);\n\n\\/\\*\\*\n\n\\* 获取传入实体的所有公开的方法;\n\n\\*\\/\n\nMethod\\[\\] methods = clazz.getDeclaredMethods\\(\\);\n\n\\/\\*\\*\n\n\\* 获取传入实体中的所有公开的的属性\n\n\\*\\/\n\nField\\[\\] fields = clazz.getDeclaredFields\\(\\);\n\nfields\\[i\\].setAccessible\\(true\\);\\/\\/取消private\n\n如果没有在获取Field之前调用setAccessible\\(true\\)方法，异常:\n\n1. java.lang.IllegalAccessException:\n2. Class com.test.accessible.Main\n3. can not access\n4. a member of **class** com.test.accessible.AccessibleTest\n5. with modifiers \"private\"\n\n","source":"_posts/Java/java.md","raw":"---\ntitle: Java反射\ndate: 2018-10-02 09:09:09\ncategories: Java\n---\n\\/\\*\\*\n\n\\* 获取操作实体的类型\n\n\\*\\/\n\nClass&lt;? extends Object&gt; clazz = entity.getClass\\(\\);\n\n\\/\\*\\*\n\n\\* 获取传入实体的所有公开的方法;\n\n\\*\\/\n\nMethod\\[\\] methods = clazz.getDeclaredMethods\\(\\);\n\n\\/\\*\\*\n\n\\* 获取传入实体中的所有公开的的属性\n\n\\*\\/\n\nField\\[\\] fields = clazz.getDeclaredFields\\(\\);\n\nfields\\[i\\].setAccessible\\(true\\);\\/\\/取消private\n\n如果没有在获取Field之前调用setAccessible\\(true\\)方法，异常:\n\n1. java.lang.IllegalAccessException:\n2. Class com.test.accessible.Main\n3. can not access\n4. a member of **class** com.test.accessible.AccessibleTest\n5. with modifiers \"private\"\n\n","slug":"Java/java","published":1,"updated":"2018-10-02T05:10:59.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mb0013ntnbmlsw514q","content":"<p>\\/**</p>\n<p>* 获取操作实体的类型</p>\n<p>*\\/</p>\n<p>Class&lt;? extends Object&gt; clazz = entity.getClass();</p>\n<p>\\/**</p>\n<p>* 获取传入实体的所有公开的方法;</p>\n<p>*\\/</p>\n<p>Method[] methods = clazz.getDeclaredMethods();</p>\n<p>\\/**</p>\n<p>* 获取传入实体中的所有公开的的属性</p>\n<p>*\\/</p>\n<p>Field[] fields = clazz.getDeclaredFields();</p>\n<p>fields[i].setAccessible(true);\\/\\/取消private</p>\n<p>如果没有在获取Field之前调用setAccessible(true)方法，异常:</p>\n<ol>\n<li>java.lang.IllegalAccessException:</li>\n<li>Class com.test.accessible.Main</li>\n<li>can not access</li>\n<li>a member of <strong>class</strong> com.test.accessible.AccessibleTest</li>\n<li>with modifiers “private”</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>\\/**</p>\n<p>* 获取操作实体的类型</p>\n<p>*\\/</p>\n<p>Class&lt;? extends Object&gt; clazz = entity.getClass();</p>\n<p>\\/**</p>\n<p>* 获取传入实体的所有公开的方法;</p>\n<p>*\\/</p>\n<p>Method[] methods = clazz.getDeclaredMethods();</p>\n<p>\\/**</p>\n<p>* 获取传入实体中的所有公开的的属性</p>\n<p>*\\/</p>\n<p>Field[] fields = clazz.getDeclaredFields();</p>\n<p>fields[i].setAccessible(true);\\/\\/取消private</p>\n<p>如果没有在获取Field之前调用setAccessible(true)方法，异常:</p>\n<ol>\n<li>java.lang.IllegalAccessException:</li>\n<li>Class com.test.accessible.Main</li>\n<li>can not access</li>\n<li>a member of <strong>class</strong> com.test.accessible.AccessibleTest</li>\n<li>with modifiers “private”</li>\n</ol>\n"},{"title":"intellij idea","date":"2018-10-02T01:09:09.000Z","_content":"> [**https://yq.aliyun.com/attachment/download/?id=1492**](https://yq.aliyun.com/attachment/download/?spm=5176.100239.blogcont69327.6.eob6EJ&id=1492)\n\n\n\n","source":"_posts/Java/javaa-li-gui-fan.md","raw":"---\ntitle: intellij idea\ndate: 2018-10-02 09:09:09\ncategories: Java\n---\n> [**https://yq.aliyun.com/attachment/download/?id=1492**](https://yq.aliyun.com/attachment/download/?spm=5176.100239.blogcont69327.6.eob6EJ&id=1492)\n\n\n\n","slug":"Java/javaa-li-gui-fan","published":1,"updated":"2018-10-02T02:12:31.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mc0014ntnbjd6jjucr","content":"<blockquote>\n<p><a href=\"https://yq.aliyun.com/attachment/download/?spm=5176.100239.blogcont69327.6.eob6EJ&amp;id=1492\" target=\"_blank\" rel=\"noopener\"><strong>https://yq.aliyun.com/attachment/download/?id=1492</strong></a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://yq.aliyun.com/attachment/download/?spm=5176.100239.blogcont69327.6.eob6EJ&amp;id=1492\" target=\"_blank\" rel=\"noopener\"><strong>https://yq.aliyun.com/attachment/download/?id=1492</strong></a></p>\n</blockquote>\n"},{"title":"google java","date":"2018-10-02T01:09:09.000Z","_content":"> [https://github.com/google/styleguide](https://github.com/google/styleguide)\n>\n> [https://google.github.io/styleguide/javaguide.html](https://google.github.io/styleguide/javaguide.html)\n\n\n\n","source":"_posts/Java/javagooglestyle.md","raw":"---\ntitle: google java\ndate: 2018-10-02 09:09:09\ncategories: Java\n---\n> [https://github.com/google/styleguide](https://github.com/google/styleguide)\n>\n> [https://google.github.io/styleguide/javaguide.html](https://google.github.io/styleguide/javaguide.html)\n\n\n\n","slug":"Java/javagooglestyle","published":1,"updated":"2018-10-02T02:12:40.899Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4me0017ntnbhkhyszs3","content":"<blockquote>\n<p><a href=\"https://github.com/google/styleguide\" target=\"_blank\" rel=\"noopener\">https://github.com/google/styleguide</a></p>\n<p><a href=\"https://google.github.io/styleguide/javaguide.html\" target=\"_blank\" rel=\"noopener\">https://google.github.io/styleguide/javaguide.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://github.com/google/styleguide\" target=\"_blank\" rel=\"noopener\">https://github.com/google/styleguide</a></p>\n<p><a href=\"https://google.github.io/styleguide/javaguide.html\" target=\"_blank\" rel=\"noopener\">https://google.github.io/styleguide/javaguide.html</a></p>\n</blockquote>\n"},{"title":"饿汉式 static final field","date":"2018-10-02T01:09:09.000Z","_content":"## 饿汉式 static final field\n\n这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。\n\n```java\npublicclassSingleton{\n//类加载时就初始化\nprivatestaticfinal Singleton instance = new Singleton();\n\nprivateSingleton(){}\n\npublicstatic Singleton getInstance(){\nreturn instance;\n    }\n}\n\n```\n\n这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance\\(\\)方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance\\(\\) 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。\n\n## 静态内部类 static nested class\n\n```java\npublicclassSingleton{  \nprivatestaticclassSingletonHolder{  \nprivatestaticfinal Singleton INSTANCE = new Singleton();  \n    }  \nprivateSingleton(){}  \npublicstaticfinal Singleton getInstance(){  \nreturn SingletonHolder.INSTANCE; \n    }  \n}\n```\n\n我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。\n\n这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance\\(\\) 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。\n\n","source":"_posts/Java/javatui-jian-de-dan-li-xie-fa.md","raw":"---\ntitle: 饿汉式 static final field\ndate: 2018-10-02 09:09:09\ncategories: Java\n---\n## 饿汉式 static final field\n\n这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。\n\n```java\npublicclassSingleton{\n//类加载时就初始化\nprivatestaticfinal Singleton instance = new Singleton();\n\nprivateSingleton(){}\n\npublicstatic Singleton getInstance(){\nreturn instance;\n    }\n}\n\n```\n\n这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance\\(\\)方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance\\(\\) 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。\n\n## 静态内部类 static nested class\n\n```java\npublicclassSingleton{  \nprivatestaticclassSingletonHolder{  \nprivatestaticfinal Singleton INSTANCE = new Singleton();  \n    }  \nprivateSingleton(){}  \npublicstaticfinal Singleton getInstance(){  \nreturn SingletonHolder.INSTANCE; \n    }  \n}\n```\n\n我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。\n\n这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance\\(\\) 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。\n\n","slug":"Java/javatui-jian-de-dan-li-xie-fa","published":1,"updated":"2018-10-02T06:04:29.506Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mh0018ntnbnmti58g4","content":"<h2 id=\"饿汉式-static-final-field\"><a href=\"#饿汉式-static-final-field\" class=\"headerlink\" title=\"饿汉式 static final field\"></a>饿汉式 static final field</h2><p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p>\n<pre><code class=\"java\">publicclassSingleton{\n//类加载时就初始化\nprivatestaticfinal Singleton instance = new Singleton();\n\nprivateSingleton(){}\n\npublicstatic Singleton getInstance(){\nreturn instance;\n    }\n}\n\n</code></pre>\n<p>这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p>\n<h2 id=\"静态内部类-static-nested-class\"><a href=\"#静态内部类-static-nested-class\" class=\"headerlink\" title=\"静态内部类 static nested class\"></a>静态内部类 static nested class</h2><pre><code class=\"java\">publicclassSingleton{  \nprivatestaticclassSingletonHolder{  \nprivatestaticfinal Singleton INSTANCE = new Singleton();  \n    }  \nprivateSingleton(){}  \npublicstaticfinal Singleton getInstance(){  \nreturn SingletonHolder.INSTANCE; \n    }  \n}\n</code></pre>\n<p>我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。</p>\n<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"饿汉式-static-final-field\"><a href=\"#饿汉式-static-final-field\" class=\"headerlink\" title=\"饿汉式 static final field\"></a>饿汉式 static final field</h2><p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p>\n<pre><code class=\"java\">publicclassSingleton{\n//类加载时就初始化\nprivatestaticfinal Singleton instance = new Singleton();\n\nprivateSingleton(){}\n\npublicstatic Singleton getInstance(){\nreturn instance;\n    }\n}\n\n</code></pre>\n<p>这种写法如果完美的话，就没必要在啰嗦那么多双检锁的问题了。缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p>\n<h2 id=\"静态内部类-static-nested-class\"><a href=\"#静态内部类-static-nested-class\" class=\"headerlink\" title=\"静态内部类 static nested class\"></a>静态内部类 static nested class</h2><pre><code class=\"java\">publicclassSingleton{  \nprivatestaticclassSingletonHolder{  \nprivatestaticfinal Singleton INSTANCE = new Singleton();  \n    }  \nprivateSingleton(){}  \npublicstaticfinal Singleton getInstance(){  \nreturn SingletonHolder.INSTANCE; \n    }  \n}\n</code></pre>\n<p>我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。</p>\n<p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>\n"},{"title":"Ubuntu配置Tomcat","date":"2018-10-02T01:09:09.000Z","_content":"# Ubuntu配置Tomcat\n\n> 参考：\n>\n> [http://blog.csdn.net/njchenyi/article/details/46641141](http://blog.csdn.net/njchenyi/article/details/46641141)\n>\n> [http://blog.csdn.net/upshi/article/details/54907464](http://blog.csdn.net/upshi/article/details/54907464)\n\n近段时间入手了一部国外虚拟服务器，在配置Tomcat时，出现了个汇总BUG。每次启动Tomcat的startup.sh都正常，但是打开8080却不能访问，而且logs下文件没有报错。尝试过解压和APT安装都是同样结果，后来在其他大神帮助下终於解决了。\n\n找到jdk1.x.x\\_xx/jre/lib/security/java.security文件，在文件中找到securerandom.source这个设置项，将其改为：securerandom.source=file:/dev/./urandom这时候根据修改内容就可以查到因为此原因不仅可以造成tomcat卡住，也会造成weblogic启动缓慢，linux或者部分unix系统提供随机数设备是/dev/random 和/dev/urandom ，两个有区别，urandom安全性没有random高，但random需要时间间隔生成随机数。jdk默认调用random。\n\n产生原因应该是：/dev/random是一个阻塞数字生成器，如果它没有足够的随机数据提供，它就一直等，这迫使JVM等待。\n\n","source":"_posts/Java/ubuntupei-zhi-tomcat.md","raw":"---\ntitle: Ubuntu配置Tomcat\ndate: 2018-10-02 09:09:09\ncategories: Java\n---\n# Ubuntu配置Tomcat\n\n> 参考：\n>\n> [http://blog.csdn.net/njchenyi/article/details/46641141](http://blog.csdn.net/njchenyi/article/details/46641141)\n>\n> [http://blog.csdn.net/upshi/article/details/54907464](http://blog.csdn.net/upshi/article/details/54907464)\n\n近段时间入手了一部国外虚拟服务器，在配置Tomcat时，出现了个汇总BUG。每次启动Tomcat的startup.sh都正常，但是打开8080却不能访问，而且logs下文件没有报错。尝试过解压和APT安装都是同样结果，后来在其他大神帮助下终於解决了。\n\n找到jdk1.x.x\\_xx/jre/lib/security/java.security文件，在文件中找到securerandom.source这个设置项，将其改为：securerandom.source=file:/dev/./urandom这时候根据修改内容就可以查到因为此原因不仅可以造成tomcat卡住，也会造成weblogic启动缓慢，linux或者部分unix系统提供随机数设备是/dev/random 和/dev/urandom ，两个有区别，urandom安全性没有random高，但random需要时间间隔生成随机数。jdk默认调用random。\n\n产生原因应该是：/dev/random是一个阻塞数字生成器，如果它没有足够的随机数据提供，它就一直等，这迫使JVM等待。\n\n","slug":"Java/ubuntupei-zhi-tomcat","published":1,"updated":"2018-10-02T06:25:38.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mi001bntnbskl8povh","content":"<h1 id=\"Ubuntu配置Tomcat\"><a href=\"#Ubuntu配置Tomcat\" class=\"headerlink\" title=\"Ubuntu配置Tomcat\"></a>Ubuntu配置Tomcat</h1><blockquote>\n<p>参考：</p>\n<p><a href=\"http://blog.csdn.net/njchenyi/article/details/46641141\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/njchenyi/article/details/46641141</a></p>\n<p><a href=\"http://blog.csdn.net/upshi/article/details/54907464\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/upshi/article/details/54907464</a></p>\n</blockquote>\n<p>近段时间入手了一部国外虚拟服务器，在配置Tomcat时，出现了个汇总BUG。每次启动Tomcat的startup.sh都正常，但是打开8080却不能访问，而且logs下文件没有报错。尝试过解压和APT安装都是同样结果，后来在其他大神帮助下终於解决了。</p>\n<p>找到jdk1.x.x_xx/jre/lib/security/java.security文件，在文件中找到securerandom.source这个设置项，将其改为：securerandom.source=file:/dev/./urandom这时候根据修改内容就可以查到因为此原因不仅可以造成tomcat卡住，也会造成weblogic启动缓慢，linux或者部分unix系统提供随机数设备是/dev/random 和/dev/urandom ，两个有区别，urandom安全性没有random高，但random需要时间间隔生成随机数。jdk默认调用random。</p>\n<p>产生原因应该是：/dev/random是一个阻塞数字生成器，如果它没有足够的随机数据提供，它就一直等，这迫使JVM等待。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Ubuntu配置Tomcat\"><a href=\"#Ubuntu配置Tomcat\" class=\"headerlink\" title=\"Ubuntu配置Tomcat\"></a>Ubuntu配置Tomcat</h1><blockquote>\n<p>参考：</p>\n<p><a href=\"http://blog.csdn.net/njchenyi/article/details/46641141\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/njchenyi/article/details/46641141</a></p>\n<p><a href=\"http://blog.csdn.net/upshi/article/details/54907464\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/upshi/article/details/54907464</a></p>\n</blockquote>\n<p>近段时间入手了一部国外虚拟服务器，在配置Tomcat时，出现了个汇总BUG。每次启动Tomcat的startup.sh都正常，但是打开8080却不能访问，而且logs下文件没有报错。尝试过解压和APT安装都是同样结果，后来在其他大神帮助下终於解决了。</p>\n<p>找到jdk1.x.x_xx/jre/lib/security/java.security文件，在文件中找到securerandom.source这个设置项，将其改为：securerandom.source=file:/dev/./urandom这时候根据修改内容就可以查到因为此原因不仅可以造成tomcat卡住，也会造成weblogic启动缓慢，linux或者部分unix系统提供随机数设备是/dev/random 和/dev/urandom ，两个有区别，urandom安全性没有random高，但random需要时间间隔生成随机数。jdk默认调用random。</p>\n<p>产生原因应该是：/dev/random是一个阻塞数字生成器，如果它没有足够的随机数据提供，它就一直等，这迫使JVM等待。</p>\n"},{"title":"从0开始PHP","date":"2018-10-02T01:09:09.000Z","_content":"# 从0开始PHP\n\n山寨一个网站\n\n##1.山寨网站\n[cinephilia谜影](http://cinephilia.net/)","source":"_posts/PHP/cong_0_kai_shi_php.md","raw":"---\ntitle: 从0开始PHP\ndate: 2018-10-02 09:09:09\ncategories: php\n---\n# 从0开始PHP\n\n山寨一个网站\n\n##1.山寨网站\n[cinephilia谜影](http://cinephilia.net/)","slug":"PHP/cong_0_kai_shi_php","published":1,"updated":"2018-10-02T02:13:39.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mj001cntnb0ll5lmqq","content":"<h1 id=\"从0开始PHP\"><a href=\"#从0开始PHP\" class=\"headerlink\" title=\"从0开始PHP\"></a>从0开始PHP</h1><p>山寨一个网站</p>\n<p>##1.山寨网站<br><a href=\"http://cinephilia.net/\" target=\"_blank\" rel=\"noopener\">cinephilia谜影</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"从0开始PHP\"><a href=\"#从0开始PHP\" class=\"headerlink\" title=\"从0开始PHP\"></a>从0开始PHP</h1><p>山寨一个网站</p>\n<p>##1.山寨网站<br><a href=\"http://cinephilia.net/\" target=\"_blank\" rel=\"noopener\">cinephilia谜影</a></p>\n"},{"title":"Laravel","date":"2018-10-02T01:09:09.000Z","_content":"### 路由参数\n\n參數按照順序與名稱無關\n\n```php\nRoute::get('posts/{post}/comments/{comment}', function ($postId, $commentId) {\n    //\n});\n```\n\n### 可選參數\n\n```php\nRoute::get('user/{name?}', function ($name = null) {\n    return $name;\n});\n\nRoute::get('user/{name?}', function ($name = 'John') {\n    return $name;\n});\n```\n\n\n\n","source":"_posts/PHP/laravel.md","raw":"---\ntitle: Laravel\ndate: 2018-10-02 09:09:09\ncategories: php\n---\n### 路由参数\n\n參數按照順序與名稱無關\n\n```php\nRoute::get('posts/{post}/comments/{comment}', function ($postId, $commentId) {\n    //\n});\n```\n\n### 可選參數\n\n```php\nRoute::get('user/{name?}', function ($name = null) {\n    return $name;\n});\n\nRoute::get('user/{name?}', function ($name = 'John') {\n    return $name;\n});\n```\n\n\n\n","slug":"PHP/laravel","published":1,"updated":"2018-10-02T02:55:00.510Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mk001fntnb6ct1twrv","content":"<h3 id=\"路由参数\"><a href=\"#路由参数\" class=\"headerlink\" title=\"路由参数\"></a>路由参数</h3><p>參數按照順序與名稱無關</p>\n<pre><code class=\"php\">Route::get(&#39;posts/{post}/comments/{comment}&#39;, function ($postId, $commentId) {\n    //\n});\n</code></pre>\n<h3 id=\"可選參數\"><a href=\"#可選參數\" class=\"headerlink\" title=\"可選參數\"></a>可選參數</h3><pre><code class=\"php\">Route::get(&#39;user/{name?}&#39;, function ($name = null) {\n    return $name;\n});\n\nRoute::get(&#39;user/{name?}&#39;, function ($name = &#39;John&#39;) {\n    return $name;\n});\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"路由参数\"><a href=\"#路由参数\" class=\"headerlink\" title=\"路由参数\"></a>路由参数</h3><p>參數按照順序與名稱無關</p>\n<pre><code class=\"php\">Route::get(&#39;posts/{post}/comments/{comment}&#39;, function ($postId, $commentId) {\n    //\n});\n</code></pre>\n<h3 id=\"可選參數\"><a href=\"#可選參數\" class=\"headerlink\" title=\"可選參數\"></a>可選參數</h3><pre><code class=\"php\">Route::get(&#39;user/{name?}&#39;, function ($name = null) {\n    return $name;\n});\n\nRoute::get(&#39;user/{name?}&#39;, function ($name = &#39;John&#39;) {\n    return $name;\n});\n</code></pre>\n"},{"title":"PHP 常用","date":"2018-10-02T01:09:09.000Z","_content":"# PHP 常用\n\n","source":"_posts/PHP/php_chang_yong.md","raw":"---\ntitle: PHP 常用\ndate: 2018-10-02 09:09:09\ncategories: php\n---\n# PHP 常用\n\n","slug":"PHP/php_chang_yong","published":1,"updated":"2018-10-02T02:13:50.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4ml001gntnbdt0ffvck","content":"<h1 id=\"PHP-常用\"><a href=\"#PHP-常用\" class=\"headerlink\" title=\"PHP 常用\"></a>PHP 常用</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"PHP-常用\"><a href=\"#PHP-常用\" class=\"headerlink\" title=\"PHP 常用\"></a>PHP 常用</h1>"},{"title":"PHP判断为空","date":"2018-10-02T01:09:09.000Z","_content":"# PHP判断为空\n\n","source":"_posts/PHP/phppan_duan_wei_kong.md","raw":"---\ntitle: PHP判断为空\ndate: 2018-10-02 09:09:09\ncategories: php\n---\n# PHP判断为空\n\n","slug":"PHP/phppan_duan_wei_kong","published":1,"updated":"2018-10-02T02:13:59.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mm001jntnbzft1zj8r","content":"<h1 id=\"PHP判断为空\"><a href=\"#PHP判断为空\" class=\"headerlink\" title=\"PHP判断为空\"></a>PHP判断为空</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"PHP判断为空\"><a href=\"#PHP判断为空\" class=\"headerlink\" title=\"PHP判断为空\"></a>PHP判断为空</h1>"},{"title":"ReactNativeES5","date":"2018-10-02T01:09:09.000Z","_content":"# ES5\n\n保留关键字: promise.catch(function() { });\nES6\n\n箭头函数Arrow functions: <C onPress={() => this.setState({pressed: true})}\n块级作用域Block scoping: let greeting = 'hi';\n数组的扩展运算Call spread: Math.max(...array);\n类Classes: class C extends React.Component { render() { return <View />; } }\n常量Constants: const answer = 42;\n解构Destructuring: var {isActive, style} = this.props;\nfor...of: for (var num of [1, 2, 3]) {}\n模块Modules: import React, { Component } from 'react';\n动态属性键Computed Properties: var key = 'abc'; var obj = {[key]: 10};\n对象方法的简写Object Consise Method: var obj = { method() { return 10; } };\n对象属性的简写Object Short Notation: var name = 'vjeux'; var obj = { name };\n参数的扩展运算Rest Params: function(type, ...args) { }\n字符串模板Template Literals: var who = 'world'; var str = `Hello ${who}`;\nES7\n\n对象的扩展运算Object Spread: var extended = { ...obj, a: 10 };\n参数列表末尾允许放置逗号Function Trailing Comma: function f(a, b, c,) { }\nAsync函数: async function doStuffAsync() { const foo = await doOtherStuffAsync(); };\n\n\n\n","source":"_posts/ReactNative/RN代码风格.md","raw":"---\ntitle: ReactNativeES5\ndate: 2018-10-02 09:09:09\ncategories: ReactNative\n---\n# ES5\n\n保留关键字: promise.catch(function() { });\nES6\n\n箭头函数Arrow functions: <C onPress={() => this.setState({pressed: true})}\n块级作用域Block scoping: let greeting = 'hi';\n数组的扩展运算Call spread: Math.max(...array);\n类Classes: class C extends React.Component { render() { return <View />; } }\n常量Constants: const answer = 42;\n解构Destructuring: var {isActive, style} = this.props;\nfor...of: for (var num of [1, 2, 3]) {}\n模块Modules: import React, { Component } from 'react';\n动态属性键Computed Properties: var key = 'abc'; var obj = {[key]: 10};\n对象方法的简写Object Consise Method: var obj = { method() { return 10; } };\n对象属性的简写Object Short Notation: var name = 'vjeux'; var obj = { name };\n参数的扩展运算Rest Params: function(type, ...args) { }\n字符串模板Template Literals: var who = 'world'; var str = `Hello ${who}`;\nES7\n\n对象的扩展运算Object Spread: var extended = { ...obj, a: 10 };\n参数列表末尾允许放置逗号Function Trailing Comma: function f(a, b, c,) { }\nAsync函数: async function doStuffAsync() { const foo = await doOtherStuffAsync(); };\n\n\n\n","slug":"ReactNative/RN代码风格","published":1,"updated":"2018-10-02T06:24:46.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mn001kntnbhqibz2vc","content":"<h1 id=\"ES5\"><a href=\"#ES5\" class=\"headerlink\" title=\"ES5\"></a>ES5</h1><p>保留关键字: promise.catch(function() { });<br>ES6</p>\n<p>箭头函数Arrow functions: <c onpress=\"{()\" ==\"\"> this.setState({pressed: true})}<br>块级作用域Block scoping: let greeting = ‘hi’;<br>数组的扩展运算Call spread: Math.max(…array);<br>类Classes: class C extends React.Component { render() { return <view>; } }<br>常量Constants: const answer = 42;<br>解构Destructuring: var {isActive, style} = this.props;<br>for…of: for (var num of [1, 2, 3]) {}<br>模块Modules: import React, { Component } from ‘react’;<br>动态属性键Computed Properties: var key = ‘abc’; var obj = {[key]: 10};<br>对象方法的简写Object Consise Method: var obj = { method() { return 10; } };<br>对象属性的简写Object Short Notation: var name = ‘vjeux’; var obj = { name };<br>参数的扩展运算Rest Params: function(type, …args) { }<br>字符串模板Template Literals: var who = ‘world’; var str = <code>Hello ${who}</code>;<br>ES7</view></c></p>\n<p>对象的扩展运算Object Spread: var extended = { …obj, a: 10 };<br>参数列表末尾允许放置逗号Function Trailing Comma: function f(a, b, c,) { }<br>Async函数: async function doStuffAsync() { const foo = await doOtherStuffAsync(); };</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ES5\"><a href=\"#ES5\" class=\"headerlink\" title=\"ES5\"></a>ES5</h1><p>保留关键字: promise.catch(function() { });<br>ES6</p>\n<p>箭头函数Arrow functions: <c onpress=\"{()\" ==\"\"> this.setState({pressed: true})}<br>块级作用域Block scoping: let greeting = ‘hi’;<br>数组的扩展运算Call spread: Math.max(…array);<br>类Classes: class C extends React.Component { render() { return <view>; } }<br>常量Constants: const answer = 42;<br>解构Destructuring: var {isActive, style} = this.props;<br>for…of: for (var num of [1, 2, 3]) {}<br>模块Modules: import React, { Component } from ‘react’;<br>动态属性键Computed Properties: var key = ‘abc’; var obj = {[key]: 10};<br>对象方法的简写Object Consise Method: var obj = { method() { return 10; } };<br>对象属性的简写Object Short Notation: var name = ‘vjeux’; var obj = { name };<br>参数的扩展运算Rest Params: function(type, …args) { }<br>字符串模板Template Literals: var who = ‘world’; var str = <code>Hello ${who}</code>;<br>ES7</view></c></p>\n<p>对象的扩展运算Object Spread: var extended = { …obj, a: 10 };<br>参数列表末尾允许放置逗号Function Trailing Comma: function f(a, b, c,) { }<br>Async函数: async function doStuffAsync() { const foo = await doOtherStuffAsync(); };</p>\n"},{"title":"ReactNative HTML","date":"2018-10-02T01:09:09.000Z","_content":"```js\nvar MyComponent = React.createClass({\n  handleClick: function() {\n    this.refs.myTextInput.focus();\n  },\n  render: function() {\n    return (\n      <div>\n        <input type=\"text\" ref=\"myTextInput\" />\n        <input type=\"button\" value=\"Focus the text input\" onClick={this.handleClick} />\n      </div>\n    );\n  }\n});\n```\n\nhttp://www.ruanyifeng.com/blog/2015/03/react.html\n\nhttp://blog.csdn.net/guojin08/article/details/53126493\n\n","source":"_posts/ReactNative/ReactNativeHTML标签.md","raw":"---\ntitle: ReactNative HTML\ndate: 2018-10-02 09:09:09\ncategories: ReactNative\n---\n```js\nvar MyComponent = React.createClass({\n  handleClick: function() {\n    this.refs.myTextInput.focus();\n  },\n  render: function() {\n    return (\n      <div>\n        <input type=\"text\" ref=\"myTextInput\" />\n        <input type=\"button\" value=\"Focus the text input\" onClick={this.handleClick} />\n      </div>\n    );\n  }\n});\n```\n\nhttp://www.ruanyifeng.com/blog/2015/03/react.html\n\nhttp://blog.csdn.net/guojin08/article/details/53126493\n\n","slug":"ReactNative/ReactNativeHTML标签","published":1,"updated":"2018-10-02T02:17:24.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mo001nntnbtu2gehrx","content":"<pre><code class=\"js\">var MyComponent = React.createClass({\n  handleClick: function() {\n    this.refs.myTextInput.focus();\n  },\n  render: function() {\n    return (\n      &lt;div&gt;\n        &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt;\n        &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={this.handleClick} /&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n</code></pre>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/03/react.html</a></p>\n<p><a href=\"http://blog.csdn.net/guojin08/article/details/53126493\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/guojin08/article/details/53126493</a></p>\n","site":{"data":{}},"excerpt":"","more":"<pre><code class=\"js\">var MyComponent = React.createClass({\n  handleClick: function() {\n    this.refs.myTextInput.focus();\n  },\n  render: function() {\n    return (\n      &lt;div&gt;\n        &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt;\n        &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={this.handleClick} /&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n</code></pre>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2015/03/react.html</a></p>\n<p><a href=\"http://blog.csdn.net/guojin08/article/details/53126493\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/guojin08/article/details/53126493</a></p>\n"},{"title":"ReactNative UI Size","date":"2018-10-02T01:09:09.000Z","_content":"#### 指定宽高（dp pt）\n\n最简单的给组件设定尺寸的方式就是在样式中指定固定的`width`和`height`。React Native中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点\n\n```js\nimport React, { Component } from 'react';\nimport { AppRegistry, View } from 'react-native';\n\nclass FixedDimensionsBasics extends Component {\n  render() {\n    return (\n      <View>\n        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\n        <View style={{width: 100, height: 100, backgroundColor: 'skyblue'}} />\n        <View style={{width: 150, height: 150, backgroundColor: 'steelblue'}} />\n      </View>\n    );\n  }\n};\n// 注册应用(registerComponent)后才能正确渲染\n// 注意：只把应用作为一个整体注册一次，而不是每个组件/模块都注册\nAppRegistry.registerComponent('AwesomeProject', () => FixedDimensionsBasics);\n```\n\n#### 弹性（Flex）宽高\n\n在组件样式中使用`flex`可以使其在可利用的空间中动态地扩张或收缩。一般而言我们会使用`flex:1`来指定某个组件扩张以撑满所有剩余的空间。如果有多个并列的子组件使用了`flex:1`，则这些子组件会平分父容器中剩余的空间。如果这些并列的子组件的`flex`值不一样，则谁的值更大，谁占据剩余空间的比例就更大（即占据剩余空间的比等于并列组件间`flex`值的比）。\n\n> 组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的`width`和`height`，也没有设定`flex`，则父容器的尺寸为零。其子组件如果使用了`flex`，也是无法显示的。\n\n```js\nimport React, { Component } from 'react';\nimport { AppRegistry, View } from 'react-native';\n\nclass FlexDimensionsBasics extends Component {\n  render() {\n    return (\n      // 试试去掉父View中的`flex: 1`。\n      // 则父View不再具有尺寸，因此子组件也无法再撑开。\n      // 然后再用`height: 300`来代替父View的`flex: 1`试试看？\n      <View style={{flex: 1}}>\n        <View style={{flex: 1, backgroundColor: 'powderblue'}} />\n        <View style={{flex: 2, backgroundColor: 'skyblue'}} />\n        <View style={{flex: 3, backgroundColor: 'steelblue'}} />\n      </View>\n    );\n  }\n};\n\nAppRegistry.registerComponent('AwesomeProject', () => FlexDimensionsBasics);\n```\n\n#### Flex Direction\n\n```js\n//水平轴(row)\n//竖直轴(column)\nimport React, { Component } from 'react';\nimport { AppRegistry, View } from 'react-native';\n\nclass FlexDirectionBasics extends Component {\n  render() {\n    return (\n      // 尝试把`flexDirection`改为`column`看看\n      <View style={{flex: 1, flexDirection: 'row'}}>\n        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\n        <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />\n        <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />\n      </View>\n    );\n  }\n};\n\nAppRegistry.registerComponent('AwesomeProject', () => FlexDirectionBasics);\n```\n\n#### Justify Content\n\n主轴的排列方式\\(`flex-start`、`center`、`flex-end`、`space-around`以及`space-between`\\)\n\n```js\nimport React, { Component } from 'react';\nimport { AppRegistry, View } from 'react-native';\n\nclass JustifyContentBasics extends Component {\n  render() {\n    return (\n      // 尝试把`justifyContent`改为`center`看看\n      // 尝试把`flexDirection`改为`row`看看\n      <View style={{\n        flex: 1,\n        flexDirection: 'column',\n        justifyContent: 'space-between',\n      }}>\n        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\n        <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />\n        <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />\n      </View>\n    );\n  }\n};\n\nAppRegistry.registerComponent('AwesomeProject', () => JustifyContentBasics);\n```\n\n#### Align Items\n\n子元素沿着次轴\n\n\n\n","source":"_posts/ReactNative/ReactNative中的尺寸.md","raw":"---\ntitle: ReactNative UI Size\ndate: 2018-10-02 09:09:09\ncategories: ReactNative\n---\n#### 指定宽高（dp pt）\n\n最简单的给组件设定尺寸的方式就是在样式中指定固定的`width`和`height`。React Native中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点\n\n```js\nimport React, { Component } from 'react';\nimport { AppRegistry, View } from 'react-native';\n\nclass FixedDimensionsBasics extends Component {\n  render() {\n    return (\n      <View>\n        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\n        <View style={{width: 100, height: 100, backgroundColor: 'skyblue'}} />\n        <View style={{width: 150, height: 150, backgroundColor: 'steelblue'}} />\n      </View>\n    );\n  }\n};\n// 注册应用(registerComponent)后才能正确渲染\n// 注意：只把应用作为一个整体注册一次，而不是每个组件/模块都注册\nAppRegistry.registerComponent('AwesomeProject', () => FixedDimensionsBasics);\n```\n\n#### 弹性（Flex）宽高\n\n在组件样式中使用`flex`可以使其在可利用的空间中动态地扩张或收缩。一般而言我们会使用`flex:1`来指定某个组件扩张以撑满所有剩余的空间。如果有多个并列的子组件使用了`flex:1`，则这些子组件会平分父容器中剩余的空间。如果这些并列的子组件的`flex`值不一样，则谁的值更大，谁占据剩余空间的比例就更大（即占据剩余空间的比等于并列组件间`flex`值的比）。\n\n> 组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的`width`和`height`，也没有设定`flex`，则父容器的尺寸为零。其子组件如果使用了`flex`，也是无法显示的。\n\n```js\nimport React, { Component } from 'react';\nimport { AppRegistry, View } from 'react-native';\n\nclass FlexDimensionsBasics extends Component {\n  render() {\n    return (\n      // 试试去掉父View中的`flex: 1`。\n      // 则父View不再具有尺寸，因此子组件也无法再撑开。\n      // 然后再用`height: 300`来代替父View的`flex: 1`试试看？\n      <View style={{flex: 1}}>\n        <View style={{flex: 1, backgroundColor: 'powderblue'}} />\n        <View style={{flex: 2, backgroundColor: 'skyblue'}} />\n        <View style={{flex: 3, backgroundColor: 'steelblue'}} />\n      </View>\n    );\n  }\n};\n\nAppRegistry.registerComponent('AwesomeProject', () => FlexDimensionsBasics);\n```\n\n#### Flex Direction\n\n```js\n//水平轴(row)\n//竖直轴(column)\nimport React, { Component } from 'react';\nimport { AppRegistry, View } from 'react-native';\n\nclass FlexDirectionBasics extends Component {\n  render() {\n    return (\n      // 尝试把`flexDirection`改为`column`看看\n      <View style={{flex: 1, flexDirection: 'row'}}>\n        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\n        <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />\n        <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />\n      </View>\n    );\n  }\n};\n\nAppRegistry.registerComponent('AwesomeProject', () => FlexDirectionBasics);\n```\n\n#### Justify Content\n\n主轴的排列方式\\(`flex-start`、`center`、`flex-end`、`space-around`以及`space-between`\\)\n\n```js\nimport React, { Component } from 'react';\nimport { AppRegistry, View } from 'react-native';\n\nclass JustifyContentBasics extends Component {\n  render() {\n    return (\n      // 尝试把`justifyContent`改为`center`看看\n      // 尝试把`flexDirection`改为`row`看看\n      <View style={{\n        flex: 1,\n        flexDirection: 'column',\n        justifyContent: 'space-between',\n      }}>\n        <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\n        <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />\n        <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />\n      </View>\n    );\n  }\n};\n\nAppRegistry.registerComponent('AwesomeProject', () => JustifyContentBasics);\n```\n\n#### Align Items\n\n子元素沿着次轴\n\n\n\n","slug":"ReactNative/ReactNative中的尺寸","published":1,"updated":"2018-10-02T02:17:36.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mp001ontnbbpshvpvt","content":"<h4 id=\"指定宽高（dp-pt）\"><a href=\"#指定宽高（dp-pt）\" class=\"headerlink\" title=\"指定宽高（dp pt）\"></a>指定宽高（dp pt）</h4><p>最简单的给组件设定尺寸的方式就是在样式中指定固定的<code>width</code>和<code>height</code>。React Native中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点</p>\n<pre><code class=\"js\">import React, { Component } from &#39;react&#39;;\nimport { AppRegistry, View } from &#39;react-native&#39;;\n\nclass FixedDimensionsBasics extends Component {\n  render() {\n    return (\n      &lt;View&gt;\n        &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;\n        &lt;View style={{width: 100, height: 100, backgroundColor: 'skyblue'}} /&gt;\n        &lt;View style={{width: 150, height: 150, backgroundColor: 'steelblue'}} /&gt;\n      &lt;/View&gt;\n    );\n  }\n};\n// 注册应用(registerComponent)后才能正确渲染\n// 注意：只把应用作为一个整体注册一次，而不是每个组件/模块都注册\nAppRegistry.registerComponent(&#39;AwesomeProject&#39;, () =&gt; FixedDimensionsBasics);\n</code></pre>\n<h4 id=\"弹性（Flex）宽高\"><a href=\"#弹性（Flex）宽高\" class=\"headerlink\" title=\"弹性（Flex）宽高\"></a>弹性（Flex）宽高</h4><p>在组件样式中使用<code>flex</code>可以使其在可利用的空间中动态地扩张或收缩。一般而言我们会使用<code>flex:1</code>来指定某个组件扩张以撑满所有剩余的空间。如果有多个并列的子组件使用了<code>flex:1</code>，则这些子组件会平分父容器中剩余的空间。如果这些并列的子组件的<code>flex</code>值不一样，则谁的值更大，谁占据剩余空间的比例就更大（即占据剩余空间的比等于并列组件间<code>flex</code>值的比）。</p>\n<blockquote>\n<p>组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的<code>width</code>和<code>height</code>，也没有设定<code>flex</code>，则父容器的尺寸为零。其子组件如果使用了<code>flex</code>，也是无法显示的。</p>\n</blockquote>\n<pre><code class=\"js\">import React, { Component } from &#39;react&#39;;\nimport { AppRegistry, View } from &#39;react-native&#39;;\n\nclass FlexDimensionsBasics extends Component {\n  render() {\n    return (\n      // 试试去掉父View中的`flex: 1`。\n      // 则父View不再具有尺寸，因此子组件也无法再撑开。\n      // 然后再用`height: 300`来代替父View的`flex: 1`试试看？\n      &lt;View style={{flex: 1}}&gt;\n        &lt;View style={{flex: 1, backgroundColor: 'powderblue'}} /&gt;\n        &lt;View style={{flex: 2, backgroundColor: 'skyblue'}} /&gt;\n        &lt;View style={{flex: 3, backgroundColor: 'steelblue'}} /&gt;\n      &lt;/View&gt;\n    );\n  }\n};\n\nAppRegistry.registerComponent(&#39;AwesomeProject&#39;, () =&gt; FlexDimensionsBasics);\n</code></pre>\n<h4 id=\"Flex-Direction\"><a href=\"#Flex-Direction\" class=\"headerlink\" title=\"Flex Direction\"></a>Flex Direction</h4><pre><code class=\"js\">//水平轴(row)\n//竖直轴(column)\nimport React, { Component } from &#39;react&#39;;\nimport { AppRegistry, View } from &#39;react-native&#39;;\n\nclass FlexDirectionBasics extends Component {\n  render() {\n    return (\n      // 尝试把`flexDirection`改为`column`看看\n      &lt;View style={{flex: 1, flexDirection: 'row'}}&gt;\n        &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;\n        &lt;View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} /&gt;\n        &lt;View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} /&gt;\n      &lt;/View&gt;\n    );\n  }\n};\n\nAppRegistry.registerComponent(&#39;AwesomeProject&#39;, () =&gt; FlexDirectionBasics);\n</code></pre>\n<h4 id=\"Justify-Content\"><a href=\"#Justify-Content\" class=\"headerlink\" title=\"Justify Content\"></a>Justify Content</h4><p>主轴的排列方式(<code>flex-start</code>、<code>center</code>、<code>flex-end</code>、<code>space-around</code>以及<code>space-between</code>)</p>\n<pre><code class=\"js\">import React, { Component } from &#39;react&#39;;\nimport { AppRegistry, View } from &#39;react-native&#39;;\n\nclass JustifyContentBasics extends Component {\n  render() {\n    return (\n      // 尝试把`justifyContent`改为`center`看看\n      // 尝试把`flexDirection`改为`row`看看\n      &lt;View style={{\n        flex: 1,\n        flexDirection: 'column',\n        justifyContent: 'space-between',\n      }}&gt;\n        &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;\n        &lt;View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} /&gt;\n        &lt;View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} /&gt;\n      &lt;/View&gt;\n    );\n  }\n};\n\nAppRegistry.registerComponent(&#39;AwesomeProject&#39;, () =&gt; JustifyContentBasics);\n</code></pre>\n<h4 id=\"Align-Items\"><a href=\"#Align-Items\" class=\"headerlink\" title=\"Align Items\"></a>Align Items</h4><p>子元素沿着次轴</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"指定宽高（dp-pt）\"><a href=\"#指定宽高（dp-pt）\" class=\"headerlink\" title=\"指定宽高（dp pt）\"></a>指定宽高（dp pt）</h4><p>最简单的给组件设定尺寸的方式就是在样式中指定固定的<code>width</code>和<code>height</code>。React Native中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点</p>\n<pre><code class=\"js\">import React, { Component } from &#39;react&#39;;\nimport { AppRegistry, View } from &#39;react-native&#39;;\n\nclass FixedDimensionsBasics extends Component {\n  render() {\n    return (\n      &lt;View&gt;\n        &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;\n        &lt;View style={{width: 100, height: 100, backgroundColor: 'skyblue'}} /&gt;\n        &lt;View style={{width: 150, height: 150, backgroundColor: 'steelblue'}} /&gt;\n      &lt;/View&gt;\n    );\n  }\n};\n// 注册应用(registerComponent)后才能正确渲染\n// 注意：只把应用作为一个整体注册一次，而不是每个组件/模块都注册\nAppRegistry.registerComponent(&#39;AwesomeProject&#39;, () =&gt; FixedDimensionsBasics);\n</code></pre>\n<h4 id=\"弹性（Flex）宽高\"><a href=\"#弹性（Flex）宽高\" class=\"headerlink\" title=\"弹性（Flex）宽高\"></a>弹性（Flex）宽高</h4><p>在组件样式中使用<code>flex</code>可以使其在可利用的空间中动态地扩张或收缩。一般而言我们会使用<code>flex:1</code>来指定某个组件扩张以撑满所有剩余的空间。如果有多个并列的子组件使用了<code>flex:1</code>，则这些子组件会平分父容器中剩余的空间。如果这些并列的子组件的<code>flex</code>值不一样，则谁的值更大，谁占据剩余空间的比例就更大（即占据剩余空间的比等于并列组件间<code>flex</code>值的比）。</p>\n<blockquote>\n<p>组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的<code>width</code>和<code>height</code>，也没有设定<code>flex</code>，则父容器的尺寸为零。其子组件如果使用了<code>flex</code>，也是无法显示的。</p>\n</blockquote>\n<pre><code class=\"js\">import React, { Component } from &#39;react&#39;;\nimport { AppRegistry, View } from &#39;react-native&#39;;\n\nclass FlexDimensionsBasics extends Component {\n  render() {\n    return (\n      // 试试去掉父View中的`flex: 1`。\n      // 则父View不再具有尺寸，因此子组件也无法再撑开。\n      // 然后再用`height: 300`来代替父View的`flex: 1`试试看？\n      &lt;View style={{flex: 1}}&gt;\n        &lt;View style={{flex: 1, backgroundColor: 'powderblue'}} /&gt;\n        &lt;View style={{flex: 2, backgroundColor: 'skyblue'}} /&gt;\n        &lt;View style={{flex: 3, backgroundColor: 'steelblue'}} /&gt;\n      &lt;/View&gt;\n    );\n  }\n};\n\nAppRegistry.registerComponent(&#39;AwesomeProject&#39;, () =&gt; FlexDimensionsBasics);\n</code></pre>\n<h4 id=\"Flex-Direction\"><a href=\"#Flex-Direction\" class=\"headerlink\" title=\"Flex Direction\"></a>Flex Direction</h4><pre><code class=\"js\">//水平轴(row)\n//竖直轴(column)\nimport React, { Component } from &#39;react&#39;;\nimport { AppRegistry, View } from &#39;react-native&#39;;\n\nclass FlexDirectionBasics extends Component {\n  render() {\n    return (\n      // 尝试把`flexDirection`改为`column`看看\n      &lt;View style={{flex: 1, flexDirection: 'row'}}&gt;\n        &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;\n        &lt;View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} /&gt;\n        &lt;View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} /&gt;\n      &lt;/View&gt;\n    );\n  }\n};\n\nAppRegistry.registerComponent(&#39;AwesomeProject&#39;, () =&gt; FlexDirectionBasics);\n</code></pre>\n<h4 id=\"Justify-Content\"><a href=\"#Justify-Content\" class=\"headerlink\" title=\"Justify Content\"></a>Justify Content</h4><p>主轴的排列方式(<code>flex-start</code>、<code>center</code>、<code>flex-end</code>、<code>space-around</code>以及<code>space-between</code>)</p>\n<pre><code class=\"js\">import React, { Component } from &#39;react&#39;;\nimport { AppRegistry, View } from &#39;react-native&#39;;\n\nclass JustifyContentBasics extends Component {\n  render() {\n    return (\n      // 尝试把`justifyContent`改为`center`看看\n      // 尝试把`flexDirection`改为`row`看看\n      &lt;View style={{\n        flex: 1,\n        flexDirection: 'column',\n        justifyContent: 'space-between',\n      }}&gt;\n        &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;\n        &lt;View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} /&gt;\n        &lt;View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} /&gt;\n      &lt;/View&gt;\n    );\n  }\n};\n\nAppRegistry.registerComponent(&#39;AwesomeProject&#39;, () =&gt; JustifyContentBasics);\n</code></pre>\n<h4 id=\"Align-Items\"><a href=\"#Align-Items\" class=\"headerlink\" title=\"Align Items\"></a>Align Items</h4><p>子元素沿着次轴</p>\n"},{"title":"ReactNative Touch Event","date":"2018-10-02T01:09:09.000Z","_content":"#### 参考：[http://www.jianshu.com/p/99cd45336849](http://www.jianshu.com/p/99cd45336849)\n\n#### TouchableHighlight\n\n制作按钮或者链接，此组件的背景会在用户手指按下时变暗\n\n```js\nclass MyButton extends Component {\n  _onPressButton() {\n    console.log(\"You tapped the button!\");\n  }\n\n  render() {\n    return (\n      <TouchableHighlight onPress={this._onPressButton}>\n        <Text>Button</Text>\n      </TouchableHighlight>\n    );\n  }\n}\n```\n\n#### TouchableNativeFeedback（Android）\n\n用户手指按下时形成类似墨水涟漪的视觉效果。在Android设备上，这个组件利用原生状态来渲染触摸的反馈。目前它只支持一个单独的View实例作为子节点。在底层实现上，实际会创建一个新的RCTView结点替换当前的子View，并附带一些额外的属性。而且原生触摸操作反馈的背景可以使用background属性来自定义。\n\nTouchableNativeFeedback继承于TouchableWithoutFeedback，所以TouchableWithoutFeedback得属性\n\nbackground 决定在触摸反馈的时候显示什么类型的背景。它接受一个有着type属性和一些基于type属性的额外数据的对象。我们推荐使用以下的静态方法之一来创建这个对象：\n\n* TouchableNativeFeedback.SelectableBackground\\(\\) - 会创建一个对象，表示安卓主题默认的对于被选中对象的背景。\\(?android:attr/selectableItemBackground\\)\n* TouchableNativeFeedback.SelectableBackgroundBorderless\\(\\) - 会创建一个对象，表示安卓主题默认的对于被选中的无边框对象的背景。\\(?android:attr/selectableItemBackgroundBorderless\\)。只在Android API level 21+适用。\n* TouchableNativeFeedback.Ripple\\(color, borderless\\) - 会创建一个对象，当按钮被按下时产生一个涟漪状的背景，你可以通过color参数来指定颜色，如果参数borderless是true，那么涟漪还会渲染到视图的范围之外。（参见原生的actionbar buttons作为该效果的一个例子）。这个背景类型只在Android API level 21+适用。\n\n#### TouchableOpacity\n\n按下时降低按钮的透明度，而不会改变背景的颜色\n\n```js\n<TouchableOpacity onPress={this._onPressButton}>\n  <Image\n    style={styles.button}\n    source={require('image!myButton')}\n  />\n</TouchableOpacity>\n```\n\n#### TouchableWithoutFeedback\n\n只支持一个子节点如果你希望包含多个子组件，用一个View来包装它们\n\n","source":"_posts/ReactNative/ReactNative处理触摸事件.md","raw":"---\ntitle: ReactNative Touch Event\ndate: 2018-10-02 09:09:09\ncategories: ReactNative\n---\n#### 参考：[http://www.jianshu.com/p/99cd45336849](http://www.jianshu.com/p/99cd45336849)\n\n#### TouchableHighlight\n\n制作按钮或者链接，此组件的背景会在用户手指按下时变暗\n\n```js\nclass MyButton extends Component {\n  _onPressButton() {\n    console.log(\"You tapped the button!\");\n  }\n\n  render() {\n    return (\n      <TouchableHighlight onPress={this._onPressButton}>\n        <Text>Button</Text>\n      </TouchableHighlight>\n    );\n  }\n}\n```\n\n#### TouchableNativeFeedback（Android）\n\n用户手指按下时形成类似墨水涟漪的视觉效果。在Android设备上，这个组件利用原生状态来渲染触摸的反馈。目前它只支持一个单独的View实例作为子节点。在底层实现上，实际会创建一个新的RCTView结点替换当前的子View，并附带一些额外的属性。而且原生触摸操作反馈的背景可以使用background属性来自定义。\n\nTouchableNativeFeedback继承于TouchableWithoutFeedback，所以TouchableWithoutFeedback得属性\n\nbackground 决定在触摸反馈的时候显示什么类型的背景。它接受一个有着type属性和一些基于type属性的额外数据的对象。我们推荐使用以下的静态方法之一来创建这个对象：\n\n* TouchableNativeFeedback.SelectableBackground\\(\\) - 会创建一个对象，表示安卓主题默认的对于被选中对象的背景。\\(?android:attr/selectableItemBackground\\)\n* TouchableNativeFeedback.SelectableBackgroundBorderless\\(\\) - 会创建一个对象，表示安卓主题默认的对于被选中的无边框对象的背景。\\(?android:attr/selectableItemBackgroundBorderless\\)。只在Android API level 21+适用。\n* TouchableNativeFeedback.Ripple\\(color, borderless\\) - 会创建一个对象，当按钮被按下时产生一个涟漪状的背景，你可以通过color参数来指定颜色，如果参数borderless是true，那么涟漪还会渲染到视图的范围之外。（参见原生的actionbar buttons作为该效果的一个例子）。这个背景类型只在Android API level 21+适用。\n\n#### TouchableOpacity\n\n按下时降低按钮的透明度，而不会改变背景的颜色\n\n```js\n<TouchableOpacity onPress={this._onPressButton}>\n  <Image\n    style={styles.button}\n    source={require('image!myButton')}\n  />\n</TouchableOpacity>\n```\n\n#### TouchableWithoutFeedback\n\n只支持一个子节点如果你希望包含多个子组件，用一个View来包装它们\n\n","slug":"ReactNative/ReactNative处理触摸事件","published":1,"updated":"2018-10-02T02:17:54.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mq001rntnbioh7wvza","content":"<h4 id=\"参考：http-www-jianshu-com-p-99cd45336849\"><a href=\"#参考：http-www-jianshu-com-p-99cd45336849\" class=\"headerlink\" title=\"参考：http://www.jianshu.com/p/99cd45336849\"></a>参考：<a href=\"http://www.jianshu.com/p/99cd45336849\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/99cd45336849</a></h4><h4 id=\"TouchableHighlight\"><a href=\"#TouchableHighlight\" class=\"headerlink\" title=\"TouchableHighlight\"></a>TouchableHighlight</h4><p>制作按钮或者链接，此组件的背景会在用户手指按下时变暗</p>\n<pre><code class=\"js\">class MyButton extends Component {\n  _onPressButton() {\n    console.log(&quot;You tapped the button!&quot;);\n  }\n\n  render() {\n    return (\n      &lt;TouchableHighlight onPress={this._onPressButton}&gt;\n        &lt;Text&gt;Button&lt;/Text&gt;\n      &lt;/TouchableHighlight&gt;\n    );\n  }\n}\n</code></pre>\n<h4 id=\"TouchableNativeFeedback（Android）\"><a href=\"#TouchableNativeFeedback（Android）\" class=\"headerlink\" title=\"TouchableNativeFeedback（Android）\"></a>TouchableNativeFeedback（Android）</h4><p>用户手指按下时形成类似墨水涟漪的视觉效果。在Android设备上，这个组件利用原生状态来渲染触摸的反馈。目前它只支持一个单独的View实例作为子节点。在底层实现上，实际会创建一个新的RCTView结点替换当前的子View，并附带一些额外的属性。而且原生触摸操作反馈的背景可以使用background属性来自定义。</p>\n<p>TouchableNativeFeedback继承于TouchableWithoutFeedback，所以TouchableWithoutFeedback得属性</p>\n<p>background 决定在触摸反馈的时候显示什么类型的背景。它接受一个有着type属性和一些基于type属性的额外数据的对象。我们推荐使用以下的静态方法之一来创建这个对象：</p>\n<ul>\n<li>TouchableNativeFeedback.SelectableBackground() - 会创建一个对象，表示安卓主题默认的对于被选中对象的背景。(?android:attr/selectableItemBackground)</li>\n<li>TouchableNativeFeedback.SelectableBackgroundBorderless() - 会创建一个对象，表示安卓主题默认的对于被选中的无边框对象的背景。(?android:attr/selectableItemBackgroundBorderless)。只在Android API level 21+适用。</li>\n<li>TouchableNativeFeedback.Ripple(color, borderless) - 会创建一个对象，当按钮被按下时产生一个涟漪状的背景，你可以通过color参数来指定颜色，如果参数borderless是true，那么涟漪还会渲染到视图的范围之外。（参见原生的actionbar buttons作为该效果的一个例子）。这个背景类型只在Android API level 21+适用。</li>\n</ul>\n<h4 id=\"TouchableOpacity\"><a href=\"#TouchableOpacity\" class=\"headerlink\" title=\"TouchableOpacity\"></a>TouchableOpacity</h4><p>按下时降低按钮的透明度，而不会改变背景的颜色</p>\n<pre><code class=\"js\">&lt;TouchableOpacity onPress={this._onPressButton}&gt;\n  &lt;Image\n    style={styles.button}\n    source={require(&#39;image!myButton&#39;)}\n  /&gt;\n&lt;/TouchableOpacity&gt;\n</code></pre>\n<h4 id=\"TouchableWithoutFeedback\"><a href=\"#TouchableWithoutFeedback\" class=\"headerlink\" title=\"TouchableWithoutFeedback\"></a>TouchableWithoutFeedback</h4><p>只支持一个子节点如果你希望包含多个子组件，用一个View来包装它们</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"参考：http-www-jianshu-com-p-99cd45336849\"><a href=\"#参考：http-www-jianshu-com-p-99cd45336849\" class=\"headerlink\" title=\"参考：http://www.jianshu.com/p/99cd45336849\"></a>参考：<a href=\"http://www.jianshu.com/p/99cd45336849\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/99cd45336849</a></h4><h4 id=\"TouchableHighlight\"><a href=\"#TouchableHighlight\" class=\"headerlink\" title=\"TouchableHighlight\"></a>TouchableHighlight</h4><p>制作按钮或者链接，此组件的背景会在用户手指按下时变暗</p>\n<pre><code class=\"js\">class MyButton extends Component {\n  _onPressButton() {\n    console.log(&quot;You tapped the button!&quot;);\n  }\n\n  render() {\n    return (\n      &lt;TouchableHighlight onPress={this._onPressButton}&gt;\n        &lt;Text&gt;Button&lt;/Text&gt;\n      &lt;/TouchableHighlight&gt;\n    );\n  }\n}\n</code></pre>\n<h4 id=\"TouchableNativeFeedback（Android）\"><a href=\"#TouchableNativeFeedback（Android）\" class=\"headerlink\" title=\"TouchableNativeFeedback（Android）\"></a>TouchableNativeFeedback（Android）</h4><p>用户手指按下时形成类似墨水涟漪的视觉效果。在Android设备上，这个组件利用原生状态来渲染触摸的反馈。目前它只支持一个单独的View实例作为子节点。在底层实现上，实际会创建一个新的RCTView结点替换当前的子View，并附带一些额外的属性。而且原生触摸操作反馈的背景可以使用background属性来自定义。</p>\n<p>TouchableNativeFeedback继承于TouchableWithoutFeedback，所以TouchableWithoutFeedback得属性</p>\n<p>background 决定在触摸反馈的时候显示什么类型的背景。它接受一个有着type属性和一些基于type属性的额外数据的对象。我们推荐使用以下的静态方法之一来创建这个对象：</p>\n<ul>\n<li>TouchableNativeFeedback.SelectableBackground() - 会创建一个对象，表示安卓主题默认的对于被选中对象的背景。(?android:attr/selectableItemBackground)</li>\n<li>TouchableNativeFeedback.SelectableBackgroundBorderless() - 会创建一个对象，表示安卓主题默认的对于被选中的无边框对象的背景。(?android:attr/selectableItemBackgroundBorderless)。只在Android API level 21+适用。</li>\n<li>TouchableNativeFeedback.Ripple(color, borderless) - 会创建一个对象，当按钮被按下时产生一个涟漪状的背景，你可以通过color参数来指定颜色，如果参数borderless是true，那么涟漪还会渲染到视图的范围之外。（参见原生的actionbar buttons作为该效果的一个例子）。这个背景类型只在Android API level 21+适用。</li>\n</ul>\n<h4 id=\"TouchableOpacity\"><a href=\"#TouchableOpacity\" class=\"headerlink\" title=\"TouchableOpacity\"></a>TouchableOpacity</h4><p>按下时降低按钮的透明度，而不会改变背景的颜色</p>\n<pre><code class=\"js\">&lt;TouchableOpacity onPress={this._onPressButton}&gt;\n  &lt;Image\n    style={styles.button}\n    source={require(&#39;image!myButton&#39;)}\n  /&gt;\n&lt;/TouchableOpacity&gt;\n</code></pre>\n<h4 id=\"TouchableWithoutFeedback\"><a href=\"#TouchableWithoutFeedback\" class=\"headerlink\" title=\"TouchableWithoutFeedback\"></a>TouchableWithoutFeedback</h4><p>只支持一个子节点如果你希望包含多个子组件，用一个View来包装它们</p>\n"},{"title":"React Native Android Build Apk","date":"2018-10-02T01:09:09.000Z","_content":"#### **发布更新**\n\n发布更新之前，需要先把 js打包成 bundle，以下是anroid的做法：\n\n**第一步** 在 工程目录里面新增 bundles文件：`mkdir bundles`\n\n**第二步** 运行命令打包 `react-native bundle --platform 平台 --entry-file 启动文件 --bundle-output 打包js输出文件 --assets-dest 资源输出目录 --dev 是否调试`。\n\n这是我的打包命名： `react-native bundle --platform android --entry-file index.android.js --bundle-output ./bundles/index.android.bundle --dev false`\n\n","source":"_posts/ReactNative/android-recat-native.md","raw":"---\ntitle: React Native Android Build Apk\ndate: 2018-10-02 09:09:09\ncategories: ReactNative\n---\n#### **发布更新**\n\n发布更新之前，需要先把 js打包成 bundle，以下是anroid的做法：\n\n**第一步** 在 工程目录里面新增 bundles文件：`mkdir bundles`\n\n**第二步** 运行命令打包 `react-native bundle --platform 平台 --entry-file 启动文件 --bundle-output 打包js输出文件 --assets-dest 资源输出目录 --dev 是否调试`。\n\n这是我的打包命名： `react-native bundle --platform android --entry-file index.android.js --bundle-output ./bundles/index.android.bundle --dev false`\n\n","slug":"ReactNative/android-recat-native","published":1,"updated":"2018-10-02T02:31:25.636Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mr001sntnbh3dfy0hx","content":"<h4 id=\"发布更新\"><a href=\"#发布更新\" class=\"headerlink\" title=\"发布更新\"></a><strong>发布更新</strong></h4><p>发布更新之前，需要先把 js打包成 bundle，以下是anroid的做法：</p>\n<p><strong>第一步</strong> 在 工程目录里面新增 bundles文件：<code>mkdir bundles</code></p>\n<p><strong>第二步</strong> 运行命令打包 <code>react-native bundle --platform 平台 --entry-file 启动文件 --bundle-output 打包js输出文件 --assets-dest 资源输出目录 --dev 是否调试</code>。</p>\n<p>这是我的打包命名： <code>react-native bundle --platform android --entry-file index.android.js --bundle-output ./bundles/index.android.bundle --dev false</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"发布更新\"><a href=\"#发布更新\" class=\"headerlink\" title=\"发布更新\"></a><strong>发布更新</strong></h4><p>发布更新之前，需要先把 js打包成 bundle，以下是anroid的做法：</p>\n<p><strong>第一步</strong> 在 工程目录里面新增 bundles文件：<code>mkdir bundles</code></p>\n<p><strong>第二步</strong> 运行命令打包 <code>react-native bundle --platform 平台 --entry-file 启动文件 --bundle-output 打包js输出文件 --assets-dest 资源输出目录 --dev 是否调试</code>。</p>\n<p>这是我的打包命名： <code>react-native bundle --platform android --entry-file index.android.js --bundle-output ./bundles/index.android.bundle --dev false</code></p>\n"},{"title":"ReactNative 通訊 Android","date":"2018-10-02T01:09:09.000Z","_content":"继承ReactContextBaseJavaModule，要求派生类实现`getName`方法\n\n模块名前的RCT前缀会被自动移除。所以如果返回的字符串为\"RCTToastAndroid\"，在JavaScript端依然通过`React.NativeModules.ToastAndroid`访问到这个模块\n\n```java\npublic class ToastModule extends ReactContextBaseJavaModule {\n\n  private static final String DURATION_SHORT_KEY = \"SHORT\";\n  private static final String DURATION_LONG_KEY = \"LONG\";\n\n  public ToastModule(ReactApplicationContext reactContext) {\n    super(reactContext);\n  }\n}\n```\n\n添加被JavaScript同步访问到的预定义的值\n\n```java\n@Override\n  public Map<String, Object> getConstants() {\n    final Map<String, Object> constants = new HashMap<>();\n    constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT);\n    constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG);\n    return constants;\n  }\n```\n\n要导出一个方法给JavaScript使用，Java方法需要使用注解`@ReactMethod`。方法的返回类型必须为`void`。React Native的跨语言访问是异步进行的，所以想要给JavaScript返回一个值的唯一办法是使用回调函数或者发送事件\n\n```java\n@ReactMethod\n  public void show(String message, int duration) {\n    Toast.makeText(getReactApplicationContext(), message, duration).show();\n  }\n```\n\n\n\n","source":"_posts/ReactNative/android.md","raw":"---\ntitle: ReactNative 通訊 Android\ndate: 2018-10-02 09:09:09\ncategories: ReactNative\n---\n继承ReactContextBaseJavaModule，要求派生类实现`getName`方法\n\n模块名前的RCT前缀会被自动移除。所以如果返回的字符串为\"RCTToastAndroid\"，在JavaScript端依然通过`React.NativeModules.ToastAndroid`访问到这个模块\n\n```java\npublic class ToastModule extends ReactContextBaseJavaModule {\n\n  private static final String DURATION_SHORT_KEY = \"SHORT\";\n  private static final String DURATION_LONG_KEY = \"LONG\";\n\n  public ToastModule(ReactApplicationContext reactContext) {\n    super(reactContext);\n  }\n}\n```\n\n添加被JavaScript同步访问到的预定义的值\n\n```java\n@Override\n  public Map<String, Object> getConstants() {\n    final Map<String, Object> constants = new HashMap<>();\n    constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT);\n    constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG);\n    return constants;\n  }\n```\n\n要导出一个方法给JavaScript使用，Java方法需要使用注解`@ReactMethod`。方法的返回类型必须为`void`。React Native的跨语言访问是异步进行的，所以想要给JavaScript返回一个值的唯一办法是使用回调函数或者发送事件\n\n```java\n@ReactMethod\n  public void show(String message, int duration) {\n    Toast.makeText(getReactApplicationContext(), message, duration).show();\n  }\n```\n\n\n\n","slug":"ReactNative/android","published":1,"updated":"2018-10-02T02:15:04.414Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4ms001vntnbv3wiao5i","content":"<p>继承ReactContextBaseJavaModule，要求派生类实现<code>getName</code>方法</p>\n<p>模块名前的RCT前缀会被自动移除。所以如果返回的字符串为”RCTToastAndroid”，在JavaScript端依然通过<code>React.NativeModules.ToastAndroid</code>访问到这个模块</p>\n<pre><code class=\"java\">public class ToastModule extends ReactContextBaseJavaModule {\n\n  private static final String DURATION_SHORT_KEY = &quot;SHORT&quot;;\n  private static final String DURATION_LONG_KEY = &quot;LONG&quot;;\n\n  public ToastModule(ReactApplicationContext reactContext) {\n    super(reactContext);\n  }\n}\n</code></pre>\n<p>添加被JavaScript同步访问到的预定义的值</p>\n<pre><code class=\"java\">@Override\n  public Map&lt;String, Object&gt; getConstants() {\n    final Map&lt;String, Object&gt; constants = new HashMap&lt;&gt;();\n    constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT);\n    constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG);\n    return constants;\n  }\n</code></pre>\n<p>要导出一个方法给JavaScript使用，Java方法需要使用注解<code>@ReactMethod</code>。方法的返回类型必须为<code>void</code>。React Native的跨语言访问是异步进行的，所以想要给JavaScript返回一个值的唯一办法是使用回调函数或者发送事件</p>\n<pre><code class=\"java\">@ReactMethod\n  public void show(String message, int duration) {\n    Toast.makeText(getReactApplicationContext(), message, duration).show();\n  }\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>继承ReactContextBaseJavaModule，要求派生类实现<code>getName</code>方法</p>\n<p>模块名前的RCT前缀会被自动移除。所以如果返回的字符串为”RCTToastAndroid”，在JavaScript端依然通过<code>React.NativeModules.ToastAndroid</code>访问到这个模块</p>\n<pre><code class=\"java\">public class ToastModule extends ReactContextBaseJavaModule {\n\n  private static final String DURATION_SHORT_KEY = &quot;SHORT&quot;;\n  private static final String DURATION_LONG_KEY = &quot;LONG&quot;;\n\n  public ToastModule(ReactApplicationContext reactContext) {\n    super(reactContext);\n  }\n}\n</code></pre>\n<p>添加被JavaScript同步访问到的预定义的值</p>\n<pre><code class=\"java\">@Override\n  public Map&lt;String, Object&gt; getConstants() {\n    final Map&lt;String, Object&gt; constants = new HashMap&lt;&gt;();\n    constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT);\n    constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG);\n    return constants;\n  }\n</code></pre>\n<p>要导出一个方法给JavaScript使用，Java方法需要使用注解<code>@ReactMethod</code>。方法的返回类型必须为<code>void</code>。React Native的跨语言访问是异步进行的，所以想要给JavaScript返回一个值的唯一办法是使用回调函数或者发送事件</p>\n<pre><code class=\"java\">@ReactMethod\n  public void show(String message, int duration) {\n    Toast.makeText(getReactApplicationContext(), message, duration).show();\n  }\n</code></pre>\n"},{"title":"ReactNative 通訊 Android","date":"2018-10-02T01:09:09.000Z","_content":"var a = {name: 1}; var b = a;\n\nconsole.log\\(a\\); console.log\\(b\\);\n\n[b.name](http://b.name/) = 2; console.log\\(a\\); console.log\\(b\\);\n\nvar b = {name: 3}; console.log\\(a\\); console.log\\(b\\);\n\n运行 test.js 结果为：\n\n{ name: 1 } { name: 1 } { name: 2 } { name: 2 } { name: 2 } { name: 3 }\n\n**解释**：a 是一个对象，b 是对 a 的引用，即 a 和 b 指向同一块内存，所以前两个输出一样。当对 b 作修改时，即 a 和 b 指向同一块内存地址的内容发生了改变，所以 a 也会体现出来，所以第三四个输出一样。当 b 被覆盖时，b 指向了一块新的内存，a 还是指向原来的内存，所以最后两个输出不一样。\n\n明白了上述例子后，我们只需知道三点就知道 exports 和 module.exports 的区别了：\n\n1. module.exports 初始值为一个空对象 {}\n2. exports 是指向的 module.exports 的引用\n3. require\\(\\) 返回的是 module.exports 而不是 exports\n\n\n\n","source":"_posts/ReactNative/exports-module.exports.md","raw":"---\ntitle: ReactNative 通訊 Android\ndate: 2018-10-02 09:09:09\ncategories: ReactNative\n---\nvar a = {name: 1}; var b = a;\n\nconsole.log\\(a\\); console.log\\(b\\);\n\n[b.name](http://b.name/) = 2; console.log\\(a\\); console.log\\(b\\);\n\nvar b = {name: 3}; console.log\\(a\\); console.log\\(b\\);\n\n运行 test.js 结果为：\n\n{ name: 1 } { name: 1 } { name: 2 } { name: 2 } { name: 2 } { name: 3 }\n\n**解释**：a 是一个对象，b 是对 a 的引用，即 a 和 b 指向同一块内存，所以前两个输出一样。当对 b 作修改时，即 a 和 b 指向同一块内存地址的内容发生了改变，所以 a 也会体现出来，所以第三四个输出一样。当 b 被覆盖时，b 指向了一块新的内存，a 还是指向原来的内存，所以最后两个输出不一样。\n\n明白了上述例子后，我们只需知道三点就知道 exports 和 module.exports 的区别了：\n\n1. module.exports 初始值为一个空对象 {}\n2. exports 是指向的 module.exports 的引用\n3. require\\(\\) 返回的是 module.exports 而不是 exports\n\n\n\n","slug":"ReactNative/exports-module.exports","published":1,"updated":"2018-10-02T02:15:13.504Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4ms001wntnb0sutndtt","content":"<p>var a = {name: 1}; var b = a;</p>\n<p>console.log(a); console.log(b);</p>\n<p><a href=\"http://b.name/\" target=\"_blank\" rel=\"noopener\">b.name</a> = 2; console.log(a); console.log(b);</p>\n<p>var b = {name: 3}; console.log(a); console.log(b);</p>\n<p>运行 test.js 结果为：</p>\n<p>{ name: 1 } { name: 1 } { name: 2 } { name: 2 } { name: 2 } { name: 3 }</p>\n<p><strong>解释</strong>：a 是一个对象，b 是对 a 的引用，即 a 和 b 指向同一块内存，所以前两个输出一样。当对 b 作修改时，即 a 和 b 指向同一块内存地址的内容发生了改变，所以 a 也会体现出来，所以第三四个输出一样。当 b 被覆盖时，b 指向了一块新的内存，a 还是指向原来的内存，所以最后两个输出不一样。</p>\n<p>明白了上述例子后，我们只需知道三点就知道 exports 和 module.exports 的区别了：</p>\n<ol>\n<li>module.exports 初始值为一个空对象 {}</li>\n<li>exports 是指向的 module.exports 的引用</li>\n<li>require() 返回的是 module.exports 而不是 exports</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>var a = {name: 1}; var b = a;</p>\n<p>console.log(a); console.log(b);</p>\n<p><a href=\"http://b.name/\" target=\"_blank\" rel=\"noopener\">b.name</a> = 2; console.log(a); console.log(b);</p>\n<p>var b = {name: 3}; console.log(a); console.log(b);</p>\n<p>运行 test.js 结果为：</p>\n<p>{ name: 1 } { name: 1 } { name: 2 } { name: 2 } { name: 2 } { name: 3 }</p>\n<p><strong>解释</strong>：a 是一个对象，b 是对 a 的引用，即 a 和 b 指向同一块内存，所以前两个输出一样。当对 b 作修改时，即 a 和 b 指向同一块内存地址的内容发生了改变，所以 a 也会体现出来，所以第三四个输出一样。当 b 被覆盖时，b 指向了一块新的内存，a 还是指向原来的内存，所以最后两个输出不一样。</p>\n<p>明白了上述例子后，我们只需知道三点就知道 exports 和 module.exports 的区别了：</p>\n<ol>\n<li>module.exports 初始值为一个空对象 {}</li>\n<li>exports 是指向的 module.exports 的引用</li>\n<li>require() 返回的是 module.exports 而不是 exports</li>\n</ol>\n"},{"title":"ReactNative 通訊 Android","date":"2018-10-02T01:09:09.000Z","_content":"#### Headless JS\n\nHeadless JS是一种使用js在后台执行任务的方法。它可以用来在后台同步数据、处理推送通知或是播放音乐等等。\n\n#### JS端的API\n\n首先我们要通过`AppRegistry`来注册一个async函数，这个函数我们称之为“任务”。注册方式类似在index.js中注册RN应用：\n\n```js\nAppRegistry.registerHeadlessTask('SomeTaskName', () => require('SomeTaskName'));\n```\n\n然后创建require对应的`SomeTaskName.js`文件:\n\n```js\nmodule.exports = async (taskData) => {\n  // 要做的事情\n}\n```\n\n可以在任务中处理任何事情（网络请求、定时器等等），但唯独不要涉及用户界面！在任务完成后（例如在promise中调用resolve），RN会进入一个“暂停”模式，直到有新任务需要执行或者是应用回到前台。\n\n\n\n#### Java端的API\n\n继承`HeadlessJsTaskService`，然后覆盖`getTaskConfig`方法的实现：\n\n```js\npublic class MyTaskService extends HeadlessJsTaskService {\n\n  @Override\n  protected @Nullable HeadlessJsTaskConfig getTaskConfig(Intent intent) {\n    Bundle extras = intent.getExtras();\n    if (extras != null) {\n      return new HeadlessJsTaskConfig(\n          \"SomeTaskName\",\n          Arguments.fromBundle(extras),\n          5000);\n    }\n    return null;\n  }\n}\n```\n\n\n\n","source":"_posts/ReactNative/headless-js.md","raw":"---\ntitle: ReactNative 通訊 Android\ndate: 2018-10-02 09:09:09\ncategories: ReactNative\n---\n#### Headless JS\n\nHeadless JS是一种使用js在后台执行任务的方法。它可以用来在后台同步数据、处理推送通知或是播放音乐等等。\n\n#### JS端的API\n\n首先我们要通过`AppRegistry`来注册一个async函数，这个函数我们称之为“任务”。注册方式类似在index.js中注册RN应用：\n\n```js\nAppRegistry.registerHeadlessTask('SomeTaskName', () => require('SomeTaskName'));\n```\n\n然后创建require对应的`SomeTaskName.js`文件:\n\n```js\nmodule.exports = async (taskData) => {\n  // 要做的事情\n}\n```\n\n可以在任务中处理任何事情（网络请求、定时器等等），但唯独不要涉及用户界面！在任务完成后（例如在promise中调用resolve），RN会进入一个“暂停”模式，直到有新任务需要执行或者是应用回到前台。\n\n\n\n#### Java端的API\n\n继承`HeadlessJsTaskService`，然后覆盖`getTaskConfig`方法的实现：\n\n```js\npublic class MyTaskService extends HeadlessJsTaskService {\n\n  @Override\n  protected @Nullable HeadlessJsTaskConfig getTaskConfig(Intent intent) {\n    Bundle extras = intent.getExtras();\n    if (extras != null) {\n      return new HeadlessJsTaskConfig(\n          \"SomeTaskName\",\n          Arguments.fromBundle(extras),\n          5000);\n    }\n    return null;\n  }\n}\n```\n\n\n\n","slug":"ReactNative/headless-js","published":1,"updated":"2018-10-02T02:15:24.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mt001zntnb5309m8ru","content":"<h4 id=\"Headless-JS\"><a href=\"#Headless-JS\" class=\"headerlink\" title=\"Headless JS\"></a>Headless JS</h4><p>Headless JS是一种使用js在后台执行任务的方法。它可以用来在后台同步数据、处理推送通知或是播放音乐等等。</p>\n<h4 id=\"JS端的API\"><a href=\"#JS端的API\" class=\"headerlink\" title=\"JS端的API\"></a>JS端的API</h4><p>首先我们要通过<code>AppRegistry</code>来注册一个async函数，这个函数我们称之为“任务”。注册方式类似在index.js中注册RN应用：</p>\n<pre><code class=\"js\">AppRegistry.registerHeadlessTask(&#39;SomeTaskName&#39;, () =&gt; require(&#39;SomeTaskName&#39;));\n</code></pre>\n<p>然后创建require对应的<code>SomeTaskName.js</code>文件:</p>\n<pre><code class=\"js\">module.exports = async (taskData) =&gt; {\n  // 要做的事情\n}\n</code></pre>\n<p>可以在任务中处理任何事情（网络请求、定时器等等），但唯独不要涉及用户界面！在任务完成后（例如在promise中调用resolve），RN会进入一个“暂停”模式，直到有新任务需要执行或者是应用回到前台。</p>\n<h4 id=\"Java端的API\"><a href=\"#Java端的API\" class=\"headerlink\" title=\"Java端的API\"></a>Java端的API</h4><p>继承<code>HeadlessJsTaskService</code>，然后覆盖<code>getTaskConfig</code>方法的实现：</p>\n<pre><code class=\"js\">public class MyTaskService extends HeadlessJsTaskService {\n\n  @Override\n  protected @Nullable HeadlessJsTaskConfig getTaskConfig(Intent intent) {\n    Bundle extras = intent.getExtras();\n    if (extras != null) {\n      return new HeadlessJsTaskConfig(\n          &quot;SomeTaskName&quot;,\n          Arguments.fromBundle(extras),\n          5000);\n    }\n    return null;\n  }\n}\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Headless-JS\"><a href=\"#Headless-JS\" class=\"headerlink\" title=\"Headless JS\"></a>Headless JS</h4><p>Headless JS是一种使用js在后台执行任务的方法。它可以用来在后台同步数据、处理推送通知或是播放音乐等等。</p>\n<h4 id=\"JS端的API\"><a href=\"#JS端的API\" class=\"headerlink\" title=\"JS端的API\"></a>JS端的API</h4><p>首先我们要通过<code>AppRegistry</code>来注册一个async函数，这个函数我们称之为“任务”。注册方式类似在index.js中注册RN应用：</p>\n<pre><code class=\"js\">AppRegistry.registerHeadlessTask(&#39;SomeTaskName&#39;, () =&gt; require(&#39;SomeTaskName&#39;));\n</code></pre>\n<p>然后创建require对应的<code>SomeTaskName.js</code>文件:</p>\n<pre><code class=\"js\">module.exports = async (taskData) =&gt; {\n  // 要做的事情\n}\n</code></pre>\n<p>可以在任务中处理任何事情（网络请求、定时器等等），但唯独不要涉及用户界面！在任务完成后（例如在promise中调用resolve），RN会进入一个“暂停”模式，直到有新任务需要执行或者是应用回到前台。</p>\n<h4 id=\"Java端的API\"><a href=\"#Java端的API\" class=\"headerlink\" title=\"Java端的API\"></a>Java端的API</h4><p>继承<code>HeadlessJsTaskService</code>，然后覆盖<code>getTaskConfig</code>方法的实现：</p>\n<pre><code class=\"js\">public class MyTaskService extends HeadlessJsTaskService {\n\n  @Override\n  protected @Nullable HeadlessJsTaskConfig getTaskConfig(Intent intent) {\n    Bundle extras = intent.getExtras();\n    if (extras != null) {\n      return new HeadlessJsTaskConfig(\n          &quot;SomeTaskName&quot;,\n          Arguments.fromBundle(extras),\n          5000);\n    }\n    return null;\n  }\n}\n</code></pre>\n"},{"title":"es6","date":"2018-10-02T01:09:09.000Z","_content":"在JavaScript ES6中，export与export default均可用于导出常量、函数、文件、模块等，你可以在其它文件或模块中通过import+\\(常量 \\| 函数 \\| 文件 \\| 模块\\)名的方式，将其导入，以便能够对其进行使用，但在一个文件或模块中，export、import可以有多个，export default仅有一个。\n\n```\n//demo1.js\nexport const str = 'hello world'\n\nexport function f(a){\n    return a+1\n}\n```\n\n对应的导入方式：\n\n```\n//demo2.js\nimport { str, f } from 'demo1' //也可以分开写两次，导入的时候带花括号\n```\n\n\n\ndefault\n\n```\n//demo1.js\nexport default const str = 'hello world'\n```\n\n对应的导入方式：\n\n```\n//demo2.js\nimport str from 'demo1' //导入的时候没有花括号\n```\n\n\n\n","source":"_posts/ReactNative/javascript-es6exportexport-default.md","raw":"---\ntitle: es6\ndate: 2018-10-02 09:09:09\ncategories: es6\n---\n在JavaScript ES6中，export与export default均可用于导出常量、函数、文件、模块等，你可以在其它文件或模块中通过import+\\(常量 \\| 函数 \\| 文件 \\| 模块\\)名的方式，将其导入，以便能够对其进行使用，但在一个文件或模块中，export、import可以有多个，export default仅有一个。\n\n```\n//demo1.js\nexport const str = 'hello world'\n\nexport function f(a){\n    return a+1\n}\n```\n\n对应的导入方式：\n\n```\n//demo2.js\nimport { str, f } from 'demo1' //也可以分开写两次，导入的时候带花括号\n```\n\n\n\ndefault\n\n```\n//demo1.js\nexport default const str = 'hello world'\n```\n\n对应的导入方式：\n\n```\n//demo2.js\nimport str from 'demo1' //导入的时候没有花括号\n```\n\n\n\n","slug":"ReactNative/javascript-es6exportexport-default","published":1,"updated":"2018-10-02T02:15:42.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mu0020ntnb7517wcna","content":"<p>在JavaScript ES6中，export与export default均可用于导出常量、函数、文件、模块等，你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用，但在一个文件或模块中，export、import可以有多个，export default仅有一个。</p>\n<pre><code>//demo1.js\nexport const str = &#39;hello world&#39;\n\nexport function f(a){\n    return a+1\n}\n</code></pre><p>对应的导入方式：</p>\n<pre><code>//demo2.js\nimport { str, f } from &#39;demo1&#39; //也可以分开写两次，导入的时候带花括号\n</code></pre><p>default</p>\n<pre><code>//demo1.js\nexport default const str = &#39;hello world&#39;\n</code></pre><p>对应的导入方式：</p>\n<pre><code>//demo2.js\nimport str from &#39;demo1&#39; //导入的时候没有花括号\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>在JavaScript ES6中，export与export default均可用于导出常量、函数、文件、模块等，你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用，但在一个文件或模块中，export、import可以有多个，export default仅有一个。</p>\n<pre><code>//demo1.js\nexport const str = &#39;hello world&#39;\n\nexport function f(a){\n    return a+1\n}\n</code></pre><p>对应的导入方式：</p>\n<pre><code>//demo2.js\nimport { str, f } from &#39;demo1&#39; //也可以分开写两次，导入的时候带花括号\n</code></pre><p>default</p>\n<pre><code>//demo1.js\nexport default const str = &#39;hello world&#39;\n</code></pre><p>对应的导入方式：</p>\n<pre><code>//demo2.js\nimport str from &#39;demo1&#39; //导入的时候没有花括号\n</code></pre>"},{"title":"ReactNative ImageView","date":"2018-10-02T01:09:09.000Z","_content":"创建一个ViewManager的子类。\n\n实现createViewInstance方法。\n\n导出视图的属性设置器：使用@ReactProp（或@ReactPropGroup）注解。\n\n把这个视图管理类注册到应用程序包的createViewManagers里。\n\n实现JavaScript模块。\n\n```java\npublic class ReactImageManager extends SimpleViewManager<ReactImageView> {\n\n  public static final String REACT_CLASS = \"RCTImageView\";\n\n  @Override\n  public String getName() {\n    return REACT_CLASS;\n  }\n  @Override\n  public ReactImageView createViewInstance(ThemedReactContext context) {\n    return new ReactImageView(context, Fresco.newDraweeControllerBuilder(), mCallerContext);\n  }\n```\n\n导出给JavaScript使用的属性，需要申明带有`@ReactProp`（或`@ReactPropGroup`）注解的设置方法.\n\n方法的第一个参数是要修改属性的视图实例，第二个参数是要设置的属性值\n\n方法的返回值类型必须为`void`\n\n声明为`public`\n\n","source":"_posts/ReactNative/javascriptimageview.md","raw":"---\ntitle: ReactNative ImageView\ndate: 2018-10-02 09:09:09\ncategories: ReactNative\n---\n创建一个ViewManager的子类。\n\n实现createViewInstance方法。\n\n导出视图的属性设置器：使用@ReactProp（或@ReactPropGroup）注解。\n\n把这个视图管理类注册到应用程序包的createViewManagers里。\n\n实现JavaScript模块。\n\n```java\npublic class ReactImageManager extends SimpleViewManager<ReactImageView> {\n\n  public static final String REACT_CLASS = \"RCTImageView\";\n\n  @Override\n  public String getName() {\n    return REACT_CLASS;\n  }\n  @Override\n  public ReactImageView createViewInstance(ThemedReactContext context) {\n    return new ReactImageView(context, Fresco.newDraweeControllerBuilder(), mCallerContext);\n  }\n```\n\n导出给JavaScript使用的属性，需要申明带有`@ReactProp`（或`@ReactPropGroup`）注解的设置方法.\n\n方法的第一个参数是要修改属性的视图实例，第二个参数是要设置的属性值\n\n方法的返回值类型必须为`void`\n\n声明为`public`\n\n","slug":"ReactNative/javascriptimageview","published":1,"updated":"2018-10-02T02:16:06.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mv0023ntnb059tvmoj","content":"<p>创建一个ViewManager的子类。</p>\n<p>实现createViewInstance方法。</p>\n<p>导出视图的属性设置器：使用@ReactProp（或@ReactPropGroup）注解。</p>\n<p>把这个视图管理类注册到应用程序包的createViewManagers里。</p>\n<p>实现JavaScript模块。</p>\n<pre><code class=\"java\">public class ReactImageManager extends SimpleViewManager&lt;ReactImageView&gt; {\n\n  public static final String REACT_CLASS = &quot;RCTImageView&quot;;\n\n  @Override\n  public String getName() {\n    return REACT_CLASS;\n  }\n  @Override\n  public ReactImageView createViewInstance(ThemedReactContext context) {\n    return new ReactImageView(context, Fresco.newDraweeControllerBuilder(), mCallerContext);\n  }\n</code></pre>\n<p>导出给JavaScript使用的属性，需要申明带有<code>@ReactProp</code>（或<code>@ReactPropGroup</code>）注解的设置方法.</p>\n<p>方法的第一个参数是要修改属性的视图实例，第二个参数是要设置的属性值</p>\n<p>方法的返回值类型必须为<code>void</code></p>\n<p>声明为<code>public</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>创建一个ViewManager的子类。</p>\n<p>实现createViewInstance方法。</p>\n<p>导出视图的属性设置器：使用@ReactProp（或@ReactPropGroup）注解。</p>\n<p>把这个视图管理类注册到应用程序包的createViewManagers里。</p>\n<p>实现JavaScript模块。</p>\n<pre><code class=\"java\">public class ReactImageManager extends SimpleViewManager&lt;ReactImageView&gt; {\n\n  public static final String REACT_CLASS = &quot;RCTImageView&quot;;\n\n  @Override\n  public String getName() {\n    return REACT_CLASS;\n  }\n  @Override\n  public ReactImageView createViewInstance(ThemedReactContext context) {\n    return new ReactImageView(context, Fresco.newDraweeControllerBuilder(), mCallerContext);\n  }\n</code></pre>\n<p>导出给JavaScript使用的属性，需要申明带有<code>@ReactProp</code>（或<code>@ReactPropGroup</code>）注解的设置方法.</p>\n<p>方法的第一个参数是要修改属性的视图实例，第二个参数是要设置的属性值</p>\n<p>方法的返回值类型必须为<code>void</code></p>\n<p>声明为<code>public</code></p>\n"},{"title":"ReactNative UI","date":"2018-10-02T01:09:09.000Z","_content":"#### 关于尺寸单位\n\nReact Native中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点。（讲甘多就系dp pt）\n\n```js\n<View style={{width:100,height:100,margin:40,backgroundColor:'gray'}}>\n        <Text style={{fontSize:16,margin:20}}>尺寸</Text>\n</View>\n```\n\n上述代码，运行在Android上时，View的长和宽被解释成：100dp 100dp单位是dp，字体被解释成16sp 单位是sp，运行在iOS上时尺寸单位被解释称了pt，这些单位确保了在任何不同dpi的手机屏幕上显示不会发生改变；\n\n#### 指定宽高\n\ndp设置尺寸\n\n```js\n<View>\n    <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\n    <View style={{width: 100, height: 100, backgroundColor: 'skyblue'}} />\n    <View style={{width: 150, height: 150, backgroundColor: 'steelblue'}} />\n</View>\n```\n\n#### 弹性（Flex）宽高\n\n就是比例分配\n\n```js\n<Text style={[styles.text, styles.header]}>\n    根节点上放一个元素，不设置宽度\n</Text>\n\n<View style={{height: 20, backgroundColor: '#333333'}} />\n\n<Text style={[styles.text, styles.header]}>\n    固定宽度的元素上放一个View，不设置宽度\n</Text>\n\n<View style={{width: 100}}>\n    <View style={{height: 20, backgroundColor: '#333333'}} />\n</View>\n\n<Text style={[styles.text, styles.header]}>\n    flex的元素上放一个View，不设置宽度\n</Text>\n<View style={{flexDirection: 'row'}}>\n    <View style={{flex: 3}}>\n        <View style={{height: 20, backgroundColor: '#333333'}} />\n    </View>\n    <View style={{flex: 1}}/>\n</View>\n```\n\n#### 获取设备屏幕信息\n\n```js\n//获取pixel，通过设备密度获取，可以该size获取图片适合的尺寸\n//dp to px\nPixelRatio.getPixelSizeForLayoutSize(200)\n\n//获取屏幕dp\nimport Dimensions\n<Text style={styles.welcome}>\n 屏幕信息如下:\n</Text>\n<Text style={styles.instructions}>\n  当前屏幕宽度:+{Dimensions.get('window').width};\n</Text>\n<Text style={styles.instructions}>\n  当前屏幕高度:'+{Dimensions.get('window').height};\n</Text>\n```\n\n```js\n//返回设备pixel\n//Returns the device pixel density. Some examples:\nPixelRatio.get() === 1\n//mdpi Android devices (160 dpi)\nPixelRatio.get() === 1.5\n//hdpi Android devices (240 dpi)\nPixelRatio.get() === 2\n//iPhone 4, 4S\n//iPhone 5, 5c, 5s\n//iPhone 6\n//xhdpi Android devices (320 dpi)\nPixelRatio.get() === 3\n//iPhone 6 plus\n//xxhdpi Android devices (480 dpi)\nPixelRatio.get() === 3.5\n//Nexus 6\n```\n\n#### 返回字体大小\n\n```\n//如果没有设置字体大小\n//按照顺序\n//Android Settings > Display > Font size\n//iOS返回默认大小\ngetFontScale(0)\n```\n\n#### 布局\n\n使用flexDirection、alignItems和 justifyContent三个样式属性就已经能满足大多数布局需求\n\n在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴\\(row\\)方向排列，还是沿着竖直轴\\(column\\)方向\n\n```js\n//Flex Direction\n//线性布局1\n//Flex Direction\n//在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，\n//还是沿着竖直轴(column)方向排列呢？默认值是竖直轴(column)方向。\n//水平\n<View>\n    <View style={{flex: 1, flexDirection: 'row'}}>\n        <View style={{flex: 1, height: 50, backgroundColor: 'powderblue'}} />\n        <View style={{flex: 2, height: 50, backgroundColor: 'skyblue'}} />\n        <View style={{flex: 1, height: 50, backgroundColor: 'steelblue'}} />\n    </View>\n</View>\n//垂直\n<View style={{flex: 1, flexDirection: 'column'}}>\n    <View style={{width: 100, height: 50, backgroundColor: 'powderblue'}} />\n    <View style={{width: 100, height: 50, backgroundColor: 'skyblue'}} />\n    <View style={{width: 100, height: 50, backgroundColor: 'steelblue'}} />\n</View>\n\n//Justify Content\n//在组件的style中指定justifyContent可以决定其子元素沿着主轴的排列方式。\n//子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？\n//对应的这些可选项有：flex-start、center、flex-end、space-around以及space-between。\n//垂直上中下平分布局->justifyContent center（居中）\n<View style={{\n    flex: 1,\n    flexDirection: 'column',\n    justifyContent: 'space-between',\n}}>\n    <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\n    <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />\n    <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />\n</View>\n//水平左中右平方布局\n<View style={{\n    flex: 1,\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n}}>\n    <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\n    <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />\n    <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />\n</View>\n\n//Align Items\n//在组件的style中指定alignItems可以决定其子元素沿着次轴（\n//与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。\n//子元素是应该靠近次轴的起始端还是末尾段分布呢？亦或应该均匀分布？\n//对应的这些可选项有：flex-start、center、flex-end以及stretch。\n// 尝试把`alignItems`改为`flex-start`看看\n// 尝试把`justifyContent`改为`flex-end`看看\n// 尝试把`flexDirection`改为`row`看看\n<View style={{\nflex: 1,\nflexDirection: 'column',\njustifyContent: 'center',\nalignItems: 'center',\n}}>\n    <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\n    <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />\n    <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />\n</View>\n```\n\n\n\n","source":"_posts/ReactNative/react-native.md","raw":"---\ntitle: ReactNative UI\ndate: 2018-10-02 09:09:09\ncategories: ReactNative\n---\n#### 关于尺寸单位\n\nReact Native中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点。（讲甘多就系dp pt）\n\n```js\n<View style={{width:100,height:100,margin:40,backgroundColor:'gray'}}>\n        <Text style={{fontSize:16,margin:20}}>尺寸</Text>\n</View>\n```\n\n上述代码，运行在Android上时，View的长和宽被解释成：100dp 100dp单位是dp，字体被解释成16sp 单位是sp，运行在iOS上时尺寸单位被解释称了pt，这些单位确保了在任何不同dpi的手机屏幕上显示不会发生改变；\n\n#### 指定宽高\n\ndp设置尺寸\n\n```js\n<View>\n    <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\n    <View style={{width: 100, height: 100, backgroundColor: 'skyblue'}} />\n    <View style={{width: 150, height: 150, backgroundColor: 'steelblue'}} />\n</View>\n```\n\n#### 弹性（Flex）宽高\n\n就是比例分配\n\n```js\n<Text style={[styles.text, styles.header]}>\n    根节点上放一个元素，不设置宽度\n</Text>\n\n<View style={{height: 20, backgroundColor: '#333333'}} />\n\n<Text style={[styles.text, styles.header]}>\n    固定宽度的元素上放一个View，不设置宽度\n</Text>\n\n<View style={{width: 100}}>\n    <View style={{height: 20, backgroundColor: '#333333'}} />\n</View>\n\n<Text style={[styles.text, styles.header]}>\n    flex的元素上放一个View，不设置宽度\n</Text>\n<View style={{flexDirection: 'row'}}>\n    <View style={{flex: 3}}>\n        <View style={{height: 20, backgroundColor: '#333333'}} />\n    </View>\n    <View style={{flex: 1}}/>\n</View>\n```\n\n#### 获取设备屏幕信息\n\n```js\n//获取pixel，通过设备密度获取，可以该size获取图片适合的尺寸\n//dp to px\nPixelRatio.getPixelSizeForLayoutSize(200)\n\n//获取屏幕dp\nimport Dimensions\n<Text style={styles.welcome}>\n 屏幕信息如下:\n</Text>\n<Text style={styles.instructions}>\n  当前屏幕宽度:+{Dimensions.get('window').width};\n</Text>\n<Text style={styles.instructions}>\n  当前屏幕高度:'+{Dimensions.get('window').height};\n</Text>\n```\n\n```js\n//返回设备pixel\n//Returns the device pixel density. Some examples:\nPixelRatio.get() === 1\n//mdpi Android devices (160 dpi)\nPixelRatio.get() === 1.5\n//hdpi Android devices (240 dpi)\nPixelRatio.get() === 2\n//iPhone 4, 4S\n//iPhone 5, 5c, 5s\n//iPhone 6\n//xhdpi Android devices (320 dpi)\nPixelRatio.get() === 3\n//iPhone 6 plus\n//xxhdpi Android devices (480 dpi)\nPixelRatio.get() === 3.5\n//Nexus 6\n```\n\n#### 返回字体大小\n\n```\n//如果没有设置字体大小\n//按照顺序\n//Android Settings > Display > Font size\n//iOS返回默认大小\ngetFontScale(0)\n```\n\n#### 布局\n\n使用flexDirection、alignItems和 justifyContent三个样式属性就已经能满足大多数布局需求\n\n在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴\\(row\\)方向排列，还是沿着竖直轴\\(column\\)方向\n\n```js\n//Flex Direction\n//线性布局1\n//Flex Direction\n//在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，\n//还是沿着竖直轴(column)方向排列呢？默认值是竖直轴(column)方向。\n//水平\n<View>\n    <View style={{flex: 1, flexDirection: 'row'}}>\n        <View style={{flex: 1, height: 50, backgroundColor: 'powderblue'}} />\n        <View style={{flex: 2, height: 50, backgroundColor: 'skyblue'}} />\n        <View style={{flex: 1, height: 50, backgroundColor: 'steelblue'}} />\n    </View>\n</View>\n//垂直\n<View style={{flex: 1, flexDirection: 'column'}}>\n    <View style={{width: 100, height: 50, backgroundColor: 'powderblue'}} />\n    <View style={{width: 100, height: 50, backgroundColor: 'skyblue'}} />\n    <View style={{width: 100, height: 50, backgroundColor: 'steelblue'}} />\n</View>\n\n//Justify Content\n//在组件的style中指定justifyContent可以决定其子元素沿着主轴的排列方式。\n//子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？\n//对应的这些可选项有：flex-start、center、flex-end、space-around以及space-between。\n//垂直上中下平分布局->justifyContent center（居中）\n<View style={{\n    flex: 1,\n    flexDirection: 'column',\n    justifyContent: 'space-between',\n}}>\n    <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\n    <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />\n    <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />\n</View>\n//水平左中右平方布局\n<View style={{\n    flex: 1,\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n}}>\n    <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\n    <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />\n    <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />\n</View>\n\n//Align Items\n//在组件的style中指定alignItems可以决定其子元素沿着次轴（\n//与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。\n//子元素是应该靠近次轴的起始端还是末尾段分布呢？亦或应该均匀分布？\n//对应的这些可选项有：flex-start、center、flex-end以及stretch。\n// 尝试把`alignItems`改为`flex-start`看看\n// 尝试把`justifyContent`改为`flex-end`看看\n// 尝试把`flexDirection`改为`row`看看\n<View style={{\nflex: 1,\nflexDirection: 'column',\njustifyContent: 'center',\nalignItems: 'center',\n}}>\n    <View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} />\n    <View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} />\n    <View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} />\n</View>\n```\n\n\n\n","slug":"ReactNative/react-native","published":1,"updated":"2018-10-02T02:16:32.828Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mw0024ntnb06abteil","content":"<h4 id=\"关于尺寸单位\"><a href=\"#关于尺寸单位\" class=\"headerlink\" title=\"关于尺寸单位\"></a>关于尺寸单位</h4><p>React Native中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点。（讲甘多就系dp pt）</p>\n<pre><code class=\"js\">&lt;View style={{width:100,height:100,margin:40,backgroundColor:'gray'}}&gt;\n        &lt;Text style={{fontSize:16,margin:20}}&gt;尺寸&lt;/Text&gt;\n&lt;/View&gt;\n</code></pre>\n<p>上述代码，运行在Android上时，View的长和宽被解释成：100dp 100dp单位是dp，字体被解释成16sp 单位是sp，运行在iOS上时尺寸单位被解释称了pt，这些单位确保了在任何不同dpi的手机屏幕上显示不会发生改变；</p>\n<h4 id=\"指定宽高\"><a href=\"#指定宽高\" class=\"headerlink\" title=\"指定宽高\"></a>指定宽高</h4><p>dp设置尺寸</p>\n<pre><code class=\"js\">&lt;View&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;\n    &lt;View style={{width: 100, height: 100, backgroundColor: 'skyblue'}} /&gt;\n    &lt;View style={{width: 150, height: 150, backgroundColor: 'steelblue'}} /&gt;\n&lt;/View&gt;\n</code></pre>\n<h4 id=\"弹性（Flex）宽高\"><a href=\"#弹性（Flex）宽高\" class=\"headerlink\" title=\"弹性（Flex）宽高\"></a>弹性（Flex）宽高</h4><p>就是比例分配</p>\n<pre><code class=\"js\">&lt;Text style={[styles.text, styles.header]}&gt;\n    根节点上放一个元素，不设置宽度\n&lt;/Text&gt;\n\n&lt;View style={{height: 20, backgroundColor: '#333333'}} /&gt;\n\n&lt;Text style={[styles.text, styles.header]}&gt;\n    固定宽度的元素上放一个View，不设置宽度\n&lt;/Text&gt;\n\n&lt;View style={{width: 100}}&gt;\n    &lt;View style={{height: 20, backgroundColor: '#333333'}} /&gt;\n&lt;/View&gt;\n\n&lt;Text style={[styles.text, styles.header]}&gt;\n    flex的元素上放一个View，不设置宽度\n&lt;/Text&gt;\n&lt;View style={{flexDirection: 'row'}}&gt;\n    &lt;View style={{flex: 3}}&gt;\n        &lt;View style={{height: 20, backgroundColor: '#333333'}} /&gt;\n    &lt;/View&gt;\n    &lt;View style={{flex: 1}}/&gt;\n&lt;/View&gt;\n</code></pre>\n<h4 id=\"获取设备屏幕信息\"><a href=\"#获取设备屏幕信息\" class=\"headerlink\" title=\"获取设备屏幕信息\"></a>获取设备屏幕信息</h4><pre><code class=\"js\">//获取pixel，通过设备密度获取，可以该size获取图片适合的尺寸\n//dp to px\nPixelRatio.getPixelSizeForLayoutSize(200)\n\n//获取屏幕dp\nimport Dimensions\n&lt;Text style={styles.welcome}&gt;\n 屏幕信息如下:\n&lt;/Text&gt;\n&lt;Text style={styles.instructions}&gt;\n  当前屏幕宽度:+{Dimensions.get(&#39;window&#39;).width};\n&lt;/Text&gt;\n&lt;Text style={styles.instructions}&gt;\n  当前屏幕高度:&#39;+{Dimensions.get(&#39;window&#39;).height};\n&lt;/Text&gt;\n</code></pre>\n<pre><code class=\"js\">//返回设备pixel\n//Returns the device pixel density. Some examples:\nPixelRatio.get() === 1\n//mdpi Android devices (160 dpi)\nPixelRatio.get() === 1.5\n//hdpi Android devices (240 dpi)\nPixelRatio.get() === 2\n//iPhone 4, 4S\n//iPhone 5, 5c, 5s\n//iPhone 6\n//xhdpi Android devices (320 dpi)\nPixelRatio.get() === 3\n//iPhone 6 plus\n//xxhdpi Android devices (480 dpi)\nPixelRatio.get() === 3.5\n//Nexus 6\n</code></pre>\n<h4 id=\"返回字体大小\"><a href=\"#返回字体大小\" class=\"headerlink\" title=\"返回字体大小\"></a>返回字体大小</h4><pre><code>//如果没有设置字体大小\n//按照顺序\n//Android Settings &gt; Display &gt; Font size\n//iOS返回默认大小\ngetFontScale(0)\n</code></pre><h4 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h4><p>使用flexDirection、alignItems和 justifyContent三个样式属性就已经能满足大多数布局需求</p>\n<p>在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，还是沿着竖直轴(column)方向</p>\n<pre><code class=\"js\">//Flex Direction\n//线性布局1\n//Flex Direction\n//在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，\n//还是沿着竖直轴(column)方向排列呢？默认值是竖直轴(column)方向。\n//水平\n&lt;View&gt;\n    &lt;View style={{flex: 1, flexDirection: 'row'}}&gt;\n        &lt;View style={{flex: 1, height: 50, backgroundColor: 'powderblue'}} /&gt;\n        &lt;View style={{flex: 2, height: 50, backgroundColor: 'skyblue'}} /&gt;\n        &lt;View style={{flex: 1, height: 50, backgroundColor: 'steelblue'}} /&gt;\n    &lt;/View&gt;\n&lt;/View&gt;\n//垂直\n&lt;View style={{flex: 1, flexDirection: 'column'}}&gt;\n    &lt;View style={{width: 100, height: 50, backgroundColor: 'powderblue'}} /&gt;\n    &lt;View style={{width: 100, height: 50, backgroundColor: 'skyblue'}} /&gt;\n    &lt;View style={{width: 100, height: 50, backgroundColor: 'steelblue'}} /&gt;\n&lt;/View&gt;\n\n//Justify Content\n//在组件的style中指定justifyContent可以决定其子元素沿着主轴的排列方式。\n//子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？\n//对应的这些可选项有：flex-start、center、flex-end、space-around以及space-between。\n//垂直上中下平分布局-&gt;justifyContent center（居中）\n&lt;View style={{\n    flex: 1,\n    flexDirection: 'column',\n    justifyContent: 'space-between',\n}}&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} /&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} /&gt;\n&lt;/View&gt;\n//水平左中右平方布局\n&lt;View style={{\n    flex: 1,\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n}}&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} /&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} /&gt;\n&lt;/View&gt;\n\n//Align Items\n//在组件的style中指定alignItems可以决定其子元素沿着次轴（\n//与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。\n//子元素是应该靠近次轴的起始端还是末尾段分布呢？亦或应该均匀分布？\n//对应的这些可选项有：flex-start、center、flex-end以及stretch。\n// 尝试把`alignItems`改为`flex-start`看看\n// 尝试把`justifyContent`改为`flex-end`看看\n// 尝试把`flexDirection`改为`row`看看\n&lt;View style={{\nflex: 1,\nflexDirection: 'column',\njustifyContent: 'center',\nalignItems: 'center',\n}}&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} /&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} /&gt;\n&lt;/View&gt;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"关于尺寸单位\"><a href=\"#关于尺寸单位\" class=\"headerlink\" title=\"关于尺寸单位\"></a>关于尺寸单位</h4><p>React Native中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点。（讲甘多就系dp pt）</p>\n<pre><code class=\"js\">&lt;View style={{width:100,height:100,margin:40,backgroundColor:'gray'}}&gt;\n        &lt;Text style={{fontSize:16,margin:20}}&gt;尺寸&lt;/Text&gt;\n&lt;/View&gt;\n</code></pre>\n<p>上述代码，运行在Android上时，View的长和宽被解释成：100dp 100dp单位是dp，字体被解释成16sp 单位是sp，运行在iOS上时尺寸单位被解释称了pt，这些单位确保了在任何不同dpi的手机屏幕上显示不会发生改变；</p>\n<h4 id=\"指定宽高\"><a href=\"#指定宽高\" class=\"headerlink\" title=\"指定宽高\"></a>指定宽高</h4><p>dp设置尺寸</p>\n<pre><code class=\"js\">&lt;View&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;\n    &lt;View style={{width: 100, height: 100, backgroundColor: 'skyblue'}} /&gt;\n    &lt;View style={{width: 150, height: 150, backgroundColor: 'steelblue'}} /&gt;\n&lt;/View&gt;\n</code></pre>\n<h4 id=\"弹性（Flex）宽高\"><a href=\"#弹性（Flex）宽高\" class=\"headerlink\" title=\"弹性（Flex）宽高\"></a>弹性（Flex）宽高</h4><p>就是比例分配</p>\n<pre><code class=\"js\">&lt;Text style={[styles.text, styles.header]}&gt;\n    根节点上放一个元素，不设置宽度\n&lt;/Text&gt;\n\n&lt;View style={{height: 20, backgroundColor: '#333333'}} /&gt;\n\n&lt;Text style={[styles.text, styles.header]}&gt;\n    固定宽度的元素上放一个View，不设置宽度\n&lt;/Text&gt;\n\n&lt;View style={{width: 100}}&gt;\n    &lt;View style={{height: 20, backgroundColor: '#333333'}} /&gt;\n&lt;/View&gt;\n\n&lt;Text style={[styles.text, styles.header]}&gt;\n    flex的元素上放一个View，不设置宽度\n&lt;/Text&gt;\n&lt;View style={{flexDirection: 'row'}}&gt;\n    &lt;View style={{flex: 3}}&gt;\n        &lt;View style={{height: 20, backgroundColor: '#333333'}} /&gt;\n    &lt;/View&gt;\n    &lt;View style={{flex: 1}}/&gt;\n&lt;/View&gt;\n</code></pre>\n<h4 id=\"获取设备屏幕信息\"><a href=\"#获取设备屏幕信息\" class=\"headerlink\" title=\"获取设备屏幕信息\"></a>获取设备屏幕信息</h4><pre><code class=\"js\">//获取pixel，通过设备密度获取，可以该size获取图片适合的尺寸\n//dp to px\nPixelRatio.getPixelSizeForLayoutSize(200)\n\n//获取屏幕dp\nimport Dimensions\n&lt;Text style={styles.welcome}&gt;\n 屏幕信息如下:\n&lt;/Text&gt;\n&lt;Text style={styles.instructions}&gt;\n  当前屏幕宽度:+{Dimensions.get(&#39;window&#39;).width};\n&lt;/Text&gt;\n&lt;Text style={styles.instructions}&gt;\n  当前屏幕高度:&#39;+{Dimensions.get(&#39;window&#39;).height};\n&lt;/Text&gt;\n</code></pre>\n<pre><code class=\"js\">//返回设备pixel\n//Returns the device pixel density. Some examples:\nPixelRatio.get() === 1\n//mdpi Android devices (160 dpi)\nPixelRatio.get() === 1.5\n//hdpi Android devices (240 dpi)\nPixelRatio.get() === 2\n//iPhone 4, 4S\n//iPhone 5, 5c, 5s\n//iPhone 6\n//xhdpi Android devices (320 dpi)\nPixelRatio.get() === 3\n//iPhone 6 plus\n//xxhdpi Android devices (480 dpi)\nPixelRatio.get() === 3.5\n//Nexus 6\n</code></pre>\n<h4 id=\"返回字体大小\"><a href=\"#返回字体大小\" class=\"headerlink\" title=\"返回字体大小\"></a>返回字体大小</h4><pre><code>//如果没有设置字体大小\n//按照顺序\n//Android Settings &gt; Display &gt; Font size\n//iOS返回默认大小\ngetFontScale(0)\n</code></pre><h4 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h4><p>使用flexDirection、alignItems和 justifyContent三个样式属性就已经能满足大多数布局需求</p>\n<p>在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，还是沿着竖直轴(column)方向</p>\n<pre><code class=\"js\">//Flex Direction\n//线性布局1\n//Flex Direction\n//在组件的style中指定flexDirection可以决定布局的主轴。子元素是应该沿着水平轴(row)方向排列，\n//还是沿着竖直轴(column)方向排列呢？默认值是竖直轴(column)方向。\n//水平\n&lt;View&gt;\n    &lt;View style={{flex: 1, flexDirection: 'row'}}&gt;\n        &lt;View style={{flex: 1, height: 50, backgroundColor: 'powderblue'}} /&gt;\n        &lt;View style={{flex: 2, height: 50, backgroundColor: 'skyblue'}} /&gt;\n        &lt;View style={{flex: 1, height: 50, backgroundColor: 'steelblue'}} /&gt;\n    &lt;/View&gt;\n&lt;/View&gt;\n//垂直\n&lt;View style={{flex: 1, flexDirection: 'column'}}&gt;\n    &lt;View style={{width: 100, height: 50, backgroundColor: 'powderblue'}} /&gt;\n    &lt;View style={{width: 100, height: 50, backgroundColor: 'skyblue'}} /&gt;\n    &lt;View style={{width: 100, height: 50, backgroundColor: 'steelblue'}} /&gt;\n&lt;/View&gt;\n\n//Justify Content\n//在组件的style中指定justifyContent可以决定其子元素沿着主轴的排列方式。\n//子元素是应该靠近主轴的起始端还是末尾段分布呢？亦或应该均匀分布？\n//对应的这些可选项有：flex-start、center、flex-end、space-around以及space-between。\n//垂直上中下平分布局-&gt;justifyContent center（居中）\n&lt;View style={{\n    flex: 1,\n    flexDirection: 'column',\n    justifyContent: 'space-between',\n}}&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} /&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} /&gt;\n&lt;/View&gt;\n//水平左中右平方布局\n&lt;View style={{\n    flex: 1,\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n}}&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} /&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} /&gt;\n&lt;/View&gt;\n\n//Align Items\n//在组件的style中指定alignItems可以决定其子元素沿着次轴（\n//与主轴垂直的轴，比如若主轴方向为row，则次轴方向为column）的排列方式。\n//子元素是应该靠近次轴的起始端还是末尾段分布呢？亦或应该均匀分布？\n//对应的这些可选项有：flex-start、center、flex-end以及stretch。\n// 尝试把`alignItems`改为`flex-start`看看\n// 尝试把`justifyContent`改为`flex-end`看看\n// 尝试把`flexDirection`改为`row`看看\n&lt;View style={{\nflex: 1,\nflexDirection: 'column',\njustifyContent: 'center',\nalignItems: 'center',\n}}&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'powderblue'}} /&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'skyblue'}} /&gt;\n    &lt;View style={{width: 50, height: 50, backgroundColor: 'steelblue'}} /&gt;\n&lt;/View&gt;\n</code></pre>\n"},{"title":"ReactNative Static Image Source","date":"2018-10-02T01:09:09.000Z","_content":"#### 静态图片资源\n\n```\n<Image source={require('./my-icon.png')} />\n```\n\n> 为了使新的图片资源机制正常工作，require中的图片名字必须是一个静态字符串\n\n```js\n// 正确\n<Image source={require('./my-icon.png')} />\n\n// 错误\nvar icon = this.props.active ? 'my-icon-active' : 'my-icon-inactive';\n<Image source={require('./' + icon + '.png')} />\n\n// 正确\nvar icon = this.props.active ? require('./my-icon-active.png') : require('./my-icon-inactive.png');\n<Image source={icon} />\n```\n\n#### 混合App的图片资源\n\n编写一个混合App（一部分UI使用React Native，而另一部分使用平台原生代码），也可以使用已经打包到App中的图片资源（通过Xcode的asset类目或者Android的drawable文件夹打包）\n\n```js\n<Image source={{uri: 'app_icon'}} style={{width: 40, height: 40}} />\n```\n\n> 注意：这一做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。\n\n#### 网络图片\n\n需要手动指定图片的尺寸\n\n```js\n// 正确\n<Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}}\n       style={{width: 400, height: 400}} />\n\n// 错误\n<Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}} />\n```\n\n\n\n","source":"_posts/ReactNative/react-native图片处理.md","raw":"---\ntitle: ReactNative Static Image Source\ndate: 2018-10-02 09:09:09\ncategories: ReactNative\n---\n#### 静态图片资源\n\n```\n<Image source={require('./my-icon.png')} />\n```\n\n> 为了使新的图片资源机制正常工作，require中的图片名字必须是一个静态字符串\n\n```js\n// 正确\n<Image source={require('./my-icon.png')} />\n\n// 错误\nvar icon = this.props.active ? 'my-icon-active' : 'my-icon-inactive';\n<Image source={require('./' + icon + '.png')} />\n\n// 正确\nvar icon = this.props.active ? require('./my-icon-active.png') : require('./my-icon-inactive.png');\n<Image source={icon} />\n```\n\n#### 混合App的图片资源\n\n编写一个混合App（一部分UI使用React Native，而另一部分使用平台原生代码），也可以使用已经打包到App中的图片资源（通过Xcode的asset类目或者Android的drawable文件夹打包）\n\n```js\n<Image source={{uri: 'app_icon'}} style={{width: 40, height: 40}} />\n```\n\n> 注意：这一做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。\n\n#### 网络图片\n\n需要手动指定图片的尺寸\n\n```js\n// 正确\n<Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}}\n       style={{width: 400, height: 400}} />\n\n// 错误\n<Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}} />\n```\n\n\n\n","slug":"ReactNative/react-native图片处理","published":1,"updated":"2018-10-02T02:16:50.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mx0027ntnbxmz4854j","content":"<h4 id=\"静态图片资源\"><a href=\"#静态图片资源\" class=\"headerlink\" title=\"静态图片资源\"></a>静态图片资源</h4><pre><code>&lt;Image source={require(&#39;./my-icon.png&#39;)} /&gt;\n</code></pre><blockquote>\n<p>为了使新的图片资源机制正常工作，require中的图片名字必须是一个静态字符串</p>\n</blockquote>\n<pre><code class=\"js\">// 正确\n&lt;Image source={require(&#39;./my-icon.png&#39;)} /&gt;\n\n// 错误\nvar icon = this.props.active ? &#39;my-icon-active&#39; : &#39;my-icon-inactive&#39;;\n&lt;Image source={require(&#39;./&#39; + icon + &#39;.png&#39;)} /&gt;\n\n// 正确\nvar icon = this.props.active ? require(&#39;./my-icon-active.png&#39;) : require(&#39;./my-icon-inactive.png&#39;);\n&lt;Image source={icon} /&gt;\n</code></pre>\n<h4 id=\"混合App的图片资源\"><a href=\"#混合App的图片资源\" class=\"headerlink\" title=\"混合App的图片资源\"></a>混合App的图片资源</h4><p>编写一个混合App（一部分UI使用React Native，而另一部分使用平台原生代码），也可以使用已经打包到App中的图片资源（通过Xcode的asset类目或者Android的drawable文件夹打包）</p>\n<pre><code class=\"js\">&lt;Image source={{uri: 'app_icon'}} style={{width: 40, height: 40}} /&gt;\n</code></pre>\n<blockquote>\n<p>注意：这一做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。</p>\n</blockquote>\n<h4 id=\"网络图片\"><a href=\"#网络图片\" class=\"headerlink\" title=\"网络图片\"></a>网络图片</h4><p>需要手动指定图片的尺寸</p>\n<pre><code class=\"js\">// 正确\n&lt;Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}}\n       style={{width: 400, height: 400}} /&gt;\n\n// 错误\n&lt;Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}} /&gt;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"静态图片资源\"><a href=\"#静态图片资源\" class=\"headerlink\" title=\"静态图片资源\"></a>静态图片资源</h4><pre><code>&lt;Image source={require(&#39;./my-icon.png&#39;)} /&gt;\n</code></pre><blockquote>\n<p>为了使新的图片资源机制正常工作，require中的图片名字必须是一个静态字符串</p>\n</blockquote>\n<pre><code class=\"js\">// 正确\n&lt;Image source={require(&#39;./my-icon.png&#39;)} /&gt;\n\n// 错误\nvar icon = this.props.active ? &#39;my-icon-active&#39; : &#39;my-icon-inactive&#39;;\n&lt;Image source={require(&#39;./&#39; + icon + &#39;.png&#39;)} /&gt;\n\n// 正确\nvar icon = this.props.active ? require(&#39;./my-icon-active.png&#39;) : require(&#39;./my-icon-inactive.png&#39;);\n&lt;Image source={icon} /&gt;\n</code></pre>\n<h4 id=\"混合App的图片资源\"><a href=\"#混合App的图片资源\" class=\"headerlink\" title=\"混合App的图片资源\"></a>混合App的图片资源</h4><p>编写一个混合App（一部分UI使用React Native，而另一部分使用平台原生代码），也可以使用已经打包到App中的图片资源（通过Xcode的asset类目或者Android的drawable文件夹打包）</p>\n<pre><code class=\"js\">&lt;Image source={{uri: 'app_icon'}} style={{width: 40, height: 40}} /&gt;\n</code></pre>\n<blockquote>\n<p>注意：这一做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。</p>\n</blockquote>\n<h4 id=\"网络图片\"><a href=\"#网络图片\" class=\"headerlink\" title=\"网络图片\"></a>网络图片</h4><p>需要手动指定图片的尺寸</p>\n<pre><code class=\"js\">// 正确\n&lt;Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}}\n       style={{width: 400, height: 400}} /&gt;\n\n// 错误\n&lt;Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}} /&gt;\n</code></pre>\n"},{"title":"ReactNative Silder Gesture","date":"2018-10-02T01:09:09.000Z","_content":"Navigator关闭侧滑手势\n\n```\nconfigureScene={(rount)=>{\n    var conf=Navigator.SceneConfigs.HorizontalSwipeJump;\n    conf.gestures=null;\n    return conf;\n}}\n```\n\n\n\n","source":"_posts/ReactNative/reactnative-navigator.md","raw":"---\ntitle: ReactNative Silder Gesture\ndate: 2018-10-02 09:09:09\ncategories: ReactNative\n---\nNavigator关闭侧滑手势\n\n```\nconfigureScene={(rount)=>{\n    var conf=Navigator.SceneConfigs.HorizontalSwipeJump;\n    conf.gestures=null;\n    return conf;\n}}\n```\n\n\n\n","slug":"ReactNative/reactnative-navigator","published":1,"updated":"2018-10-02T02:17:09.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4my0028ntnboylfkl13","content":"<p>Navigator关闭侧滑手势</p>\n<pre><code>configureScene={(rount)=&gt;{\n    var conf=Navigator.SceneConfigs.HorizontalSwipeJump;\n    conf.gestures=null;\n    return conf;\n}}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>Navigator关闭侧滑手势</p>\n<pre><code>configureScene={(rount)=&gt;{\n    var conf=Navigator.SceneConfigs.HorizontalSwipeJump;\n    conf.gestures=null;\n    return conf;\n}}\n</code></pre>"},{"title":"ReactNative Cancel Fourse","date":"2018-10-02T01:09:09.000Z","_content":"http://react-china.org/t/touchablehighlight/3320\n\n页面内有一个输入框和一个TouchableHighlight的按钮，当在输入框输入，直接点击该按钮时，第一次点击按钮总是执行取消TextInput的焦点回收键盘，第二次点击时按钮才会响应\n\n```\nkeyboardShouldPersistTaps={true}\nkeyboardShouldPersistTaps enum('always', 'never', 'handled', false, true) #\n```\n\n\n\n","source":"_posts/ReactNative/reacttemp.md","raw":"---\ntitle: ReactNative Cancel Fourse\ndate: 2018-10-02 09:09:09\ncategories: ReactNative\n---\nhttp://react-china.org/t/touchablehighlight/3320\n\n页面内有一个输入框和一个TouchableHighlight的按钮，当在输入框输入，直接点击该按钮时，第一次点击按钮总是执行取消TextInput的焦点回收键盘，第二次点击时按钮才会响应\n\n```\nkeyboardShouldPersistTaps={true}\nkeyboardShouldPersistTaps enum('always', 'never', 'handled', false, true) #\n```\n\n\n\n","slug":"ReactNative/reacttemp","published":1,"updated":"2018-10-02T02:18:24.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4mz002bntnb83iua28o","content":"<p><a href=\"http://react-china.org/t/touchablehighlight/3320\" target=\"_blank\" rel=\"noopener\">http://react-china.org/t/touchablehighlight/3320</a></p>\n<p>页面内有一个输入框和一个TouchableHighlight的按钮，当在输入框输入，直接点击该按钮时，第一次点击按钮总是执行取消TextInput的焦点回收键盘，第二次点击时按钮才会响应</p>\n<pre><code>keyboardShouldPersistTaps={true}\nkeyboardShouldPersistTaps enum(&#39;always&#39;, &#39;never&#39;, &#39;handled&#39;, false, true) #\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://react-china.org/t/touchablehighlight/3320\" target=\"_blank\" rel=\"noopener\">http://react-china.org/t/touchablehighlight/3320</a></p>\n<p>页面内有一个输入框和一个TouchableHighlight的按钮，当在输入框输入，直接点击该按钮时，第一次点击按钮总是执行取消TextInput的焦点回收键盘，第二次点击时按钮才会响应</p>\n<pre><code>keyboardShouldPersistTaps={true}\nkeyboardShouldPersistTaps enum(&#39;always&#39;, &#39;never&#39;, &#39;handled&#39;, false, true) #\n</code></pre>"},{"title":"ReactNative Task","date":"2018-10-02T01:09:09.000Z","_content":"#### 定时器\n\n```js\nsetTimeout, clearTimeout\nsetInterval, clearInterval\nsetImmediate, clearImmediate\nrequestAnimationFrame, cancelAnimationFrame\n```\n\n#### InteractionManager\n\n```js\nInteractionManager.runAfterInteractions(() => {\n   // ...需要长时间同步执行的任务...\n});\n\nrequestAnimationFrame(): 用来执行在一段时间内控制视图动画的代码\nsetImmediate/setTimeout/setInterval(): 在稍后执行代码。注意这有可能会延迟当前正在进行的动画。\nrunAfterInteractions(): 在稍后执行代码，不会延迟当前进行的动画。\n\n//InteractionManager还允许应用注册动画，在动画开始时创建一个交互“句柄”，然后在结束的时候清除它\nvar handle = InteractionManager.createInteractionHandle();\n// 执行动画... (`runAfterInteractions`中的任务现在开始排队等候)\n// 在动画完成之后\nInteractionManager.clearInteractionHandle(handle);\n// 在所有句柄都清除之后，现在开始依序执行队列中的任务\n```\n\n#### TimerMixin\n\n当你的组件卸载时，所有的计时器事件也会被正确的清除。\n\n需要在项目文件夹下输入`npm i react-timer-mixin --save`来单独安装它。\n\n强烈建议您使用react-timer-mixin提供的`this.setTimeout(...)`来代替`setTimeout(...)`。这可以规避许多难以排查的BUG\n\n```js\nvar TimerMixin = require('react-timer-mixin');\n\nvar Component = React.createClass({\n  mixins: [TimerMixin],\n  componentDidMount: function() {\n    this.setTimeout(\n      () => { console.log('这样我就不会导致内存泄露!'); },\n      500\n    );\n  }\n});\n```\n\nMixin属于ES5语法，对于ES6代码来说，**无法直接使用Mixin**。\n\n```js\nimport React,{\n  Component\n} from 'react';\n\nexport default class Hello extends Component {\n  componentDidMount() {\n    this.timer = setTimeout(\n      () => { console.log('把一个定时器的引用挂在this上'); },\n      500\n    );\n  }\n  componentWillUnmount() {\n    // 如果存在this.timer，则使用clearTimeout清空。\n    // 如果你使用多个timer，那么用多个变量，或者用个数组来保存引用，然后逐个clear\n    this.timer && clearTimeout(this.timer);\n  }\n};\n```\n\n\n\n","source":"_posts/ReactNative/处理耗时业务事件.md","raw":"---\ntitle: ReactNative Task\ndate: 2018-10-02 09:09:09\ncategories: ReactNative\n---\n#### 定时器\n\n```js\nsetTimeout, clearTimeout\nsetInterval, clearInterval\nsetImmediate, clearImmediate\nrequestAnimationFrame, cancelAnimationFrame\n```\n\n#### InteractionManager\n\n```js\nInteractionManager.runAfterInteractions(() => {\n   // ...需要长时间同步执行的任务...\n});\n\nrequestAnimationFrame(): 用来执行在一段时间内控制视图动画的代码\nsetImmediate/setTimeout/setInterval(): 在稍后执行代码。注意这有可能会延迟当前正在进行的动画。\nrunAfterInteractions(): 在稍后执行代码，不会延迟当前进行的动画。\n\n//InteractionManager还允许应用注册动画，在动画开始时创建一个交互“句柄”，然后在结束的时候清除它\nvar handle = InteractionManager.createInteractionHandle();\n// 执行动画... (`runAfterInteractions`中的任务现在开始排队等候)\n// 在动画完成之后\nInteractionManager.clearInteractionHandle(handle);\n// 在所有句柄都清除之后，现在开始依序执行队列中的任务\n```\n\n#### TimerMixin\n\n当你的组件卸载时，所有的计时器事件也会被正确的清除。\n\n需要在项目文件夹下输入`npm i react-timer-mixin --save`来单独安装它。\n\n强烈建议您使用react-timer-mixin提供的`this.setTimeout(...)`来代替`setTimeout(...)`。这可以规避许多难以排查的BUG\n\n```js\nvar TimerMixin = require('react-timer-mixin');\n\nvar Component = React.createClass({\n  mixins: [TimerMixin],\n  componentDidMount: function() {\n    this.setTimeout(\n      () => { console.log('这样我就不会导致内存泄露!'); },\n      500\n    );\n  }\n});\n```\n\nMixin属于ES5语法，对于ES6代码来说，**无法直接使用Mixin**。\n\n```js\nimport React,{\n  Component\n} from 'react';\n\nexport default class Hello extends Component {\n  componentDidMount() {\n    this.timer = setTimeout(\n      () => { console.log('把一个定时器的引用挂在this上'); },\n      500\n    );\n  }\n  componentWillUnmount() {\n    // 如果存在this.timer，则使用clearTimeout清空。\n    // 如果你使用多个timer，那么用多个变量，或者用个数组来保存引用，然后逐个clear\n    this.timer && clearTimeout(this.timer);\n  }\n};\n```\n\n\n\n","slug":"ReactNative/处理耗时业务事件","published":1,"updated":"2018-10-02T03:34:26.653Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4n0002cntnby8e5tmsz","content":"<h4 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h4><pre><code class=\"js\">setTimeout, clearTimeout\nsetInterval, clearInterval\nsetImmediate, clearImmediate\nrequestAnimationFrame, cancelAnimationFrame\n</code></pre>\n<h4 id=\"InteractionManager\"><a href=\"#InteractionManager\" class=\"headerlink\" title=\"InteractionManager\"></a>InteractionManager</h4><pre><code class=\"js\">InteractionManager.runAfterInteractions(() =&gt; {\n   // ...需要长时间同步执行的任务...\n});\n\nrequestAnimationFrame(): 用来执行在一段时间内控制视图动画的代码\nsetImmediate/setTimeout/setInterval(): 在稍后执行代码。注意这有可能会延迟当前正在进行的动画。\nrunAfterInteractions(): 在稍后执行代码，不会延迟当前进行的动画。\n\n//InteractionManager还允许应用注册动画，在动画开始时创建一个交互“句柄”，然后在结束的时候清除它\nvar handle = InteractionManager.createInteractionHandle();\n// 执行动画... (`runAfterInteractions`中的任务现在开始排队等候)\n// 在动画完成之后\nInteractionManager.clearInteractionHandle(handle);\n// 在所有句柄都清除之后，现在开始依序执行队列中的任务\n</code></pre>\n<h4 id=\"TimerMixin\"><a href=\"#TimerMixin\" class=\"headerlink\" title=\"TimerMixin\"></a>TimerMixin</h4><p>当你的组件卸载时，所有的计时器事件也会被正确的清除。</p>\n<p>需要在项目文件夹下输入<code>npm i react-timer-mixin --save</code>来单独安装它。</p>\n<p>强烈建议您使用react-timer-mixin提供的<code>this.setTimeout(...)</code>来代替<code>setTimeout(...)</code>。这可以规避许多难以排查的BUG</p>\n<pre><code class=\"js\">var TimerMixin = require(&#39;react-timer-mixin&#39;);\n\nvar Component = React.createClass({\n  mixins: [TimerMixin],\n  componentDidMount: function() {\n    this.setTimeout(\n      () =&gt; { console.log(&#39;这样我就不会导致内存泄露!&#39;); },\n      500\n    );\n  }\n});\n</code></pre>\n<p>Mixin属于ES5语法，对于ES6代码来说，<strong>无法直接使用Mixin</strong>。</p>\n<pre><code class=\"js\">import React,{\n  Component\n} from &#39;react&#39;;\n\nexport default class Hello extends Component {\n  componentDidMount() {\n    this.timer = setTimeout(\n      () =&gt; { console.log(&#39;把一个定时器的引用挂在this上&#39;); },\n      500\n    );\n  }\n  componentWillUnmount() {\n    // 如果存在this.timer，则使用clearTimeout清空。\n    // 如果你使用多个timer，那么用多个变量，或者用个数组来保存引用，然后逐个clear\n    this.timer &amp;&amp; clearTimeout(this.timer);\n  }\n};\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h4><pre><code class=\"js\">setTimeout, clearTimeout\nsetInterval, clearInterval\nsetImmediate, clearImmediate\nrequestAnimationFrame, cancelAnimationFrame\n</code></pre>\n<h4 id=\"InteractionManager\"><a href=\"#InteractionManager\" class=\"headerlink\" title=\"InteractionManager\"></a>InteractionManager</h4><pre><code class=\"js\">InteractionManager.runAfterInteractions(() =&gt; {\n   // ...需要长时间同步执行的任务...\n});\n\nrequestAnimationFrame(): 用来执行在一段时间内控制视图动画的代码\nsetImmediate/setTimeout/setInterval(): 在稍后执行代码。注意这有可能会延迟当前正在进行的动画。\nrunAfterInteractions(): 在稍后执行代码，不会延迟当前进行的动画。\n\n//InteractionManager还允许应用注册动画，在动画开始时创建一个交互“句柄”，然后在结束的时候清除它\nvar handle = InteractionManager.createInteractionHandle();\n// 执行动画... (`runAfterInteractions`中的任务现在开始排队等候)\n// 在动画完成之后\nInteractionManager.clearInteractionHandle(handle);\n// 在所有句柄都清除之后，现在开始依序执行队列中的任务\n</code></pre>\n<h4 id=\"TimerMixin\"><a href=\"#TimerMixin\" class=\"headerlink\" title=\"TimerMixin\"></a>TimerMixin</h4><p>当你的组件卸载时，所有的计时器事件也会被正确的清除。</p>\n<p>需要在项目文件夹下输入<code>npm i react-timer-mixin --save</code>来单独安装它。</p>\n<p>强烈建议您使用react-timer-mixin提供的<code>this.setTimeout(...)</code>来代替<code>setTimeout(...)</code>。这可以规避许多难以排查的BUG</p>\n<pre><code class=\"js\">var TimerMixin = require(&#39;react-timer-mixin&#39;);\n\nvar Component = React.createClass({\n  mixins: [TimerMixin],\n  componentDidMount: function() {\n    this.setTimeout(\n      () =&gt; { console.log(&#39;这样我就不会导致内存泄露!&#39;); },\n      500\n    );\n  }\n});\n</code></pre>\n<p>Mixin属于ES5语法，对于ES6代码来说，<strong>无法直接使用Mixin</strong>。</p>\n<pre><code class=\"js\">import React,{\n  Component\n} from &#39;react&#39;;\n\nexport default class Hello extends Component {\n  componentDidMount() {\n    this.timer = setTimeout(\n      () =&gt; { console.log(&#39;把一个定时器的引用挂在this上&#39;); },\n      500\n    );\n  }\n  componentWillUnmount() {\n    // 如果存在this.timer，则使用clearTimeout清空。\n    // 如果你使用多个timer，那么用多个变量，或者用个数组来保存引用，然后逐个clear\n    this.timer &amp;&amp; clearTimeout(this.timer);\n  }\n};\n</code></pre>\n"},{"title":"Flutter是什么","date":"2018-10-02T01:09:09.000Z","_content":"# Flutter是什么\n\nFlutter是Fuchsia的开发框架，是一套移动UI框架，可以快速在iOS、Android以及Fuchsia上构建高质量的原生用户界面。是一套建立在 Skia 图形库上，提供实际呈现的部件，而不仅仅是原生控件的包装的框架。\n\nFlutter不使用浏览器技术，也不使用Native的原生控件，它使用自己的渲染引擎来绘制widget。对于Android平台，Flutter引擎的C/C++代码是由NDK编译，在iOS平台，则是由LLVM编译，两个平台的Dart代码都是AOT编译为本地代码，Flutter应用程序使用本机指令集运行。\n\n## Flutter设计\n\n![](/assets/Screen Shot 2018-09-30 at 3.05.02 PM.png)\n\nFlutter Framework: 这是一个纯 Dart实现的 SDK，类似于 React在 JavaScript中的作用。它实现了一套基础库， 用于处理动画、绘图和手势。并且基于绘图封装了一套 UI组件库，然后根据 Material 和Cupertino两种视觉风格区分开来。这个纯 Dart实现的 SDK被封装为了一个叫作 dart:ui的 Dart库。我们在使用 Flutter写 App的时候，直接导入这个库即可使用组件等功能。\n\nFlutter Engine: 这是一个纯 C++实现的 SDK，其中囊括了 Skia引擎、Dart运行时、文字排版引擎等。不过说白了，它就是 Dart的一个运行时，它可以以 JIT、JIT Snapshot 或者 AOT的模式运行 Dart代码。在代码调用 dart:ui库时，提供 dart:ui库中 Native Binding 实现。\n\n# Flutter为什么使用\n\nFlutter跟大部分构建移动应用的技术或者框架不同的是，Flutter没有使用WebView或者平台自带的控件，相反Flutter使用自身的高性能渲染引擎绘制自己的控件。\n\n另外，Flutter仅仅只有小部分C++代码，Flutter使用Dart实现了它自身大部分功能（控件，动画，手势，compositing等等）。这样开发者能够容易阅读，修改Flutter的实现，所以这里提供开发者相当大的空间去控制整个框架而且显著降低入门门槛。\n\n## 特性：\n\n1. 快速开发：Flutter的热重载可以快速地进行测试、构建UI、添加功能并更快地修复错误。\n2. 富有表现力，漂亮的用户界面：自带的Material Design和Cupertino（iOS风格）widget、丰富的motion API、平滑而自然的滑动效果。\n3. 响应式框架：使用Flutter的现代、响应式框架，和一系列基础widget，轻松构建您的用户界面。\n4. 访问本地功能和SDK：Flutter可以复用现有的Java、Swift或ObjC代码，访问iOS和Android上的原生系统功能和系统SDK。\n5. 统一的应用开发体验：Flutter拥有丰富的工具和库，可以帮助开发者轻松地同时在iOS和Android系统中实现想法和创意。\n6. 原生性能：Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。\n\n# Flutter能做什么\n\nFlutter能够开发Android和iOS上2D（不支持3D）界面的移动应用。\n\n你可以使用Flutter开发具有全特性的应用（包含支持照相，定位，网络连接，存储，第三方SDK等等）。\n\n# Flutter适合什么人使用\n\nFlutter框架对于熟悉面向对象编程和命令编程的开发者门槛是相当低的，并不需要有移动应用的开发经验，我们已经见过编程经验不多的人都能学习并使用Flutter开发应用。\n\n# Flutter缺点\n\n暂时对 iOS 效果有点不佳\n\n# Flutter对比\n\n![](/assets/Screen Shot 2018-09-19 at 6.10.18 PM.png)\n\n# ![](/assets/Screen Shot 2018-09-30 at 12.04.50 PM.png)\n\n# \n\n# Flutter相关产品\n\n谷歌在使用Flutter构建一些business-critical（业务相关的）移动应用，例如，谷歌的移动销售工具应用就是使用Flutter开发的，还有Google Shopping Express的Store Manage应用，还有一些应用处于开发中。\n\n\n\n# 参考\n\n[http://flutter-dev.cn/topic/16/flutter常见问题答疑](http://flutter-dev.cn/topic/16/flutter常见问题答疑)\n\n","source":"_posts/flutter/flutter-jian-jie.md","raw":"---\ntitle: Flutter是什么\ndate: 2018-10-02 09:09:09\ncategories: flutter\n---\n# Flutter是什么\n\nFlutter是Fuchsia的开发框架，是一套移动UI框架，可以快速在iOS、Android以及Fuchsia上构建高质量的原生用户界面。是一套建立在 Skia 图形库上，提供实际呈现的部件，而不仅仅是原生控件的包装的框架。\n\nFlutter不使用浏览器技术，也不使用Native的原生控件，它使用自己的渲染引擎来绘制widget。对于Android平台，Flutter引擎的C/C++代码是由NDK编译，在iOS平台，则是由LLVM编译，两个平台的Dart代码都是AOT编译为本地代码，Flutter应用程序使用本机指令集运行。\n\n## Flutter设计\n\n![](/assets/Screen Shot 2018-09-30 at 3.05.02 PM.png)\n\nFlutter Framework: 这是一个纯 Dart实现的 SDK，类似于 React在 JavaScript中的作用。它实现了一套基础库， 用于处理动画、绘图和手势。并且基于绘图封装了一套 UI组件库，然后根据 Material 和Cupertino两种视觉风格区分开来。这个纯 Dart实现的 SDK被封装为了一个叫作 dart:ui的 Dart库。我们在使用 Flutter写 App的时候，直接导入这个库即可使用组件等功能。\n\nFlutter Engine: 这是一个纯 C++实现的 SDK，其中囊括了 Skia引擎、Dart运行时、文字排版引擎等。不过说白了，它就是 Dart的一个运行时，它可以以 JIT、JIT Snapshot 或者 AOT的模式运行 Dart代码。在代码调用 dart:ui库时，提供 dart:ui库中 Native Binding 实现。\n\n# Flutter为什么使用\n\nFlutter跟大部分构建移动应用的技术或者框架不同的是，Flutter没有使用WebView或者平台自带的控件，相反Flutter使用自身的高性能渲染引擎绘制自己的控件。\n\n另外，Flutter仅仅只有小部分C++代码，Flutter使用Dart实现了它自身大部分功能（控件，动画，手势，compositing等等）。这样开发者能够容易阅读，修改Flutter的实现，所以这里提供开发者相当大的空间去控制整个框架而且显著降低入门门槛。\n\n## 特性：\n\n1. 快速开发：Flutter的热重载可以快速地进行测试、构建UI、添加功能并更快地修复错误。\n2. 富有表现力，漂亮的用户界面：自带的Material Design和Cupertino（iOS风格）widget、丰富的motion API、平滑而自然的滑动效果。\n3. 响应式框架：使用Flutter的现代、响应式框架，和一系列基础widget，轻松构建您的用户界面。\n4. 访问本地功能和SDK：Flutter可以复用现有的Java、Swift或ObjC代码，访问iOS和Android上的原生系统功能和系统SDK。\n5. 统一的应用开发体验：Flutter拥有丰富的工具和库，可以帮助开发者轻松地同时在iOS和Android系统中实现想法和创意。\n6. 原生性能：Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。\n\n# Flutter能做什么\n\nFlutter能够开发Android和iOS上2D（不支持3D）界面的移动应用。\n\n你可以使用Flutter开发具有全特性的应用（包含支持照相，定位，网络连接，存储，第三方SDK等等）。\n\n# Flutter适合什么人使用\n\nFlutter框架对于熟悉面向对象编程和命令编程的开发者门槛是相当低的，并不需要有移动应用的开发经验，我们已经见过编程经验不多的人都能学习并使用Flutter开发应用。\n\n# Flutter缺点\n\n暂时对 iOS 效果有点不佳\n\n# Flutter对比\n\n![](/assets/Screen Shot 2018-09-19 at 6.10.18 PM.png)\n\n# ![](/assets/Screen Shot 2018-09-30 at 12.04.50 PM.png)\n\n# \n\n# Flutter相关产品\n\n谷歌在使用Flutter构建一些business-critical（业务相关的）移动应用，例如，谷歌的移动销售工具应用就是使用Flutter开发的，还有Google Shopping Express的Store Manage应用，还有一些应用处于开发中。\n\n\n\n# 参考\n\n[http://flutter-dev.cn/topic/16/flutter常见问题答疑](http://flutter-dev.cn/topic/16/flutter常见问题答疑)\n\n","slug":"flutter/flutter-jian-jie","published":1,"updated":"2018-10-02T02:08:23.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4n1002fntnbu5pdm2lr","content":"<h1 id=\"Flutter是什么\"><a href=\"#Flutter是什么\" class=\"headerlink\" title=\"Flutter是什么\"></a>Flutter是什么</h1><p>Flutter是Fuchsia的开发框架，是一套移动UI框架，可以快速在iOS、Android以及Fuchsia上构建高质量的原生用户界面。是一套建立在 Skia 图形库上，提供实际呈现的部件，而不仅仅是原生控件的包装的框架。</p>\n<p>Flutter不使用浏览器技术，也不使用Native的原生控件，它使用自己的渲染引擎来绘制widget。对于Android平台，Flutter引擎的C/C++代码是由NDK编译，在iOS平台，则是由LLVM编译，两个平台的Dart代码都是AOT编译为本地代码，Flutter应用程序使用本机指令集运行。</p>\n<h2 id=\"Flutter设计\"><a href=\"#Flutter设计\" class=\"headerlink\" title=\"Flutter设计\"></a>Flutter设计</h2><p><img src=\"/assets/Screen Shot 2018-09-30 at 3.05.02 PM.png\" alt=\"\"></p>\n<p>Flutter Framework: 这是一个纯 Dart实现的 SDK，类似于 React在 JavaScript中的作用。它实现了一套基础库， 用于处理动画、绘图和手势。并且基于绘图封装了一套 UI组件库，然后根据 Material 和Cupertino两种视觉风格区分开来。这个纯 Dart实现的 SDK被封装为了一个叫作 dart:ui的 Dart库。我们在使用 Flutter写 App的时候，直接导入这个库即可使用组件等功能。</p>\n<p>Flutter Engine: 这是一个纯 C++实现的 SDK，其中囊括了 Skia引擎、Dart运行时、文字排版引擎等。不过说白了，它就是 Dart的一个运行时，它可以以 JIT、JIT Snapshot 或者 AOT的模式运行 Dart代码。在代码调用 dart:ui库时，提供 dart:ui库中 Native Binding 实现。</p>\n<h1 id=\"Flutter为什么使用\"><a href=\"#Flutter为什么使用\" class=\"headerlink\" title=\"Flutter为什么使用\"></a>Flutter为什么使用</h1><p>Flutter跟大部分构建移动应用的技术或者框架不同的是，Flutter没有使用WebView或者平台自带的控件，相反Flutter使用自身的高性能渲染引擎绘制自己的控件。</p>\n<p>另外，Flutter仅仅只有小部分C++代码，Flutter使用Dart实现了它自身大部分功能（控件，动画，手势，compositing等等）。这样开发者能够容易阅读，修改Flutter的实现，所以这里提供开发者相当大的空间去控制整个框架而且显著降低入门门槛。</p>\n<h2 id=\"特性：\"><a href=\"#特性：\" class=\"headerlink\" title=\"特性：\"></a>特性：</h2><ol>\n<li>快速开发：Flutter的热重载可以快速地进行测试、构建UI、添加功能并更快地修复错误。</li>\n<li>富有表现力，漂亮的用户界面：自带的Material Design和Cupertino（iOS风格）widget、丰富的motion API、平滑而自然的滑动效果。</li>\n<li>响应式框架：使用Flutter的现代、响应式框架，和一系列基础widget，轻松构建您的用户界面。</li>\n<li>访问本地功能和SDK：Flutter可以复用现有的Java、Swift或ObjC代码，访问iOS和Android上的原生系统功能和系统SDK。</li>\n<li>统一的应用开发体验：Flutter拥有丰富的工具和库，可以帮助开发者轻松地同时在iOS和Android系统中实现想法和创意。</li>\n<li>原生性能：Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。</li>\n</ol>\n<h1 id=\"Flutter能做什么\"><a href=\"#Flutter能做什么\" class=\"headerlink\" title=\"Flutter能做什么\"></a>Flutter能做什么</h1><p>Flutter能够开发Android和iOS上2D（不支持3D）界面的移动应用。</p>\n<p>你可以使用Flutter开发具有全特性的应用（包含支持照相，定位，网络连接，存储，第三方SDK等等）。</p>\n<h1 id=\"Flutter适合什么人使用\"><a href=\"#Flutter适合什么人使用\" class=\"headerlink\" title=\"Flutter适合什么人使用\"></a>Flutter适合什么人使用</h1><p>Flutter框架对于熟悉面向对象编程和命令编程的开发者门槛是相当低的，并不需要有移动应用的开发经验，我们已经见过编程经验不多的人都能学习并使用Flutter开发应用。</p>\n<h1 id=\"Flutter缺点\"><a href=\"#Flutter缺点\" class=\"headerlink\" title=\"Flutter缺点\"></a>Flutter缺点</h1><p>暂时对 iOS 效果有点不佳</p>\n<h1 id=\"Flutter对比\"><a href=\"#Flutter对比\" class=\"headerlink\" title=\"Flutter对比\"></a>Flutter对比</h1><p><img src=\"/assets/Screen Shot 2018-09-19 at 6.10.18 PM.png\" alt=\"\"></p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"/assets/Screen Shot 2018-09-30 at 12.04.50 PM.png\" alt=\"\"></h1><p># </p>\n<h1 id=\"Flutter相关产品\"><a href=\"#Flutter相关产品\" class=\"headerlink\" title=\"Flutter相关产品\"></a>Flutter相关产品</h1><p>谷歌在使用Flutter构建一些business-critical（业务相关的）移动应用，例如，谷歌的移动销售工具应用就是使用Flutter开发的，还有Google Shopping Express的Store Manage应用，还有一些应用处于开发中。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://flutter-dev.cn/topic/16/flutter常见问题答疑\" target=\"_blank\" rel=\"noopener\">http://flutter-dev.cn/topic/16/flutter常见问题答疑</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Flutter是什么\"><a href=\"#Flutter是什么\" class=\"headerlink\" title=\"Flutter是什么\"></a>Flutter是什么</h1><p>Flutter是Fuchsia的开发框架，是一套移动UI框架，可以快速在iOS、Android以及Fuchsia上构建高质量的原生用户界面。是一套建立在 Skia 图形库上，提供实际呈现的部件，而不仅仅是原生控件的包装的框架。</p>\n<p>Flutter不使用浏览器技术，也不使用Native的原生控件，它使用自己的渲染引擎来绘制widget。对于Android平台，Flutter引擎的C/C++代码是由NDK编译，在iOS平台，则是由LLVM编译，两个平台的Dart代码都是AOT编译为本地代码，Flutter应用程序使用本机指令集运行。</p>\n<h2 id=\"Flutter设计\"><a href=\"#Flutter设计\" class=\"headerlink\" title=\"Flutter设计\"></a>Flutter设计</h2><p><img src=\"/assets/Screen Shot 2018-09-30 at 3.05.02 PM.png\" alt=\"\"></p>\n<p>Flutter Framework: 这是一个纯 Dart实现的 SDK，类似于 React在 JavaScript中的作用。它实现了一套基础库， 用于处理动画、绘图和手势。并且基于绘图封装了一套 UI组件库，然后根据 Material 和Cupertino两种视觉风格区分开来。这个纯 Dart实现的 SDK被封装为了一个叫作 dart:ui的 Dart库。我们在使用 Flutter写 App的时候，直接导入这个库即可使用组件等功能。</p>\n<p>Flutter Engine: 这是一个纯 C++实现的 SDK，其中囊括了 Skia引擎、Dart运行时、文字排版引擎等。不过说白了，它就是 Dart的一个运行时，它可以以 JIT、JIT Snapshot 或者 AOT的模式运行 Dart代码。在代码调用 dart:ui库时，提供 dart:ui库中 Native Binding 实现。</p>\n<h1 id=\"Flutter为什么使用\"><a href=\"#Flutter为什么使用\" class=\"headerlink\" title=\"Flutter为什么使用\"></a>Flutter为什么使用</h1><p>Flutter跟大部分构建移动应用的技术或者框架不同的是，Flutter没有使用WebView或者平台自带的控件，相反Flutter使用自身的高性能渲染引擎绘制自己的控件。</p>\n<p>另外，Flutter仅仅只有小部分C++代码，Flutter使用Dart实现了它自身大部分功能（控件，动画，手势，compositing等等）。这样开发者能够容易阅读，修改Flutter的实现，所以这里提供开发者相当大的空间去控制整个框架而且显著降低入门门槛。</p>\n<h2 id=\"特性：\"><a href=\"#特性：\" class=\"headerlink\" title=\"特性：\"></a>特性：</h2><ol>\n<li>快速开发：Flutter的热重载可以快速地进行测试、构建UI、添加功能并更快地修复错误。</li>\n<li>富有表现力，漂亮的用户界面：自带的Material Design和Cupertino（iOS风格）widget、丰富的motion API、平滑而自然的滑动效果。</li>\n<li>响应式框架：使用Flutter的现代、响应式框架，和一系列基础widget，轻松构建您的用户界面。</li>\n<li>访问本地功能和SDK：Flutter可以复用现有的Java、Swift或ObjC代码，访问iOS和Android上的原生系统功能和系统SDK。</li>\n<li>统一的应用开发体验：Flutter拥有丰富的工具和库，可以帮助开发者轻松地同时在iOS和Android系统中实现想法和创意。</li>\n<li>原生性能：Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。</li>\n</ol>\n<h1 id=\"Flutter能做什么\"><a href=\"#Flutter能做什么\" class=\"headerlink\" title=\"Flutter能做什么\"></a>Flutter能做什么</h1><p>Flutter能够开发Android和iOS上2D（不支持3D）界面的移动应用。</p>\n<p>你可以使用Flutter开发具有全特性的应用（包含支持照相，定位，网络连接，存储，第三方SDK等等）。</p>\n<h1 id=\"Flutter适合什么人使用\"><a href=\"#Flutter适合什么人使用\" class=\"headerlink\" title=\"Flutter适合什么人使用\"></a>Flutter适合什么人使用</h1><p>Flutter框架对于熟悉面向对象编程和命令编程的开发者门槛是相当低的，并不需要有移动应用的开发经验，我们已经见过编程经验不多的人都能学习并使用Flutter开发应用。</p>\n<h1 id=\"Flutter缺点\"><a href=\"#Flutter缺点\" class=\"headerlink\" title=\"Flutter缺点\"></a>Flutter缺点</h1><p>暂时对 iOS 效果有点不佳</p>\n<h1 id=\"Flutter对比\"><a href=\"#Flutter对比\" class=\"headerlink\" title=\"Flutter对比\"></a>Flutter对比</h1><p><img src=\"/assets/Screen Shot 2018-09-19 at 6.10.18 PM.png\" alt=\"\"></p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"/assets/Screen Shot 2018-09-30 at 12.04.50 PM.png\" alt=\"\"></h1><p># </p>\n<h1 id=\"Flutter相关产品\"><a href=\"#Flutter相关产品\" class=\"headerlink\" title=\"Flutter相关产品\"></a>Flutter相关产品</h1><p>谷歌在使用Flutter构建一些business-critical（业务相关的）移动应用，例如，谷歌的移动销售工具应用就是使用Flutter开发的，还有Google Shopping Express的Store Manage应用，还有一些应用处于开发中。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://flutter-dev.cn/topic/16/flutter常见问题答疑\" target=\"_blank\" rel=\"noopener\">http://flutter-dev.cn/topic/16/flutter常见问题答疑</a></p>\n"},{"title":"Flutter笔记","date":"2018-10-02T01:09:09.000Z","_content":"在Flutter中您可以通过挂接到WidgetsBinding观察并监听didChangeAppLifecycleState更改事件来监听生命周期事件\n\n您可以监听到的生命周期事件是\n\n* resumed - 应用程序可见并响应用户输入。这是来自Android的onResume\n* inactive - 应用程序处于非活动状态，并且未接收用户输入。此事件在Android上未使用，仅适用于iOS\n* paused - 应用程序当前对用户不可见，不响应用户输入，并在后台运行。这是来自Android的暂停\n* suspending - 该应用程序将暂时中止。这在iOS上未使用\n\n![](/assets/flutter_app_tree.png)\n\n","source":"_posts/flutter/flutter-kai-fa-bi-ji.md","raw":"---\ntitle: Flutter笔记\ndate: 2018-10-02 09:09:09\ncategories: flutter\n---\n在Flutter中您可以通过挂接到WidgetsBinding观察并监听didChangeAppLifecycleState更改事件来监听生命周期事件\n\n您可以监听到的生命周期事件是\n\n* resumed - 应用程序可见并响应用户输入。这是来自Android的onResume\n* inactive - 应用程序处于非活动状态，并且未接收用户输入。此事件在Android上未使用，仅适用于iOS\n* paused - 应用程序当前对用户不可见，不响应用户输入，并在后台运行。这是来自Android的暂停\n* suspending - 该应用程序将暂时中止。这在iOS上未使用\n\n![](/assets/flutter_app_tree.png)\n\n","slug":"flutter/flutter-kai-fa-bi-ji","published":1,"updated":"2018-10-02T02:08:27.621Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4n2002gntnb26fmh806","content":"<p>在Flutter中您可以通过挂接到WidgetsBinding观察并监听didChangeAppLifecycleState更改事件来监听生命周期事件</p>\n<p>您可以监听到的生命周期事件是</p>\n<ul>\n<li>resumed - 应用程序可见并响应用户输入。这是来自Android的onResume</li>\n<li>inactive - 应用程序处于非活动状态，并且未接收用户输入。此事件在Android上未使用，仅适用于iOS</li>\n<li>paused - 应用程序当前对用户不可见，不响应用户输入，并在后台运行。这是来自Android的暂停</li>\n<li>suspending - 该应用程序将暂时中止。这在iOS上未使用</li>\n</ul>\n<p><img src=\"/assets/flutter_app_tree.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在Flutter中您可以通过挂接到WidgetsBinding观察并监听didChangeAppLifecycleState更改事件来监听生命周期事件</p>\n<p>您可以监听到的生命周期事件是</p>\n<ul>\n<li>resumed - 应用程序可见并响应用户输入。这是来自Android的onResume</li>\n<li>inactive - 应用程序处于非活动状态，并且未接收用户输入。此事件在Android上未使用，仅适用于iOS</li>\n<li>paused - 应用程序当前对用户不可见，不响应用户输入，并在后台运行。这是来自Android的暂停</li>\n<li>suspending - 该应用程序将暂时中止。这在iOS上未使用</li>\n</ul>\n<p><img src=\"/assets/flutter_app_tree.png\" alt=\"\"></p>\n"},{"title":"Android Library","date":"2018-10-02T01:09:09.000Z","_content":"[http://www.jianshu.com/p/f664ebc03d93](http://www.jianshu.com/p/f664ebc03d93)\n\n[http://www.wxtlife.com/2015/12/17/Android-studio-quote-same-lib/](http://www.wxtlife.com/2015/12/17/Android-studio-quote-same-lib/)\n\n第一种方法是对library向每个引用的项目建立软连接。这样修改就会对每个引用同步修改.这种方法就是看起来会很臃肿，如果要引用多个library就很痛苦。\n\n第二种就是maven 仓库的方式，将所有的library都上传到maven仓库，然后在各个工程中进行引用，当然这种是对稳定的library来说是最好的一种方式，但对于library需要开发和修改的就不太适合了。\n\n\n\n第三种就是将所以的library作为一个工程使用，然后将所有的library都放入此工程中，然后在其他引用library的工程中，引入新建的工程，这样看起来和eclipse 引用library的结构就很像了，且可以放入多个library都不影响。下面就来看看这种解决方法，该如何实现。\n\n首先新建一个工程，注意是工程，不是Stuio里面的Module，起一个容易理解的工程名称CommonLibrary\n\n将需添加的library添加进CommonLibrary中，记得每个library也是需要有\n\n1. `build.gradle`\n   文件的，且配置项正确。\n2. 在需要引用的的工程中，需要在`settings.gradle`文件中添加引用代码如下：\n\n```\ninclude ':CommonLibrary'\n```\n\n```\nproject (':CommonLibrary').projectDir = new File('../CommonLibrary/')\ninclude ':CommonLibrary:CommonsA'\n```\n\n其中CommonsA为项目要使用的公共library名称\n\n然后在我们项目实际的model中修改`build.gradle`文件，需要在`dependencies`中添加下面的代码。CommonsA和CommonsB都是要要引用的项目。\n\ncompile project \\(':CommonLibrary:CommonsA'\\)\n\ncompile project \\(':CommonLibrary:CommonsB'\\)\n\n","source":"_posts/android/andoridgong-gong-library-shi-xian-fang-fa.md","raw":"---\ntitle: Android Library\ndate: 2018-10-02 09:09:09\ncategories: Android\n---\n[http://www.jianshu.com/p/f664ebc03d93](http://www.jianshu.com/p/f664ebc03d93)\n\n[http://www.wxtlife.com/2015/12/17/Android-studio-quote-same-lib/](http://www.wxtlife.com/2015/12/17/Android-studio-quote-same-lib/)\n\n第一种方法是对library向每个引用的项目建立软连接。这样修改就会对每个引用同步修改.这种方法就是看起来会很臃肿，如果要引用多个library就很痛苦。\n\n第二种就是maven 仓库的方式，将所有的library都上传到maven仓库，然后在各个工程中进行引用，当然这种是对稳定的library来说是最好的一种方式，但对于library需要开发和修改的就不太适合了。\n\n\n\n第三种就是将所以的library作为一个工程使用，然后将所有的library都放入此工程中，然后在其他引用library的工程中，引入新建的工程，这样看起来和eclipse 引用library的结构就很像了，且可以放入多个library都不影响。下面就来看看这种解决方法，该如何实现。\n\n首先新建一个工程，注意是工程，不是Stuio里面的Module，起一个容易理解的工程名称CommonLibrary\n\n将需添加的library添加进CommonLibrary中，记得每个library也是需要有\n\n1. `build.gradle`\n   文件的，且配置项正确。\n2. 在需要引用的的工程中，需要在`settings.gradle`文件中添加引用代码如下：\n\n```\ninclude ':CommonLibrary'\n```\n\n```\nproject (':CommonLibrary').projectDir = new File('../CommonLibrary/')\ninclude ':CommonLibrary:CommonsA'\n```\n\n其中CommonsA为项目要使用的公共library名称\n\n然后在我们项目实际的model中修改`build.gradle`文件，需要在`dependencies`中添加下面的代码。CommonsA和CommonsB都是要要引用的项目。\n\ncompile project \\(':CommonLibrary:CommonsA'\\)\n\ncompile project \\(':CommonLibrary:CommonsB'\\)\n\n","slug":"android/andoridgong-gong-library-shi-xian-fang-fa","published":1,"updated":"2018-10-02T02:52:44.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4n3002intnbw7609353","content":"<p><a href=\"http://www.jianshu.com/p/f664ebc03d93\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/f664ebc03d93</a></p>\n<p><a href=\"http://www.wxtlife.com/2015/12/17/Android-studio-quote-same-lib/\" target=\"_blank\" rel=\"noopener\">http://www.wxtlife.com/2015/12/17/Android-studio-quote-same-lib/</a></p>\n<p>第一种方法是对library向每个引用的项目建立软连接。这样修改就会对每个引用同步修改.这种方法就是看起来会很臃肿，如果要引用多个library就很痛苦。</p>\n<p>第二种就是maven 仓库的方式，将所有的library都上传到maven仓库，然后在各个工程中进行引用，当然这种是对稳定的library来说是最好的一种方式，但对于library需要开发和修改的就不太适合了。</p>\n<p>第三种就是将所以的library作为一个工程使用，然后将所有的library都放入此工程中，然后在其他引用library的工程中，引入新建的工程，这样看起来和eclipse 引用library的结构就很像了，且可以放入多个library都不影响。下面就来看看这种解决方法，该如何实现。</p>\n<p>首先新建一个工程，注意是工程，不是Stuio里面的Module，起一个容易理解的工程名称CommonLibrary</p>\n<p>将需添加的library添加进CommonLibrary中，记得每个library也是需要有</p>\n<ol>\n<li><code>build.gradle</code><br>文件的，且配置项正确。</li>\n<li>在需要引用的的工程中，需要在<code>settings.gradle</code>文件中添加引用代码如下：</li>\n</ol>\n<pre><code>include &#39;:CommonLibrary&#39;\n</code></pre><pre><code>project (&#39;:CommonLibrary&#39;).projectDir = new File(&#39;../CommonLibrary/&#39;)\ninclude &#39;:CommonLibrary:CommonsA&#39;\n</code></pre><p>其中CommonsA为项目要使用的公共library名称</p>\n<p>然后在我们项目实际的model中修改<code>build.gradle</code>文件，需要在<code>dependencies</code>中添加下面的代码。CommonsA和CommonsB都是要要引用的项目。</p>\n<p>compile project (‘:CommonLibrary:CommonsA’)</p>\n<p>compile project (‘:CommonLibrary:CommonsB’)</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.jianshu.com/p/f664ebc03d93\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/f664ebc03d93</a></p>\n<p><a href=\"http://www.wxtlife.com/2015/12/17/Android-studio-quote-same-lib/\" target=\"_blank\" rel=\"noopener\">http://www.wxtlife.com/2015/12/17/Android-studio-quote-same-lib/</a></p>\n<p>第一种方法是对library向每个引用的项目建立软连接。这样修改就会对每个引用同步修改.这种方法就是看起来会很臃肿，如果要引用多个library就很痛苦。</p>\n<p>第二种就是maven 仓库的方式，将所有的library都上传到maven仓库，然后在各个工程中进行引用，当然这种是对稳定的library来说是最好的一种方式，但对于library需要开发和修改的就不太适合了。</p>\n<p>第三种就是将所以的library作为一个工程使用，然后将所有的library都放入此工程中，然后在其他引用library的工程中，引入新建的工程，这样看起来和eclipse 引用library的结构就很像了，且可以放入多个library都不影响。下面就来看看这种解决方法，该如何实现。</p>\n<p>首先新建一个工程，注意是工程，不是Stuio里面的Module，起一个容易理解的工程名称CommonLibrary</p>\n<p>将需添加的library添加进CommonLibrary中，记得每个library也是需要有</p>\n<ol>\n<li><code>build.gradle</code><br>文件的，且配置项正确。</li>\n<li>在需要引用的的工程中，需要在<code>settings.gradle</code>文件中添加引用代码如下：</li>\n</ol>\n<pre><code>include &#39;:CommonLibrary&#39;\n</code></pre><pre><code>project (&#39;:CommonLibrary&#39;).projectDir = new File(&#39;../CommonLibrary/&#39;)\ninclude &#39;:CommonLibrary:CommonsA&#39;\n</code></pre><p>其中CommonsA为项目要使用的公共library名称</p>\n<p>然后在我们项目实际的model中修改<code>build.gradle</code>文件，需要在<code>dependencies</code>中添加下面的代码。CommonsA和CommonsB都是要要引用的项目。</p>\n<p>compile project (‘:CommonLibrary:CommonsA’)</p>\n<p>compile project (‘:CommonLibrary:CommonsB’)</p>\n"},{"title":"Android Library","date":"2018-10-02T01:09:09.000Z","_content":"","source":"_posts/android/android-activity-guan-li-985e5d28-android-android-activity-guan-li-985e-md.md","raw":"---\ntitle: Android Library\ndate: 2018-10-02 09:09:09\ncategories: Android\n---","slug":"android/android-activity-guan-li-985e5d28-android-android-activity-guan-li-985e-md","published":1,"updated":"2018-10-02T02:52:44.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4n4002kntnbnbq3ao6s","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Android Library","date":"2018-10-02T01:09:09.000Z","_content":"","source":"_posts/android/android-adbcha-kan-jin-cheng-xin-606f5d28-android-andorid-adb-cha-kan-jin-cheng-xin-606f-md.md","raw":"---\ntitle: Android Library\ndate: 2018-10-02 09:09:09\ncategories: Android\n---","slug":"android/android-adbcha-kan-jin-cheng-xin-606f5d28-android-andorid-adb-cha-kan-jin-cheng-xin-606f-md","published":1,"updated":"2018-10-02T02:52:44.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4n5002lntnbl02y53dq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Android AudioRecord配置","date":"2018-10-02T01:09:09.000Z","_content":"# Android AudioRecord配置\n\n> 项目地址：[https://github.com/ChocolateTan/AudioRecordWithFFMpeg](https://github.com/ChocolateTan/AudioRecordWithFFMpeg)\n\n该项目使用AudriodRecord录音，使用FFMpegAndroid库转码，由PCM到MP3\n\n\n\n","source":"_posts/android/android-audiorecordpei-zhi.md","raw":"---\ntitle: Android AudioRecord配置\ndate: 2018-10-02 09:09:09\ncategories: Android\n---\n# Android AudioRecord配置\n\n> 项目地址：[https://github.com/ChocolateTan/AudioRecordWithFFMpeg](https://github.com/ChocolateTan/AudioRecordWithFFMpeg)\n\n该项目使用AudriodRecord录音，使用FFMpegAndroid库转码，由PCM到MP3\n\n\n\n","slug":"android/android-audiorecordpei-zhi","published":1,"updated":"2018-10-02T02:52:44.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4n6002ontnb6yj8huwo","content":"<h1 id=\"Android-AudioRecord配置\"><a href=\"#Android-AudioRecord配置\" class=\"headerlink\" title=\"Android AudioRecord配置\"></a>Android AudioRecord配置</h1><blockquote>\n<p>项目地址：<a href=\"https://github.com/ChocolateTan/AudioRecordWithFFMpeg\" target=\"_blank\" rel=\"noopener\">https://github.com/ChocolateTan/AudioRecordWithFFMpeg</a></p>\n</blockquote>\n<p>该项目使用AudriodRecord录音，使用FFMpegAndroid库转码，由PCM到MP3</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Android-AudioRecord配置\"><a href=\"#Android-AudioRecord配置\" class=\"headerlink\" title=\"Android AudioRecord配置\"></a>Android AudioRecord配置</h1><blockquote>\n<p>项目地址：<a href=\"https://github.com/ChocolateTan/AudioRecordWithFFMpeg\" target=\"_blank\" rel=\"noopener\">https://github.com/ChocolateTan/AudioRecordWithFFMpeg</a></p>\n</blockquote>\n<p>该项目使用AudriodRecord录音，使用FFMpegAndroid库转码，由PCM到MP3</p>\n"},{"title":"Android Studio Code Style","date":"2018-10-02T01:09:09.000Z","_content":"## [https://github.com/ChocolateTan/AndroidCodeStyle](https://github.com/ChocolateTan/AndroidCodeStyle)\n\n\n\n","source":"_posts/android/android.md","raw":"---\ntitle: Android Studio Code Style\ndate: 2018-10-02 09:09:09\ncategories: Android\n---\n## [https://github.com/ChocolateTan/AndroidCodeStyle](https://github.com/ChocolateTan/AndroidCodeStyle)\n\n\n\n","slug":"android/android","published":1,"updated":"2018-10-02T02:52:44.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4n7002pntnb7shu6uea","content":"<h2 id=\"https-github-com-ChocolateTan-AndroidCodeStyle\"><a href=\"#https-github-com-ChocolateTan-AndroidCodeStyle\" class=\"headerlink\" title=\"https://github.com/ChocolateTan/AndroidCodeStyle\"></a><a href=\"https://github.com/ChocolateTan/AndroidCodeStyle\" target=\"_blank\" rel=\"noopener\">https://github.com/ChocolateTan/AndroidCodeStyle</a></h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"https-github-com-ChocolateTan-AndroidCodeStyle\"><a href=\"#https-github-com-ChocolateTan-AndroidCodeStyle\" class=\"headerlink\" title=\"https://github.com/ChocolateTan/AndroidCodeStyle\"></a><a href=\"https://github.com/ChocolateTan/AndroidCodeStyle\" target=\"_blank\" rel=\"noopener\">https://github.com/ChocolateTan/AndroidCodeStyle</a></h2>"},{"title":"Android Studio Plugins","date":"2018-10-02T01:09:09.000Z","_content":"","source":"_posts/android/androidcomparatorshi-75285d28-android-android-comparator-shi-7528-md.md","raw":"---\ntitle: Android Studio Plugins\ndate: 2018-10-02 09:09:09\ncategories: Android\n---","slug":"android/androidcomparatorshi-75285d28-android-android-comparator-shi-7528-md","published":1,"updated":"2018-10-02T02:52:44.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4n8002sntnbevhotovo","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Android手势处理","date":"2018-10-02T01:09:09.000Z","_content":"### Android手势处理\n\n> 参考：[https://my.oschina.net/gavinjin/blog/206509](#)\n\n#### OnTouchListener与OnGestureListener的区别\n\n两者之间的区别在于OnTouchListener获取Touch事件，通过MotionEvent处理事件（如监听到三种触摸事件，即按下，移动，松开）。OnGestureListener则能监听到双击、滑动、长按等复杂的手势操作。\n\n","source":"_posts/android/androidshou-shi-chu-li.md","raw":"---\ntitle: Android手势处理\ndate: 2018-10-02 09:09:09\ncategories: Android\n---\n### Android手势处理\n\n> 参考：[https://my.oschina.net/gavinjin/blog/206509](#)\n\n#### OnTouchListener与OnGestureListener的区别\n\n两者之间的区别在于OnTouchListener获取Touch事件，通过MotionEvent处理事件（如监听到三种触摸事件，即按下，移动，松开）。OnGestureListener则能监听到双击、滑动、长按等复杂的手势操作。\n\n","slug":"android/androidshou-shi-chu-li","published":1,"updated":"2018-10-02T02:52:44.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4n9002tntnbtm58v298","content":"<h3 id=\"Android手势处理\"><a href=\"#Android手势处理\" class=\"headerlink\" title=\"Android手势处理\"></a>Android手势处理</h3><blockquote>\n<p>参考：<a href=\"#\">https://my.oschina.net/gavinjin/blog/206509</a></p>\n</blockquote>\n<h4 id=\"OnTouchListener与OnGestureListener的区别\"><a href=\"#OnTouchListener与OnGestureListener的区别\" class=\"headerlink\" title=\"OnTouchListener与OnGestureListener的区别\"></a>OnTouchListener与OnGestureListener的区别</h4><p>两者之间的区别在于OnTouchListener获取Touch事件，通过MotionEvent处理事件（如监听到三种触摸事件，即按下，移动，松开）。OnGestureListener则能监听到双击、滑动、长按等复杂的手势操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Android手势处理\"><a href=\"#Android手势处理\" class=\"headerlink\" title=\"Android手势处理\"></a>Android手势处理</h3><blockquote>\n<p>参考：<a href=\"#\">https://my.oschina.net/gavinjin/blog/206509</a></p>\n</blockquote>\n<h4 id=\"OnTouchListener与OnGestureListener的区别\"><a href=\"#OnTouchListener与OnGestureListener的区别\" class=\"headerlink\" title=\"OnTouchListener与OnGestureListener的区别\"></a>OnTouchListener与OnGestureListener的区别</h4><p>两者之间的区别在于OnTouchListener获取Touch事件，通过MotionEvent处理事件（如监听到三种触摸事件，即按下，移动，松开）。OnGestureListener则能监听到双击、滑动、长按等复杂的手势操作。</p>\n"},{"title":"Android CMake","date":"2018-10-02T01:09:09.000Z","_content":"> ##### 参考：[http://wl9739.github.io/2016/09/21/%E5%9C%A8-Android-Studio-2-2-%E4%B8%AD%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8-C-C-md/](http://wl9739.github.io/2016/09/21/%E5%9C%A8-Android-Studio-2-2-%E4%B8%AD%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8-C-C-md/)\n\n#### 简介\n\n> 注意：要在 Android Studio 中使用 CMake 或者 ndk-build，需要使用 Android Studio 2.2 或更高的版本，同时需要配合使用 Android Plugin for Gradle 2.2.0 及以上的版本。\n\n`The Android Native Development Kit (NDK)`\n\n* : 让你能在 Android 上面使用 C 和 C++ 代码的工具集。\n* `CMake`: 外部构建工具。如果你准备只使用 ndk-build 的话，可以不使用它。\n* `LLDB`: Android Studio 上面调试本地代码的工具。\n\n> 注意：**Instant Run**并不兼容使用了 native code 的项目。Android Studio 会自动禁止**Instant Run**功能。\n\n#### 编译过程\n\n1. Gradle 调用外部构建脚本，也就是**CMakeLists.txt**。\n2. CMake 会根据构建脚本的指令去编译一个 C++ 源文件，也就是`native-lib.cpp`，并将编译后的产物扔进共享对象库中，并将其命名为**libnative-lib.so**，然后 Gradle 将其打包到 APK 中。\n3. 在运行期间，APP 的 MainActivity 会调用`System.loadLibrary()`方法，加载 native library。而这个库的原生函数，`stringFromJNI()`，就可以为 APP 所用了。\n4. MainActivity.onCreate\\(\\) 方法会调用`stringFromJNI()`，然后返回 “Hello from C++”，并更新 TextView 的显示。\n\n#### 将 C/C++ 代码添加到现有的项目中\n\n如果你想将 native code 添加到一个现有的项目中，请按照下面的步骤操作：\n\n1. 创建新的 native source 文件，并将其添加到你的 Android Studio 项目中。如果你已经有了 native code，也可以跳过这一步。\n2. 创建一个 CMake 构建脚本。如果你已经有了一个 CMakeLists.txt 构建脚本，或者你想使用 ndk-build 然后有一个 Android.mk 构建脚本，也可以跳过这一步。\n3. 将你的 native library 与 Gradle 关联起来。Gradle 使用构建脚本将源码导入到你的 Android Studio 项目中，并且将你的 native library （也就是 .so 文件）打包到 APK 中。\n\n一旦你配置好了项目，你就可以在 Java 代码中，使用 JNI 框架开调用原生函数（native functions）。只需要点击**Run**按钮，就可以编译运行你的 APP 了。\n\n","source":"_posts/android/androidstudioandc++.md","raw":"---\ntitle: Android CMake\ndate: 2018-10-02 09:09:09\ncategories: Android\n---\n> ##### 参考：[http://wl9739.github.io/2016/09/21/%E5%9C%A8-Android-Studio-2-2-%E4%B8%AD%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8-C-C-md/](http://wl9739.github.io/2016/09/21/%E5%9C%A8-Android-Studio-2-2-%E4%B8%AD%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8-C-C-md/)\n\n#### 简介\n\n> 注意：要在 Android Studio 中使用 CMake 或者 ndk-build，需要使用 Android Studio 2.2 或更高的版本，同时需要配合使用 Android Plugin for Gradle 2.2.0 及以上的版本。\n\n`The Android Native Development Kit (NDK)`\n\n* : 让你能在 Android 上面使用 C 和 C++ 代码的工具集。\n* `CMake`: 外部构建工具。如果你准备只使用 ndk-build 的话，可以不使用它。\n* `LLDB`: Android Studio 上面调试本地代码的工具。\n\n> 注意：**Instant Run**并不兼容使用了 native code 的项目。Android Studio 会自动禁止**Instant Run**功能。\n\n#### 编译过程\n\n1. Gradle 调用外部构建脚本，也就是**CMakeLists.txt**。\n2. CMake 会根据构建脚本的指令去编译一个 C++ 源文件，也就是`native-lib.cpp`，并将编译后的产物扔进共享对象库中，并将其命名为**libnative-lib.so**，然后 Gradle 将其打包到 APK 中。\n3. 在运行期间，APP 的 MainActivity 会调用`System.loadLibrary()`方法，加载 native library。而这个库的原生函数，`stringFromJNI()`，就可以为 APP 所用了。\n4. MainActivity.onCreate\\(\\) 方法会调用`stringFromJNI()`，然后返回 “Hello from C++”，并更新 TextView 的显示。\n\n#### 将 C/C++ 代码添加到现有的项目中\n\n如果你想将 native code 添加到一个现有的项目中，请按照下面的步骤操作：\n\n1. 创建新的 native source 文件，并将其添加到你的 Android Studio 项目中。如果你已经有了 native code，也可以跳过这一步。\n2. 创建一个 CMake 构建脚本。如果你已经有了一个 CMakeLists.txt 构建脚本，或者你想使用 ndk-build 然后有一个 Android.mk 构建脚本，也可以跳过这一步。\n3. 将你的 native library 与 Gradle 关联起来。Gradle 使用构建脚本将源码导入到你的 Android Studio 项目中，并且将你的 native library （也就是 .so 文件）打包到 APK 中。\n\n一旦你配置好了项目，你就可以在 Java 代码中，使用 JNI 框架开调用原生函数（native functions）。只需要点击**Run**按钮，就可以编译运行你的 APP 了。\n\n","slug":"android/androidstudioandc++","published":1,"updated":"2018-10-02T02:52:44.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4na002wntnbpxnrrvok","content":"<blockquote>\n<h5 id=\"参考：http-wl9739-github-io-2016-09-21-E5-9C-A8-Android-Studio-2-2-E4-B8-AD-E6-84-89-E5-BF-AB-E5-9C-B0-E4-BD-BF-E7-94-A8-C-C-md\"><a href=\"#参考：http-wl9739-github-io-2016-09-21-E5-9C-A8-Android-Studio-2-2-E4-B8-AD-E6-84-89-E5-BF-AB-E5-9C-B0-E4-BD-BF-E7-94-A8-C-C-md\" class=\"headerlink\" title=\"参考：http://wl9739.github.io/2016/09/21/%E5%9C%A8-Android-Studio-2-2-%E4%B8%AD%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8-C-C-md/\"></a>参考：<a href=\"http://wl9739.github.io/2016/09/21/%E5%9C%A8-Android-Studio-2-2-%E4%B8%AD%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8-C-C-md/\" target=\"_blank\" rel=\"noopener\">http://wl9739.github.io/2016/09/21/%E5%9C%A8-Android-Studio-2-2-%E4%B8%AD%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8-C-C-md/</a></h5></blockquote>\n<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><blockquote>\n<p>注意：要在 Android Studio 中使用 CMake 或者 ndk-build，需要使用 Android Studio 2.2 或更高的版本，同时需要配合使用 Android Plugin for Gradle 2.2.0 及以上的版本。</p>\n</blockquote>\n<p><code>The Android Native Development Kit (NDK)</code></p>\n<ul>\n<li>: 让你能在 Android 上面使用 C 和 C++ 代码的工具集。</li>\n<li><code>CMake</code>: 外部构建工具。如果你准备只使用 ndk-build 的话，可以不使用它。</li>\n<li><code>LLDB</code>: Android Studio 上面调试本地代码的工具。</li>\n</ul>\n<blockquote>\n<p>注意：<strong>Instant Run</strong>并不兼容使用了 native code 的项目。Android Studio 会自动禁止<strong>Instant Run</strong>功能。</p>\n</blockquote>\n<h4 id=\"编译过程\"><a href=\"#编译过程\" class=\"headerlink\" title=\"编译过程\"></a>编译过程</h4><ol>\n<li>Gradle 调用外部构建脚本，也就是<strong>CMakeLists.txt</strong>。</li>\n<li>CMake 会根据构建脚本的指令去编译一个 C++ 源文件，也就是<code>native-lib.cpp</code>，并将编译后的产物扔进共享对象库中，并将其命名为<strong>libnative-lib.so</strong>，然后 Gradle 将其打包到 APK 中。</li>\n<li>在运行期间，APP 的 MainActivity 会调用<code>System.loadLibrary()</code>方法，加载 native library。而这个库的原生函数，<code>stringFromJNI()</code>，就可以为 APP 所用了。</li>\n<li>MainActivity.onCreate() 方法会调用<code>stringFromJNI()</code>，然后返回 “Hello from C++”，并更新 TextView 的显示。</li>\n</ol>\n<h4 id=\"将-C-C-代码添加到现有的项目中\"><a href=\"#将-C-C-代码添加到现有的项目中\" class=\"headerlink\" title=\"将 C/C++ 代码添加到现有的项目中\"></a>将 C/C++ 代码添加到现有的项目中</h4><p>如果你想将 native code 添加到一个现有的项目中，请按照下面的步骤操作：</p>\n<ol>\n<li>创建新的 native source 文件，并将其添加到你的 Android Studio 项目中。如果你已经有了 native code，也可以跳过这一步。</li>\n<li>创建一个 CMake 构建脚本。如果你已经有了一个 CMakeLists.txt 构建脚本，或者你想使用 ndk-build 然后有一个 Android.mk 构建脚本，也可以跳过这一步。</li>\n<li>将你的 native library 与 Gradle 关联起来。Gradle 使用构建脚本将源码导入到你的 Android Studio 项目中，并且将你的 native library （也就是 .so 文件）打包到 APK 中。</li>\n</ol>\n<p>一旦你配置好了项目，你就可以在 Java 代码中，使用 JNI 框架开调用原生函数（native functions）。只需要点击<strong>Run</strong>按钮，就可以编译运行你的 APP 了。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<h5 id=\"参考：http-wl9739-github-io-2016-09-21-E5-9C-A8-Android-Studio-2-2-E4-B8-AD-E6-84-89-E5-BF-AB-E5-9C-B0-E4-BD-BF-E7-94-A8-C-C-md\"><a href=\"#参考：http-wl9739-github-io-2016-09-21-E5-9C-A8-Android-Studio-2-2-E4-B8-AD-E6-84-89-E5-BF-AB-E5-9C-B0-E4-BD-BF-E7-94-A8-C-C-md\" class=\"headerlink\" title=\"参考：http://wl9739.github.io/2016/09/21/%E5%9C%A8-Android-Studio-2-2-%E4%B8%AD%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8-C-C-md/\"></a>参考：<a href=\"http://wl9739.github.io/2016/09/21/%E5%9C%A8-Android-Studio-2-2-%E4%B8%AD%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8-C-C-md/\" target=\"_blank\" rel=\"noopener\">http://wl9739.github.io/2016/09/21/%E5%9C%A8-Android-Studio-2-2-%E4%B8%AD%E6%84%89%E5%BF%AB%E5%9C%B0%E4%BD%BF%E7%94%A8-C-C-md/</a></h5></blockquote>\n<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><blockquote>\n<p>注意：要在 Android Studio 中使用 CMake 或者 ndk-build，需要使用 Android Studio 2.2 或更高的版本，同时需要配合使用 Android Plugin for Gradle 2.2.0 及以上的版本。</p>\n</blockquote>\n<p><code>The Android Native Development Kit (NDK)</code></p>\n<ul>\n<li>: 让你能在 Android 上面使用 C 和 C++ 代码的工具集。</li>\n<li><code>CMake</code>: 外部构建工具。如果你准备只使用 ndk-build 的话，可以不使用它。</li>\n<li><code>LLDB</code>: Android Studio 上面调试本地代码的工具。</li>\n</ul>\n<blockquote>\n<p>注意：<strong>Instant Run</strong>并不兼容使用了 native code 的项目。Android Studio 会自动禁止<strong>Instant Run</strong>功能。</p>\n</blockquote>\n<h4 id=\"编译过程\"><a href=\"#编译过程\" class=\"headerlink\" title=\"编译过程\"></a>编译过程</h4><ol>\n<li>Gradle 调用外部构建脚本，也就是<strong>CMakeLists.txt</strong>。</li>\n<li>CMake 会根据构建脚本的指令去编译一个 C++ 源文件，也就是<code>native-lib.cpp</code>，并将编译后的产物扔进共享对象库中，并将其命名为<strong>libnative-lib.so</strong>，然后 Gradle 将其打包到 APK 中。</li>\n<li>在运行期间，APP 的 MainActivity 会调用<code>System.loadLibrary()</code>方法，加载 native library。而这个库的原生函数，<code>stringFromJNI()</code>，就可以为 APP 所用了。</li>\n<li>MainActivity.onCreate() 方法会调用<code>stringFromJNI()</code>，然后返回 “Hello from C++”，并更新 TextView 的显示。</li>\n</ol>\n<h4 id=\"将-C-C-代码添加到现有的项目中\"><a href=\"#将-C-C-代码添加到现有的项目中\" class=\"headerlink\" title=\"将 C/C++ 代码添加到现有的项目中\"></a>将 C/C++ 代码添加到现有的项目中</h4><p>如果你想将 native code 添加到一个现有的项目中，请按照下面的步骤操作：</p>\n<ol>\n<li>创建新的 native source 文件，并将其添加到你的 Android Studio 项目中。如果你已经有了 native code，也可以跳过这一步。</li>\n<li>创建一个 CMake 构建脚本。如果你已经有了一个 CMakeLists.txt 构建脚本，或者你想使用 ndk-build 然后有一个 Android.mk 构建脚本，也可以跳过这一步。</li>\n<li>将你的 native library 与 Gradle 关联起来。Gradle 使用构建脚本将源码导入到你的 Android Studio 项目中，并且将你的 native library （也就是 .so 文件）打包到 APK 中。</li>\n</ol>\n<p>一旦你配置好了项目，你就可以在 Java 代码中，使用 JNI 框架开调用原生函数（native functions）。只需要点击<strong>Run</strong>按钮，就可以编译运行你的 APP 了。</p>\n"},{"title":"Android 依賴項","date":"2018-10-02T01:09:09.000Z","_content":"```\ngradlew -q dependencies app:dependencies --configuration compile\n```\n\n輸入該命令，查看依賴項\n\n\n\n參考\n\nhttp://www.paincker.com/gradle-dependencies\n\n","source":"_posts/android/androidyi-lai-xiang-chong-tu-chu-li.md","raw":"---\ntitle: Android 依賴項\ndate: 2018-10-02 09:09:09\ncategories: Android\n---\n```\ngradlew -q dependencies app:dependencies --configuration compile\n```\n\n輸入該命令，查看依賴項\n\n\n\n參考\n\nhttp://www.paincker.com/gradle-dependencies\n\n","slug":"android/androidyi-lai-xiang-chong-tu-chu-li","published":1,"updated":"2018-10-02T02:52:44.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4na002xntnbpxw81wnh","content":"<pre><code>gradlew -q dependencies app:dependencies --configuration compile\n</code></pre><p>輸入該命令，查看依賴項</p>\n<p>參考</p>\n<p><a href=\"http://www.paincker.com/gradle-dependencies\" target=\"_blank\" rel=\"noopener\">http://www.paincker.com/gradle-dependencies</a></p>\n","site":{"data":{}},"excerpt":"","more":"<pre><code>gradlew -q dependencies app:dependencies --configuration compile\n</code></pre><p>輸入該命令，查看依賴項</p>\n<p>參考</p>\n<p><a href=\"http://www.paincker.com/gradle-dependencies\" target=\"_blank\" rel=\"noopener\">http://www.paincker.com/gradle-dependencies</a></p>\n"},{"title":"Android Gradlew","date":"2018-10-02T01:09:09.000Z","_content":"gradlew app:dependencies\n\n","source":"_posts/android/gradle.md","raw":"---\ntitle: Android Gradlew\ndate: 2018-10-02 09:09:09\ncategories: Android\n---\ngradlew app:dependencies\n\n","slug":"android/gradle","published":1,"updated":"2018-10-02T02:53:13.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4nc0030ntnbgj3i6grc","content":"<p>gradlew app:dependencies</p>\n","site":{"data":{}},"excerpt":"","more":"<p>gradlew app:dependencies</p>\n"},{"title":"Android音频开发","_content":"## Android音频开发\n\n### Android音频简介\n\n更加详尽的参考：\n\n [http://www.jianshu.com/p/2cb75a71009f](http://www.jianshu.com/p/2cb75a71009f)\n\n [http://blog.csdn.net/cjh\\_android/article/details/51341004](http://blog.csdn.net/cjh_android/article/details/51341004)\n\n 其他下载网站：[https://www.xiph.org/downloads/](https://www.xiph.org/downloads/)\n\n#### **AudioRecord**\n\n主要是实现边录边播（AudioRecord+AudioTrack）以及对音频的实时处理（如会说话的汤姆猫、语音）\n\n优点：语音的实时处理，可以用代码实现各种音频的封装\n\n缺点：输出是PCM语音数据，如果保存成音频文件，是不能够被播放器播放的，所以必须先写代码实现数据编码以及压缩\n\n示例：\n\n使用AudioRecord类录音，并实现WAV格式封装。录音20s，输出的音频文件大概为3.5M左右（已写测试代码）\n\n#### **MediaRecorder**\n\n已经集成了录音、编码、压缩等，支持少量的录音音频格式，大概有.aac（API = 16） .amr .3gp\n\n优点：大部分以及集成，直接调用相关接口即可，代码量小\n\n缺点：无法实时处理音频；输出的音频格式不是很多，例如没有输出mp3格式文件\n\n示例：\n\n使用MediaRecorder类录音，输出amr格式文件。录音20s，输出的音频文件大概为33K（已写测试代码）\n\n#### **音频格式比较**\n\nWAV格式：录音质量高，但是压缩率小，文件大\n\nAAC格式：相对于mp3，AAC格式的音质更佳，文件更小；有损压缩；一般苹果或者Android SDK4.1.2（API 16）及以上版本支持播放\n\nAMR格式：压缩比比较大，但相对其他的压缩格式质量比较差，多用于人声，通话录音\n\n至于常用的mp3格式，使用MediaRecorder没有该视频格式输出。一些人的做法是使用AudioRecord录音，然后编码成wav格式，再转换成mp3格式\n\n---\n\n### Android关于MediaRecorder开发\n\n采用频率（the sampling rate）：模拟信息转成数字信号的采样率。\n\n采样位数：8位 或者 16位 去存储每一次的采样结果。\n\n声道数：单声道，立体声道。\n\n比特率（Bit rate ）/位率：声音中的比特率是指将模拟声音信号转换成数字声音信号后，单位时间内的二进制数据量，是间接衡量音频质量的一个指标。\n\n比特率\\(bps\\) = 采样频率（HZ）采样位数（Bit）声道数\n\n```java\nsetAudioEncodingBitRate\n\nMediaRecorder recorder = new MediaRecorder();\nrecorder.setAudioSource(MediaRecorder.AudioSource.MIC);\nif (Build.VERSION.SDK_INT >= 10) {\n    recorder.setAudioSamplingRate(44100);\n    recorder.setAudioEncodingBitRate(96000);\n    recorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);\n    recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\n} else {\n    // older version of Android, use crappy sounding voice codec\n    recorder.setAudioSamplingRate(8000);\n    recorder.setAudioEncodingBitRate(12200);\n    recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);\n    recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);\n}\nrecorder.setOutputFile(file.getAbsolutePath());\ntry {\n    recorder.prepare();\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n```\n\nsetAudioEncodingBitRate\n\n这个方法，声音会变得奇怪，类似回音之类，这个参数会影响输出文件的效果，尽量按照bit rate设置。\n\nsetAudioSamplingRate\n\n一般参数为44100 16000 11025，这个影响文件采集效果，直接影响录音质量和文件大小。\n\n---\n\n### Android关于AudioRecorder开发\n\n> 参考：[http://www.cnblogs.com/tyjsjl/p/3695122.html](http://www.cnblogs.com/tyjsjl/p/3695122.html)\n\n---\n\n### 使用FFmpeg\n\n> 项目地址：[https://github.com/WritingMinds/ffmpeg-android-java](https://github.com/WritingMinds/ffmpeg-android-java)\n\n---\n\n### MediaRecorder和AudioRecorder获取分贝\n\n在使用AudioRecorder的时候读取流计算分贝必须要用short\\[\\]类型计算\n\n> [http://blog.csdn.net/sno\\_guo/article/details/42428587](http://blog.csdn.net/sno_guo/article/details/42428587)\n\n\n\n","source":"_posts/android/androidyin-pin-kai-fa.md","raw":"---\ntitle: Android音频开发\ncategory: Android\n---\n## Android音频开发\n\n### Android音频简介\n\n更加详尽的参考：\n\n [http://www.jianshu.com/p/2cb75a71009f](http://www.jianshu.com/p/2cb75a71009f)\n\n [http://blog.csdn.net/cjh\\_android/article/details/51341004](http://blog.csdn.net/cjh_android/article/details/51341004)\n\n 其他下载网站：[https://www.xiph.org/downloads/](https://www.xiph.org/downloads/)\n\n#### **AudioRecord**\n\n主要是实现边录边播（AudioRecord+AudioTrack）以及对音频的实时处理（如会说话的汤姆猫、语音）\n\n优点：语音的实时处理，可以用代码实现各种音频的封装\n\n缺点：输出是PCM语音数据，如果保存成音频文件，是不能够被播放器播放的，所以必须先写代码实现数据编码以及压缩\n\n示例：\n\n使用AudioRecord类录音，并实现WAV格式封装。录音20s，输出的音频文件大概为3.5M左右（已写测试代码）\n\n#### **MediaRecorder**\n\n已经集成了录音、编码、压缩等，支持少量的录音音频格式，大概有.aac（API = 16） .amr .3gp\n\n优点：大部分以及集成，直接调用相关接口即可，代码量小\n\n缺点：无法实时处理音频；输出的音频格式不是很多，例如没有输出mp3格式文件\n\n示例：\n\n使用MediaRecorder类录音，输出amr格式文件。录音20s，输出的音频文件大概为33K（已写测试代码）\n\n#### **音频格式比较**\n\nWAV格式：录音质量高，但是压缩率小，文件大\n\nAAC格式：相对于mp3，AAC格式的音质更佳，文件更小；有损压缩；一般苹果或者Android SDK4.1.2（API 16）及以上版本支持播放\n\nAMR格式：压缩比比较大，但相对其他的压缩格式质量比较差，多用于人声，通话录音\n\n至于常用的mp3格式，使用MediaRecorder没有该视频格式输出。一些人的做法是使用AudioRecord录音，然后编码成wav格式，再转换成mp3格式\n\n---\n\n### Android关于MediaRecorder开发\n\n采用频率（the sampling rate）：模拟信息转成数字信号的采样率。\n\n采样位数：8位 或者 16位 去存储每一次的采样结果。\n\n声道数：单声道，立体声道。\n\n比特率（Bit rate ）/位率：声音中的比特率是指将模拟声音信号转换成数字声音信号后，单位时间内的二进制数据量，是间接衡量音频质量的一个指标。\n\n比特率\\(bps\\) = 采样频率（HZ）采样位数（Bit）声道数\n\n```java\nsetAudioEncodingBitRate\n\nMediaRecorder recorder = new MediaRecorder();\nrecorder.setAudioSource(MediaRecorder.AudioSource.MIC);\nif (Build.VERSION.SDK_INT >= 10) {\n    recorder.setAudioSamplingRate(44100);\n    recorder.setAudioEncodingBitRate(96000);\n    recorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);\n    recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\n} else {\n    // older version of Android, use crappy sounding voice codec\n    recorder.setAudioSamplingRate(8000);\n    recorder.setAudioEncodingBitRate(12200);\n    recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);\n    recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);\n}\nrecorder.setOutputFile(file.getAbsolutePath());\ntry {\n    recorder.prepare();\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n```\n\nsetAudioEncodingBitRate\n\n这个方法，声音会变得奇怪，类似回音之类，这个参数会影响输出文件的效果，尽量按照bit rate设置。\n\nsetAudioSamplingRate\n\n一般参数为44100 16000 11025，这个影响文件采集效果，直接影响录音质量和文件大小。\n\n---\n\n### Android关于AudioRecorder开发\n\n> 参考：[http://www.cnblogs.com/tyjsjl/p/3695122.html](http://www.cnblogs.com/tyjsjl/p/3695122.html)\n\n---\n\n### 使用FFmpeg\n\n> 项目地址：[https://github.com/WritingMinds/ffmpeg-android-java](https://github.com/WritingMinds/ffmpeg-android-java)\n\n---\n\n### MediaRecorder和AudioRecorder获取分贝\n\n在使用AudioRecorder的时候读取流计算分贝必须要用short\\[\\]类型计算\n\n> [http://blog.csdn.net/sno\\_guo/article/details/42428587](http://blog.csdn.net/sno_guo/article/details/42428587)\n\n\n\n","slug":"android/androidyin-pin-kai-fa","published":1,"date":"2018-09-12T06:27:55.805Z","updated":"2018-10-02T02:52:44.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4nc0031ntnbuflp886o","content":"<h2 id=\"Android音频开发\"><a href=\"#Android音频开发\" class=\"headerlink\" title=\"Android音频开发\"></a>Android音频开发</h2><h3 id=\"Android音频简介\"><a href=\"#Android音频简介\" class=\"headerlink\" title=\"Android音频简介\"></a>Android音频简介</h3><p>更加详尽的参考：</p>\n<p> <a href=\"http://www.jianshu.com/p/2cb75a71009f\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/2cb75a71009f</a></p>\n<p> <a href=\"http://blog.csdn.net/cjh_android/article/details/51341004\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/cjh_android/article/details/51341004</a></p>\n<p> 其他下载网站：<a href=\"https://www.xiph.org/downloads/\" target=\"_blank\" rel=\"noopener\">https://www.xiph.org/downloads/</a></p>\n<h4 id=\"AudioRecord\"><a href=\"#AudioRecord\" class=\"headerlink\" title=\"AudioRecord\"></a><strong>AudioRecord</strong></h4><p>主要是实现边录边播（AudioRecord+AudioTrack）以及对音频的实时处理（如会说话的汤姆猫、语音）</p>\n<p>优点：语音的实时处理，可以用代码实现各种音频的封装</p>\n<p>缺点：输出是PCM语音数据，如果保存成音频文件，是不能够被播放器播放的，所以必须先写代码实现数据编码以及压缩</p>\n<p>示例：</p>\n<p>使用AudioRecord类录音，并实现WAV格式封装。录音20s，输出的音频文件大概为3.5M左右（已写测试代码）</p>\n<h4 id=\"MediaRecorder\"><a href=\"#MediaRecorder\" class=\"headerlink\" title=\"MediaRecorder\"></a><strong>MediaRecorder</strong></h4><p>已经集成了录音、编码、压缩等，支持少量的录音音频格式，大概有.aac（API = 16） .amr .3gp</p>\n<p>优点：大部分以及集成，直接调用相关接口即可，代码量小</p>\n<p>缺点：无法实时处理音频；输出的音频格式不是很多，例如没有输出mp3格式文件</p>\n<p>示例：</p>\n<p>使用MediaRecorder类录音，输出amr格式文件。录音20s，输出的音频文件大概为33K（已写测试代码）</p>\n<h4 id=\"音频格式比较\"><a href=\"#音频格式比较\" class=\"headerlink\" title=\"音频格式比较\"></a><strong>音频格式比较</strong></h4><p>WAV格式：录音质量高，但是压缩率小，文件大</p>\n<p>AAC格式：相对于mp3，AAC格式的音质更佳，文件更小；有损压缩；一般苹果或者Android SDK4.1.2（API 16）及以上版本支持播放</p>\n<p>AMR格式：压缩比比较大，但相对其他的压缩格式质量比较差，多用于人声，通话录音</p>\n<p>至于常用的mp3格式，使用MediaRecorder没有该视频格式输出。一些人的做法是使用AudioRecord录音，然后编码成wav格式，再转换成mp3格式</p>\n<hr>\n<h3 id=\"Android关于MediaRecorder开发\"><a href=\"#Android关于MediaRecorder开发\" class=\"headerlink\" title=\"Android关于MediaRecorder开发\"></a>Android关于MediaRecorder开发</h3><p>采用频率（the sampling rate）：模拟信息转成数字信号的采样率。</p>\n<p>采样位数：8位 或者 16位 去存储每一次的采样结果。</p>\n<p>声道数：单声道，立体声道。</p>\n<p>比特率（Bit rate ）/位率：声音中的比特率是指将模拟声音信号转换成数字声音信号后，单位时间内的二进制数据量，是间接衡量音频质量的一个指标。</p>\n<p>比特率(bps) = 采样频率（HZ）采样位数（Bit）声道数</p>\n<pre><code class=\"java\">setAudioEncodingBitRate\n\nMediaRecorder recorder = new MediaRecorder();\nrecorder.setAudioSource(MediaRecorder.AudioSource.MIC);\nif (Build.VERSION.SDK_INT &gt;= 10) {\n    recorder.setAudioSamplingRate(44100);\n    recorder.setAudioEncodingBitRate(96000);\n    recorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);\n    recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\n} else {\n    // older version of Android, use crappy sounding voice codec\n    recorder.setAudioSamplingRate(8000);\n    recorder.setAudioEncodingBitRate(12200);\n    recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);\n    recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);\n}\nrecorder.setOutputFile(file.getAbsolutePath());\ntry {\n    recorder.prepare();\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n</code></pre>\n<p>setAudioEncodingBitRate</p>\n<p>这个方法，声音会变得奇怪，类似回音之类，这个参数会影响输出文件的效果，尽量按照bit rate设置。</p>\n<p>setAudioSamplingRate</p>\n<p>一般参数为44100 16000 11025，这个影响文件采集效果，直接影响录音质量和文件大小。</p>\n<hr>\n<h3 id=\"Android关于AudioRecorder开发\"><a href=\"#Android关于AudioRecorder开发\" class=\"headerlink\" title=\"Android关于AudioRecorder开发\"></a>Android关于AudioRecorder开发</h3><blockquote>\n<p>参考：<a href=\"http://www.cnblogs.com/tyjsjl/p/3695122.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/tyjsjl/p/3695122.html</a></p>\n</blockquote>\n<hr>\n<h3 id=\"使用FFmpeg\"><a href=\"#使用FFmpeg\" class=\"headerlink\" title=\"使用FFmpeg\"></a>使用FFmpeg</h3><blockquote>\n<p>项目地址：<a href=\"https://github.com/WritingMinds/ffmpeg-android-java\" target=\"_blank\" rel=\"noopener\">https://github.com/WritingMinds/ffmpeg-android-java</a></p>\n</blockquote>\n<hr>\n<h3 id=\"MediaRecorder和AudioRecorder获取分贝\"><a href=\"#MediaRecorder和AudioRecorder获取分贝\" class=\"headerlink\" title=\"MediaRecorder和AudioRecorder获取分贝\"></a>MediaRecorder和AudioRecorder获取分贝</h3><p>在使用AudioRecorder的时候读取流计算分贝必须要用short[]类型计算</p>\n<blockquote>\n<p><a href=\"http://blog.csdn.net/sno_guo/article/details/42428587\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/sno_guo/article/details/42428587</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android音频开发\"><a href=\"#Android音频开发\" class=\"headerlink\" title=\"Android音频开发\"></a>Android音频开发</h2><h3 id=\"Android音频简介\"><a href=\"#Android音频简介\" class=\"headerlink\" title=\"Android音频简介\"></a>Android音频简介</h3><p>更加详尽的参考：</p>\n<p> <a href=\"http://www.jianshu.com/p/2cb75a71009f\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/2cb75a71009f</a></p>\n<p> <a href=\"http://blog.csdn.net/cjh_android/article/details/51341004\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/cjh_android/article/details/51341004</a></p>\n<p> 其他下载网站：<a href=\"https://www.xiph.org/downloads/\" target=\"_blank\" rel=\"noopener\">https://www.xiph.org/downloads/</a></p>\n<h4 id=\"AudioRecord\"><a href=\"#AudioRecord\" class=\"headerlink\" title=\"AudioRecord\"></a><strong>AudioRecord</strong></h4><p>主要是实现边录边播（AudioRecord+AudioTrack）以及对音频的实时处理（如会说话的汤姆猫、语音）</p>\n<p>优点：语音的实时处理，可以用代码实现各种音频的封装</p>\n<p>缺点：输出是PCM语音数据，如果保存成音频文件，是不能够被播放器播放的，所以必须先写代码实现数据编码以及压缩</p>\n<p>示例：</p>\n<p>使用AudioRecord类录音，并实现WAV格式封装。录音20s，输出的音频文件大概为3.5M左右（已写测试代码）</p>\n<h4 id=\"MediaRecorder\"><a href=\"#MediaRecorder\" class=\"headerlink\" title=\"MediaRecorder\"></a><strong>MediaRecorder</strong></h4><p>已经集成了录音、编码、压缩等，支持少量的录音音频格式，大概有.aac（API = 16） .amr .3gp</p>\n<p>优点：大部分以及集成，直接调用相关接口即可，代码量小</p>\n<p>缺点：无法实时处理音频；输出的音频格式不是很多，例如没有输出mp3格式文件</p>\n<p>示例：</p>\n<p>使用MediaRecorder类录音，输出amr格式文件。录音20s，输出的音频文件大概为33K（已写测试代码）</p>\n<h4 id=\"音频格式比较\"><a href=\"#音频格式比较\" class=\"headerlink\" title=\"音频格式比较\"></a><strong>音频格式比较</strong></h4><p>WAV格式：录音质量高，但是压缩率小，文件大</p>\n<p>AAC格式：相对于mp3，AAC格式的音质更佳，文件更小；有损压缩；一般苹果或者Android SDK4.1.2（API 16）及以上版本支持播放</p>\n<p>AMR格式：压缩比比较大，但相对其他的压缩格式质量比较差，多用于人声，通话录音</p>\n<p>至于常用的mp3格式，使用MediaRecorder没有该视频格式输出。一些人的做法是使用AudioRecord录音，然后编码成wav格式，再转换成mp3格式</p>\n<hr>\n<h3 id=\"Android关于MediaRecorder开发\"><a href=\"#Android关于MediaRecorder开发\" class=\"headerlink\" title=\"Android关于MediaRecorder开发\"></a>Android关于MediaRecorder开发</h3><p>采用频率（the sampling rate）：模拟信息转成数字信号的采样率。</p>\n<p>采样位数：8位 或者 16位 去存储每一次的采样结果。</p>\n<p>声道数：单声道，立体声道。</p>\n<p>比特率（Bit rate ）/位率：声音中的比特率是指将模拟声音信号转换成数字声音信号后，单位时间内的二进制数据量，是间接衡量音频质量的一个指标。</p>\n<p>比特率(bps) = 采样频率（HZ）采样位数（Bit）声道数</p>\n<pre><code class=\"java\">setAudioEncodingBitRate\n\nMediaRecorder recorder = new MediaRecorder();\nrecorder.setAudioSource(MediaRecorder.AudioSource.MIC);\nif (Build.VERSION.SDK_INT &gt;= 10) {\n    recorder.setAudioSamplingRate(44100);\n    recorder.setAudioEncodingBitRate(96000);\n    recorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);\n    recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\n} else {\n    // older version of Android, use crappy sounding voice codec\n    recorder.setAudioSamplingRate(8000);\n    recorder.setAudioEncodingBitRate(12200);\n    recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);\n    recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);\n}\nrecorder.setOutputFile(file.getAbsolutePath());\ntry {\n    recorder.prepare();\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n</code></pre>\n<p>setAudioEncodingBitRate</p>\n<p>这个方法，声音会变得奇怪，类似回音之类，这个参数会影响输出文件的效果，尽量按照bit rate设置。</p>\n<p>setAudioSamplingRate</p>\n<p>一般参数为44100 16000 11025，这个影响文件采集效果，直接影响录音质量和文件大小。</p>\n<hr>\n<h3 id=\"Android关于AudioRecorder开发\"><a href=\"#Android关于AudioRecorder开发\" class=\"headerlink\" title=\"Android关于AudioRecorder开发\"></a>Android关于AudioRecorder开发</h3><blockquote>\n<p>参考：<a href=\"http://www.cnblogs.com/tyjsjl/p/3695122.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/tyjsjl/p/3695122.html</a></p>\n</blockquote>\n<hr>\n<h3 id=\"使用FFmpeg\"><a href=\"#使用FFmpeg\" class=\"headerlink\" title=\"使用FFmpeg\"></a>使用FFmpeg</h3><blockquote>\n<p>项目地址：<a href=\"https://github.com/WritingMinds/ffmpeg-android-java\" target=\"_blank\" rel=\"noopener\">https://github.com/WritingMinds/ffmpeg-android-java</a></p>\n</blockquote>\n<hr>\n<h3 id=\"MediaRecorder和AudioRecorder获取分贝\"><a href=\"#MediaRecorder和AudioRecorder获取分贝\" class=\"headerlink\" title=\"MediaRecorder和AudioRecorder获取分贝\"></a>MediaRecorder和AudioRecorder获取分贝</h3><p>在使用AudioRecorder的时候读取流计算分贝必须要用short[]类型计算</p>\n<blockquote>\n<p><a href=\"http://blog.csdn.net/sno_guo/article/details/42428587\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/sno_guo/article/details/42428587</a></p>\n</blockquote>\n"},{"title":"html 模板下載方案ts.txt文件","date":"2018-10-02T01:09:09.000Z","_content":"html 模板下載方案：\n\n![](/assets/html_download.png)\n\njs native 通訊方案：\n\n![](/assets/js_call_native2.png)\n\n","source":"_posts/hybrid/note.md","raw":"---\ntitle: html 模板下載方案ts.txt文件\ndate: 2018-10-02 09:09:09\ncategories: hybrid\n---\nhtml 模板下載方案：\n\n![](/assets/html_download.png)\n\njs native 通訊方案：\n\n![](/assets/js_call_native2.png)\n\n","slug":"hybrid/note","published":1,"updated":"2018-10-02T07:26:06.127Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4ne0034ntnbqh23kvzo","content":"<p>html 模板下載方案：</p>\n<p><img src=\"/assets/html_download.png\" alt=\"\"></p>\n<p>js native 通訊方案：</p>\n<p><img src=\"/assets/js_call_native2.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>html 模板下載方案：</p>\n<p><img src=\"/assets/html_download.png\" alt=\"\"></p>\n<p>js native 通訊方案：</p>\n<p><img src=\"/assets/js_call_native2.png\" alt=\"\"></p>\n"},{"title":"iOS Note","date":"2018-10-02T01:09:09.000Z","_content":"## iOS Note\n\n---\n\n### 1.WebView加载本地html\n\n```\n        let htmlFile = NSBundle.mainBundle().pathForResource(\"BullsEye\", ofType: \"html\")!;\n        let htmlData = NSData(contentsOfFile: htmlFile)!;\n        let baseURL = NSURL.fileURLWithPath(NSBundle.mainBundle().bundlePath);\n        print(\"htmlData =\\(htmlData)\");\n        print(\"baseURL =\\(baseURL)\");\n\n        webView.loadData(htmlData, MIMEType: \"text/html\", textEncodingName: \"UTF-8\", baseURL: baseURL);\n```\n\n---\n\n## 2.WebView加载网址\n\n```\n        let url = NSURL(string: \"https://www.baidu.com\");\n        let request = NSURLRequest(URL: url!);\n        webView.loadRequest(request);\n```\n\n在info.plist添加\n\nApp Transport Security Settings\n\n－－Allow Arbitrary Loads  -&gt; YES\n\n---\n\n## 3.iOS库\n\n1.AFNetworking\n\n轻量级而又超级高效的iOS忘了编程框架，支持iOS5.0及以上版本\n\n2.GPUImage\n\n处理图片框架，实时照片和视频处理，使用gpu而不是cpu，从而大大提高呈现运行效率。比苹果官方的Core Image还要快，不过缺少一些先进的功能，比如Core Image的面部识别。\n\n3.SocketRocket\n\n在iOS开发中和Web sockets通讯。轻松实现单一TCP连接的双工交流。但只有部分浏览器支持。\n\n4.HocketKit & Crashlity\n\n崩溃报告\n\n5.JSONKit & NSJSONSerialization\n\n高速解析JSON\n\n6.MagicalRecord\n\ncore data操作\n\n7.RestKit\n\n和REST远程API整合，可以出来网络事务，解析xml或JSON，并转换成自定义的类\n\n## Optional\n\n一个Optional值和非Optional值的区别就在于：Optional值未经初始化虽然为nil，但普通变量连nil都没有\n\n```\n//未被初始化，但是是一个Optional类型，为nil\nvar str: String?\nstr //输出nil\n//未被初始化，也不是Optional类型\nvar str2: String\nstr2    //使用时出错\n```\n\n显式拆包\n\n```\nvar str: String? = \"Hello World!\"\nstr     //{Some \"Hello World!\"}\nstr!    //Hello World!\n```\n\n隐式拆包\n\n```\nvar str: String! = \"Hello World!\"\nstr //Hello World!\n```\n\n## 不带参数函数\n\n```\nfunc funcname() -> datatype {\n   return datatype\n}\n```\n\n## 元组作为函数返回值\n\n```\nfunc minMax(array: [Int]) -> (min: Int, max: Int) {\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..<array.count] {\n        if value < currentMin {\n            currentMin = value\n        } else if value > currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\n\nlet bounds = minMax(array: [8, -6, 2, 109, 3, 71])\nprint(\"最小值为 \\(bounds.min) ，最大值为 \\(bounds.max)\")\n```\n\n```\nfunc minMax(array: [Int]) -> (min: Int, max: Int)? {\n    if array.isEmpty { return nil }\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..<array.count] {\n        if value < currentMin {\n            currentMin = value\n        } else if value > currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\nif let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {\n    print(\"最小值为 \\(bounds.min)，组大值为 \\(bounds.max)\")\n}\n```\n\n## 可变参数\n\n```\nfunc vari<N>(members: N...){\n    for i in members {\n        print(i)\n    }\n}\nvari(members: 4,3,5)\nvari(members: 4.5, 3.1, 5.6)\nvari(members: \"Google\", \"Baidu\", \"Runoob\")\n```\n\n### 使用函数类型\n\n```\nfunc sum(a: Int, b: Int) -> Int {\n   return a + b\n}\nvar addition: (Int, Int) -> Int = sum\nprint(\"输出结果: \\(addition(40, 89))\")\n```\n\n## 函数类型作为参数类型、函数类型作为返回类型\n\n```\nfunc sum(a: Int, b: Int) -> Int {\n    return a + b\n}\nvar addition: (Int, Int) -> Int = sum\nprint(\"输出结果: \\(addition(40, 89))\")\n\nfunc another(addition: (Int, Int) -> Int, a: Int, b: Int) {\n    print(\"输出结果: \\(addition(a, b))\")\n}\nanother(addition: sum, a: 10, b: 20)\n```\n\n\n\n","source":"_posts/iOS/iOS Note.md","raw":"---\ntitle: iOS Note\ndate: 2018-10-02 09:09:09\ncategories: iOS\n---\n## iOS Note\n\n---\n\n### 1.WebView加载本地html\n\n```\n        let htmlFile = NSBundle.mainBundle().pathForResource(\"BullsEye\", ofType: \"html\")!;\n        let htmlData = NSData(contentsOfFile: htmlFile)!;\n        let baseURL = NSURL.fileURLWithPath(NSBundle.mainBundle().bundlePath);\n        print(\"htmlData =\\(htmlData)\");\n        print(\"baseURL =\\(baseURL)\");\n\n        webView.loadData(htmlData, MIMEType: \"text/html\", textEncodingName: \"UTF-8\", baseURL: baseURL);\n```\n\n---\n\n## 2.WebView加载网址\n\n```\n        let url = NSURL(string: \"https://www.baidu.com\");\n        let request = NSURLRequest(URL: url!);\n        webView.loadRequest(request);\n```\n\n在info.plist添加\n\nApp Transport Security Settings\n\n－－Allow Arbitrary Loads  -&gt; YES\n\n---\n\n## 3.iOS库\n\n1.AFNetworking\n\n轻量级而又超级高效的iOS忘了编程框架，支持iOS5.0及以上版本\n\n2.GPUImage\n\n处理图片框架，实时照片和视频处理，使用gpu而不是cpu，从而大大提高呈现运行效率。比苹果官方的Core Image还要快，不过缺少一些先进的功能，比如Core Image的面部识别。\n\n3.SocketRocket\n\n在iOS开发中和Web sockets通讯。轻松实现单一TCP连接的双工交流。但只有部分浏览器支持。\n\n4.HocketKit & Crashlity\n\n崩溃报告\n\n5.JSONKit & NSJSONSerialization\n\n高速解析JSON\n\n6.MagicalRecord\n\ncore data操作\n\n7.RestKit\n\n和REST远程API整合，可以出来网络事务，解析xml或JSON，并转换成自定义的类\n\n## Optional\n\n一个Optional值和非Optional值的区别就在于：Optional值未经初始化虽然为nil，但普通变量连nil都没有\n\n```\n//未被初始化，但是是一个Optional类型，为nil\nvar str: String?\nstr //输出nil\n//未被初始化，也不是Optional类型\nvar str2: String\nstr2    //使用时出错\n```\n\n显式拆包\n\n```\nvar str: String? = \"Hello World!\"\nstr     //{Some \"Hello World!\"}\nstr!    //Hello World!\n```\n\n隐式拆包\n\n```\nvar str: String! = \"Hello World!\"\nstr //Hello World!\n```\n\n## 不带参数函数\n\n```\nfunc funcname() -> datatype {\n   return datatype\n}\n```\n\n## 元组作为函数返回值\n\n```\nfunc minMax(array: [Int]) -> (min: Int, max: Int) {\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..<array.count] {\n        if value < currentMin {\n            currentMin = value\n        } else if value > currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\n\nlet bounds = minMax(array: [8, -6, 2, 109, 3, 71])\nprint(\"最小值为 \\(bounds.min) ，最大值为 \\(bounds.max)\")\n```\n\n```\nfunc minMax(array: [Int]) -> (min: Int, max: Int)? {\n    if array.isEmpty { return nil }\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..<array.count] {\n        if value < currentMin {\n            currentMin = value\n        } else if value > currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\nif let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {\n    print(\"最小值为 \\(bounds.min)，组大值为 \\(bounds.max)\")\n}\n```\n\n## 可变参数\n\n```\nfunc vari<N>(members: N...){\n    for i in members {\n        print(i)\n    }\n}\nvari(members: 4,3,5)\nvari(members: 4.5, 3.1, 5.6)\nvari(members: \"Google\", \"Baidu\", \"Runoob\")\n```\n\n### 使用函数类型\n\n```\nfunc sum(a: Int, b: Int) -> Int {\n   return a + b\n}\nvar addition: (Int, Int) -> Int = sum\nprint(\"输出结果: \\(addition(40, 89))\")\n```\n\n## 函数类型作为参数类型、函数类型作为返回类型\n\n```\nfunc sum(a: Int, b: Int) -> Int {\n    return a + b\n}\nvar addition: (Int, Int) -> Int = sum\nprint(\"输出结果: \\(addition(40, 89))\")\n\nfunc another(addition: (Int, Int) -> Int, a: Int, b: Int) {\n    print(\"输出结果: \\(addition(a, b))\")\n}\nanother(addition: sum, a: 10, b: 20)\n```\n\n\n\n","slug":"iOS/iOS Note","published":1,"updated":"2018-10-02T02:09:29.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4ne0035ntnbin9q6kpa","content":"<h2 id=\"iOS-Note\"><a href=\"#iOS-Note\" class=\"headerlink\" title=\"iOS Note\"></a>iOS Note</h2><hr>\n<h3 id=\"1-WebView加载本地html\"><a href=\"#1-WebView加载本地html\" class=\"headerlink\" title=\"1.WebView加载本地html\"></a>1.WebView加载本地html</h3><pre><code>        let htmlFile = NSBundle.mainBundle().pathForResource(&quot;BullsEye&quot;, ofType: &quot;html&quot;)!;\n        let htmlData = NSData(contentsOfFile: htmlFile)!;\n        let baseURL = NSURL.fileURLWithPath(NSBundle.mainBundle().bundlePath);\n        print(&quot;htmlData =\\(htmlData)&quot;);\n        print(&quot;baseURL =\\(baseURL)&quot;);\n\n        webView.loadData(htmlData, MIMEType: &quot;text/html&quot;, textEncodingName: &quot;UTF-8&quot;, baseURL: baseURL);\n</code></pre><hr>\n<h2 id=\"2-WebView加载网址\"><a href=\"#2-WebView加载网址\" class=\"headerlink\" title=\"2.WebView加载网址\"></a>2.WebView加载网址</h2><pre><code>        let url = NSURL(string: &quot;https://www.baidu.com&quot;);\n        let request = NSURLRequest(URL: url!);\n        webView.loadRequest(request);\n</code></pre><p>在info.plist添加</p>\n<p>App Transport Security Settings</p>\n<p>－－Allow Arbitrary Loads  -&gt; YES</p>\n<hr>\n<h2 id=\"3-iOS库\"><a href=\"#3-iOS库\" class=\"headerlink\" title=\"3.iOS库\"></a>3.iOS库</h2><p>1.AFNetworking</p>\n<p>轻量级而又超级高效的iOS忘了编程框架，支持iOS5.0及以上版本</p>\n<p>2.GPUImage</p>\n<p>处理图片框架，实时照片和视频处理，使用gpu而不是cpu，从而大大提高呈现运行效率。比苹果官方的Core Image还要快，不过缺少一些先进的功能，比如Core Image的面部识别。</p>\n<p>3.SocketRocket</p>\n<p>在iOS开发中和Web sockets通讯。轻松实现单一TCP连接的双工交流。但只有部分浏览器支持。</p>\n<p>4.HocketKit &amp; Crashlity</p>\n<p>崩溃报告</p>\n<p>5.JSONKit &amp; NSJSONSerialization</p>\n<p>高速解析JSON</p>\n<p>6.MagicalRecord</p>\n<p>core data操作</p>\n<p>7.RestKit</p>\n<p>和REST远程API整合，可以出来网络事务，解析xml或JSON，并转换成自定义的类</p>\n<h2 id=\"Optional\"><a href=\"#Optional\" class=\"headerlink\" title=\"Optional\"></a>Optional</h2><p>一个Optional值和非Optional值的区别就在于：Optional值未经初始化虽然为nil，但普通变量连nil都没有</p>\n<pre><code>//未被初始化，但是是一个Optional类型，为nil\nvar str: String?\nstr //输出nil\n//未被初始化，也不是Optional类型\nvar str2: String\nstr2    //使用时出错\n</code></pre><p>显式拆包</p>\n<pre><code>var str: String? = &quot;Hello World!&quot;\nstr     //{Some &quot;Hello World!&quot;}\nstr!    //Hello World!\n</code></pre><p>隐式拆包</p>\n<pre><code>var str: String! = &quot;Hello World!&quot;\nstr //Hello World!\n</code></pre><h2 id=\"不带参数函数\"><a href=\"#不带参数函数\" class=\"headerlink\" title=\"不带参数函数\"></a>不带参数函数</h2><pre><code>func funcname() -&gt; datatype {\n   return datatype\n}\n</code></pre><h2 id=\"元组作为函数返回值\"><a href=\"#元组作为函数返回值\" class=\"headerlink\" title=\"元组作为函数返回值\"></a>元组作为函数返回值</h2><pre><code>func minMax(array: [Int]) -&gt; (min: Int, max: Int) {\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..&lt;array.count] {\n        if value &lt; currentMin {\n            currentMin = value\n        } else if value &gt; currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\n\nlet bounds = minMax(array: [8, -6, 2, 109, 3, 71])\nprint(&quot;最小值为 \\(bounds.min) ，最大值为 \\(bounds.max)&quot;)\n</code></pre><pre><code>func minMax(array: [Int]) -&gt; (min: Int, max: Int)? {\n    if array.isEmpty { return nil }\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..&lt;array.count] {\n        if value &lt; currentMin {\n            currentMin = value\n        } else if value &gt; currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\nif let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {\n    print(&quot;最小值为 \\(bounds.min)，组大值为 \\(bounds.max)&quot;)\n}\n</code></pre><h2 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h2><pre><code>func vari&lt;N&gt;(members: N...){\n    for i in members {\n        print(i)\n    }\n}\nvari(members: 4,3,5)\nvari(members: 4.5, 3.1, 5.6)\nvari(members: &quot;Google&quot;, &quot;Baidu&quot;, &quot;Runoob&quot;)\n</code></pre><h3 id=\"使用函数类型\"><a href=\"#使用函数类型\" class=\"headerlink\" title=\"使用函数类型\"></a>使用函数类型</h3><pre><code>func sum(a: Int, b: Int) -&gt; Int {\n   return a + b\n}\nvar addition: (Int, Int) -&gt; Int = sum\nprint(&quot;输出结果: \\(addition(40, 89))&quot;)\n</code></pre><h2 id=\"函数类型作为参数类型、函数类型作为返回类型\"><a href=\"#函数类型作为参数类型、函数类型作为返回类型\" class=\"headerlink\" title=\"函数类型作为参数类型、函数类型作为返回类型\"></a>函数类型作为参数类型、函数类型作为返回类型</h2><pre><code>func sum(a: Int, b: Int) -&gt; Int {\n    return a + b\n}\nvar addition: (Int, Int) -&gt; Int = sum\nprint(&quot;输出结果: \\(addition(40, 89))&quot;)\n\nfunc another(addition: (Int, Int) -&gt; Int, a: Int, b: Int) {\n    print(&quot;输出结果: \\(addition(a, b))&quot;)\n}\nanother(addition: sum, a: 10, b: 20)\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"iOS-Note\"><a href=\"#iOS-Note\" class=\"headerlink\" title=\"iOS Note\"></a>iOS Note</h2><hr>\n<h3 id=\"1-WebView加载本地html\"><a href=\"#1-WebView加载本地html\" class=\"headerlink\" title=\"1.WebView加载本地html\"></a>1.WebView加载本地html</h3><pre><code>        let htmlFile = NSBundle.mainBundle().pathForResource(&quot;BullsEye&quot;, ofType: &quot;html&quot;)!;\n        let htmlData = NSData(contentsOfFile: htmlFile)!;\n        let baseURL = NSURL.fileURLWithPath(NSBundle.mainBundle().bundlePath);\n        print(&quot;htmlData =\\(htmlData)&quot;);\n        print(&quot;baseURL =\\(baseURL)&quot;);\n\n        webView.loadData(htmlData, MIMEType: &quot;text/html&quot;, textEncodingName: &quot;UTF-8&quot;, baseURL: baseURL);\n</code></pre><hr>\n<h2 id=\"2-WebView加载网址\"><a href=\"#2-WebView加载网址\" class=\"headerlink\" title=\"2.WebView加载网址\"></a>2.WebView加载网址</h2><pre><code>        let url = NSURL(string: &quot;https://www.baidu.com&quot;);\n        let request = NSURLRequest(URL: url!);\n        webView.loadRequest(request);\n</code></pre><p>在info.plist添加</p>\n<p>App Transport Security Settings</p>\n<p>－－Allow Arbitrary Loads  -&gt; YES</p>\n<hr>\n<h2 id=\"3-iOS库\"><a href=\"#3-iOS库\" class=\"headerlink\" title=\"3.iOS库\"></a>3.iOS库</h2><p>1.AFNetworking</p>\n<p>轻量级而又超级高效的iOS忘了编程框架，支持iOS5.0及以上版本</p>\n<p>2.GPUImage</p>\n<p>处理图片框架，实时照片和视频处理，使用gpu而不是cpu，从而大大提高呈现运行效率。比苹果官方的Core Image还要快，不过缺少一些先进的功能，比如Core Image的面部识别。</p>\n<p>3.SocketRocket</p>\n<p>在iOS开发中和Web sockets通讯。轻松实现单一TCP连接的双工交流。但只有部分浏览器支持。</p>\n<p>4.HocketKit &amp; Crashlity</p>\n<p>崩溃报告</p>\n<p>5.JSONKit &amp; NSJSONSerialization</p>\n<p>高速解析JSON</p>\n<p>6.MagicalRecord</p>\n<p>core data操作</p>\n<p>7.RestKit</p>\n<p>和REST远程API整合，可以出来网络事务，解析xml或JSON，并转换成自定义的类</p>\n<h2 id=\"Optional\"><a href=\"#Optional\" class=\"headerlink\" title=\"Optional\"></a>Optional</h2><p>一个Optional值和非Optional值的区别就在于：Optional值未经初始化虽然为nil，但普通变量连nil都没有</p>\n<pre><code>//未被初始化，但是是一个Optional类型，为nil\nvar str: String?\nstr //输出nil\n//未被初始化，也不是Optional类型\nvar str2: String\nstr2    //使用时出错\n</code></pre><p>显式拆包</p>\n<pre><code>var str: String? = &quot;Hello World!&quot;\nstr     //{Some &quot;Hello World!&quot;}\nstr!    //Hello World!\n</code></pre><p>隐式拆包</p>\n<pre><code>var str: String! = &quot;Hello World!&quot;\nstr //Hello World!\n</code></pre><h2 id=\"不带参数函数\"><a href=\"#不带参数函数\" class=\"headerlink\" title=\"不带参数函数\"></a>不带参数函数</h2><pre><code>func funcname() -&gt; datatype {\n   return datatype\n}\n</code></pre><h2 id=\"元组作为函数返回值\"><a href=\"#元组作为函数返回值\" class=\"headerlink\" title=\"元组作为函数返回值\"></a>元组作为函数返回值</h2><pre><code>func minMax(array: [Int]) -&gt; (min: Int, max: Int) {\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..&lt;array.count] {\n        if value &lt; currentMin {\n            currentMin = value\n        } else if value &gt; currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\n\nlet bounds = minMax(array: [8, -6, 2, 109, 3, 71])\nprint(&quot;最小值为 \\(bounds.min) ，最大值为 \\(bounds.max)&quot;)\n</code></pre><pre><code>func minMax(array: [Int]) -&gt; (min: Int, max: Int)? {\n    if array.isEmpty { return nil }\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..&lt;array.count] {\n        if value &lt; currentMin {\n            currentMin = value\n        } else if value &gt; currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\nif let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {\n    print(&quot;最小值为 \\(bounds.min)，组大值为 \\(bounds.max)&quot;)\n}\n</code></pre><h2 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h2><pre><code>func vari&lt;N&gt;(members: N...){\n    for i in members {\n        print(i)\n    }\n}\nvari(members: 4,3,5)\nvari(members: 4.5, 3.1, 5.6)\nvari(members: &quot;Google&quot;, &quot;Baidu&quot;, &quot;Runoob&quot;)\n</code></pre><h3 id=\"使用函数类型\"><a href=\"#使用函数类型\" class=\"headerlink\" title=\"使用函数类型\"></a>使用函数类型</h3><pre><code>func sum(a: Int, b: Int) -&gt; Int {\n   return a + b\n}\nvar addition: (Int, Int) -&gt; Int = sum\nprint(&quot;输出结果: \\(addition(40, 89))&quot;)\n</code></pre><h2 id=\"函数类型作为参数类型、函数类型作为返回类型\"><a href=\"#函数类型作为参数类型、函数类型作为返回类型\" class=\"headerlink\" title=\"函数类型作为参数类型、函数类型作为返回类型\"></a>函数类型作为参数类型、函数类型作为返回类型</h2><pre><code>func sum(a: Int, b: Int) -&gt; Int {\n    return a + b\n}\nvar addition: (Int, Int) -&gt; Int = sum\nprint(&quot;输出结果: \\(addition(40, 89))&quot;)\n\nfunc another(addition: (Int, Int) -&gt; Int, a: Int, b: Int) {\n    print(&quot;输出结果: \\(addition(a, b))&quot;)\n}\nanother(addition: sum, a: 10, b: 20)\n</code></pre>"},{"title":"iOS Note","date":"2018-10-02T01:09:09.000Z","_content":"","source":"_posts/iOS/ios-noteiosios-notemd.md","raw":"---\ntitle: iOS Note\ndate: 2018-10-02 09:09:09\ncategories: iOS\n---","slug":"iOS/ios-noteiosios-notemd","published":1,"updated":"2018-10-02T02:09:38.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4ng0038ntnbf4v4k9qy","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"NSUserDefaults存储数据","date":"2018-10-02T01:09:09.000Z","_content":"### NSUserDefaults存储数据\n\n一般我们拿它用来保存应用程序设置和属性、用户保存的数据,用户的手机不管是关机or开机时候都会保存在本地\\(除非你把他删除了\\),它一般可以存储类型包括:字符,数组,字典,NSData,NSNumber以及基本数据类型都可.\n\n### write写入方式存储为plist属性列表\n\nwrite写入方式也是一种把数据永久保存在磁盘中储存方式,一般步骤:1\\)获取路径\\(一般有两种方式:使用NSSearchPathForDirectoriesInDomains或URLsForDirectory;使用NSHomeDirectory➕相应的路径\\);2\\)向文件中写入数据;3\\)从文件中读取数据.\n\n### NSKeyedArchiver采用归档的形式来保存数据\n\nNSKeyedArchiver保存数据对象需要遵守NSCoding协议，并且该对象对应的类必须提供encodeWithCoder:和initWithCoder:方法,简单的说就是告诉系统怎么对对象进行编码，怎么对对象进行解码.\n\n","source":"_posts/iOS/ios-shu-ju-cun-chu.md","raw":"---\ntitle: NSUserDefaults存储数据\ndate: 2018-10-02 09:09:09\ncategories: iOS\n---\n### NSUserDefaults存储数据\n\n一般我们拿它用来保存应用程序设置和属性、用户保存的数据,用户的手机不管是关机or开机时候都会保存在本地\\(除非你把他删除了\\),它一般可以存储类型包括:字符,数组,字典,NSData,NSNumber以及基本数据类型都可.\n\n### write写入方式存储为plist属性列表\n\nwrite写入方式也是一种把数据永久保存在磁盘中储存方式,一般步骤:1\\)获取路径\\(一般有两种方式:使用NSSearchPathForDirectoriesInDomains或URLsForDirectory;使用NSHomeDirectory➕相应的路径\\);2\\)向文件中写入数据;3\\)从文件中读取数据.\n\n### NSKeyedArchiver采用归档的形式来保存数据\n\nNSKeyedArchiver保存数据对象需要遵守NSCoding协议，并且该对象对应的类必须提供encodeWithCoder:和initWithCoder:方法,简单的说就是告诉系统怎么对对象进行编码，怎么对对象进行解码.\n\n","slug":"iOS/ios-shu-ju-cun-chu","published":1,"updated":"2018-10-02T02:09:53.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4ng0039ntnb49fmmud1","content":"<h3 id=\"NSUserDefaults存储数据\"><a href=\"#NSUserDefaults存储数据\" class=\"headerlink\" title=\"NSUserDefaults存储数据\"></a>NSUserDefaults存储数据</h3><p>一般我们拿它用来保存应用程序设置和属性、用户保存的数据,用户的手机不管是关机or开机时候都会保存在本地(除非你把他删除了),它一般可以存储类型包括:字符,数组,字典,NSData,NSNumber以及基本数据类型都可.</p>\n<h3 id=\"write写入方式存储为plist属性列表\"><a href=\"#write写入方式存储为plist属性列表\" class=\"headerlink\" title=\"write写入方式存储为plist属性列表\"></a>write写入方式存储为plist属性列表</h3><p>write写入方式也是一种把数据永久保存在磁盘中储存方式,一般步骤:1)获取路径(一般有两种方式:使用NSSearchPathForDirectoriesInDomains或URLsForDirectory;使用NSHomeDirectory➕相应的路径);2)向文件中写入数据;3)从文件中读取数据.</p>\n<h3 id=\"NSKeyedArchiver采用归档的形式来保存数据\"><a href=\"#NSKeyedArchiver采用归档的形式来保存数据\" class=\"headerlink\" title=\"NSKeyedArchiver采用归档的形式来保存数据\"></a>NSKeyedArchiver采用归档的形式来保存数据</h3><p>NSKeyedArchiver保存数据对象需要遵守NSCoding协议，并且该对象对应的类必须提供encodeWithCoder:和initWithCoder:方法,简单的说就是告诉系统怎么对对象进行编码，怎么对对象进行解码.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"NSUserDefaults存储数据\"><a href=\"#NSUserDefaults存储数据\" class=\"headerlink\" title=\"NSUserDefaults存储数据\"></a>NSUserDefaults存储数据</h3><p>一般我们拿它用来保存应用程序设置和属性、用户保存的数据,用户的手机不管是关机or开机时候都会保存在本地(除非你把他删除了),它一般可以存储类型包括:字符,数组,字典,NSData,NSNumber以及基本数据类型都可.</p>\n<h3 id=\"write写入方式存储为plist属性列表\"><a href=\"#write写入方式存储为plist属性列表\" class=\"headerlink\" title=\"write写入方式存储为plist属性列表\"></a>write写入方式存储为plist属性列表</h3><p>write写入方式也是一种把数据永久保存在磁盘中储存方式,一般步骤:1)获取路径(一般有两种方式:使用NSSearchPathForDirectoriesInDomains或URLsForDirectory;使用NSHomeDirectory➕相应的路径);2)向文件中写入数据;3)从文件中读取数据.</p>\n<h3 id=\"NSKeyedArchiver采用归档的形式来保存数据\"><a href=\"#NSKeyedArchiver采用归档的形式来保存数据\" class=\"headerlink\" title=\"NSKeyedArchiver采用归档的形式来保存数据\"></a>NSKeyedArchiver采用归档的形式来保存数据</h3><p>NSKeyedArchiver保存数据对象需要遵守NSCoding协议，并且该对象对应的类必须提供encodeWithCoder:和initWithCoder:方法,简单的说就是告诉系统怎么对对象进行编码，怎么对对象进行解码.</p>\n"},{"title":"iOS版本控制","date":"2018-10-02T01:09:09.000Z","_content":"1.在 user defined 設置自定義變量，在 info.plist 添加變量 如：$\\(SERVER\\_ADDRESS\\) 對應 user-defined，通過該方法獲取\n\n```swift\nlet env = Bundle.main.infoDictionary![\"SERVER_ADDRESS\"] as! String\n```\n\n2.建立 多個對應的 plist 文件，packing 裡設置相應\n\n3.在 other Swift Flags 設置 -D 開頭的變量 如：-DDEV -DPRO\n\n```swift\n#if DEV\n    let SERVER_URL = \"http://dev.server.com/api/\"\n#elseif PRE\n    let SERVER_URL = \"http://pre/api/\"\n#elseif PRO\n    let SERVER_URL = \"http://pro.server.com/api/\"\n#else\n    let SERVER_URL = \"http://prod.server.com/api/\"\n#endif\n```\n\n4.object-c 通過宏定義\n\n![](/assets/import.png)\n\n```object-c\n#if DEV\n\n#define IS_PRODUCTON NO\n\n#elif PRE\n\n#define IS_PRODUCTON  NO\n\n#else\n\n#define IS_PRODUCTON YES\n\n#endif\n\n#ifdef DEBUG\n#else\n#define NSLog(format, ...)\n#endif\n```\n\n> [https://juejin.im/entry/59cc826bf265da064c387e24](https://juejin.im/entry/59cc826bf265da064c387e24)\n>\n> [http://www.jianshu.com/p/d74e3756e4e6](http://www.jianshu.com/p/d74e3756e4e6)\n\n\n\n","source":"_posts/iOS/ios-swiftsheng-chan-ban-ben-kong-zhi.md","raw":"---\ntitle: iOS版本控制\ndate: 2018-10-02 09:09:09\ncategories: iOS\n---\n1.在 user defined 設置自定義變量，在 info.plist 添加變量 如：$\\(SERVER\\_ADDRESS\\) 對應 user-defined，通過該方法獲取\n\n```swift\nlet env = Bundle.main.infoDictionary![\"SERVER_ADDRESS\"] as! String\n```\n\n2.建立 多個對應的 plist 文件，packing 裡設置相應\n\n3.在 other Swift Flags 設置 -D 開頭的變量 如：-DDEV -DPRO\n\n```swift\n#if DEV\n    let SERVER_URL = \"http://dev.server.com/api/\"\n#elseif PRE\n    let SERVER_URL = \"http://pre/api/\"\n#elseif PRO\n    let SERVER_URL = \"http://pro.server.com/api/\"\n#else\n    let SERVER_URL = \"http://prod.server.com/api/\"\n#endif\n```\n\n4.object-c 通過宏定義\n\n![](/assets/import.png)\n\n```object-c\n#if DEV\n\n#define IS_PRODUCTON NO\n\n#elif PRE\n\n#define IS_PRODUCTON  NO\n\n#else\n\n#define IS_PRODUCTON YES\n\n#endif\n\n#ifdef DEBUG\n#else\n#define NSLog(format, ...)\n#endif\n```\n\n> [https://juejin.im/entry/59cc826bf265da064c387e24](https://juejin.im/entry/59cc826bf265da064c387e24)\n>\n> [http://www.jianshu.com/p/d74e3756e4e6](http://www.jianshu.com/p/d74e3756e4e6)\n\n\n\n","slug":"iOS/ios-swiftsheng-chan-ban-ben-kong-zhi","published":1,"updated":"2018-10-02T02:11:15.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4ni003cntnbjt0rmxlo","content":"<p>1.在 user defined 設置自定義變量，在 info.plist 添加變量 如：$(SERVER_ADDRESS) 對應 user-defined，通過該方法獲取</p>\n<pre><code class=\"swift\">let env = Bundle.main.infoDictionary![&quot;SERVER_ADDRESS&quot;] as! String\n</code></pre>\n<p>2.建立 多個對應的 plist 文件，packing 裡設置相應</p>\n<p>3.在 other Swift Flags 設置 -D 開頭的變量 如：-DDEV -DPRO</p>\n<pre><code class=\"swift\">#if DEV\n    let SERVER_URL = &quot;http://dev.server.com/api/&quot;\n#elseif PRE\n    let SERVER_URL = &quot;http://pre/api/&quot;\n#elseif PRO\n    let SERVER_URL = &quot;http://pro.server.com/api/&quot;\n#else\n    let SERVER_URL = &quot;http://prod.server.com/api/&quot;\n#endif\n</code></pre>\n<p>4.object-c 通過宏定義</p>\n<p><img src=\"/assets/import.png\" alt=\"\"></p>\n<pre><code class=\"object-c\">#if DEV\n\n#define IS_PRODUCTON NO\n\n#elif PRE\n\n#define IS_PRODUCTON  NO\n\n#else\n\n#define IS_PRODUCTON YES\n\n#endif\n\n#ifdef DEBUG\n#else\n#define NSLog(format, ...)\n#endif\n</code></pre>\n<blockquote>\n<p><a href=\"https://juejin.im/entry/59cc826bf265da064c387e24\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/59cc826bf265da064c387e24</a></p>\n<p><a href=\"http://www.jianshu.com/p/d74e3756e4e6\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/d74e3756e4e6</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>1.在 user defined 設置自定義變量，在 info.plist 添加變量 如：$(SERVER_ADDRESS) 對應 user-defined，通過該方法獲取</p>\n<pre><code class=\"swift\">let env = Bundle.main.infoDictionary![&quot;SERVER_ADDRESS&quot;] as! String\n</code></pre>\n<p>2.建立 多個對應的 plist 文件，packing 裡設置相應</p>\n<p>3.在 other Swift Flags 設置 -D 開頭的變量 如：-DDEV -DPRO</p>\n<pre><code class=\"swift\">#if DEV\n    let SERVER_URL = &quot;http://dev.server.com/api/&quot;\n#elseif PRE\n    let SERVER_URL = &quot;http://pre/api/&quot;\n#elseif PRO\n    let SERVER_URL = &quot;http://pro.server.com/api/&quot;\n#else\n    let SERVER_URL = &quot;http://prod.server.com/api/&quot;\n#endif\n</code></pre>\n<p>4.object-c 通過宏定義</p>\n<p><img src=\"/assets/import.png\" alt=\"\"></p>\n<pre><code class=\"object-c\">#if DEV\n\n#define IS_PRODUCTON NO\n\n#elif PRE\n\n#define IS_PRODUCTON  NO\n\n#else\n\n#define IS_PRODUCTON YES\n\n#endif\n\n#ifdef DEBUG\n#else\n#define NSLog(format, ...)\n#endif\n</code></pre>\n<blockquote>\n<p><a href=\"https://juejin.im/entry/59cc826bf265da064c387e24\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/59cc826bf265da064c387e24</a></p>\n<p><a href=\"http://www.jianshu.com/p/d74e3756e4e6\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/d74e3756e4e6</a></p>\n</blockquote>\n"},{"title":"iOS status bar","date":"2018-10-02T01:09:09.000Z","_content":"### 在Info中将Status bar is initially hidden\\(UIStatusBarHidden\\)对应的Value设置为Yes，没有变化\n\n设置statusBar的【前景部分】\n\n简单来说，就是设置显示电池电量、时间、网络部分标示的颜色， 这里只能设置两种颜色：\n\n默认的黑色（UIStatusBarStyleDefault）  \n白色（UIStatusBarStyleLightContent）  \n可以设置的地方有两个：plist设置里面 和 程序代码里  \n初始化设置:导航栏设置为不透明并给了\"标题\"与状态栏文字作对比\n\n改变状态栏的方法\n\n方法一:\n\n1、plist\n\nView controller-based status bar appearance 设置为 NO\n\n2、代码设置\n\n```\n[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent;\n```\n\n方法二:\n\n1、plist\n\nView controller-based status bar appearance 设置为 YES 或者默认\\(不设置\\)\n\n注意:\n\n如果View controller-based status bar appearance为YES。\n\n则\\[UIApplication sharedApplication\\].statusBarStyle 无效。\n\n2、代码设置\n\n```\nself.navigationController.navigationBar.barStyle = UIBarStyleBlack;\n```\n\n\\(二\\)设置statusBar的【背景部分】\n\n1、系统提供的方法\n\nnavigationBar的setBarTintColor接口，用此接口可改变statusBar的背景色\n\n```\nself.navigationController.navigationBar.barTintColor = [UIColor greenColor];\n```\n\n### 使用ui preview功能\n\n1.点开Main.storyboard；\n\n2.点击view-》Assistant Editor-》Show Assistant Editor，编辑区分成两部分；\n\n3.点击右半部分顶部导航栏Automatic，在弹出菜单最下面选择Preview-》Main.storyboard（Preview）。\n\nPreview界面的左下角的+号可以添加不同尺寸的屏幕，鼠标移到视图上可以选择旋转。\n\n### Aspect Ratio\n\n添加约束，解决屏幕适配被拉伸等问题\n\n\n\n\n\n\n\n","source":"_posts/iOS/ios-tips.md","raw":"---\ntitle: iOS status bar\ndate: 2018-10-02 09:09:09\ncategories: iOS\n---\n### 在Info中将Status bar is initially hidden\\(UIStatusBarHidden\\)对应的Value设置为Yes，没有变化\n\n设置statusBar的【前景部分】\n\n简单来说，就是设置显示电池电量、时间、网络部分标示的颜色， 这里只能设置两种颜色：\n\n默认的黑色（UIStatusBarStyleDefault）  \n白色（UIStatusBarStyleLightContent）  \n可以设置的地方有两个：plist设置里面 和 程序代码里  \n初始化设置:导航栏设置为不透明并给了\"标题\"与状态栏文字作对比\n\n改变状态栏的方法\n\n方法一:\n\n1、plist\n\nView controller-based status bar appearance 设置为 NO\n\n2、代码设置\n\n```\n[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent;\n```\n\n方法二:\n\n1、plist\n\nView controller-based status bar appearance 设置为 YES 或者默认\\(不设置\\)\n\n注意:\n\n如果View controller-based status bar appearance为YES。\n\n则\\[UIApplication sharedApplication\\].statusBarStyle 无效。\n\n2、代码设置\n\n```\nself.navigationController.navigationBar.barStyle = UIBarStyleBlack;\n```\n\n\\(二\\)设置statusBar的【背景部分】\n\n1、系统提供的方法\n\nnavigationBar的setBarTintColor接口，用此接口可改变statusBar的背景色\n\n```\nself.navigationController.navigationBar.barTintColor = [UIColor greenColor];\n```\n\n### 使用ui preview功能\n\n1.点开Main.storyboard；\n\n2.点击view-》Assistant Editor-》Show Assistant Editor，编辑区分成两部分；\n\n3.点击右半部分顶部导航栏Automatic，在弹出菜单最下面选择Preview-》Main.storyboard（Preview）。\n\nPreview界面的左下角的+号可以添加不同尺寸的屏幕，鼠标移到视图上可以选择旋转。\n\n### Aspect Ratio\n\n添加约束，解决屏幕适配被拉伸等问题\n\n\n\n\n\n\n\n","slug":"iOS/ios-tips","published":1,"updated":"2018-10-02T03:43:21.986Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4ni003dntnb7zy37d4n","content":"<h3 id=\"在Info中将Status-bar-is-initially-hidden-UIStatusBarHidden-对应的Value设置为Yes，没有变化\"><a href=\"#在Info中将Status-bar-is-initially-hidden-UIStatusBarHidden-对应的Value设置为Yes，没有变化\" class=\"headerlink\" title=\"在Info中将Status bar is initially hidden(UIStatusBarHidden)对应的Value设置为Yes，没有变化\"></a>在Info中将Status bar is initially hidden(UIStatusBarHidden)对应的Value设置为Yes，没有变化</h3><p>设置statusBar的【前景部分】</p>\n<p>简单来说，就是设置显示电池电量、时间、网络部分标示的颜色， 这里只能设置两种颜色：</p>\n<p>默认的黑色（UIStatusBarStyleDefault）<br>白色（UIStatusBarStyleLightContent）<br>可以设置的地方有两个：plist设置里面 和 程序代码里<br>初始化设置:导航栏设置为不透明并给了”标题”与状态栏文字作对比</p>\n<p>改变状态栏的方法</p>\n<p>方法一:</p>\n<p>1、plist</p>\n<p>View controller-based status bar appearance 设置为 NO</p>\n<p>2、代码设置</p>\n<pre><code>[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent;\n</code></pre><p>方法二:</p>\n<p>1、plist</p>\n<p>View controller-based status bar appearance 设置为 YES 或者默认(不设置)</p>\n<p>注意:</p>\n<p>如果View controller-based status bar appearance为YES。</p>\n<p>则[UIApplication sharedApplication].statusBarStyle 无效。</p>\n<p>2、代码设置</p>\n<pre><code>self.navigationController.navigationBar.barStyle = UIBarStyleBlack;\n</code></pre><p>(二)设置statusBar的【背景部分】</p>\n<p>1、系统提供的方法</p>\n<p>navigationBar的setBarTintColor接口，用此接口可改变statusBar的背景色</p>\n<pre><code>self.navigationController.navigationBar.barTintColor = [UIColor greenColor];\n</code></pre><h3 id=\"使用ui-preview功能\"><a href=\"#使用ui-preview功能\" class=\"headerlink\" title=\"使用ui preview功能\"></a>使用ui preview功能</h3><p>1.点开Main.storyboard；</p>\n<p>2.点击view-》Assistant Editor-》Show Assistant Editor，编辑区分成两部分；</p>\n<p>3.点击右半部分顶部导航栏Automatic，在弹出菜单最下面选择Preview-》Main.storyboard（Preview）。</p>\n<p>Preview界面的左下角的+号可以添加不同尺寸的屏幕，鼠标移到视图上可以选择旋转。</p>\n<h3 id=\"Aspect-Ratio\"><a href=\"#Aspect-Ratio\" class=\"headerlink\" title=\"Aspect Ratio\"></a>Aspect Ratio</h3><p>添加约束，解决屏幕适配被拉伸等问题</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"在Info中将Status-bar-is-initially-hidden-UIStatusBarHidden-对应的Value设置为Yes，没有变化\"><a href=\"#在Info中将Status-bar-is-initially-hidden-UIStatusBarHidden-对应的Value设置为Yes，没有变化\" class=\"headerlink\" title=\"在Info中将Status bar is initially hidden(UIStatusBarHidden)对应的Value设置为Yes，没有变化\"></a>在Info中将Status bar is initially hidden(UIStatusBarHidden)对应的Value设置为Yes，没有变化</h3><p>设置statusBar的【前景部分】</p>\n<p>简单来说，就是设置显示电池电量、时间、网络部分标示的颜色， 这里只能设置两种颜色：</p>\n<p>默认的黑色（UIStatusBarStyleDefault）<br>白色（UIStatusBarStyleLightContent）<br>可以设置的地方有两个：plist设置里面 和 程序代码里<br>初始化设置:导航栏设置为不透明并给了”标题”与状态栏文字作对比</p>\n<p>改变状态栏的方法</p>\n<p>方法一:</p>\n<p>1、plist</p>\n<p>View controller-based status bar appearance 设置为 NO</p>\n<p>2、代码设置</p>\n<pre><code>[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent;\n</code></pre><p>方法二:</p>\n<p>1、plist</p>\n<p>View controller-based status bar appearance 设置为 YES 或者默认(不设置)</p>\n<p>注意:</p>\n<p>如果View controller-based status bar appearance为YES。</p>\n<p>则[UIApplication sharedApplication].statusBarStyle 无效。</p>\n<p>2、代码设置</p>\n<pre><code>self.navigationController.navigationBar.barStyle = UIBarStyleBlack;\n</code></pre><p>(二)设置statusBar的【背景部分】</p>\n<p>1、系统提供的方法</p>\n<p>navigationBar的setBarTintColor接口，用此接口可改变statusBar的背景色</p>\n<pre><code>self.navigationController.navigationBar.barTintColor = [UIColor greenColor];\n</code></pre><h3 id=\"使用ui-preview功能\"><a href=\"#使用ui-preview功能\" class=\"headerlink\" title=\"使用ui preview功能\"></a>使用ui preview功能</h3><p>1.点开Main.storyboard；</p>\n<p>2.点击view-》Assistant Editor-》Show Assistant Editor，编辑区分成两部分；</p>\n<p>3.点击右半部分顶部导航栏Automatic，在弹出菜单最下面选择Preview-》Main.storyboard（Preview）。</p>\n<p>Preview界面的左下角的+号可以添加不同尺寸的屏幕，鼠标移到视图上可以选择旋转。</p>\n<h3 id=\"Aspect-Ratio\"><a href=\"#Aspect-Ratio\" class=\"headerlink\" title=\"Aspect Ratio\"></a>Aspect Ratio</h3><p>添加约束，解决屏幕适配被拉伸等问题</p>\n"},{"title":"MAC下Homebrew基本使用","date":"2018-10-02T01:09:09.000Z","_content":"# MAC下Homebrew基本使用\n\n---\n\n简介\n\nMac OS X是基于Unix的操作系统，可以安装大部分为Unix\\/Linux开发的软件。然而，如果只是以使用为目的，对每个软件都进行手工编译不是很方便，也不利于管理已安装的软件，于是出现了类似于Linux中APT、Yum等类似的软件包管理系统，其中最著名的有MacPorts、Fink、Homebrew等。  \n我曾经是MacPorts的使用者，但了解Homebrew之后，立即“弃暗投明”了。其实MacPorts也是一个很不错的解决方案，除了一个实在让我头疼的特性。MacPorts有个原则，对于软件包之间的依赖，都在MacPorts内部解决（\\/opt\\/local），无论系统本身是否包含了需要的库，都不会加以利用。这使得MacPorts过分的庞大臃肿，导致系统出现大量软件包的冗余，占用不小的磁盘空间，同时稍大型一点的软件编译时间都会难以忍受。  \n而Homebrew的原则恰恰相反，它尽可能地利用系统自带的各种库，使得软件包的编译时间大为缩短；同时由于几乎不会造成冗余，软件包的管理也清晰、灵活了许多。Homebrew的另一个特点是使用Ruby定义软件包安装配置（叫做formula），定制非常简单。\n\n一些命令\n\n## **Homebrew 基本使用**\n\n安装一个包，可以简单的运行：\n\n```\n$ brew install <package_name>\n```\n\n更新 Homebrew 在服务器端上的包目录：\n\n```\n$ brew update\n```\n\n查看你的包是否需要更新：\n\n```\n$ brew outdated\n```\n\n更新包：\n\n```\n$ brew upgrade <package_name>\n```\n\nHomebrew 将会把老版本的包缓存下来，以便当你想回滚至旧版本时使用。但这是比较少使用的情况，当你想清理旧版本的包缓存时，可以运行：\n\n```\n$ brew cleanup\n```\n\n查看你安装过的包列表（包括版本号）：\n\n```\n$ brew list --versions\n```\n\nhttp:\\/\\/wiki.jikexueyuan.com\\/project\\/mac-dev-setup\\/homebrew.html\n\n","source":"_posts/iOS/ios下homebrew基本使用.md","raw":"---\ntitle: MAC下Homebrew基本使用\ndate: 2018-10-02 09:09:09\ncategories: iOS\n---\n# MAC下Homebrew基本使用\n\n---\n\n简介\n\nMac OS X是基于Unix的操作系统，可以安装大部分为Unix\\/Linux开发的软件。然而，如果只是以使用为目的，对每个软件都进行手工编译不是很方便，也不利于管理已安装的软件，于是出现了类似于Linux中APT、Yum等类似的软件包管理系统，其中最著名的有MacPorts、Fink、Homebrew等。  \n我曾经是MacPorts的使用者，但了解Homebrew之后，立即“弃暗投明”了。其实MacPorts也是一个很不错的解决方案，除了一个实在让我头疼的特性。MacPorts有个原则，对于软件包之间的依赖，都在MacPorts内部解决（\\/opt\\/local），无论系统本身是否包含了需要的库，都不会加以利用。这使得MacPorts过分的庞大臃肿，导致系统出现大量软件包的冗余，占用不小的磁盘空间，同时稍大型一点的软件编译时间都会难以忍受。  \n而Homebrew的原则恰恰相反，它尽可能地利用系统自带的各种库，使得软件包的编译时间大为缩短；同时由于几乎不会造成冗余，软件包的管理也清晰、灵活了许多。Homebrew的另一个特点是使用Ruby定义软件包安装配置（叫做formula），定制非常简单。\n\n一些命令\n\n## **Homebrew 基本使用**\n\n安装一个包，可以简单的运行：\n\n```\n$ brew install <package_name>\n```\n\n更新 Homebrew 在服务器端上的包目录：\n\n```\n$ brew update\n```\n\n查看你的包是否需要更新：\n\n```\n$ brew outdated\n```\n\n更新包：\n\n```\n$ brew upgrade <package_name>\n```\n\nHomebrew 将会把老版本的包缓存下来，以便当你想回滚至旧版本时使用。但这是比较少使用的情况，当你想清理旧版本的包缓存时，可以运行：\n\n```\n$ brew cleanup\n```\n\n查看你安装过的包列表（包括版本号）：\n\n```\n$ brew list --versions\n```\n\nhttp:\\/\\/wiki.jikexueyuan.com\\/project\\/mac-dev-setup\\/homebrew.html\n\n","slug":"iOS/ios下homebrew基本使用","published":1,"updated":"2018-10-02T02:11:43.014Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4nk003gntnb9qcw32po","content":"<h1 id=\"MAC下Homebrew基本使用\"><a href=\"#MAC下Homebrew基本使用\" class=\"headerlink\" title=\"MAC下Homebrew基本使用\"></a>MAC下Homebrew基本使用</h1><hr>\n<p>简介</p>\n<p>Mac OS X是基于Unix的操作系统，可以安装大部分为Unix\\/Linux开发的软件。然而，如果只是以使用为目的，对每个软件都进行手工编译不是很方便，也不利于管理已安装的软件，于是出现了类似于Linux中APT、Yum等类似的软件包管理系统，其中最著名的有MacPorts、Fink、Homebrew等。<br>我曾经是MacPorts的使用者，但了解Homebrew之后，立即“弃暗投明”了。其实MacPorts也是一个很不错的解决方案，除了一个实在让我头疼的特性。MacPorts有个原则，对于软件包之间的依赖，都在MacPorts内部解决（\\/opt\\/local），无论系统本身是否包含了需要的库，都不会加以利用。这使得MacPorts过分的庞大臃肿，导致系统出现大量软件包的冗余，占用不小的磁盘空间，同时稍大型一点的软件编译时间都会难以忍受。<br>而Homebrew的原则恰恰相反，它尽可能地利用系统自带的各种库，使得软件包的编译时间大为缩短；同时由于几乎不会造成冗余，软件包的管理也清晰、灵活了许多。Homebrew的另一个特点是使用Ruby定义软件包安装配置（叫做formula），定制非常简单。</p>\n<p>一些命令</p>\n<h2 id=\"Homebrew-基本使用\"><a href=\"#Homebrew-基本使用\" class=\"headerlink\" title=\"Homebrew 基本使用\"></a><strong>Homebrew 基本使用</strong></h2><p>安装一个包，可以简单的运行：</p>\n<pre><code>$ brew install &lt;package_name&gt;\n</code></pre><p>更新 Homebrew 在服务器端上的包目录：</p>\n<pre><code>$ brew update\n</code></pre><p>查看你的包是否需要更新：</p>\n<pre><code>$ brew outdated\n</code></pre><p>更新包：</p>\n<pre><code>$ brew upgrade &lt;package_name&gt;\n</code></pre><p>Homebrew 将会把老版本的包缓存下来，以便当你想回滚至旧版本时使用。但这是比较少使用的情况，当你想清理旧版本的包缓存时，可以运行：</p>\n<pre><code>$ brew cleanup\n</code></pre><p>查看你安装过的包列表（包括版本号）：</p>\n<pre><code>$ brew list --versions\n</code></pre><p>http:\\/\\/wiki.jikexueyuan.com\\/project\\/mac-dev-setup\\/homebrew.html</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MAC下Homebrew基本使用\"><a href=\"#MAC下Homebrew基本使用\" class=\"headerlink\" title=\"MAC下Homebrew基本使用\"></a>MAC下Homebrew基本使用</h1><hr>\n<p>简介</p>\n<p>Mac OS X是基于Unix的操作系统，可以安装大部分为Unix\\/Linux开发的软件。然而，如果只是以使用为目的，对每个软件都进行手工编译不是很方便，也不利于管理已安装的软件，于是出现了类似于Linux中APT、Yum等类似的软件包管理系统，其中最著名的有MacPorts、Fink、Homebrew等。<br>我曾经是MacPorts的使用者，但了解Homebrew之后，立即“弃暗投明”了。其实MacPorts也是一个很不错的解决方案，除了一个实在让我头疼的特性。MacPorts有个原则，对于软件包之间的依赖，都在MacPorts内部解决（\\/opt\\/local），无论系统本身是否包含了需要的库，都不会加以利用。这使得MacPorts过分的庞大臃肿，导致系统出现大量软件包的冗余，占用不小的磁盘空间，同时稍大型一点的软件编译时间都会难以忍受。<br>而Homebrew的原则恰恰相反，它尽可能地利用系统自带的各种库，使得软件包的编译时间大为缩短；同时由于几乎不会造成冗余，软件包的管理也清晰、灵活了许多。Homebrew的另一个特点是使用Ruby定义软件包安装配置（叫做formula），定制非常简单。</p>\n<p>一些命令</p>\n<h2 id=\"Homebrew-基本使用\"><a href=\"#Homebrew-基本使用\" class=\"headerlink\" title=\"Homebrew 基本使用\"></a><strong>Homebrew 基本使用</strong></h2><p>安装一个包，可以简单的运行：</p>\n<pre><code>$ brew install &lt;package_name&gt;\n</code></pre><p>更新 Homebrew 在服务器端上的包目录：</p>\n<pre><code>$ brew update\n</code></pre><p>查看你的包是否需要更新：</p>\n<pre><code>$ brew outdated\n</code></pre><p>更新包：</p>\n<pre><code>$ brew upgrade &lt;package_name&gt;\n</code></pre><p>Homebrew 将会把老版本的包缓存下来，以便当你想回滚至旧版本时使用。但这是比较少使用的情况，当你想清理旧版本的包缓存时，可以运行：</p>\n<pre><code>$ brew cleanup\n</code></pre><p>查看你安装过的包列表（包括版本号）：</p>\n<pre><code>$ brew list --versions\n</code></pre><p>http:\\/\\/wiki.jikexueyuan.com\\/project\\/mac-dev-setup\\/homebrew.html</p>\n"},{"title":"jQuery常用API","date":"2018-10-02T01:09:09.000Z","_content":"# jQuery常用API\n\n\n---\n\n##hide() 和 show() 方法来隐藏和显示 HTML 元素\n语法：\n\n``$(selector).show(speed,callback);``\n\n实例\n```javascript\n$(\"button\").click(function(){\n  $(\"p\").hide(1000);\n});\n```\n\n通过 jQuery，您可以使用 toggle() 方法来切换 hide() 和 show() 方法。\n显示被隐藏的元素，并隐藏已显示的元素：\n\n语法：\n\n``$(selector).toggle(speed,callback);``\n实例\n```javascript\n$(\"button\").click(function(){\n  $(\"p\").toggle();\n});\n```","source":"_posts/jQuery/jQuery常用API.md","raw":"---\ntitle: jQuery常用API\ndate: 2018-10-02 09:09:09\ncategories: jQuery\n---\n# jQuery常用API\n\n\n---\n\n##hide() 和 show() 方法来隐藏和显示 HTML 元素\n语法：\n\n``$(selector).show(speed,callback);``\n\n实例\n```javascript\n$(\"button\").click(function(){\n  $(\"p\").hide(1000);\n});\n```\n\n通过 jQuery，您可以使用 toggle() 方法来切换 hide() 和 show() 方法。\n显示被隐藏的元素，并隐藏已显示的元素：\n\n语法：\n\n``$(selector).toggle(speed,callback);``\n实例\n```javascript\n$(\"button\").click(function(){\n  $(\"p\").toggle();\n});\n```","slug":"jQuery/jQuery常用API","published":1,"updated":"2018-10-02T02:13:11.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4nl003hntnb11zhf5hp","content":"<h1 id=\"jQuery常用API\"><a href=\"#jQuery常用API\" class=\"headerlink\" title=\"jQuery常用API\"></a>jQuery常用API</h1><hr>\n<p>##hide() 和 show() 方法来隐藏和显示 HTML 元素<br>语法：</p>\n<p><code>$(selector).show(speed,callback);</code></p>\n<p>实例</p>\n<pre><code class=\"javascript\">$(&quot;button&quot;).click(function(){\n  $(&quot;p&quot;).hide(1000);\n});\n</code></pre>\n<p>通过 jQuery，您可以使用 toggle() 方法来切换 hide() 和 show() 方法。<br>显示被隐藏的元素，并隐藏已显示的元素：</p>\n<p>语法：</p>\n<p><code>$(selector).toggle(speed,callback);</code><br>实例</p>\n<pre><code class=\"javascript\">$(&quot;button&quot;).click(function(){\n  $(&quot;p&quot;).toggle();\n});\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"jQuery常用API\"><a href=\"#jQuery常用API\" class=\"headerlink\" title=\"jQuery常用API\"></a>jQuery常用API</h1><hr>\n<p>##hide() 和 show() 方法来隐藏和显示 HTML 元素<br>语法：</p>\n<p><code>$(selector).show(speed,callback);</code></p>\n<p>实例</p>\n<pre><code class=\"javascript\">$(&quot;button&quot;).click(function(){\n  $(&quot;p&quot;).hide(1000);\n});\n</code></pre>\n<p>通过 jQuery，您可以使用 toggle() 方法来切换 hide() 和 show() 方法。<br>显示被隐藏的元素，并隐藏已显示的元素：</p>\n<p>语法：</p>\n<p><code>$(selector).toggle(speed,callback);</code><br>实例</p>\n<pre><code class=\"javascript\">$(&quot;button&quot;).click(function(){\n  $(&quot;p&quot;).toggle();\n});\n</code></pre>\n"},{"title":"jQuery选择器","date":"2018-10-02T01:09:09.000Z","_content":"# jQuery选择器\n\n\n---\n\n| 选择器 | 实例 | 选取 |\n| -- | -- | -- |\n| \\*\t|$(\"*\")\t|所有元素 |\n|#id\t|$(\"#lastname\")\t|id=\"lastname\" 的元素|\n|.class\t|$(\".intro\")\t|所有 class=\"intro\" 的元素|\n|element|\t$(\"p\")\t|所有 < p > 元素|\n|.class.class\t|$(\".intro.demo\")|\t所有 class=\"intro\" 且 class=\"demo\" 的元素|\n|--|--|--|\n|:first\t|$(\"p:first\")\t|第一个< p >元素|\n|:last\t|$(\"p:last\")\t|最后一个 < p > 元素|\n|:even\t|$(\"tr:even\")\t|所有偶数 < tr > 元素|\n|:odd\t|$(\"tr:odd\")|\t所有奇数 < tr > 元素|\n|:eq(index)|\t$(\"ul li:eq(3)\")\t|列表中的第四个元素（index 从 0 开始）|\n|:gt(no)\t|$(\"ul li:gt(3)\")|\t列出 index 大于 3 的元素|\n|:lt(no)\t|$(\"ul li:lt(3)\")\t|列出 index 小于 3 的元素|\n|:not(selector)|\t$(\"input:not(:empty)\")\t|所有不为空的 input 元素|\n|:header|\t$(\":header\")|\t所有标题元素 < h1 > - < h6 >|\n|:animated\t| \t|所有动画元素|\n|:contains(text)\t|$(\":contains('W3School')\")|\t包含指定字符串的所有元素|\n|:empty|\t$(\":empty\")|\t无子（元素）节点的所有元素|\n|:hidden\t|$(\"p:hidden\")|\t所有隐藏的 < p > 元素|\n|:visible|\t$(\"table:visible\")\t|所有可见的表格|\n|s1,s2,s3\t|$(\"th,td,.intro\")\t|所有带有匹配选择的元素|\n|[attribute]\t|$(\"[href]\")\t|所有带有 href 属性的元素|\n|[attribute=value]\t|$(\"[href='#']\")|\t所有 href 属性的值等于 \"#\" 的元素|\n|[attribute!=value]\t|$(\"[href!='#']\")|\t所有 href 属性的值不等于 \"#\" 的元素|\n|[attribute$=value]|\t$(\"[href$='.jpg']\")|\t所有 href 属性的值包含以 \".jpg\" 结尾的元素|\n|:input|\t$(\":input\")\t|所有 < input > 元素|\n|:text\t|$(\":text\")|\t所有 type=\"text\" 的 < input > 元素|\n|:password|\t$(\":password\")|\t所有 type=\"password\" 的 < input > 元素|\n|:radio|\t$(\":radio\")|\t所有 type=\"radio\" 的 < input > 元素|\n|:checkbox\t|$(\":checkbox\")|\t所有 type=\"checkbox\" 的 < input > 元素|\n|:submit\t|$(\":submit\")\t|所有 type=\"submit\" 的 < input > 元素|\n|:reset\t|$(\":reset\")|\t所有 type=\"reset\" 的 < input > 元素|\n|:button\t|$(\":button\")|\t所有 type=\"button\" 的 < input > 元素|\n|:image|\t$(\":image\")\t|所有 type=\"image\" 的 < input > 元素|\n|:file\t|$(\":file\")\t|所有 type=\"file\" 的 < input > 元素|\t \n|:enabled\t|$(\":enabled\")\t|所有激活的 input 元素|\n|:disabled\t|$(\":disabled\")\t|所有禁用的 input 元素|\n|:selected\t|$(\":selected\")\t|所有被选取的 input 元素|\n|:checked\t|$(\":checked\")\t|所有被选中的 input 元素|","source":"_posts/jQuery/jQuery选择器.md","raw":"---\ntitle: jQuery选择器\ndate: 2018-10-02 09:09:09\ncategories: jQuery\n---\n# jQuery选择器\n\n\n---\n\n| 选择器 | 实例 | 选取 |\n| -- | -- | -- |\n| \\*\t|$(\"*\")\t|所有元素 |\n|#id\t|$(\"#lastname\")\t|id=\"lastname\" 的元素|\n|.class\t|$(\".intro\")\t|所有 class=\"intro\" 的元素|\n|element|\t$(\"p\")\t|所有 < p > 元素|\n|.class.class\t|$(\".intro.demo\")|\t所有 class=\"intro\" 且 class=\"demo\" 的元素|\n|--|--|--|\n|:first\t|$(\"p:first\")\t|第一个< p >元素|\n|:last\t|$(\"p:last\")\t|最后一个 < p > 元素|\n|:even\t|$(\"tr:even\")\t|所有偶数 < tr > 元素|\n|:odd\t|$(\"tr:odd\")|\t所有奇数 < tr > 元素|\n|:eq(index)|\t$(\"ul li:eq(3)\")\t|列表中的第四个元素（index 从 0 开始）|\n|:gt(no)\t|$(\"ul li:gt(3)\")|\t列出 index 大于 3 的元素|\n|:lt(no)\t|$(\"ul li:lt(3)\")\t|列出 index 小于 3 的元素|\n|:not(selector)|\t$(\"input:not(:empty)\")\t|所有不为空的 input 元素|\n|:header|\t$(\":header\")|\t所有标题元素 < h1 > - < h6 >|\n|:animated\t| \t|所有动画元素|\n|:contains(text)\t|$(\":contains('W3School')\")|\t包含指定字符串的所有元素|\n|:empty|\t$(\":empty\")|\t无子（元素）节点的所有元素|\n|:hidden\t|$(\"p:hidden\")|\t所有隐藏的 < p > 元素|\n|:visible|\t$(\"table:visible\")\t|所有可见的表格|\n|s1,s2,s3\t|$(\"th,td,.intro\")\t|所有带有匹配选择的元素|\n|[attribute]\t|$(\"[href]\")\t|所有带有 href 属性的元素|\n|[attribute=value]\t|$(\"[href='#']\")|\t所有 href 属性的值等于 \"#\" 的元素|\n|[attribute!=value]\t|$(\"[href!='#']\")|\t所有 href 属性的值不等于 \"#\" 的元素|\n|[attribute$=value]|\t$(\"[href$='.jpg']\")|\t所有 href 属性的值包含以 \".jpg\" 结尾的元素|\n|:input|\t$(\":input\")\t|所有 < input > 元素|\n|:text\t|$(\":text\")|\t所有 type=\"text\" 的 < input > 元素|\n|:password|\t$(\":password\")|\t所有 type=\"password\" 的 < input > 元素|\n|:radio|\t$(\":radio\")|\t所有 type=\"radio\" 的 < input > 元素|\n|:checkbox\t|$(\":checkbox\")|\t所有 type=\"checkbox\" 的 < input > 元素|\n|:submit\t|$(\":submit\")\t|所有 type=\"submit\" 的 < input > 元素|\n|:reset\t|$(\":reset\")|\t所有 type=\"reset\" 的 < input > 元素|\n|:button\t|$(\":button\")|\t所有 type=\"button\" 的 < input > 元素|\n|:image|\t$(\":image\")\t|所有 type=\"image\" 的 < input > 元素|\n|:file\t|$(\":file\")\t|所有 type=\"file\" 的 < input > 元素|\t \n|:enabled\t|$(\":enabled\")\t|所有激活的 input 元素|\n|:disabled\t|$(\":disabled\")\t|所有禁用的 input 元素|\n|:selected\t|$(\":selected\")\t|所有被选取的 input 元素|\n|:checked\t|$(\":checked\")\t|所有被选中的 input 元素|","slug":"jQuery/jQuery选择器","published":1,"updated":"2018-10-02T02:13:19.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4nm003kntnb8il7cjqq","content":"<h1 id=\"jQuery选择器\"><a href=\"#jQuery选择器\" class=\"headerlink\" title=\"jQuery选择器\"></a>jQuery选择器</h1><hr>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>实例</th>\n<th>选取</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td>$(“*”)</td>\n<td>所有元素</td>\n</tr>\n<tr>\n<td>#id</td>\n<td>$(“#lastname”)</td>\n<td>id=”lastname” 的元素</td>\n</tr>\n<tr>\n<td>.class</td>\n<td>$(“.intro”)</td>\n<td>所有 class=”intro” 的元素</td>\n</tr>\n<tr>\n<td>element</td>\n<td>$(“p”)</td>\n<td>所有 &lt; p &gt; 元素</td>\n</tr>\n<tr>\n<td>.class.class</td>\n<td>$(“.intro.demo”)</td>\n<td>所有 class=”intro” 且 class=”demo” 的元素</td>\n</tr>\n<tr>\n<td>–</td>\n<td>–</td>\n<td>–</td>\n</tr>\n<tr>\n<td>:first</td>\n<td>$(“p:first”)</td>\n<td>第一个&lt; p &gt;元素</td>\n</tr>\n<tr>\n<td>:last</td>\n<td>$(“p:last”)</td>\n<td>最后一个 &lt; p &gt; 元素</td>\n</tr>\n<tr>\n<td>:even</td>\n<td>$(“tr:even”)</td>\n<td>所有偶数 &lt; tr &gt; 元素</td>\n</tr>\n<tr>\n<td>:odd</td>\n<td>$(“tr:odd”)</td>\n<td>所有奇数 &lt; tr &gt; 元素</td>\n</tr>\n<tr>\n<td>:eq(index)</td>\n<td>$(“ul li:eq(3)”)</td>\n<td>列表中的第四个元素（index 从 0 开始）</td>\n</tr>\n<tr>\n<td>:gt(no)</td>\n<td>$(“ul li:gt(3)”)</td>\n<td>列出 index 大于 3 的元素</td>\n</tr>\n<tr>\n<td>:lt(no)</td>\n<td>$(“ul li:lt(3)”)</td>\n<td>列出 index 小于 3 的元素</td>\n</tr>\n<tr>\n<td>:not(selector)</td>\n<td>$(“input:not(:empty)”)</td>\n<td>所有不为空的 input 元素</td>\n</tr>\n<tr>\n<td>:header</td>\n<td>$(“:header”)</td>\n<td>所有标题元素 &lt; h1 &gt; - &lt; h6 &gt;</td>\n</tr>\n<tr>\n<td>:animated</td>\n<td></td>\n<td>所有动画元素</td>\n</tr>\n<tr>\n<td>:contains(text)</td>\n<td>$(“:contains(‘W3School’)”)</td>\n<td>包含指定字符串的所有元素</td>\n</tr>\n<tr>\n<td>:empty</td>\n<td>$(“:empty”)</td>\n<td>无子（元素）节点的所有元素</td>\n</tr>\n<tr>\n<td>:hidden</td>\n<td>$(“p:hidden”)</td>\n<td>所有隐藏的 &lt; p &gt; 元素</td>\n</tr>\n<tr>\n<td>:visible</td>\n<td>$(“table:visible”)</td>\n<td>所有可见的表格</td>\n</tr>\n<tr>\n<td>s1,s2,s3</td>\n<td>$(“th,td,.intro”)</td>\n<td>所有带有匹配选择的元素</td>\n</tr>\n<tr>\n<td>[attribute]</td>\n<td>$(“[href]”)</td>\n<td>所有带有 href 属性的元素</td>\n</tr>\n<tr>\n<td>[attribute=value]</td>\n<td>$(“[href=’#’]”)</td>\n<td>所有 href 属性的值等于 “#” 的元素</td>\n</tr>\n<tr>\n<td>[attribute!=value]</td>\n<td>$(“[href!=’#’]”)</td>\n<td>所有 href 属性的值不等于 “#” 的元素</td>\n</tr>\n<tr>\n<td>[attribute$=value]</td>\n<td>$(“[href$=’.jpg’]”)</td>\n<td>所有 href 属性的值包含以 “.jpg” 结尾的元素</td>\n</tr>\n<tr>\n<td>:input</td>\n<td>$(“:input”)</td>\n<td>所有 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:text</td>\n<td>$(“:text”)</td>\n<td>所有 type=”text” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:password</td>\n<td>$(“:password”)</td>\n<td>所有 type=”password” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:radio</td>\n<td>$(“:radio”)</td>\n<td>所有 type=”radio” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:checkbox</td>\n<td>$(“:checkbox”)</td>\n<td>所有 type=”checkbox” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:submit</td>\n<td>$(“:submit”)</td>\n<td>所有 type=”submit” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:reset</td>\n<td>$(“:reset”)</td>\n<td>所有 type=”reset” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:button</td>\n<td>$(“:button”)</td>\n<td>所有 type=”button” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:image</td>\n<td>$(“:image”)</td>\n<td>所有 type=”image” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:file</td>\n<td>$(“:file”)</td>\n<td>所有 type=”file” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:enabled</td>\n<td>$(“:enabled”)</td>\n<td>所有激活的 input 元素</td>\n</tr>\n<tr>\n<td>:disabled</td>\n<td>$(“:disabled”)</td>\n<td>所有禁用的 input 元素</td>\n</tr>\n<tr>\n<td>:selected</td>\n<td>$(“:selected”)</td>\n<td>所有被选取的 input 元素</td>\n</tr>\n<tr>\n<td>:checked</td>\n<td>$(“:checked”)</td>\n<td>所有被选中的 input 元素</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"jQuery选择器\"><a href=\"#jQuery选择器\" class=\"headerlink\" title=\"jQuery选择器\"></a>jQuery选择器</h1><hr>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>实例</th>\n<th>选取</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td>$(“*”)</td>\n<td>所有元素</td>\n</tr>\n<tr>\n<td>#id</td>\n<td>$(“#lastname”)</td>\n<td>id=”lastname” 的元素</td>\n</tr>\n<tr>\n<td>.class</td>\n<td>$(“.intro”)</td>\n<td>所有 class=”intro” 的元素</td>\n</tr>\n<tr>\n<td>element</td>\n<td>$(“p”)</td>\n<td>所有 &lt; p &gt; 元素</td>\n</tr>\n<tr>\n<td>.class.class</td>\n<td>$(“.intro.demo”)</td>\n<td>所有 class=”intro” 且 class=”demo” 的元素</td>\n</tr>\n<tr>\n<td>–</td>\n<td>–</td>\n<td>–</td>\n</tr>\n<tr>\n<td>:first</td>\n<td>$(“p:first”)</td>\n<td>第一个&lt; p &gt;元素</td>\n</tr>\n<tr>\n<td>:last</td>\n<td>$(“p:last”)</td>\n<td>最后一个 &lt; p &gt; 元素</td>\n</tr>\n<tr>\n<td>:even</td>\n<td>$(“tr:even”)</td>\n<td>所有偶数 &lt; tr &gt; 元素</td>\n</tr>\n<tr>\n<td>:odd</td>\n<td>$(“tr:odd”)</td>\n<td>所有奇数 &lt; tr &gt; 元素</td>\n</tr>\n<tr>\n<td>:eq(index)</td>\n<td>$(“ul li:eq(3)”)</td>\n<td>列表中的第四个元素（index 从 0 开始）</td>\n</tr>\n<tr>\n<td>:gt(no)</td>\n<td>$(“ul li:gt(3)”)</td>\n<td>列出 index 大于 3 的元素</td>\n</tr>\n<tr>\n<td>:lt(no)</td>\n<td>$(“ul li:lt(3)”)</td>\n<td>列出 index 小于 3 的元素</td>\n</tr>\n<tr>\n<td>:not(selector)</td>\n<td>$(“input:not(:empty)”)</td>\n<td>所有不为空的 input 元素</td>\n</tr>\n<tr>\n<td>:header</td>\n<td>$(“:header”)</td>\n<td>所有标题元素 &lt; h1 &gt; - &lt; h6 &gt;</td>\n</tr>\n<tr>\n<td>:animated</td>\n<td></td>\n<td>所有动画元素</td>\n</tr>\n<tr>\n<td>:contains(text)</td>\n<td>$(“:contains(‘W3School’)”)</td>\n<td>包含指定字符串的所有元素</td>\n</tr>\n<tr>\n<td>:empty</td>\n<td>$(“:empty”)</td>\n<td>无子（元素）节点的所有元素</td>\n</tr>\n<tr>\n<td>:hidden</td>\n<td>$(“p:hidden”)</td>\n<td>所有隐藏的 &lt; p &gt; 元素</td>\n</tr>\n<tr>\n<td>:visible</td>\n<td>$(“table:visible”)</td>\n<td>所有可见的表格</td>\n</tr>\n<tr>\n<td>s1,s2,s3</td>\n<td>$(“th,td,.intro”)</td>\n<td>所有带有匹配选择的元素</td>\n</tr>\n<tr>\n<td>[attribute]</td>\n<td>$(“[href]”)</td>\n<td>所有带有 href 属性的元素</td>\n</tr>\n<tr>\n<td>[attribute=value]</td>\n<td>$(“[href=’#’]”)</td>\n<td>所有 href 属性的值等于 “#” 的元素</td>\n</tr>\n<tr>\n<td>[attribute!=value]</td>\n<td>$(“[href!=’#’]”)</td>\n<td>所有 href 属性的值不等于 “#” 的元素</td>\n</tr>\n<tr>\n<td>[attribute$=value]</td>\n<td>$(“[href$=’.jpg’]”)</td>\n<td>所有 href 属性的值包含以 “.jpg” 结尾的元素</td>\n</tr>\n<tr>\n<td>:input</td>\n<td>$(“:input”)</td>\n<td>所有 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:text</td>\n<td>$(“:text”)</td>\n<td>所有 type=”text” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:password</td>\n<td>$(“:password”)</td>\n<td>所有 type=”password” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:radio</td>\n<td>$(“:radio”)</td>\n<td>所有 type=”radio” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:checkbox</td>\n<td>$(“:checkbox”)</td>\n<td>所有 type=”checkbox” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:submit</td>\n<td>$(“:submit”)</td>\n<td>所有 type=”submit” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:reset</td>\n<td>$(“:reset”)</td>\n<td>所有 type=”reset” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:button</td>\n<td>$(“:button”)</td>\n<td>所有 type=”button” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:image</td>\n<td>$(“:image”)</td>\n<td>所有 type=”image” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:file</td>\n<td>$(“:file”)</td>\n<td>所有 type=”file” 的 &lt; input &gt; 元素</td>\n</tr>\n<tr>\n<td>:enabled</td>\n<td>$(“:enabled”)</td>\n<td>所有激活的 input 元素</td>\n</tr>\n<tr>\n<td>:disabled</td>\n<td>$(“:disabled”)</td>\n<td>所有禁用的 input 元素</td>\n</tr>\n<tr>\n<td>:selected</td>\n<td>$(“:selected”)</td>\n<td>所有被选取的 input 元素</td>\n</tr>\n<tr>\n<td>:checked</td>\n<td>$(“:checked”)</td>\n<td>所有被选中的 input 元素</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"jQuery Note","date":"2018-10-02T01:09:09.000Z","_content":"# Jquery Note\n\n\n---\n\n##jQuery 语法\njQuery 语法是为 HTML 元素的选取编制的，可以对元素执行某些操作。\n\n基础语法是：$(selector).action()\n\n美元符号定义 jQuery\n\n选择符（selector）“查询”和“查找” HTML 元素\n\njQuery 的 action() 执行对元素的操作\n\n示例\n\n$(this).hide() - 隐藏当前元素\n\n$(\"p\").hide() - 隐藏所有段落\n\n$(\".test\").hide() - 隐藏所有 class=\"test\" 的所有元素\n\n$(\"#test\").hide() - 隐藏所有 id=\"test\" 的元素\n\n\n\n---\n\n##文档就绪函数\n您也许已经注意到在我们的实例中的所有 jQuery 函数位于一个 document ready 函数中：\n```javascript\n$(document).ready(function(){\n\n--- jQuery functions go here ----\n\n});\n```\n这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码。\n\n\n---\n\n\n##jQuery 事件\n\n下面是 jQuery 中事件方法的一些例子：\n\n| Event 函数 | 绑定函数至 |\n|--|--|\n|$(document).ready(function)\t|将函数绑定到文档的就绪事件（当文档完成加载时）|\n|$(selector).click(function)\t|触发或将函数绑定到被选元素的点击事件|\n|$(selector).dblclick(function)\t|触发或将函数绑定到被选元素的双击事件|\n|$(selector).focus(function)\t|触发或将函数绑定到被选元素的获得焦点事件|\n|$(selector).mouseover(function)\t|触发或将函数绑定到被选元素的鼠标悬停事件|","source":"_posts/jQuery/jquery_note.md","raw":"---\ntitle: jQuery Note\ndate: 2018-10-02 09:09:09\ncategories: jQuery\n---\n# Jquery Note\n\n\n---\n\n##jQuery 语法\njQuery 语法是为 HTML 元素的选取编制的，可以对元素执行某些操作。\n\n基础语法是：$(selector).action()\n\n美元符号定义 jQuery\n\n选择符（selector）“查询”和“查找” HTML 元素\n\njQuery 的 action() 执行对元素的操作\n\n示例\n\n$(this).hide() - 隐藏当前元素\n\n$(\"p\").hide() - 隐藏所有段落\n\n$(\".test\").hide() - 隐藏所有 class=\"test\" 的所有元素\n\n$(\"#test\").hide() - 隐藏所有 id=\"test\" 的元素\n\n\n\n---\n\n##文档就绪函数\n您也许已经注意到在我们的实例中的所有 jQuery 函数位于一个 document ready 函数中：\n```javascript\n$(document).ready(function(){\n\n--- jQuery functions go here ----\n\n});\n```\n这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码。\n\n\n---\n\n\n##jQuery 事件\n\n下面是 jQuery 中事件方法的一些例子：\n\n| Event 函数 | 绑定函数至 |\n|--|--|\n|$(document).ready(function)\t|将函数绑定到文档的就绪事件（当文档完成加载时）|\n|$(selector).click(function)\t|触发或将函数绑定到被选元素的点击事件|\n|$(selector).dblclick(function)\t|触发或将函数绑定到被选元素的双击事件|\n|$(selector).focus(function)\t|触发或将函数绑定到被选元素的获得焦点事件|\n|$(selector).mouseover(function)\t|触发或将函数绑定到被选元素的鼠标悬停事件|","slug":"jQuery/jquery_note","published":1,"updated":"2018-10-02T02:13:00.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4nn003lntnb8r2wqs3z","content":"<h1 id=\"Jquery-Note\"><a href=\"#Jquery-Note\" class=\"headerlink\" title=\"Jquery Note\"></a>Jquery Note</h1><hr>\n<p>##jQuery 语法<br>jQuery 语法是为 HTML 元素的选取编制的，可以对元素执行某些操作。</p>\n<p>基础语法是：$(selector).action()</p>\n<p>美元符号定义 jQuery</p>\n<p>选择符（selector）“查询”和“查找” HTML 元素</p>\n<p>jQuery 的 action() 执行对元素的操作</p>\n<p>示例</p>\n<p>$(this).hide() - 隐藏当前元素</p>\n<p>$(“p”).hide() - 隐藏所有段落</p>\n<p>$(“.test”).hide() - 隐藏所有 class=”test” 的所有元素</p>\n<p>$(“#test”).hide() - 隐藏所有 id=”test” 的元素</p>\n<hr>\n<p>##文档就绪函数<br>您也许已经注意到在我们的实例中的所有 jQuery 函数位于一个 document ready 函数中：</p>\n<pre><code class=\"javascript\">$(document).ready(function(){\n\n--- jQuery functions go here ----\n\n});\n</code></pre>\n<p>这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码。</p>\n<hr>\n<p>##jQuery 事件</p>\n<p>下面是 jQuery 中事件方法的一些例子：</p>\n<table>\n<thead>\n<tr>\n<th>Event 函数</th>\n<th>绑定函数至</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$(document).ready(function)</td>\n<td>将函数绑定到文档的就绪事件（当文档完成加载时）</td>\n</tr>\n<tr>\n<td>$(selector).click(function)</td>\n<td>触发或将函数绑定到被选元素的点击事件</td>\n</tr>\n<tr>\n<td>$(selector).dblclick(function)</td>\n<td>触发或将函数绑定到被选元素的双击事件</td>\n</tr>\n<tr>\n<td>$(selector).focus(function)</td>\n<td>触发或将函数绑定到被选元素的获得焦点事件</td>\n</tr>\n<tr>\n<td>$(selector).mouseover(function)</td>\n<td>触发或将函数绑定到被选元素的鼠标悬停事件</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Jquery-Note\"><a href=\"#Jquery-Note\" class=\"headerlink\" title=\"Jquery Note\"></a>Jquery Note</h1><hr>\n<p>##jQuery 语法<br>jQuery 语法是为 HTML 元素的选取编制的，可以对元素执行某些操作。</p>\n<p>基础语法是：$(selector).action()</p>\n<p>美元符号定义 jQuery</p>\n<p>选择符（selector）“查询”和“查找” HTML 元素</p>\n<p>jQuery 的 action() 执行对元素的操作</p>\n<p>示例</p>\n<p>$(this).hide() - 隐藏当前元素</p>\n<p>$(“p”).hide() - 隐藏所有段落</p>\n<p>$(“.test”).hide() - 隐藏所有 class=”test” 的所有元素</p>\n<p>$(“#test”).hide() - 隐藏所有 id=”test” 的元素</p>\n<hr>\n<p>##文档就绪函数<br>您也许已经注意到在我们的实例中的所有 jQuery 函数位于一个 document ready 函数中：</p>\n<pre><code class=\"javascript\">$(document).ready(function(){\n\n--- jQuery functions go here ----\n\n});\n</code></pre>\n<p>这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码。</p>\n<hr>\n<p>##jQuery 事件</p>\n<p>下面是 jQuery 中事件方法的一些例子：</p>\n<table>\n<thead>\n<tr>\n<th>Event 函数</th>\n<th>绑定函数至</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$(document).ready(function)</td>\n<td>将函数绑定到文档的就绪事件（当文档完成加载时）</td>\n</tr>\n<tr>\n<td>$(selector).click(function)</td>\n<td>触发或将函数绑定到被选元素的点击事件</td>\n</tr>\n<tr>\n<td>$(selector).dblclick(function)</td>\n<td>触发或将函数绑定到被选元素的双击事件</td>\n</tr>\n<tr>\n<td>$(selector).focus(function)</td>\n<td>触发或将函数绑定到被选元素的获得焦点事件</td>\n</tr>\n<tr>\n<td>$(selector).mouseover(function)</td>\n<td>触发或将函数绑定到被选元素的鼠标悬停事件</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"jekyll","date":"2018-10-02T01:09:09.000Z","_content":"# jekyll\n```\n$ gem install jekyll\n$ jekyll new myblog\n$ cd myblog\n$ ~/myblog$jekyll serve\n\n$ gem search jekyll --remote\n```\n\nJekyll 网站的目录结构\n\n```\n.\n├── _config.yml\n├── _drafts\n|   ├── begin-with-the-crazy-ideas.textile\n|   └── on-simplicity-in-technology.markdown\n├── _includes\n|   ├── footer.html\n|   └── header.html\n├── _layouts\n|   ├── default.html\n|   └── post.html\n├── _posts\n|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile\n|   └── 2009-04-26-barcamp-boston-4-roundup.textile\n├── _site\n├── .jekyll-metadata\n└── index.html\n```\n\n| 文件 / 目录 | 描述 |\n| :--- | :--- |\n| `_config.yml` | 保存[配置](http://jekyllcn.com/docs/configuration/)数据。很多配置选项都可以直接在命令行中进行设置，但是如果你把那些配置写在这儿，你就不用非要去记住那些命令了。 |\n| `_drafts` | drafts（草稿）是未发布的文章。这些文件的格式中都没有`title.MARKUP`数据。学习如何[使用草稿](http://jekyllcn.com/docs/drafts/). |\n| `_includes` | 你可以加载这些包含部分到你的布局或者文章中以方便重用。可以用这个标签{\\% include file.ext %}`来把文件`_includes/file.ext`包含进来。 |\n| `_layouts` | layouts（布局）是包裹在文章外部的模板。布局可以在[YAML 头信息](http://jekyllcn.com/docs/frontmatter/)中根据不同文章进行选择。 这将在下一个部分进行介绍。标签`{{ content }}`可以将content插入页面中。 |\n| `_posts` | 这里放的就是你的文章了。文件格式很重要，必须要符合:`YEAR-MONTH-DAY-title.MARKUP`。[永久链接](http://jekyllcn.com/docs/permalinks/)可以在文章中自己定制，但是数据和标记语言都是根据文件名来确定的。 |\n| `_data` | 格式化好的网站数据应放在这里。jekyll 的引擎会自动加载在该目录下所有的 yaml 文件（后缀是`.yml`,`.yaml`,`.json`或者`.csv`）。这些文件可以经由 ｀site.data｀ 访问。如果有一个`members.yml`文件在该目录下，你就可以通过`site.data.members`获取该文件的内容。 |\n| `_site` | 一旦 Jekyll 完成转换，就会将生成的页面放在这里（默认）。最好将这个目录放进你的`.gitignore`文件中。 |\n| `.jekyll-metadata` | 该文件帮助 Jekyll 跟踪哪些文件从上次建立站点开始到现在没有被修改，哪些文件需要在下一次站点建立时重新生成。该文件不会被包含在生成的站点中。将它加入到你的`.gitignore`文件可能是一个好注意。 |\n| `index.html`and other HTML, Markdown, Textile files | 如果这些文件中包含[YAML 头信息](http://jekyllcn.com/docs/frontmatter/)部分，Jekyll 就会自动将它们进行转换。当然，其他的如`.html`,`.markdown`,`.md`, 或者`.textile`等在你的站点根目录下或者不是以上提到的目录中的文件也会被转换。 |\n| Other Files/Folders | 其他一些未被提及的目录和文件如`css`还有`images`文件夹，`favicon.ico`等文件都将被完全拷贝到生成的 site 中。这里有一些[使用 Jekyll 的站点](http://jekyllcn.com/docs/sites/)，如果你感兴趣就来看看吧。 |\n\n\n","source":"_posts/python/jekyll.md","raw":"---\ntitle: jekyll\ndate: 2018-10-02 09:09:09\ncategories: python\n---\n# jekyll\n```\n$ gem install jekyll\n$ jekyll new myblog\n$ cd myblog\n$ ~/myblog$jekyll serve\n\n$ gem search jekyll --remote\n```\n\nJekyll 网站的目录结构\n\n```\n.\n├── _config.yml\n├── _drafts\n|   ├── begin-with-the-crazy-ideas.textile\n|   └── on-simplicity-in-technology.markdown\n├── _includes\n|   ├── footer.html\n|   └── header.html\n├── _layouts\n|   ├── default.html\n|   └── post.html\n├── _posts\n|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile\n|   └── 2009-04-26-barcamp-boston-4-roundup.textile\n├── _site\n├── .jekyll-metadata\n└── index.html\n```\n\n| 文件 / 目录 | 描述 |\n| :--- | :--- |\n| `_config.yml` | 保存[配置](http://jekyllcn.com/docs/configuration/)数据。很多配置选项都可以直接在命令行中进行设置，但是如果你把那些配置写在这儿，你就不用非要去记住那些命令了。 |\n| `_drafts` | drafts（草稿）是未发布的文章。这些文件的格式中都没有`title.MARKUP`数据。学习如何[使用草稿](http://jekyllcn.com/docs/drafts/). |\n| `_includes` | 你可以加载这些包含部分到你的布局或者文章中以方便重用。可以用这个标签{\\% include file.ext %}`来把文件`_includes/file.ext`包含进来。 |\n| `_layouts` | layouts（布局）是包裹在文章外部的模板。布局可以在[YAML 头信息](http://jekyllcn.com/docs/frontmatter/)中根据不同文章进行选择。 这将在下一个部分进行介绍。标签`{{ content }}`可以将content插入页面中。 |\n| `_posts` | 这里放的就是你的文章了。文件格式很重要，必须要符合:`YEAR-MONTH-DAY-title.MARKUP`。[永久链接](http://jekyllcn.com/docs/permalinks/)可以在文章中自己定制，但是数据和标记语言都是根据文件名来确定的。 |\n| `_data` | 格式化好的网站数据应放在这里。jekyll 的引擎会自动加载在该目录下所有的 yaml 文件（后缀是`.yml`,`.yaml`,`.json`或者`.csv`）。这些文件可以经由 ｀site.data｀ 访问。如果有一个`members.yml`文件在该目录下，你就可以通过`site.data.members`获取该文件的内容。 |\n| `_site` | 一旦 Jekyll 完成转换，就会将生成的页面放在这里（默认）。最好将这个目录放进你的`.gitignore`文件中。 |\n| `.jekyll-metadata` | 该文件帮助 Jekyll 跟踪哪些文件从上次建立站点开始到现在没有被修改，哪些文件需要在下一次站点建立时重新生成。该文件不会被包含在生成的站点中。将它加入到你的`.gitignore`文件可能是一个好注意。 |\n| `index.html`and other HTML, Markdown, Textile files | 如果这些文件中包含[YAML 头信息](http://jekyllcn.com/docs/frontmatter/)部分，Jekyll 就会自动将它们进行转换。当然，其他的如`.html`,`.markdown`,`.md`, 或者`.textile`等在你的站点根目录下或者不是以上提到的目录中的文件也会被转换。 |\n| Other Files/Folders | 其他一些未被提及的目录和文件如`css`还有`images`文件夹，`favicon.ico`等文件都将被完全拷贝到生成的 site 中。这里有一些[使用 Jekyll 的站点](http://jekyllcn.com/docs/sites/)，如果你感兴趣就来看看吧。 |\n\n\n","slug":"python/jekyll","published":1,"updated":"2018-10-02T06:22:27.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4no003ontnbm1ea20bb","content":"<h1 id=\"jekyll\"><a href=\"#jekyll\" class=\"headerlink\" title=\"jekyll\"></a>jekyll</h1><pre><code>$ gem install jekyll\n$ jekyll new myblog\n$ cd myblog\n$ ~/myblog$jekyll serve\n\n$ gem search jekyll --remote\n</code></pre><p>Jekyll 网站的目录结构</p>\n<pre><code>.\n├── _config.yml\n├── _drafts\n|   ├── begin-with-the-crazy-ideas.textile\n|   └── on-simplicity-in-technology.markdown\n├── _includes\n|   ├── footer.html\n|   └── header.html\n├── _layouts\n|   ├── default.html\n|   └── post.html\n├── _posts\n|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile\n|   └── 2009-04-26-barcamp-boston-4-roundup.textile\n├── _site\n├── .jekyll-metadata\n└── index.html\n</code></pre><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">文件 / 目录</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>_config.yml</code></td>\n<td style=\"text-align:left\">保存<a href=\"http://jekyllcn.com/docs/configuration/\" target=\"_blank\" rel=\"noopener\">配置</a>数据。很多配置选项都可以直接在命令行中进行设置，但是如果你把那些配置写在这儿，你就不用非要去记住那些命令了。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_drafts</code></td>\n<td style=\"text-align:left\">drafts（草稿）是未发布的文章。这些文件的格式中都没有<code>title.MARKUP</code>数据。学习如何<a href=\"http://jekyllcn.com/docs/drafts/\" target=\"_blank\" rel=\"noopener\">使用草稿</a>.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_includes</code></td>\n<td style=\"text-align:left\">你可以加载这些包含部分到你的布局或者文章中以方便重用。可以用这个标签{\\% include file.ext %}<code>来把文件</code>_includes/file.ext`包含进来。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_layouts</code></td>\n<td style=\"text-align:left\">layouts（布局）是包裹在文章外部的模板。布局可以在<a href=\"http://jekyllcn.com/docs/frontmatter/\" target=\"_blank\" rel=\"noopener\">YAML 头信息</a>中根据不同文章进行选择。 这将在下一个部分进行介绍。标签<code><h1 id=\"jekyll\"><a href=\"#jekyll\" class=\"headerlink\" title=\"jekyll\"></a>jekyll</h1><pre><code>$ gem install jekyll\n$ jekyll new myblog\n$ cd myblog\n$ ~/myblog$jekyll serve\n\n$ gem search jekyll --remote\n</code></pre><p>Jekyll 网站的目录结构</p>\n<pre><code>.\n├── _config.yml\n├── _drafts\n|   ├── begin-with-the-crazy-ideas.textile\n|   └── on-simplicity-in-technology.markdown\n├── _includes\n|   ├── footer.html\n|   └── header.html\n├── _layouts\n|   ├── default.html\n|   └── post.html\n├── _posts\n|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile\n|   └── 2009-04-26-barcamp-boston-4-roundup.textile\n├── _site\n├── .jekyll-metadata\n└── index.html\n</code></pre><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">文件 / 目录</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>_config.yml</code></td>\n<td style=\"text-align:left\">保存<a href=\"http://jekyllcn.com/docs/configuration/\" target=\"_blank\" rel=\"noopener\">配置</a>数据。很多配置选项都可以直接在命令行中进行设置，但是如果你把那些配置写在这儿，你就不用非要去记住那些命令了。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_drafts</code></td>\n<td style=\"text-align:left\">drafts（草稿）是未发布的文章。这些文件的格式中都没有<code>title.MARKUP</code>数据。学习如何<a href=\"http://jekyllcn.com/docs/drafts/\" target=\"_blank\" rel=\"noopener\">使用草稿</a>.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_includes</code></td>\n<td style=\"text-align:left\">你可以加载这些包含部分到你的布局或者文章中以方便重用。可以用这个标签{\\% include file.ext %}<code>来把文件</code>_includes/file.ext`包含进来。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_layouts</code></td>\n<td style=\"text-align:left\">layouts（布局）是包裹在文章外部的模板。布局可以在<a href=\"http://jekyllcn.com/docs/frontmatter/\" target=\"_blank\" rel=\"noopener\">YAML 头信息</a>中根据不同文章进行选择。 这将在下一个部分进行介绍。标签<code>{{ content }}</code>可以将content插入页面中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_posts</code></td>\n<td style=\"text-align:left\">这里放的就是你的文章了。文件格式很重要，必须要符合:<code>YEAR-MONTH-DAY-title.MARKUP</code>。<a href=\"http://jekyllcn.com/docs/permalinks/\" target=\"_blank\" rel=\"noopener\">永久链接</a>可以在文章中自己定制，但是数据和标记语言都是根据文件名来确定的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_data</code></td>\n<td style=\"text-align:left\">格式化好的网站数据应放在这里。jekyll 的引擎会自动加载在该目录下所有的 yaml 文件（后缀是<code>.yml</code>,<code>.yaml</code>,<code>.json</code>或者<code>.csv</code>）。这些文件可以经由 ｀site.data｀ 访问。如果有一个<code>members.yml</code>文件在该目录下，你就可以通过<code>site.data.members</code>获取该文件的内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_site</code></td>\n<td style=\"text-align:left\">一旦 Jekyll 完成转换，就会将生成的页面放在这里（默认）。最好将这个目录放进你的<code>.gitignore</code>文件中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>.jekyll-metadata</code></td>\n<td style=\"text-align:left\">该文件帮助 Jekyll 跟踪哪些文件从上次建立站点开始到现在没有被修改，哪些文件需要在下一次站点建立时重新生成。该文件不会被包含在生成的站点中。将它加入到你的<code>.gitignore</code>文件可能是一个好注意。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>index.html</code>and other HTML, Markdown, Textile files</td>\n<td style=\"text-align:left\">如果这些文件中包含<a href=\"http://jekyllcn.com/docs/frontmatter/\" target=\"_blank\" rel=\"noopener\">YAML 头信息</a>部分，Jekyll 就会自动将它们进行转换。当然，其他的如<code>.html</code>,<code>.markdown</code>,<code>.md</code>, 或者<code>.textile</code>等在你的站点根目录下或者不是以上提到的目录中的文件也会被转换。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Other Files/Folders</td>\n<td style=\"text-align:left\">其他一些未被提及的目录和文件如<code>css</code>还有<code>images</code>文件夹，<code>favicon.ico</code>等文件都将被完全拷贝到生成的 site 中。这里有一些<a href=\"http://jekyllcn.com/docs/sites/\" target=\"_blank\" rel=\"noopener\">使用 Jekyll 的站点</a>，如果你感兴趣就来看看吧。</td>\n</tr>\n</tbody>\n</table>\n</code>可以将content插入页面中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_posts</code></td>\n<td style=\"text-align:left\">这里放的就是你的文章了。文件格式很重要，必须要符合:<code>YEAR-MONTH-DAY-title.MARKUP</code>。<a href=\"http://jekyllcn.com/docs/permalinks/\" target=\"_blank\" rel=\"noopener\">永久链接</a>可以在文章中自己定制，但是数据和标记语言都是根据文件名来确定的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_data</code></td>\n<td style=\"text-align:left\">格式化好的网站数据应放在这里。jekyll 的引擎会自动加载在该目录下所有的 yaml 文件（后缀是<code>.yml</code>,<code>.yaml</code>,<code>.json</code>或者<code>.csv</code>）。这些文件可以经由 ｀site.data｀ 访问。如果有一个<code>members.yml</code>文件在该目录下，你就可以通过<code>site.data.members</code>获取该文件的内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_site</code></td>\n<td style=\"text-align:left\">一旦 Jekyll 完成转换，就会将生成的页面放在这里（默认）。最好将这个目录放进你的<code>.gitignore</code>文件中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>.jekyll-metadata</code></td>\n<td style=\"text-align:left\">该文件帮助 Jekyll 跟踪哪些文件从上次建立站点开始到现在没有被修改，哪些文件需要在下一次站点建立时重新生成。该文件不会被包含在生成的站点中。将它加入到你的<code>.gitignore</code>文件可能是一个好注意。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>index.html</code>and other HTML, Markdown, Textile files</td>\n<td style=\"text-align:left\">如果这些文件中包含<a href=\"http://jekyllcn.com/docs/frontmatter/\" target=\"_blank\" rel=\"noopener\">YAML 头信息</a>部分，Jekyll 就会自动将它们进行转换。当然，其他的如<code>.html</code>,<code>.markdown</code>,<code>.md</code>, 或者<code>.textile</code>等在你的站点根目录下或者不是以上提到的目录中的文件也会被转换。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Other Files/Folders</td>\n<td style=\"text-align:left\">其他一些未被提及的目录和文件如<code>css</code>还有<code>images</code>文件夹，<code>favicon.ico</code>等文件都将被完全拷贝到生成的 site 中。这里有一些<a href=\"http://jekyllcn.com/docs/sites/\" target=\"_blank\" rel=\"noopener\">使用 Jekyll 的站点</a>，如果你感兴趣就来看看吧。</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"jekyll\"><a href=\"#jekyll\" class=\"headerlink\" title=\"jekyll\"></a>jekyll</h1><pre><code>$ gem install jekyll\n$ jekyll new myblog\n$ cd myblog\n$ ~/myblog$jekyll serve\n\n$ gem search jekyll --remote\n</code></pre><p>Jekyll 网站的目录结构</p>\n<pre><code>.\n├── _config.yml\n├── _drafts\n|   ├── begin-with-the-crazy-ideas.textile\n|   └── on-simplicity-in-technology.markdown\n├── _includes\n|   ├── footer.html\n|   └── header.html\n├── _layouts\n|   ├── default.html\n|   └── post.html\n├── _posts\n|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile\n|   └── 2009-04-26-barcamp-boston-4-roundup.textile\n├── _site\n├── .jekyll-metadata\n└── index.html\n</code></pre><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">文件 / 目录</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>_config.yml</code></td>\n<td style=\"text-align:left\">保存<a href=\"http://jekyllcn.com/docs/configuration/\" target=\"_blank\" rel=\"noopener\">配置</a>数据。很多配置选项都可以直接在命令行中进行设置，但是如果你把那些配置写在这儿，你就不用非要去记住那些命令了。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_drafts</code></td>\n<td style=\"text-align:left\">drafts（草稿）是未发布的文章。这些文件的格式中都没有<code>title.MARKUP</code>数据。学习如何<a href=\"http://jekyllcn.com/docs/drafts/\" target=\"_blank\" rel=\"noopener\">使用草稿</a>.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_includes</code></td>\n<td style=\"text-align:left\">你可以加载这些包含部分到你的布局或者文章中以方便重用。可以用这个标签{\\% include file.ext %}<code>来把文件</code>_includes/file.ext`包含进来。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_layouts</code></td>\n<td style=\"text-align:left\">layouts（布局）是包裹在文章外部的模板。布局可以在<a href=\"http://jekyllcn.com/docs/frontmatter/\" target=\"_blank\" rel=\"noopener\">YAML 头信息</a>中根据不同文章进行选择。 这将在下一个部分进行介绍。标签<code><h1 id=\"jekyll\"><a href=\"#jekyll\" class=\"headerlink\" title=\"jekyll\"></a>jekyll</h1><pre><code>$ gem install jekyll\n$ jekyll new myblog\n$ cd myblog\n$ ~/myblog$jekyll serve\n\n$ gem search jekyll --remote\n</code></pre><p>Jekyll 网站的目录结构</p>\n<pre><code>.\n├── _config.yml\n├── _drafts\n|   ├── begin-with-the-crazy-ideas.textile\n|   └── on-simplicity-in-technology.markdown\n├── _includes\n|   ├── footer.html\n|   └── header.html\n├── _layouts\n|   ├── default.html\n|   └── post.html\n├── _posts\n|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile\n|   └── 2009-04-26-barcamp-boston-4-roundup.textile\n├── _site\n├── .jekyll-metadata\n└── index.html\n</code></pre><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">文件 / 目录</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>_config.yml</code></td>\n<td style=\"text-align:left\">保存<a href=\"http://jekyllcn.com/docs/configuration/\" target=\"_blank\" rel=\"noopener\">配置</a>数据。很多配置选项都可以直接在命令行中进行设置，但是如果你把那些配置写在这儿，你就不用非要去记住那些命令了。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_drafts</code></td>\n<td style=\"text-align:left\">drafts（草稿）是未发布的文章。这些文件的格式中都没有<code>title.MARKUP</code>数据。学习如何<a href=\"http://jekyllcn.com/docs/drafts/\" target=\"_blank\" rel=\"noopener\">使用草稿</a>.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_includes</code></td>\n<td style=\"text-align:left\">你可以加载这些包含部分到你的布局或者文章中以方便重用。可以用这个标签{\\% include file.ext %}<code>来把文件</code>_includes/file.ext`包含进来。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_layouts</code></td>\n<td style=\"text-align:left\">layouts（布局）是包裹在文章外部的模板。布局可以在<a href=\"http://jekyllcn.com/docs/frontmatter/\" target=\"_blank\" rel=\"noopener\">YAML 头信息</a>中根据不同文章进行选择。 这将在下一个部分进行介绍。标签<code>{{ content }}</code>可以将content插入页面中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_posts</code></td>\n<td style=\"text-align:left\">这里放的就是你的文章了。文件格式很重要，必须要符合:<code>YEAR-MONTH-DAY-title.MARKUP</code>。<a href=\"http://jekyllcn.com/docs/permalinks/\" target=\"_blank\" rel=\"noopener\">永久链接</a>可以在文章中自己定制，但是数据和标记语言都是根据文件名来确定的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_data</code></td>\n<td style=\"text-align:left\">格式化好的网站数据应放在这里。jekyll 的引擎会自动加载在该目录下所有的 yaml 文件（后缀是<code>.yml</code>,<code>.yaml</code>,<code>.json</code>或者<code>.csv</code>）。这些文件可以经由 ｀site.data｀ 访问。如果有一个<code>members.yml</code>文件在该目录下，你就可以通过<code>site.data.members</code>获取该文件的内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_site</code></td>\n<td style=\"text-align:left\">一旦 Jekyll 完成转换，就会将生成的页面放在这里（默认）。最好将这个目录放进你的<code>.gitignore</code>文件中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>.jekyll-metadata</code></td>\n<td style=\"text-align:left\">该文件帮助 Jekyll 跟踪哪些文件从上次建立站点开始到现在没有被修改，哪些文件需要在下一次站点建立时重新生成。该文件不会被包含在生成的站点中。将它加入到你的<code>.gitignore</code>文件可能是一个好注意。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>index.html</code>and other HTML, Markdown, Textile files</td>\n<td style=\"text-align:left\">如果这些文件中包含<a href=\"http://jekyllcn.com/docs/frontmatter/\" target=\"_blank\" rel=\"noopener\">YAML 头信息</a>部分，Jekyll 就会自动将它们进行转换。当然，其他的如<code>.html</code>,<code>.markdown</code>,<code>.md</code>, 或者<code>.textile</code>等在你的站点根目录下或者不是以上提到的目录中的文件也会被转换。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Other Files/Folders</td>\n<td style=\"text-align:left\">其他一些未被提及的目录和文件如<code>css</code>还有<code>images</code>文件夹，<code>favicon.ico</code>等文件都将被完全拷贝到生成的 site 中。这里有一些<a href=\"http://jekyllcn.com/docs/sites/\" target=\"_blank\" rel=\"noopener\">使用 Jekyll 的站点</a>，如果你感兴趣就来看看吧。</td>\n</tr>\n</tbody>\n</table>\n</code>可以将content插入页面中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_posts</code></td>\n<td style=\"text-align:left\">这里放的就是你的文章了。文件格式很重要，必须要符合:<code>YEAR-MONTH-DAY-title.MARKUP</code>。<a href=\"http://jekyllcn.com/docs/permalinks/\" target=\"_blank\" rel=\"noopener\">永久链接</a>可以在文章中自己定制，但是数据和标记语言都是根据文件名来确定的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_data</code></td>\n<td style=\"text-align:left\">格式化好的网站数据应放在这里。jekyll 的引擎会自动加载在该目录下所有的 yaml 文件（后缀是<code>.yml</code>,<code>.yaml</code>,<code>.json</code>或者<code>.csv</code>）。这些文件可以经由 ｀site.data｀ 访问。如果有一个<code>members.yml</code>文件在该目录下，你就可以通过<code>site.data.members</code>获取该文件的内容。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>_site</code></td>\n<td style=\"text-align:left\">一旦 Jekyll 完成转换，就会将生成的页面放在这里（默认）。最好将这个目录放进你的<code>.gitignore</code>文件中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>.jekyll-metadata</code></td>\n<td style=\"text-align:left\">该文件帮助 Jekyll 跟踪哪些文件从上次建立站点开始到现在没有被修改，哪些文件需要在下一次站点建立时重新生成。该文件不会被包含在生成的站点中。将它加入到你的<code>.gitignore</code>文件可能是一个好注意。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>index.html</code>and other HTML, Markdown, Textile files</td>\n<td style=\"text-align:left\">如果这些文件中包含<a href=\"http://jekyllcn.com/docs/frontmatter/\" target=\"_blank\" rel=\"noopener\">YAML 头信息</a>部分，Jekyll 就会自动将它们进行转换。当然，其他的如<code>.html</code>,<code>.markdown</code>,<code>.md</code>, 或者<code>.textile</code>等在你的站点根目录下或者不是以上提到的目录中的文件也会被转换。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Other Files/Folders</td>\n<td style=\"text-align:left\">其他一些未被提及的目录和文件如<code>css</code>还有<code>images</code>文件夹，<code>favicon.ico</code>等文件都将被完全拷贝到生成的 site 中。这里有一些<a href=\"http://jekyllcn.com/docs/sites/\" target=\"_blank\" rel=\"noopener\">使用 Jekyll 的站点</a>，如果你感兴趣就来看看吧。</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"robots.txt文件","date":"2018-10-02T01:09:09.000Z","_content":"### robots.txt文件\n\n网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。\n\n文件写法\n\nUser-agent: \\* 这里的\\*代表的所有的搜索引擎种类，\\*是一个通配符\n\nDisallow: /admin/ 这里定义是禁止爬寻admin目录下面的目录\n\nDisallow: /require/ 这里定义是禁止爬寻require目录下面的目录\n\nDisallow: /ABC/ 这里定义是禁止爬寻ABC目录下面的目录\n\nDisallow: /cgi-bin/\\*.htm 禁止访问/cgi-bin/目录下的所有以\".htm\"为后缀的URL\\(包含子目录\\)。\n\nDisallow: /\\*?\\* 禁止访问网站中所有包含问号 \\(?\\) 的网址\n\nDisallow: /.jpg$ 禁止抓取网页所有的.jpg格式的图片\n\nDisallow:/ab/adc.html 禁止爬取ab文件夹下面的adc.html文件。\n\nAllow: /cgi-bin/　这里定义是允许爬寻cgi-bin目录下面的目录\n\nAllow: /tmp 这里定义是允许爬寻tmp的整个目录\n\nAllow: .htm$ 仅允许访问以\".htm\"为后缀的URL。\n\nAllow: .gif$ 允许抓取网页和gif格式图片\n\nSitemap: 网站地图 告诉爬虫这个页面是网站地图\n\n","source":"_posts/python/pythonpa-chong.md","raw":"---\ntitle: robots.txt文件\ndate: 2018-10-02 09:09:09\ncategories: python\n---\n### robots.txt文件\n\n网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。\n\n文件写法\n\nUser-agent: \\* 这里的\\*代表的所有的搜索引擎种类，\\*是一个通配符\n\nDisallow: /admin/ 这里定义是禁止爬寻admin目录下面的目录\n\nDisallow: /require/ 这里定义是禁止爬寻require目录下面的目录\n\nDisallow: /ABC/ 这里定义是禁止爬寻ABC目录下面的目录\n\nDisallow: /cgi-bin/\\*.htm 禁止访问/cgi-bin/目录下的所有以\".htm\"为后缀的URL\\(包含子目录\\)。\n\nDisallow: /\\*?\\* 禁止访问网站中所有包含问号 \\(?\\) 的网址\n\nDisallow: /.jpg$ 禁止抓取网页所有的.jpg格式的图片\n\nDisallow:/ab/adc.html 禁止爬取ab文件夹下面的adc.html文件。\n\nAllow: /cgi-bin/　这里定义是允许爬寻cgi-bin目录下面的目录\n\nAllow: /tmp 这里定义是允许爬寻tmp的整个目录\n\nAllow: .htm$ 仅允许访问以\".htm\"为后缀的URL。\n\nAllow: .gif$ 允许抓取网页和gif格式图片\n\nSitemap: 网站地图 告诉爬虫这个页面是网站地图\n\n","slug":"python/pythonpa-chong","published":1,"updated":"2018-10-02T07:24:33.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4nr003pntnbhkerhd72","content":"<h3 id=\"robots-txt文件\"><a href=\"#robots-txt文件\" class=\"headerlink\" title=\"robots.txt文件\"></a>robots.txt文件</h3><p>网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。</p>\n<p>文件写法</p>\n<p>User-agent: * 这里的*代表的所有的搜索引擎种类，*是一个通配符</p>\n<p>Disallow: /admin/ 这里定义是禁止爬寻admin目录下面的目录</p>\n<p>Disallow: /require/ 这里定义是禁止爬寻require目录下面的目录</p>\n<p>Disallow: /ABC/ 这里定义是禁止爬寻ABC目录下面的目录</p>\n<p>Disallow: /cgi-bin/*.htm 禁止访问/cgi-bin/目录下的所有以”.htm”为后缀的URL(包含子目录)。</p>\n<p>Disallow: /*?* 禁止访问网站中所有包含问号 (?) 的网址</p>\n<p>Disallow: /.jpg$ 禁止抓取网页所有的.jpg格式的图片</p>\n<p>Disallow:/ab/adc.html 禁止爬取ab文件夹下面的adc.html文件。</p>\n<p>Allow: /cgi-bin/　这里定义是允许爬寻cgi-bin目录下面的目录</p>\n<p>Allow: /tmp 这里定义是允许爬寻tmp的整个目录</p>\n<p>Allow: .htm$ 仅允许访问以”.htm”为后缀的URL。</p>\n<p>Allow: .gif$ 允许抓取网页和gif格式图片</p>\n<p>Sitemap: 网站地图 告诉爬虫这个页面是网站地图</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"robots-txt文件\"><a href=\"#robots-txt文件\" class=\"headerlink\" title=\"robots.txt文件\"></a>robots.txt文件</h3><p>网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。</p>\n<p>文件写法</p>\n<p>User-agent: * 这里的*代表的所有的搜索引擎种类，*是一个通配符</p>\n<p>Disallow: /admin/ 这里定义是禁止爬寻admin目录下面的目录</p>\n<p>Disallow: /require/ 这里定义是禁止爬寻require目录下面的目录</p>\n<p>Disallow: /ABC/ 这里定义是禁止爬寻ABC目录下面的目录</p>\n<p>Disallow: /cgi-bin/*.htm 禁止访问/cgi-bin/目录下的所有以”.htm”为后缀的URL(包含子目录)。</p>\n<p>Disallow: /*?* 禁止访问网站中所有包含问号 (?) 的网址</p>\n<p>Disallow: /.jpg$ 禁止抓取网页所有的.jpg格式的图片</p>\n<p>Disallow:/ab/adc.html 禁止爬取ab文件夹下面的adc.html文件。</p>\n<p>Allow: /cgi-bin/　这里定义是允许爬寻cgi-bin目录下面的目录</p>\n<p>Allow: /tmp 这里定义是允许爬寻tmp的整个目录</p>\n<p>Allow: .htm$ 仅允许访问以”.htm”为后缀的URL。</p>\n<p>Allow: .gif$ 允许抓取网页和gif格式图片</p>\n<p>Sitemap: 网站地图 告诉爬虫这个页面是网站地图</p>\n"},{"title":"python","date":"2018-10-02T01:09:09.000Z","_content":"## 标识符\n\n以下划线开头的标识符是有特殊意义的。\n\n以单下划线开头\\_foo的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用from xxx import \\*而导入；\n\n以双下划线开头的\\_\\_foo代表类的私有成员；\n\n以双下划线开头和结尾的\\_\\_foo\\_\\_代表 Python 里特殊方法专用的标识，如\\_\\_init\\_\\_\\(\\)代表类的构造函数。\n\n","source":"_posts/python/pythonru-men.md","raw":"---\ntitle: python \ndate: 2018-10-02 09:09:09\ncategories: python\n---\n## 标识符\n\n以下划线开头的标识符是有特殊意义的。\n\n以单下划线开头\\_foo的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用from xxx import \\*而导入；\n\n以双下划线开头的\\_\\_foo代表类的私有成员；\n\n以双下划线开头和结尾的\\_\\_foo\\_\\_代表 Python 里特殊方法专用的标识，如\\_\\_init\\_\\_\\(\\)代表类的构造函数。\n\n","slug":"python/pythonru-men","published":1,"updated":"2018-10-02T03:01:59.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4nt003sntnbt9g13rg4","content":"<h2 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h2><p>以下划线开头的标识符是有特殊意义的。</p>\n<p>以单下划线开头_foo的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用from xxx import *而导入；</p>\n<p>以双下划线开头的__foo代表类的私有成员；</p>\n<p>以双下划线开头和结尾的__foo__代表 Python 里特殊方法专用的标识，如__init__()代表类的构造函数。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h2><p>以下划线开头的标识符是有特殊意义的。</p>\n<p>以单下划线开头_foo的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用from xxx import *而导入；</p>\n<p>以双下划线开头的__foo代表类的私有成员；</p>\n<p>以双下划线开头和结尾的__foo__代表 Python 里特殊方法专用的标识，如__init__()代表类的构造函数。</p>\n"},{"title":"Xamarin体验","date":"2018-10-02T01:09:09.000Z","_content":"## Xamarin 是什么\n\n使用 .net 技術完成所有平台共用的和無關的邏輯部分，由於各個平台的 UI 和交互不同，在使用由 Xamarin 封裝好的 C\\# API 來訪問和操作 native 的控件，分別進行不同平台的 UI 開發。![](/assets/xamarin-share.png)\n\n主要幾項技術，Xamarin.Android、Xamarin.iOS、Xamarin.UWP 和 Xamarin.Forms 等。\n\n![](/assets/xamarinwhat.png)\n\n### 工作原理\n\n#### iOS 通過 AOT 靜態編譯成二進制運行\n\n在 iOS 上，Xamarin 的預先 \\(AOT靜態編譯\\) 編譯器將 Xamarin.iOS 應用程序直接編譯到本機 ARM 程序集代碼。對於開發者來說，Xamarin.IOS相對於Xamarin.Android就要簡單很多了，我們用C\\#開發的iOS應用程序在被編譯成IL代碼之後，然後轉交給Apple complier直接編譯成iOS的本地機器碼，也就是說C\\#寫的iOS應用程序和Objective-C 寫的是一樣的。透過 Ahead-of-Time \\(AOT\\) 編譯程序，直接將Xamarin.iOS程序編譯為ARM的執行檔。編譯封裝完成的應用程序被直接編譯為原生的二進制執行文件。\n\n![](/assets/xamarin-iOS-run.png)\n\n#### Android 在啟動時通過 JIT 動態編譯\n\n在 Android 上，Xamarin 編譯器則將應用編譯為中間語言 \\(IL\\)，隨後啟用應用程序時，再實時 \\(JIT動態編譯\\) 編譯為本機程序集。\n\n##### Android Callable Wrappers（ACW）\n\n使用 C\\# 開發的Android應用程序在運行的時候，C\\# 代碼是在 Mono 虛擬機中執行的，而 Mono 虛擬機是寄宿在Dalvik虛擬機中運行的，所有的 C\\# 代碼都通過ACW的方式被調用。  \n由於需要打包 Mono 環境，使用 C\\# 開發的 Android 應用的 APK 文件會比原生開發的大，執行效率也會差一些。\n\n##### Managed Callable Wrapper（MCW）\n\n如果需要在 C\\# 中調用一些系統的功能或者 Java 實現的類庫，該如何調用那？ 答案就是 MCW ，MCW 就是一個JNI橋梁，可以使用托管代碼調用 Android 的代碼。MCW 將整個 Android.\\*  以及相關的命名空間通過 jar綁定的方式暴露出來，是的C\\#可以調用。\n\n![](/assets/xamarin-android-mono.png)\n\n## Xamarin 為什麽要使用\n\n從各個平台底層業務代碼統一（web、mobile、desktop），界面開發統一。Xamarin.Forms 各平台 GUI 統一抽象，獲得原生平台的外觀和性能，但不適合開發圖形界面覆雜且頻繁的應用。遇到這情況可以使用Xamarin.Android、Xamarin.iOS 解決。Forms 的 mvvm 設計模式和綁定數據非常直觀，提高開發速度。\n\n## Xamarin 能做什麽\n\n構建 iOS 應用；構建 Android 應用；構建 Forms 跨平台應用；開發生產 iOS、Android 和 Windows Phone 的應用甚至遊戲，配合平台能做測試、數據分析等所有熱門功能，但不能熱更新。\n\n## Xamarin 什麽時候用\n\n適合規模較少，需要跨平台開發的項目；有 .net 底蘊的團隊，將資源分配到移動項目的團隊。\n\n## Xamarin 適合什麽人使用\n\n熟悉 C\\# .NET 技術的開發人員；iOS 或 Android 經驗的開發人員\n\n## Xamarin 與時下技術比較\n\n|  | Xarmarin | Native App（Android/iOS） | WebApp（Angular、React） | Hybrid（phonegap/Cordova） | 基于JS的Native（RN） | PWA | U3D |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| 原生技术 | yes | yes |  | maybe 依賴接口 | yes |  | yes |\n| 原生交互 |  |  |  | maybe 依賴接口 | yes |  | yes |\n| 前端技术 |  |  | yes | yes | yes | yes | yes |\n| 跨平台 | yes |  | yes | yes | yes | yes | yes |\n| 本地交互 | yes | yes |  | maybe 依賴接口 | yes |  | yes |\n| 免安装 |  |  | yes |  |  | yes | yes |\n| 热更新 |  |  | yes | yes | yes 但 iOS 含有 jspatch 被禁止 | yes | yes |\n| 性能 | 4 | 5 | 1 | 2 | 2 | 3 | 3 |\n\n## Xamarin 缺點\n\n#### 与最新版本的各种平台不兼容\n\n與其他跨平台一樣，Xamarin建立在本機iOS操作系統和框架之上。對iOS，Android和Windows的最新平台更新有延遲支持。盡管擁有一個龐大的團隊，但Xamarin需要時間來適應iOS和Android的操作系統更改。\n\n#### 有限的開源庫\n\n儘管有 .NET 許多的開源庫，但是不能使用 iOS 或 Android 的第三方庫\n\n#### 社區規模小\n\n## 與 Xamarin 有關的用戶和產品\n\n[http://www.cnblogs.com/cloudinfo/p/7286628.html](http://www.cnblogs.com/cloudinfo/p/7286628.html)\n\n[https://www.xamarin.com/customers](https://www.xamarin.com/customers)\n\n","source":"_posts/xamarin/xarmarinchu-bu-le-jie.md","raw":"---\ntitle: Xamarin体验\ndate: 2018-10-02 09:09:09\ncategories: xamarin\n---\n## Xamarin 是什么\n\n使用 .net 技術完成所有平台共用的和無關的邏輯部分，由於各個平台的 UI 和交互不同，在使用由 Xamarin 封裝好的 C\\# API 來訪問和操作 native 的控件，分別進行不同平台的 UI 開發。![](/assets/xamarin-share.png)\n\n主要幾項技術，Xamarin.Android、Xamarin.iOS、Xamarin.UWP 和 Xamarin.Forms 等。\n\n![](/assets/xamarinwhat.png)\n\n### 工作原理\n\n#### iOS 通過 AOT 靜態編譯成二進制運行\n\n在 iOS 上，Xamarin 的預先 \\(AOT靜態編譯\\) 編譯器將 Xamarin.iOS 應用程序直接編譯到本機 ARM 程序集代碼。對於開發者來說，Xamarin.IOS相對於Xamarin.Android就要簡單很多了，我們用C\\#開發的iOS應用程序在被編譯成IL代碼之後，然後轉交給Apple complier直接編譯成iOS的本地機器碼，也就是說C\\#寫的iOS應用程序和Objective-C 寫的是一樣的。透過 Ahead-of-Time \\(AOT\\) 編譯程序，直接將Xamarin.iOS程序編譯為ARM的執行檔。編譯封裝完成的應用程序被直接編譯為原生的二進制執行文件。\n\n![](/assets/xamarin-iOS-run.png)\n\n#### Android 在啟動時通過 JIT 動態編譯\n\n在 Android 上，Xamarin 編譯器則將應用編譯為中間語言 \\(IL\\)，隨後啟用應用程序時，再實時 \\(JIT動態編譯\\) 編譯為本機程序集。\n\n##### Android Callable Wrappers（ACW）\n\n使用 C\\# 開發的Android應用程序在運行的時候，C\\# 代碼是在 Mono 虛擬機中執行的，而 Mono 虛擬機是寄宿在Dalvik虛擬機中運行的，所有的 C\\# 代碼都通過ACW的方式被調用。  \n由於需要打包 Mono 環境，使用 C\\# 開發的 Android 應用的 APK 文件會比原生開發的大，執行效率也會差一些。\n\n##### Managed Callable Wrapper（MCW）\n\n如果需要在 C\\# 中調用一些系統的功能或者 Java 實現的類庫，該如何調用那？ 答案就是 MCW ，MCW 就是一個JNI橋梁，可以使用托管代碼調用 Android 的代碼。MCW 將整個 Android.\\*  以及相關的命名空間通過 jar綁定的方式暴露出來，是的C\\#可以調用。\n\n![](/assets/xamarin-android-mono.png)\n\n## Xamarin 為什麽要使用\n\n從各個平台底層業務代碼統一（web、mobile、desktop），界面開發統一。Xamarin.Forms 各平台 GUI 統一抽象，獲得原生平台的外觀和性能，但不適合開發圖形界面覆雜且頻繁的應用。遇到這情況可以使用Xamarin.Android、Xamarin.iOS 解決。Forms 的 mvvm 設計模式和綁定數據非常直觀，提高開發速度。\n\n## Xamarin 能做什麽\n\n構建 iOS 應用；構建 Android 應用；構建 Forms 跨平台應用；開發生產 iOS、Android 和 Windows Phone 的應用甚至遊戲，配合平台能做測試、數據分析等所有熱門功能，但不能熱更新。\n\n## Xamarin 什麽時候用\n\n適合規模較少，需要跨平台開發的項目；有 .net 底蘊的團隊，將資源分配到移動項目的團隊。\n\n## Xamarin 適合什麽人使用\n\n熟悉 C\\# .NET 技術的開發人員；iOS 或 Android 經驗的開發人員\n\n## Xamarin 與時下技術比較\n\n|  | Xarmarin | Native App（Android/iOS） | WebApp（Angular、React） | Hybrid（phonegap/Cordova） | 基于JS的Native（RN） | PWA | U3D |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| 原生技术 | yes | yes |  | maybe 依賴接口 | yes |  | yes |\n| 原生交互 |  |  |  | maybe 依賴接口 | yes |  | yes |\n| 前端技术 |  |  | yes | yes | yes | yes | yes |\n| 跨平台 | yes |  | yes | yes | yes | yes | yes |\n| 本地交互 | yes | yes |  | maybe 依賴接口 | yes |  | yes |\n| 免安装 |  |  | yes |  |  | yes | yes |\n| 热更新 |  |  | yes | yes | yes 但 iOS 含有 jspatch 被禁止 | yes | yes |\n| 性能 | 4 | 5 | 1 | 2 | 2 | 3 | 3 |\n\n## Xamarin 缺點\n\n#### 与最新版本的各种平台不兼容\n\n與其他跨平台一樣，Xamarin建立在本機iOS操作系統和框架之上。對iOS，Android和Windows的最新平台更新有延遲支持。盡管擁有一個龐大的團隊，但Xamarin需要時間來適應iOS和Android的操作系統更改。\n\n#### 有限的開源庫\n\n儘管有 .NET 許多的開源庫，但是不能使用 iOS 或 Android 的第三方庫\n\n#### 社區規模小\n\n## 與 Xamarin 有關的用戶和產品\n\n[http://www.cnblogs.com/cloudinfo/p/7286628.html](http://www.cnblogs.com/cloudinfo/p/7286628.html)\n\n[https://www.xamarin.com/customers](https://www.xamarin.com/customers)\n\n","slug":"xamarin/xarmarinchu-bu-le-jie","published":1,"updated":"2018-10-02T03:31:49.497Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4nu003tntnb7uqzbn8s","content":"<h2 id=\"Xamarin-是什么\"><a href=\"#Xamarin-是什么\" class=\"headerlink\" title=\"Xamarin 是什么\"></a>Xamarin 是什么</h2><p>使用 .net 技術完成所有平台共用的和無關的邏輯部分，由於各個平台的 UI 和交互不同，在使用由 Xamarin 封裝好的 C# API 來訪問和操作 native 的控件，分別進行不同平台的 UI 開發。<img src=\"/assets/xamarin-share.png\" alt=\"\"></p>\n<p>主要幾項技術，Xamarin.Android、Xamarin.iOS、Xamarin.UWP 和 Xamarin.Forms 等。</p>\n<p><img src=\"/assets/xamarinwhat.png\" alt=\"\"></p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><h4 id=\"iOS-通過-AOT-靜態編譯成二進制運行\"><a href=\"#iOS-通過-AOT-靜態編譯成二進制運行\" class=\"headerlink\" title=\"iOS 通過 AOT 靜態編譯成二進制運行\"></a>iOS 通過 AOT 靜態編譯成二進制運行</h4><p>在 iOS 上，Xamarin 的預先 (AOT靜態編譯) 編譯器將 Xamarin.iOS 應用程序直接編譯到本機 ARM 程序集代碼。對於開發者來說，Xamarin.IOS相對於Xamarin.Android就要簡單很多了，我們用C#開發的iOS應用程序在被編譯成IL代碼之後，然後轉交給Apple complier直接編譯成iOS的本地機器碼，也就是說C#寫的iOS應用程序和Objective-C 寫的是一樣的。透過 Ahead-of-Time (AOT) 編譯程序，直接將Xamarin.iOS程序編譯為ARM的執行檔。編譯封裝完成的應用程序被直接編譯為原生的二進制執行文件。</p>\n<p><img src=\"/assets/xamarin-iOS-run.png\" alt=\"\"></p>\n<h4 id=\"Android-在啟動時通過-JIT-動態編譯\"><a href=\"#Android-在啟動時通過-JIT-動態編譯\" class=\"headerlink\" title=\"Android 在啟動時通過 JIT 動態編譯\"></a>Android 在啟動時通過 JIT 動態編譯</h4><p>在 Android 上，Xamarin 編譯器則將應用編譯為中間語言 (IL)，隨後啟用應用程序時，再實時 (JIT動態編譯) 編譯為本機程序集。</p>\n<h5 id=\"Android-Callable-Wrappers（ACW）\"><a href=\"#Android-Callable-Wrappers（ACW）\" class=\"headerlink\" title=\"Android Callable Wrappers（ACW）\"></a>Android Callable Wrappers（ACW）</h5><p>使用 C# 開發的Android應用程序在運行的時候，C# 代碼是在 Mono 虛擬機中執行的，而 Mono 虛擬機是寄宿在Dalvik虛擬機中運行的，所有的 C# 代碼都通過ACW的方式被調用。<br>由於需要打包 Mono 環境，使用 C# 開發的 Android 應用的 APK 文件會比原生開發的大，執行效率也會差一些。</p>\n<h5 id=\"Managed-Callable-Wrapper（MCW）\"><a href=\"#Managed-Callable-Wrapper（MCW）\" class=\"headerlink\" title=\"Managed Callable Wrapper（MCW）\"></a>Managed Callable Wrapper（MCW）</h5><p>如果需要在 C# 中調用一些系統的功能或者 Java 實現的類庫，該如何調用那？ 答案就是 MCW ，MCW 就是一個JNI橋梁，可以使用托管代碼調用 Android 的代碼。MCW 將整個 Android.*  以及相關的命名空間通過 jar綁定的方式暴露出來，是的C#可以調用。</p>\n<p><img src=\"/assets/xamarin-android-mono.png\" alt=\"\"></p>\n<h2 id=\"Xamarin-為什麽要使用\"><a href=\"#Xamarin-為什麽要使用\" class=\"headerlink\" title=\"Xamarin 為什麽要使用\"></a>Xamarin 為什麽要使用</h2><p>從各個平台底層業務代碼統一（web、mobile、desktop），界面開發統一。Xamarin.Forms 各平台 GUI 統一抽象，獲得原生平台的外觀和性能，但不適合開發圖形界面覆雜且頻繁的應用。遇到這情況可以使用Xamarin.Android、Xamarin.iOS 解決。Forms 的 mvvm 設計模式和綁定數據非常直觀，提高開發速度。</p>\n<h2 id=\"Xamarin-能做什麽\"><a href=\"#Xamarin-能做什麽\" class=\"headerlink\" title=\"Xamarin 能做什麽\"></a>Xamarin 能做什麽</h2><p>構建 iOS 應用；構建 Android 應用；構建 Forms 跨平台應用；開發生產 iOS、Android 和 Windows Phone 的應用甚至遊戲，配合平台能做測試、數據分析等所有熱門功能，但不能熱更新。</p>\n<h2 id=\"Xamarin-什麽時候用\"><a href=\"#Xamarin-什麽時候用\" class=\"headerlink\" title=\"Xamarin 什麽時候用\"></a>Xamarin 什麽時候用</h2><p>適合規模較少，需要跨平台開發的項目；有 .net 底蘊的團隊，將資源分配到移動項目的團隊。</p>\n<h2 id=\"Xamarin-適合什麽人使用\"><a href=\"#Xamarin-適合什麽人使用\" class=\"headerlink\" title=\"Xamarin 適合什麽人使用\"></a>Xamarin 適合什麽人使用</h2><p>熟悉 C# .NET 技術的開發人員；iOS 或 Android 經驗的開發人員</p>\n<h2 id=\"Xamarin-與時下技術比較\"><a href=\"#Xamarin-與時下技術比較\" class=\"headerlink\" title=\"Xamarin 與時下技術比較\"></a>Xamarin 與時下技術比較</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">Xarmarin</th>\n<th style=\"text-align:left\">Native App（Android/iOS）</th>\n<th style=\"text-align:left\">WebApp（Angular、React）</th>\n<th style=\"text-align:left\">Hybrid（phonegap/Cordova）</th>\n<th style=\"text-align:left\">基于JS的Native（RN）</th>\n<th style=\"text-align:left\">PWA</th>\n<th style=\"text-align:left\">U3D</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">原生技术</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">maybe 依賴接口</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">原生交互</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">maybe 依賴接口</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">前端技术</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">跨平台</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">本地交互</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">maybe 依賴接口</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">免安装</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">热更新</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes 但 iOS 含有 jspatch 被禁止</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">性能</td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">3</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Xamarin-缺點\"><a href=\"#Xamarin-缺點\" class=\"headerlink\" title=\"Xamarin 缺點\"></a>Xamarin 缺點</h2><h4 id=\"与最新版本的各种平台不兼容\"><a href=\"#与最新版本的各种平台不兼容\" class=\"headerlink\" title=\"与最新版本的各种平台不兼容\"></a>与最新版本的各种平台不兼容</h4><p>與其他跨平台一樣，Xamarin建立在本機iOS操作系統和框架之上。對iOS，Android和Windows的最新平台更新有延遲支持。盡管擁有一個龐大的團隊，但Xamarin需要時間來適應iOS和Android的操作系統更改。</p>\n<h4 id=\"有限的開源庫\"><a href=\"#有限的開源庫\" class=\"headerlink\" title=\"有限的開源庫\"></a>有限的開源庫</h4><p>儘管有 .NET 許多的開源庫，但是不能使用 iOS 或 Android 的第三方庫</p>\n<h4 id=\"社區規模小\"><a href=\"#社區規模小\" class=\"headerlink\" title=\"社區規模小\"></a>社區規模小</h4><h2 id=\"與-Xamarin-有關的用戶和產品\"><a href=\"#與-Xamarin-有關的用戶和產品\" class=\"headerlink\" title=\"與 Xamarin 有關的用戶和產品\"></a>與 Xamarin 有關的用戶和產品</h2><p><a href=\"http://www.cnblogs.com/cloudinfo/p/7286628.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/cloudinfo/p/7286628.html</a></p>\n<p><a href=\"https://www.xamarin.com/customers\" target=\"_blank\" rel=\"noopener\">https://www.xamarin.com/customers</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Xamarin-是什么\"><a href=\"#Xamarin-是什么\" class=\"headerlink\" title=\"Xamarin 是什么\"></a>Xamarin 是什么</h2><p>使用 .net 技術完成所有平台共用的和無關的邏輯部分，由於各個平台的 UI 和交互不同，在使用由 Xamarin 封裝好的 C# API 來訪問和操作 native 的控件，分別進行不同平台的 UI 開發。<img src=\"/assets/xamarin-share.png\" alt=\"\"></p>\n<p>主要幾項技術，Xamarin.Android、Xamarin.iOS、Xamarin.UWP 和 Xamarin.Forms 等。</p>\n<p><img src=\"/assets/xamarinwhat.png\" alt=\"\"></p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><h4 id=\"iOS-通過-AOT-靜態編譯成二進制運行\"><a href=\"#iOS-通過-AOT-靜態編譯成二進制運行\" class=\"headerlink\" title=\"iOS 通過 AOT 靜態編譯成二進制運行\"></a>iOS 通過 AOT 靜態編譯成二進制運行</h4><p>在 iOS 上，Xamarin 的預先 (AOT靜態編譯) 編譯器將 Xamarin.iOS 應用程序直接編譯到本機 ARM 程序集代碼。對於開發者來說，Xamarin.IOS相對於Xamarin.Android就要簡單很多了，我們用C#開發的iOS應用程序在被編譯成IL代碼之後，然後轉交給Apple complier直接編譯成iOS的本地機器碼，也就是說C#寫的iOS應用程序和Objective-C 寫的是一樣的。透過 Ahead-of-Time (AOT) 編譯程序，直接將Xamarin.iOS程序編譯為ARM的執行檔。編譯封裝完成的應用程序被直接編譯為原生的二進制執行文件。</p>\n<p><img src=\"/assets/xamarin-iOS-run.png\" alt=\"\"></p>\n<h4 id=\"Android-在啟動時通過-JIT-動態編譯\"><a href=\"#Android-在啟動時通過-JIT-動態編譯\" class=\"headerlink\" title=\"Android 在啟動時通過 JIT 動態編譯\"></a>Android 在啟動時通過 JIT 動態編譯</h4><p>在 Android 上，Xamarin 編譯器則將應用編譯為中間語言 (IL)，隨後啟用應用程序時，再實時 (JIT動態編譯) 編譯為本機程序集。</p>\n<h5 id=\"Android-Callable-Wrappers（ACW）\"><a href=\"#Android-Callable-Wrappers（ACW）\" class=\"headerlink\" title=\"Android Callable Wrappers（ACW）\"></a>Android Callable Wrappers（ACW）</h5><p>使用 C# 開發的Android應用程序在運行的時候，C# 代碼是在 Mono 虛擬機中執行的，而 Mono 虛擬機是寄宿在Dalvik虛擬機中運行的，所有的 C# 代碼都通過ACW的方式被調用。<br>由於需要打包 Mono 環境，使用 C# 開發的 Android 應用的 APK 文件會比原生開發的大，執行效率也會差一些。</p>\n<h5 id=\"Managed-Callable-Wrapper（MCW）\"><a href=\"#Managed-Callable-Wrapper（MCW）\" class=\"headerlink\" title=\"Managed Callable Wrapper（MCW）\"></a>Managed Callable Wrapper（MCW）</h5><p>如果需要在 C# 中調用一些系統的功能或者 Java 實現的類庫，該如何調用那？ 答案就是 MCW ，MCW 就是一個JNI橋梁，可以使用托管代碼調用 Android 的代碼。MCW 將整個 Android.*  以及相關的命名空間通過 jar綁定的方式暴露出來，是的C#可以調用。</p>\n<p><img src=\"/assets/xamarin-android-mono.png\" alt=\"\"></p>\n<h2 id=\"Xamarin-為什麽要使用\"><a href=\"#Xamarin-為什麽要使用\" class=\"headerlink\" title=\"Xamarin 為什麽要使用\"></a>Xamarin 為什麽要使用</h2><p>從各個平台底層業務代碼統一（web、mobile、desktop），界面開發統一。Xamarin.Forms 各平台 GUI 統一抽象，獲得原生平台的外觀和性能，但不適合開發圖形界面覆雜且頻繁的應用。遇到這情況可以使用Xamarin.Android、Xamarin.iOS 解決。Forms 的 mvvm 設計模式和綁定數據非常直觀，提高開發速度。</p>\n<h2 id=\"Xamarin-能做什麽\"><a href=\"#Xamarin-能做什麽\" class=\"headerlink\" title=\"Xamarin 能做什麽\"></a>Xamarin 能做什麽</h2><p>構建 iOS 應用；構建 Android 應用；構建 Forms 跨平台應用；開發生產 iOS、Android 和 Windows Phone 的應用甚至遊戲，配合平台能做測試、數據分析等所有熱門功能，但不能熱更新。</p>\n<h2 id=\"Xamarin-什麽時候用\"><a href=\"#Xamarin-什麽時候用\" class=\"headerlink\" title=\"Xamarin 什麽時候用\"></a>Xamarin 什麽時候用</h2><p>適合規模較少，需要跨平台開發的項目；有 .net 底蘊的團隊，將資源分配到移動項目的團隊。</p>\n<h2 id=\"Xamarin-適合什麽人使用\"><a href=\"#Xamarin-適合什麽人使用\" class=\"headerlink\" title=\"Xamarin 適合什麽人使用\"></a>Xamarin 適合什麽人使用</h2><p>熟悉 C# .NET 技術的開發人員；iOS 或 Android 經驗的開發人員</p>\n<h2 id=\"Xamarin-與時下技術比較\"><a href=\"#Xamarin-與時下技術比較\" class=\"headerlink\" title=\"Xamarin 與時下技術比較\"></a>Xamarin 與時下技術比較</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">Xarmarin</th>\n<th style=\"text-align:left\">Native App（Android/iOS）</th>\n<th style=\"text-align:left\">WebApp（Angular、React）</th>\n<th style=\"text-align:left\">Hybrid（phonegap/Cordova）</th>\n<th style=\"text-align:left\">基于JS的Native（RN）</th>\n<th style=\"text-align:left\">PWA</th>\n<th style=\"text-align:left\">U3D</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">原生技术</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">maybe 依賴接口</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">原生交互</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">maybe 依賴接口</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">前端技术</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">跨平台</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">本地交互</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">maybe 依賴接口</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">免安装</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">热更新</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes 但 iOS 含有 jspatch 被禁止</td>\n<td style=\"text-align:left\">yes</td>\n<td style=\"text-align:left\">yes</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">性能</td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">3</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Xamarin-缺點\"><a href=\"#Xamarin-缺點\" class=\"headerlink\" title=\"Xamarin 缺點\"></a>Xamarin 缺點</h2><h4 id=\"与最新版本的各种平台不兼容\"><a href=\"#与最新版本的各种平台不兼容\" class=\"headerlink\" title=\"与最新版本的各种平台不兼容\"></a>与最新版本的各种平台不兼容</h4><p>與其他跨平台一樣，Xamarin建立在本機iOS操作系統和框架之上。對iOS，Android和Windows的最新平台更新有延遲支持。盡管擁有一個龐大的團隊，但Xamarin需要時間來適應iOS和Android的操作系統更改。</p>\n<h4 id=\"有限的開源庫\"><a href=\"#有限的開源庫\" class=\"headerlink\" title=\"有限的開源庫\"></a>有限的開源庫</h4><p>儘管有 .NET 許多的開源庫，但是不能使用 iOS 或 Android 的第三方庫</p>\n<h4 id=\"社區規模小\"><a href=\"#社區規模小\" class=\"headerlink\" title=\"社區規模小\"></a>社區規模小</h4><h2 id=\"與-Xamarin-有關的用戶和產品\"><a href=\"#與-Xamarin-有關的用戶和產品\" class=\"headerlink\" title=\"與 Xamarin 有關的用戶和產品\"></a>與 Xamarin 有關的用戶和產品</h2><p><a href=\"http://www.cnblogs.com/cloudinfo/p/7286628.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/cloudinfo/p/7286628.html</a></p>\n<p><a href=\"https://www.xamarin.com/customers\" target=\"_blank\" rel=\"noopener\">https://www.xamarin.com/customers</a></p>\n"},{"title":"Xamarin笔记","date":"2018-10-02T01:09:09.000Z","_content":"# 項目結構\n\n建立 Forms 應用之後，能創建 android 和 iOS 的應用項目，下圖解決方案裡有三個項目第一個是 Forms，是共用與 android 和 iOS 兩個平台的源碼；.Droid 是 android 項目，單獨對 android 項目使用的源碼，是 C\\# 編程，可以使用 xml 佈局文件，樣式資源文件等；.iOS 是 iOS 項目，同樣使用 C\\# 編程，可以通過 storyboard 構建頁面邏輯。\n\n![](/assets/xamarin_project_structure.png)\n\n\n\n","source":"_posts/xamarin/xiang-mu-jie-gou.md","raw":"---\ntitle: Xamarin笔记\ndate: 2018-10-02 09:09:09\ncategories: xamarin\n---\n# 項目結構\n\n建立 Forms 應用之後，能創建 android 和 iOS 的應用項目，下圖解決方案裡有三個項目第一個是 Forms，是共用與 android 和 iOS 兩個平台的源碼；.Droid 是 android 項目，單獨對 android 項目使用的源碼，是 C\\# 編程，可以使用 xml 佈局文件，樣式資源文件等；.iOS 是 iOS 項目，同樣使用 C\\# 編程，可以通過 storyboard 構建頁面邏輯。\n\n![](/assets/xamarin_project_structure.png)\n\n\n\n","slug":"xamarin/xiang-mu-jie-gou","published":1,"updated":"2018-10-02T03:31:31.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4nv003wntnb3s28nga2","content":"<h1 id=\"項目結構\"><a href=\"#項目結構\" class=\"headerlink\" title=\"項目結構\"></a>項目結構</h1><p>建立 Forms 應用之後，能創建 android 和 iOS 的應用項目，下圖解決方案裡有三個項目第一個是 Forms，是共用與 android 和 iOS 兩個平台的源碼；.Droid 是 android 項目，單獨對 android 項目使用的源碼，是 C# 編程，可以使用 xml 佈局文件，樣式資源文件等；.iOS 是 iOS 項目，同樣使用 C# 編程，可以通過 storyboard 構建頁面邏輯。</p>\n<p><img src=\"/assets/xamarin_project_structure.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"項目結構\"><a href=\"#項目結構\" class=\"headerlink\" title=\"項目結構\"></a>項目結構</h1><p>建立 Forms 應用之後，能創建 android 和 iOS 的應用項目，下圖解決方案裡有三個項目第一個是 Forms，是共用與 android 和 iOS 兩個平台的源碼；.Droid 是 android 項目，單獨對 android 項目使用的源碼，是 C# 編程，可以使用 xml 佈局文件，樣式資源文件等；.iOS 是 iOS 項目，同樣使用 C# 編程，可以通過 storyboard 構建頁面邏輯。</p>\n<p><img src=\"/assets/xamarin_project_structure.png\" alt=\"\"></p>\n"},{"title":"byrid","date":"2018-10-02T01:09:09.000Z","_content":"# app 混合開發方案\n\n本方案基於 js 橋接方式作為混合開發，在線下載 html 模板更新 ui，適合在線更新。\n\n需要了解：前端異步請求，了解 html 作為模板與正常網頁製作的區別，了解 iOS Android 場景跳轉\n\n進階開發：js 與 iOS Android  通訊\n\n## 1.設計方案\n\n### 1.1.html下載模板流程\n\n![](/assets/html_download.png)\n\n### 1.2.js 與 native 通訊流程\n\n![](blob:file:///ac20539a-0d43-479f-ba28-e811032391f9)\n\n## 2.方案實現\n\n### 2.1服務端開發\n\n#### 2.1.1.文件說明\n\nGlobalValue.js 配置 host，因為打包到手機本地需要完整的請求地址。\n\nHybridJs.js 是封裝好與 native 通訊。\n\n#### 2.1.2.現有接口\n\n| 接口名稱 | 功能說明 |\n| :--- | :--- |\n| HybridJs.nativeCmdGetH5Params | 獲取上一個頁面的參數。eg:列表進入詳細頁面，詳細頁面根據產品 id 獲取數據。 |\n| HybridJs.nativeCmdLoadApi | 通過 native get 請求 api |\n| HybridJs.nativeCmdLoadApiPost | 通過 native post 請求 api |\n| HybridJs.nativeCmdGetContacts | 獲取手機通訊錄權限 |\n| HybridJs.nativeCmdPresentViewH5 | iOS 打開 h5 新頁；Android 打開 h5 activity |\n| HybridJs.nativeCmdPushViewH5 | iOS push新頁；Android 添加 fragment |\n| HybridJs.nativeCmdPopView | iOS pop；Android pop fragment |\n| HybridJs.nativeCmdPopViewToH5 | iOS pop and open new; Android pop fragment and open new |\n| HybridJs.nativeCmdPopViewToRoot | iOS pop to root view; Android pop fragment to first fragment |\n| HybridJs.nativeCmdDismissView | iOS dismiss view; Android finish Activity |\n| HybridJs.nativeCmdLocalNotification | call native notification |\n\n接口數據格式：\n\n```\n{\n//固定格式，對應命令\n\"cmd\":\"CmdLoadApiPost\",\n//固定格式，js 新加命令（HYBRID_CALLBACK_+命令+時間+隨機數）\n\"cmd_callback\":\"HYBRID_CALLBACK_CmdLoadApiPost_1527589130297_7809\",\n//固定格式，cmd 參數\n\"cmd_params\":\n    {\n        //api 或 對應文件\n        \"url\":\"http://192.168.3.229:9999/api/testrr\",\n        //api 或 對應文件參數\n        \"params\":\n        {\n            //自定義結構\n            \"url\":\"http://192.168.3.229:9999/api/product/1\",\n            \"params\":null\n        }\n    }\n}\n```\n\n#### 2.1.3.HybridJs.callNativeMethod 自定義接口\n\njs 調用 native 唯一接口，通過該接口可以實現更多個性化訂製接口，但必須在 native 上聲明協或繼承 HybridCommand，並在事件分發上添加該功能\n\n接口數據格式：\n\n```\n{\n//固定格式，對應命令\"cmd\":\"CmdLoadApiPost\",\n//固定格式，js 新加命令（HYBRID_CALLBACK_+命令+時間+隨機數）\n\"cmd_callback\":\"HYBRID_CALLBACK_CmdLoadApiPost_1527589130297_7809\",\n//固定格式，cmd 參數\n\"cmd_params\":\n    {\n        //自定義參數結構\n        //api 或 對應文件\n        \"id\":\"http://192.168.3.229:9999/api/testrr\",\n        //api 或 對應文件參數\n        \"params\":\n        {\n            \"url\":\"http://192.168.3.229:9999/api/product/1\",\n            \"params\":null\n        }\n    }\n}\n```\n\n### 2.2.服務端開發流程（以 php 為例子）\n\n#### 2.2.1.版本控制接口\n\n```php\nRoute::get('/version', function () {\n    $version = array(\n        'status' => 1,\n        'error_code' => 1,\n        'info' => '',\n        'data' => array(\n            'app_name' => 'v0.0.1',\n            'last_force_update' => 0,\n            'version_code' => 1,\n            'source_version_code' => 13,\n            'debug_download' => 1\n        )\n    );\n    return json_encode($version);\n});\n```\n\n#### 2.2.2.壓縮 html 資源和下載接口\n\n```php\nfunction addFileToZip($path, $zip)\n{\n    $str_array = explode('/', $path);\n    $root_dir = '';\n//    echo $str_array;\n    if (count($str_array) > 0) {\n        $root_dir = $str_array[count($str_array) - 1];\n    }\n\n    $handler = opendir($path); //打开当前文件夹由$path指定。\n    while (($filename = readdir($handler)) !== false) {\n        if ($filename != \".\" && $filename != \"..\") {//文件夹文件名字为'.'和‘..’，不要对他们进行操作\n            if (is_dir($path . \"/\" . $filename)) {// 如果读取的某个对象是文件夹，则递归\n                addFileToZip($path . \"/\" . $filename, $zip);\n            } else { //将文件加入zip对象\n                $zip->addFile($path . \"/\" . $filename, $root_dir . '/' . \n                str_replace('.blade.php', '.html', $filename));\n            }\n        }\n    }\n    @closedir($path);\n}\n```\n\n```php\nRoute::get('/zip', function () {\n\n$dir = realpath('.');\n$a = scandir($dir);\n$path_parts = pathinfo(__FILE__);\n\n$dir = realpath('..') . '/public/web_source.zip';\n$zip = new ZipArchive();\nif (file_exists($dir)) {\nunlink($dir);\n}\nif ($zip->open($dir, ZipArchive::CREATE) === TRUE) {\n// realpath(base_path('public'))\naddFileToZip(realpath('..') . '/resources/views', $zip); \naddFileToZip(realpath('..') . '/public/css', $zip); \naddFileToZip(realpath('..') . '/public/img', $zip); \naddFileToZip(realpath('..') . '/public/js', $zip); \n$zip->close(); //关闭处理的zip文件\n}\n\nreturn $a;\n});\n```\n\n```php\nRoute::get('/download_source', function () {\n    return response()->download(realpath(base_path('public')) . '/web_source.zip', 'web_source.zip');\n});\n```\n\n#### 2.2.3.構建 html 頁面\n\n```html\n//引用相關資源\n<script src=\"../js/GlobalValue.js\"></script>\n<script src=\"../js/HybridJs.js\"></script>\n```\n\n```js\n//使用 api 請求接口\nfunction testPost() {\n            HybridJs.nativeCmdLoadApiPost(GlobalValue.api_host + \"/api/testrr\", {\n                    \"url\": GlobalValue.api_host + \"/api/product/\" + page,\n                    \"params\": 'ssss'\n                },\n                function (data) {\n                    alert(\"ss=\"+data.callbackData);\n                },\n                function (data) {\n                    alert(\"error=\"+data.callbackData);\n                });\n        }\n//打開一個新頁面\nHybridJs.nativeCmdPushViewH5(\"/views/hy_fg_product_detail.html\",\n                                {\n                                    \"product_id\": this.product_id,\n                                    \"product_name\": this.product_name,\n                                    \"link\": this.link,\n                                    \"is_h5_open\": this.is_h5_open,\n                                });\n```\n\n## 3. app 端構建\n\n### 3.1.Android\n\n#### 3.1.1.添加版本控制和下載 html 資源\n\nApplication 繼承 Application.ActivityLifecycleCallbacks，添加版本控制和下載代碼\n\n```java\npublic class HybridApp extends Application implements Application.ActivityLifecycleCallbacks {\n  private static final String  TAG             = \"hk.nmg.hybrid.HybridApp\";\n  public static        boolean IS_DEBUG_ONLINE = true;\n\n  @Override public void onCreate() {\n    super.onCreate();\n    HybridConfigs.API_HOST = HybridValues.API_HOST;\n    registerActivityLifecycleCallbacks(this);\n  }\n\n  @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n\n  }\n\n  @Override public void onActivityStarted(Activity activity) {\n\n  }\n\n  @Override public void onActivityResumed(Activity activity) {\n    NMGLog.i(TAG, \"onActivityResumed\");\n    checkVersion();\n  }\n\n  @Override public void onActivityPaused(Activity activity) {\n\n  }\n\n  @Override public void onActivityStopped(Activity activity) {\n\n  }\n\n  @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {\n\n  }\n\n  @Override public void onActivityDestroyed(Activity activity) {\n\n  }\n\n  //TODO 下載文件並保存\n  private void checkVersion() {\n    NMGSubscribe<BaseEntity<VersionEntity>> subscribe = new NMGSubscribe<>();\n    subscribe.onNMGSubscribe(d -> {\n    });\n    subscribe.onNMGNext(d -> {\n      //      if (oldVersion.getLast_force_update() < newVersion.getLast_force_update()) {\n      //        //TODO force update app\n      //        return;\n      //      }\n\n      //      if (oldVersion.getVersion_code() < newVersion.getVersion_code()) {\n      //        //TODO update app\n      //      }\n      int oldSourceVersionCode = CommonUtils.getSourceVersionCode(this);\n      int newSourceVersionCode = d.getData().getSource_version_code();\n      if (oldSourceVersionCode < newSourceVersionCode) {\n        downloadHtmlSource(newSourceVersionCode);\n      }\n    });\n    subscribe.onNMGError(d -> {\n    });\n    subscribe.onNMGFinal(() -> {\n    });\n    CommonUtils.requestVersion(subscribe);\n  }\n\n  private void downloadHtmlSource(int newSourceVersionCode) {\n    NMGLog.i(\"downloadHtmlSource\", \"downloadHtmlSource\");\n    //获取当前程序路径 应用在内存上的目录 :/data/data/com.mufeng.toolproject/files\n    String filesDir = this.getFilesDir().toString();\n    NMGDownloadFileDelegate subscribe = new NMGDownloadFileDelegate() {\n      @Override public void onSubscribe(Disposable d) {\n\n      }\n\n      @Override public void onNext(String savePath) {\n        NMGZip zip = new NMGZip();\n        zip.decompress(filesDir + \"/web_source\", filesDir + \"/web_source.zip\", new NMGZip.NMGZipListener() {\n          @Override public void onCompleted(boolean b) {\n            NMGLog.i(\"downloadHtmlSource\", \"onCompleted\");\n            CommonUtils.saveSourceVersionCode(HybridApp.this, newSourceVersionCode);\n          }\n        });\n      }\n\n      @Override public void onError(Throwable e) {\n\n      }\n\n      @Override public void onFinal() {\n\n      }\n    };\n    NMGHttp.downloadFile(\"http://192.168.3.229:9999/download_source\",\n        filesDir,\n        \"/web_source.zip\",\n        subscribe);\n\n    //    CommonUtils.downloadFile(\"http://192.168.3.229:9999/download_source\", subscribe);\n  }\n}\n```\n\n#### 3.1.2.繼承 BaseHybridFragment\n\n創建 activity ，和 fragment，將 fragment 添加到 activity，fragment 繼承 BaseHybridFragment，運行即可\n\n```java\npublic class HomeHybridFragment extends BaseHybridFragment {\n  private static HomeHybridFragment instance;\n\n  public static synchronized HomeHybridFragment getInstance() {\n    if (instance == null)\n      instance = new HomeHybridFragment();\n    return instance;\n  }\n\n  @Override public void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n  }\n\n  @Nullable @Override public View onCreateView(LayoutInflater inflater, \n  @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n//    BaseHybridFragment f = BaseHybridFragment.newInstance(mHost, \"/view/hy_fg_home.html\", \"\");\n    return setupUI(HybridValues.API_HOST, \"/views/hy_fg_home.html\");\n  }\n}\n```\n\n### 3.2.iOS\n\n#### 3.2.1.添加版本控制和下載 html 資源\n\n在 AppDelegate 添加版本檢測和下載資源功能\n\n```Swift\nprivate func checkVersion(){\n        _ = AlamofireUtils.requestUrl(url: ConfigsValues.API_VERSION, parameters: [:],\n      onSuccess: {(json) in\n        let dictNew = NMGJson.jsonToDict(text: json!)\n        var versionOld:Int? = nil\n        let dataNew = dictNew![\"data\"] as! [String : Any]\n\n        let userDefault = NMGNSUserDefaults()\n        if userDefault.getNormalDefult(key: \"UD_VERSION_CODE\") != nil  {\n            versionOld = userDefault.getNormalDefult(key: \"UD_VERSION_CODE\") as? Int\n\n            let versionNew = dataNew[\"source_version_code\"] as? Int\n\n            if versionNew! > versionOld!{\n                self.downloadFile(versionCode: versionNew)\n            }\n        }else{\n            self.downloadFile(versionCode: dataNew[\"source_version_code\"] as? Int)\n        }\n\n},\n      onFail: {(error) in self.downloadFile(versionCode: nil)})\n    }\n    private func downloadFile(versionCode: Int?){\n        _ = AlamofireUtils.downloadFile(url: ConfigsValues.API_DOWNLOAD,\n        onSuccess: {(destinationUrl) in\n            print(\"download success\")\n\n            SSZipArchive.unzipFile(atPath: (destinationUrl?.absoluteString)!, \n            toDestination: (destinationUrl?.absoluteString)!)\n            let zipPath = ConfigsValues.WEB_SOURCE_PATH//(destinationUrl?.absoluteString)!\n            let unzipPath = ConfigsValues.WEB_SOURCE_DIR?.path\n\n            print(zipPath)\n            print(unzipPath!)\n\n            let success = SSZipArchive.unzipFile(atPath: zipPath, toDestination: unzipPath!)\n            if !success {\n                print(\"解压 fail\")\n                return\n            }\n            if versionCode != nil{\n                let userDefault = NMGNSUserDefaults()\n                userDefault.setNormalDefault(key: \"UD_VERSION_CODE\", value: versionCode as AnyObject)\n            }\n            print(\"解压成功---\\(unzipPath!)\")},\n        onFail: {(error) in print(\"download error\")})\n    }\n```\n\n#### 3.2.2.繼承 HybridViewController\n\n```\n//繼承 HybridViewController 填寫相應文件\nclass HomeViewController: HybridViewController {\n\n    @objc private func refreshWebView(sender: UIRefreshControl) {\n        self.webView.reload()\n        sender.endRefreshing()\n    }\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        let refreshControl = UIRefreshControl()\n        refreshControl.attributedTitle = NSAttributedString(string: \"下拉刷新数据\")\n        refreshControl.addTarget(self, action: #selector(refreshWebView), for: UIControlEvents.valueChanged)\n\n        self.webView.scrollView.addSubview(refreshControl)\n        view.addSubview(self.webView)\n\n        self.webView.snp.makeConstraints { (make) -> Void in\n            make.top.equalTo(view).offset(0)\n            make.left.equalTo(view).offset(0)\n            make.bottom.equalTo(view).offset(0)\n            make.right.equalTo(view).offset(0)\n        }\n\n        self.load(webFile: \"/views/hy_fg_home.html\")\n\n//        self.registerCmd(cmd: HybridCommand)\n    }\n}\n```\n\n## 4.待完善功能\n\ntoolbar 的控制\n\n更多的權限和原生接口\n\n事件分發的處理\n\n數據庫\n\n","source":"_posts/hybrid/yi-dong-duan-hun-he-kai-fa.md","raw":"---\ntitle: byrid\ndate: 2018-10-02 09:09:09\ncategories: hybrid\n---\n# app 混合開發方案\n\n本方案基於 js 橋接方式作為混合開發，在線下載 html 模板更新 ui，適合在線更新。\n\n需要了解：前端異步請求，了解 html 作為模板與正常網頁製作的區別，了解 iOS Android 場景跳轉\n\n進階開發：js 與 iOS Android  通訊\n\n## 1.設計方案\n\n### 1.1.html下載模板流程\n\n![](/assets/html_download.png)\n\n### 1.2.js 與 native 通訊流程\n\n![](blob:file:///ac20539a-0d43-479f-ba28-e811032391f9)\n\n## 2.方案實現\n\n### 2.1服務端開發\n\n#### 2.1.1.文件說明\n\nGlobalValue.js 配置 host，因為打包到手機本地需要完整的請求地址。\n\nHybridJs.js 是封裝好與 native 通訊。\n\n#### 2.1.2.現有接口\n\n| 接口名稱 | 功能說明 |\n| :--- | :--- |\n| HybridJs.nativeCmdGetH5Params | 獲取上一個頁面的參數。eg:列表進入詳細頁面，詳細頁面根據產品 id 獲取數據。 |\n| HybridJs.nativeCmdLoadApi | 通過 native get 請求 api |\n| HybridJs.nativeCmdLoadApiPost | 通過 native post 請求 api |\n| HybridJs.nativeCmdGetContacts | 獲取手機通訊錄權限 |\n| HybridJs.nativeCmdPresentViewH5 | iOS 打開 h5 新頁；Android 打開 h5 activity |\n| HybridJs.nativeCmdPushViewH5 | iOS push新頁；Android 添加 fragment |\n| HybridJs.nativeCmdPopView | iOS pop；Android pop fragment |\n| HybridJs.nativeCmdPopViewToH5 | iOS pop and open new; Android pop fragment and open new |\n| HybridJs.nativeCmdPopViewToRoot | iOS pop to root view; Android pop fragment to first fragment |\n| HybridJs.nativeCmdDismissView | iOS dismiss view; Android finish Activity |\n| HybridJs.nativeCmdLocalNotification | call native notification |\n\n接口數據格式：\n\n```\n{\n//固定格式，對應命令\n\"cmd\":\"CmdLoadApiPost\",\n//固定格式，js 新加命令（HYBRID_CALLBACK_+命令+時間+隨機數）\n\"cmd_callback\":\"HYBRID_CALLBACK_CmdLoadApiPost_1527589130297_7809\",\n//固定格式，cmd 參數\n\"cmd_params\":\n    {\n        //api 或 對應文件\n        \"url\":\"http://192.168.3.229:9999/api/testrr\",\n        //api 或 對應文件參數\n        \"params\":\n        {\n            //自定義結構\n            \"url\":\"http://192.168.3.229:9999/api/product/1\",\n            \"params\":null\n        }\n    }\n}\n```\n\n#### 2.1.3.HybridJs.callNativeMethod 自定義接口\n\njs 調用 native 唯一接口，通過該接口可以實現更多個性化訂製接口，但必須在 native 上聲明協或繼承 HybridCommand，並在事件分發上添加該功能\n\n接口數據格式：\n\n```\n{\n//固定格式，對應命令\"cmd\":\"CmdLoadApiPost\",\n//固定格式，js 新加命令（HYBRID_CALLBACK_+命令+時間+隨機數）\n\"cmd_callback\":\"HYBRID_CALLBACK_CmdLoadApiPost_1527589130297_7809\",\n//固定格式，cmd 參數\n\"cmd_params\":\n    {\n        //自定義參數結構\n        //api 或 對應文件\n        \"id\":\"http://192.168.3.229:9999/api/testrr\",\n        //api 或 對應文件參數\n        \"params\":\n        {\n            \"url\":\"http://192.168.3.229:9999/api/product/1\",\n            \"params\":null\n        }\n    }\n}\n```\n\n### 2.2.服務端開發流程（以 php 為例子）\n\n#### 2.2.1.版本控制接口\n\n```php\nRoute::get('/version', function () {\n    $version = array(\n        'status' => 1,\n        'error_code' => 1,\n        'info' => '',\n        'data' => array(\n            'app_name' => 'v0.0.1',\n            'last_force_update' => 0,\n            'version_code' => 1,\n            'source_version_code' => 13,\n            'debug_download' => 1\n        )\n    );\n    return json_encode($version);\n});\n```\n\n#### 2.2.2.壓縮 html 資源和下載接口\n\n```php\nfunction addFileToZip($path, $zip)\n{\n    $str_array = explode('/', $path);\n    $root_dir = '';\n//    echo $str_array;\n    if (count($str_array) > 0) {\n        $root_dir = $str_array[count($str_array) - 1];\n    }\n\n    $handler = opendir($path); //打开当前文件夹由$path指定。\n    while (($filename = readdir($handler)) !== false) {\n        if ($filename != \".\" && $filename != \"..\") {//文件夹文件名字为'.'和‘..’，不要对他们进行操作\n            if (is_dir($path . \"/\" . $filename)) {// 如果读取的某个对象是文件夹，则递归\n                addFileToZip($path . \"/\" . $filename, $zip);\n            } else { //将文件加入zip对象\n                $zip->addFile($path . \"/\" . $filename, $root_dir . '/' . \n                str_replace('.blade.php', '.html', $filename));\n            }\n        }\n    }\n    @closedir($path);\n}\n```\n\n```php\nRoute::get('/zip', function () {\n\n$dir = realpath('.');\n$a = scandir($dir);\n$path_parts = pathinfo(__FILE__);\n\n$dir = realpath('..') . '/public/web_source.zip';\n$zip = new ZipArchive();\nif (file_exists($dir)) {\nunlink($dir);\n}\nif ($zip->open($dir, ZipArchive::CREATE) === TRUE) {\n// realpath(base_path('public'))\naddFileToZip(realpath('..') . '/resources/views', $zip); \naddFileToZip(realpath('..') . '/public/css', $zip); \naddFileToZip(realpath('..') . '/public/img', $zip); \naddFileToZip(realpath('..') . '/public/js', $zip); \n$zip->close(); //关闭处理的zip文件\n}\n\nreturn $a;\n});\n```\n\n```php\nRoute::get('/download_source', function () {\n    return response()->download(realpath(base_path('public')) . '/web_source.zip', 'web_source.zip');\n});\n```\n\n#### 2.2.3.構建 html 頁面\n\n```html\n//引用相關資源\n<script src=\"../js/GlobalValue.js\"></script>\n<script src=\"../js/HybridJs.js\"></script>\n```\n\n```js\n//使用 api 請求接口\nfunction testPost() {\n            HybridJs.nativeCmdLoadApiPost(GlobalValue.api_host + \"/api/testrr\", {\n                    \"url\": GlobalValue.api_host + \"/api/product/\" + page,\n                    \"params\": 'ssss'\n                },\n                function (data) {\n                    alert(\"ss=\"+data.callbackData);\n                },\n                function (data) {\n                    alert(\"error=\"+data.callbackData);\n                });\n        }\n//打開一個新頁面\nHybridJs.nativeCmdPushViewH5(\"/views/hy_fg_product_detail.html\",\n                                {\n                                    \"product_id\": this.product_id,\n                                    \"product_name\": this.product_name,\n                                    \"link\": this.link,\n                                    \"is_h5_open\": this.is_h5_open,\n                                });\n```\n\n## 3. app 端構建\n\n### 3.1.Android\n\n#### 3.1.1.添加版本控制和下載 html 資源\n\nApplication 繼承 Application.ActivityLifecycleCallbacks，添加版本控制和下載代碼\n\n```java\npublic class HybridApp extends Application implements Application.ActivityLifecycleCallbacks {\n  private static final String  TAG             = \"hk.nmg.hybrid.HybridApp\";\n  public static        boolean IS_DEBUG_ONLINE = true;\n\n  @Override public void onCreate() {\n    super.onCreate();\n    HybridConfigs.API_HOST = HybridValues.API_HOST;\n    registerActivityLifecycleCallbacks(this);\n  }\n\n  @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n\n  }\n\n  @Override public void onActivityStarted(Activity activity) {\n\n  }\n\n  @Override public void onActivityResumed(Activity activity) {\n    NMGLog.i(TAG, \"onActivityResumed\");\n    checkVersion();\n  }\n\n  @Override public void onActivityPaused(Activity activity) {\n\n  }\n\n  @Override public void onActivityStopped(Activity activity) {\n\n  }\n\n  @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {\n\n  }\n\n  @Override public void onActivityDestroyed(Activity activity) {\n\n  }\n\n  //TODO 下載文件並保存\n  private void checkVersion() {\n    NMGSubscribe<BaseEntity<VersionEntity>> subscribe = new NMGSubscribe<>();\n    subscribe.onNMGSubscribe(d -> {\n    });\n    subscribe.onNMGNext(d -> {\n      //      if (oldVersion.getLast_force_update() < newVersion.getLast_force_update()) {\n      //        //TODO force update app\n      //        return;\n      //      }\n\n      //      if (oldVersion.getVersion_code() < newVersion.getVersion_code()) {\n      //        //TODO update app\n      //      }\n      int oldSourceVersionCode = CommonUtils.getSourceVersionCode(this);\n      int newSourceVersionCode = d.getData().getSource_version_code();\n      if (oldSourceVersionCode < newSourceVersionCode) {\n        downloadHtmlSource(newSourceVersionCode);\n      }\n    });\n    subscribe.onNMGError(d -> {\n    });\n    subscribe.onNMGFinal(() -> {\n    });\n    CommonUtils.requestVersion(subscribe);\n  }\n\n  private void downloadHtmlSource(int newSourceVersionCode) {\n    NMGLog.i(\"downloadHtmlSource\", \"downloadHtmlSource\");\n    //获取当前程序路径 应用在内存上的目录 :/data/data/com.mufeng.toolproject/files\n    String filesDir = this.getFilesDir().toString();\n    NMGDownloadFileDelegate subscribe = new NMGDownloadFileDelegate() {\n      @Override public void onSubscribe(Disposable d) {\n\n      }\n\n      @Override public void onNext(String savePath) {\n        NMGZip zip = new NMGZip();\n        zip.decompress(filesDir + \"/web_source\", filesDir + \"/web_source.zip\", new NMGZip.NMGZipListener() {\n          @Override public void onCompleted(boolean b) {\n            NMGLog.i(\"downloadHtmlSource\", \"onCompleted\");\n            CommonUtils.saveSourceVersionCode(HybridApp.this, newSourceVersionCode);\n          }\n        });\n      }\n\n      @Override public void onError(Throwable e) {\n\n      }\n\n      @Override public void onFinal() {\n\n      }\n    };\n    NMGHttp.downloadFile(\"http://192.168.3.229:9999/download_source\",\n        filesDir,\n        \"/web_source.zip\",\n        subscribe);\n\n    //    CommonUtils.downloadFile(\"http://192.168.3.229:9999/download_source\", subscribe);\n  }\n}\n```\n\n#### 3.1.2.繼承 BaseHybridFragment\n\n創建 activity ，和 fragment，將 fragment 添加到 activity，fragment 繼承 BaseHybridFragment，運行即可\n\n```java\npublic class HomeHybridFragment extends BaseHybridFragment {\n  private static HomeHybridFragment instance;\n\n  public static synchronized HomeHybridFragment getInstance() {\n    if (instance == null)\n      instance = new HomeHybridFragment();\n    return instance;\n  }\n\n  @Override public void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n  }\n\n  @Nullable @Override public View onCreateView(LayoutInflater inflater, \n  @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n//    BaseHybridFragment f = BaseHybridFragment.newInstance(mHost, \"/view/hy_fg_home.html\", \"\");\n    return setupUI(HybridValues.API_HOST, \"/views/hy_fg_home.html\");\n  }\n}\n```\n\n### 3.2.iOS\n\n#### 3.2.1.添加版本控制和下載 html 資源\n\n在 AppDelegate 添加版本檢測和下載資源功能\n\n```Swift\nprivate func checkVersion(){\n        _ = AlamofireUtils.requestUrl(url: ConfigsValues.API_VERSION, parameters: [:],\n      onSuccess: {(json) in\n        let dictNew = NMGJson.jsonToDict(text: json!)\n        var versionOld:Int? = nil\n        let dataNew = dictNew![\"data\"] as! [String : Any]\n\n        let userDefault = NMGNSUserDefaults()\n        if userDefault.getNormalDefult(key: \"UD_VERSION_CODE\") != nil  {\n            versionOld = userDefault.getNormalDefult(key: \"UD_VERSION_CODE\") as? Int\n\n            let versionNew = dataNew[\"source_version_code\"] as? Int\n\n            if versionNew! > versionOld!{\n                self.downloadFile(versionCode: versionNew)\n            }\n        }else{\n            self.downloadFile(versionCode: dataNew[\"source_version_code\"] as? Int)\n        }\n\n},\n      onFail: {(error) in self.downloadFile(versionCode: nil)})\n    }\n    private func downloadFile(versionCode: Int?){\n        _ = AlamofireUtils.downloadFile(url: ConfigsValues.API_DOWNLOAD,\n        onSuccess: {(destinationUrl) in\n            print(\"download success\")\n\n            SSZipArchive.unzipFile(atPath: (destinationUrl?.absoluteString)!, \n            toDestination: (destinationUrl?.absoluteString)!)\n            let zipPath = ConfigsValues.WEB_SOURCE_PATH//(destinationUrl?.absoluteString)!\n            let unzipPath = ConfigsValues.WEB_SOURCE_DIR?.path\n\n            print(zipPath)\n            print(unzipPath!)\n\n            let success = SSZipArchive.unzipFile(atPath: zipPath, toDestination: unzipPath!)\n            if !success {\n                print(\"解压 fail\")\n                return\n            }\n            if versionCode != nil{\n                let userDefault = NMGNSUserDefaults()\n                userDefault.setNormalDefault(key: \"UD_VERSION_CODE\", value: versionCode as AnyObject)\n            }\n            print(\"解压成功---\\(unzipPath!)\")},\n        onFail: {(error) in print(\"download error\")})\n    }\n```\n\n#### 3.2.2.繼承 HybridViewController\n\n```\n//繼承 HybridViewController 填寫相應文件\nclass HomeViewController: HybridViewController {\n\n    @objc private func refreshWebView(sender: UIRefreshControl) {\n        self.webView.reload()\n        sender.endRefreshing()\n    }\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        let refreshControl = UIRefreshControl()\n        refreshControl.attributedTitle = NSAttributedString(string: \"下拉刷新数据\")\n        refreshControl.addTarget(self, action: #selector(refreshWebView), for: UIControlEvents.valueChanged)\n\n        self.webView.scrollView.addSubview(refreshControl)\n        view.addSubview(self.webView)\n\n        self.webView.snp.makeConstraints { (make) -> Void in\n            make.top.equalTo(view).offset(0)\n            make.left.equalTo(view).offset(0)\n            make.bottom.equalTo(view).offset(0)\n            make.right.equalTo(view).offset(0)\n        }\n\n        self.load(webFile: \"/views/hy_fg_home.html\")\n\n//        self.registerCmd(cmd: HybridCommand)\n    }\n}\n```\n\n## 4.待完善功能\n\ntoolbar 的控制\n\n更多的權限和原生接口\n\n事件分發的處理\n\n數據庫\n\n","slug":"hybrid/yi-dong-duan-hun-he-kai-fa","published":1,"updated":"2018-10-02T03:06:28.500Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4oj005tntnb2uapfyzv","content":"<h1 id=\"app-混合開發方案\"><a href=\"#app-混合開發方案\" class=\"headerlink\" title=\"app 混合開發方案\"></a>app 混合開發方案</h1><p>本方案基於 js 橋接方式作為混合開發，在線下載 html 模板更新 ui，適合在線更新。</p>\n<p>需要了解：前端異步請求，了解 html 作為模板與正常網頁製作的區別，了解 iOS Android 場景跳轉</p>\n<p>進階開發：js 與 iOS Android  通訊</p>\n<h2 id=\"1-設計方案\"><a href=\"#1-設計方案\" class=\"headerlink\" title=\"1.設計方案\"></a>1.設計方案</h2><h3 id=\"1-1-html下載模板流程\"><a href=\"#1-1-html下載模板流程\" class=\"headerlink\" title=\"1.1.html下載模板流程\"></a>1.1.html下載模板流程</h3><p><img src=\"/assets/html_download.png\" alt=\"\"></p>\n<h3 id=\"1-2-js-與-native-通訊流程\"><a href=\"#1-2-js-與-native-通訊流程\" class=\"headerlink\" title=\"1.2.js 與 native 通訊流程\"></a>1.2.js 與 native 通訊流程</h3><p><img src=\"blob:file:///ac20539a-0d43-479f-ba28-e811032391f9\" alt=\"\"></p>\n<h2 id=\"2-方案實現\"><a href=\"#2-方案實現\" class=\"headerlink\" title=\"2.方案實現\"></a>2.方案實現</h2><h3 id=\"2-1服務端開發\"><a href=\"#2-1服務端開發\" class=\"headerlink\" title=\"2.1服務端開發\"></a>2.1服務端開發</h3><h4 id=\"2-1-1-文件說明\"><a href=\"#2-1-1-文件說明\" class=\"headerlink\" title=\"2.1.1.文件說明\"></a>2.1.1.文件說明</h4><p>GlobalValue.js 配置 host，因為打包到手機本地需要完整的請求地址。</p>\n<p>HybridJs.js 是封裝好與 native 通訊。</p>\n<h4 id=\"2-1-2-現有接口\"><a href=\"#2-1-2-現有接口\" class=\"headerlink\" title=\"2.1.2.現有接口\"></a>2.1.2.現有接口</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">接口名稱</th>\n<th style=\"text-align:left\">功能說明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdGetH5Params</td>\n<td style=\"text-align:left\">獲取上一個頁面的參數。eg:列表進入詳細頁面，詳細頁面根據產品 id 獲取數據。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdLoadApi</td>\n<td style=\"text-align:left\">通過 native get 請求 api</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdLoadApiPost</td>\n<td style=\"text-align:left\">通過 native post 請求 api</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdGetContacts</td>\n<td style=\"text-align:left\">獲取手機通訊錄權限</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdPresentViewH5</td>\n<td style=\"text-align:left\">iOS 打開 h5 新頁；Android 打開 h5 activity</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdPushViewH5</td>\n<td style=\"text-align:left\">iOS push新頁；Android 添加 fragment</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdPopView</td>\n<td style=\"text-align:left\">iOS pop；Android pop fragment</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdPopViewToH5</td>\n<td style=\"text-align:left\">iOS pop and open new; Android pop fragment and open new</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdPopViewToRoot</td>\n<td style=\"text-align:left\">iOS pop to root view; Android pop fragment to first fragment</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdDismissView</td>\n<td style=\"text-align:left\">iOS dismiss view; Android finish Activity</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdLocalNotification</td>\n<td style=\"text-align:left\">call native notification</td>\n</tr>\n</tbody>\n</table>\n<p>接口數據格式：</p>\n<pre><code>{\n//固定格式，對應命令\n&quot;cmd&quot;:&quot;CmdLoadApiPost&quot;,\n//固定格式，js 新加命令（HYBRID_CALLBACK_+命令+時間+隨機數）\n&quot;cmd_callback&quot;:&quot;HYBRID_CALLBACK_CmdLoadApiPost_1527589130297_7809&quot;,\n//固定格式，cmd 參數\n&quot;cmd_params&quot;:\n    {\n        //api 或 對應文件\n        &quot;url&quot;:&quot;http://192.168.3.229:9999/api/testrr&quot;,\n        //api 或 對應文件參數\n        &quot;params&quot;:\n        {\n            //自定義結構\n            &quot;url&quot;:&quot;http://192.168.3.229:9999/api/product/1&quot;,\n            &quot;params&quot;:null\n        }\n    }\n}\n</code></pre><h4 id=\"2-1-3-HybridJs-callNativeMethod-自定義接口\"><a href=\"#2-1-3-HybridJs-callNativeMethod-自定義接口\" class=\"headerlink\" title=\"2.1.3.HybridJs.callNativeMethod 自定義接口\"></a>2.1.3.HybridJs.callNativeMethod 自定義接口</h4><p>js 調用 native 唯一接口，通過該接口可以實現更多個性化訂製接口，但必須在 native 上聲明協或繼承 HybridCommand，並在事件分發上添加該功能</p>\n<p>接口數據格式：</p>\n<pre><code>{\n//固定格式，對應命令&quot;cmd&quot;:&quot;CmdLoadApiPost&quot;,\n//固定格式，js 新加命令（HYBRID_CALLBACK_+命令+時間+隨機數）\n&quot;cmd_callback&quot;:&quot;HYBRID_CALLBACK_CmdLoadApiPost_1527589130297_7809&quot;,\n//固定格式，cmd 參數\n&quot;cmd_params&quot;:\n    {\n        //自定義參數結構\n        //api 或 對應文件\n        &quot;id&quot;:&quot;http://192.168.3.229:9999/api/testrr&quot;,\n        //api 或 對應文件參數\n        &quot;params&quot;:\n        {\n            &quot;url&quot;:&quot;http://192.168.3.229:9999/api/product/1&quot;,\n            &quot;params&quot;:null\n        }\n    }\n}\n</code></pre><h3 id=\"2-2-服務端開發流程（以-php-為例子）\"><a href=\"#2-2-服務端開發流程（以-php-為例子）\" class=\"headerlink\" title=\"2.2.服務端開發流程（以 php 為例子）\"></a>2.2.服務端開發流程（以 php 為例子）</h3><h4 id=\"2-2-1-版本控制接口\"><a href=\"#2-2-1-版本控制接口\" class=\"headerlink\" title=\"2.2.1.版本控制接口\"></a>2.2.1.版本控制接口</h4><pre><code class=\"php\">Route::get(&#39;/version&#39;, function () {\n    $version = array(\n        &#39;status&#39; =&gt; 1,\n        &#39;error_code&#39; =&gt; 1,\n        &#39;info&#39; =&gt; &#39;&#39;,\n        &#39;data&#39; =&gt; array(\n            &#39;app_name&#39; =&gt; &#39;v0.0.1&#39;,\n            &#39;last_force_update&#39; =&gt; 0,\n            &#39;version_code&#39; =&gt; 1,\n            &#39;source_version_code&#39; =&gt; 13,\n            &#39;debug_download&#39; =&gt; 1\n        )\n    );\n    return json_encode($version);\n});\n</code></pre>\n<h4 id=\"2-2-2-壓縮-html-資源和下載接口\"><a href=\"#2-2-2-壓縮-html-資源和下載接口\" class=\"headerlink\" title=\"2.2.2.壓縮 html 資源和下載接口\"></a>2.2.2.壓縮 html 資源和下載接口</h4><pre><code class=\"php\">function addFileToZip($path, $zip)\n{\n    $str_array = explode(&#39;/&#39;, $path);\n    $root_dir = &#39;&#39;;\n//    echo $str_array;\n    if (count($str_array) &gt; 0) {\n        $root_dir = $str_array[count($str_array) - 1];\n    }\n\n    $handler = opendir($path); //打开当前文件夹由$path指定。\n    while (($filename = readdir($handler)) !== false) {\n        if ($filename != &quot;.&quot; &amp;&amp; $filename != &quot;..&quot;) {//文件夹文件名字为&#39;.&#39;和‘..’，不要对他们进行操作\n            if (is_dir($path . &quot;/&quot; . $filename)) {// 如果读取的某个对象是文件夹，则递归\n                addFileToZip($path . &quot;/&quot; . $filename, $zip);\n            } else { //将文件加入zip对象\n                $zip-&gt;addFile($path . &quot;/&quot; . $filename, $root_dir . &#39;/&#39; . \n                str_replace(&#39;.blade.php&#39;, &#39;.html&#39;, $filename));\n            }\n        }\n    }\n    @closedir($path);\n}\n</code></pre>\n<pre><code class=\"php\">Route::get(&#39;/zip&#39;, function () {\n\n$dir = realpath(&#39;.&#39;);\n$a = scandir($dir);\n$path_parts = pathinfo(__FILE__);\n\n$dir = realpath(&#39;..&#39;) . &#39;/public/web_source.zip&#39;;\n$zip = new ZipArchive();\nif (file_exists($dir)) {\nunlink($dir);\n}\nif ($zip-&gt;open($dir, ZipArchive::CREATE) === TRUE) {\n// realpath(base_path(&#39;public&#39;))\naddFileToZip(realpath(&#39;..&#39;) . &#39;/resources/views&#39;, $zip); \naddFileToZip(realpath(&#39;..&#39;) . &#39;/public/css&#39;, $zip); \naddFileToZip(realpath(&#39;..&#39;) . &#39;/public/img&#39;, $zip); \naddFileToZip(realpath(&#39;..&#39;) . &#39;/public/js&#39;, $zip); \n$zip-&gt;close(); //关闭处理的zip文件\n}\n\nreturn $a;\n});\n</code></pre>\n<pre><code class=\"php\">Route::get(&#39;/download_source&#39;, function () {\n    return response()-&gt;download(realpath(base_path(&#39;public&#39;)) . &#39;/web_source.zip&#39;, &#39;web_source.zip&#39;);\n});\n</code></pre>\n<h4 id=\"2-2-3-構建-html-頁面\"><a href=\"#2-2-3-構建-html-頁面\" class=\"headerlink\" title=\"2.2.3.構建 html 頁面\"></a>2.2.3.構建 html 頁面</h4><pre><code class=\"html\">//引用相關資源\n&lt;script src=&quot;../js/GlobalValue.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;../js/HybridJs.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<pre><code class=\"js\">//使用 api 請求接口\nfunction testPost() {\n            HybridJs.nativeCmdLoadApiPost(GlobalValue.api_host + &quot;/api/testrr&quot;, {\n                    &quot;url&quot;: GlobalValue.api_host + &quot;/api/product/&quot; + page,\n                    &quot;params&quot;: &#39;ssss&#39;\n                },\n                function (data) {\n                    alert(&quot;ss=&quot;+data.callbackData);\n                },\n                function (data) {\n                    alert(&quot;error=&quot;+data.callbackData);\n                });\n        }\n//打開一個新頁面\nHybridJs.nativeCmdPushViewH5(&quot;/views/hy_fg_product_detail.html&quot;,\n                                {\n                                    &quot;product_id&quot;: this.product_id,\n                                    &quot;product_name&quot;: this.product_name,\n                                    &quot;link&quot;: this.link,\n                                    &quot;is_h5_open&quot;: this.is_h5_open,\n                                });\n</code></pre>\n<h2 id=\"3-app-端構建\"><a href=\"#3-app-端構建\" class=\"headerlink\" title=\"3. app 端構建\"></a>3. app 端構建</h2><h3 id=\"3-1-Android\"><a href=\"#3-1-Android\" class=\"headerlink\" title=\"3.1.Android\"></a>3.1.Android</h3><h4 id=\"3-1-1-添加版本控制和下載-html-資源\"><a href=\"#3-1-1-添加版本控制和下載-html-資源\" class=\"headerlink\" title=\"3.1.1.添加版本控制和下載 html 資源\"></a>3.1.1.添加版本控制和下載 html 資源</h4><p>Application 繼承 Application.ActivityLifecycleCallbacks，添加版本控制和下載代碼</p>\n<pre><code class=\"java\">public class HybridApp extends Application implements Application.ActivityLifecycleCallbacks {\n  private static final String  TAG             = &quot;hk.nmg.hybrid.HybridApp&quot;;\n  public static        boolean IS_DEBUG_ONLINE = true;\n\n  @Override public void onCreate() {\n    super.onCreate();\n    HybridConfigs.API_HOST = HybridValues.API_HOST;\n    registerActivityLifecycleCallbacks(this);\n  }\n\n  @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n\n  }\n\n  @Override public void onActivityStarted(Activity activity) {\n\n  }\n\n  @Override public void onActivityResumed(Activity activity) {\n    NMGLog.i(TAG, &quot;onActivityResumed&quot;);\n    checkVersion();\n  }\n\n  @Override public void onActivityPaused(Activity activity) {\n\n  }\n\n  @Override public void onActivityStopped(Activity activity) {\n\n  }\n\n  @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {\n\n  }\n\n  @Override public void onActivityDestroyed(Activity activity) {\n\n  }\n\n  //TODO 下載文件並保存\n  private void checkVersion() {\n    NMGSubscribe&lt;BaseEntity&lt;VersionEntity&gt;&gt; subscribe = new NMGSubscribe&lt;&gt;();\n    subscribe.onNMGSubscribe(d -&gt; {\n    });\n    subscribe.onNMGNext(d -&gt; {\n      //      if (oldVersion.getLast_force_update() &lt; newVersion.getLast_force_update()) {\n      //        //TODO force update app\n      //        return;\n      //      }\n\n      //      if (oldVersion.getVersion_code() &lt; newVersion.getVersion_code()) {\n      //        //TODO update app\n      //      }\n      int oldSourceVersionCode = CommonUtils.getSourceVersionCode(this);\n      int newSourceVersionCode = d.getData().getSource_version_code();\n      if (oldSourceVersionCode &lt; newSourceVersionCode) {\n        downloadHtmlSource(newSourceVersionCode);\n      }\n    });\n    subscribe.onNMGError(d -&gt; {\n    });\n    subscribe.onNMGFinal(() -&gt; {\n    });\n    CommonUtils.requestVersion(subscribe);\n  }\n\n  private void downloadHtmlSource(int newSourceVersionCode) {\n    NMGLog.i(&quot;downloadHtmlSource&quot;, &quot;downloadHtmlSource&quot;);\n    //获取当前程序路径 应用在内存上的目录 :/data/data/com.mufeng.toolproject/files\n    String filesDir = this.getFilesDir().toString();\n    NMGDownloadFileDelegate subscribe = new NMGDownloadFileDelegate() {\n      @Override public void onSubscribe(Disposable d) {\n\n      }\n\n      @Override public void onNext(String savePath) {\n        NMGZip zip = new NMGZip();\n        zip.decompress(filesDir + &quot;/web_source&quot;, filesDir + &quot;/web_source.zip&quot;, new NMGZip.NMGZipListener() {\n          @Override public void onCompleted(boolean b) {\n            NMGLog.i(&quot;downloadHtmlSource&quot;, &quot;onCompleted&quot;);\n            CommonUtils.saveSourceVersionCode(HybridApp.this, newSourceVersionCode);\n          }\n        });\n      }\n\n      @Override public void onError(Throwable e) {\n\n      }\n\n      @Override public void onFinal() {\n\n      }\n    };\n    NMGHttp.downloadFile(&quot;http://192.168.3.229:9999/download_source&quot;,\n        filesDir,\n        &quot;/web_source.zip&quot;,\n        subscribe);\n\n    //    CommonUtils.downloadFile(&quot;http://192.168.3.229:9999/download_source&quot;, subscribe);\n  }\n}\n</code></pre>\n<h4 id=\"3-1-2-繼承-BaseHybridFragment\"><a href=\"#3-1-2-繼承-BaseHybridFragment\" class=\"headerlink\" title=\"3.1.2.繼承 BaseHybridFragment\"></a>3.1.2.繼承 BaseHybridFragment</h4><p>創建 activity ，和 fragment，將 fragment 添加到 activity，fragment 繼承 BaseHybridFragment，運行即可</p>\n<pre><code class=\"java\">public class HomeHybridFragment extends BaseHybridFragment {\n  private static HomeHybridFragment instance;\n\n  public static synchronized HomeHybridFragment getInstance() {\n    if (instance == null)\n      instance = new HomeHybridFragment();\n    return instance;\n  }\n\n  @Override public void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n  }\n\n  @Nullable @Override public View onCreateView(LayoutInflater inflater, \n  @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n//    BaseHybridFragment f = BaseHybridFragment.newInstance(mHost, &quot;/view/hy_fg_home.html&quot;, &quot;&quot;);\n    return setupUI(HybridValues.API_HOST, &quot;/views/hy_fg_home.html&quot;);\n  }\n}\n</code></pre>\n<h3 id=\"3-2-iOS\"><a href=\"#3-2-iOS\" class=\"headerlink\" title=\"3.2.iOS\"></a>3.2.iOS</h3><h4 id=\"3-2-1-添加版本控制和下載-html-資源\"><a href=\"#3-2-1-添加版本控制和下載-html-資源\" class=\"headerlink\" title=\"3.2.1.添加版本控制和下載 html 資源\"></a>3.2.1.添加版本控制和下載 html 資源</h4><p>在 AppDelegate 添加版本檢測和下載資源功能</p>\n<pre><code class=\"Swift\">private func checkVersion(){\n        _ = AlamofireUtils.requestUrl(url: ConfigsValues.API_VERSION, parameters: [:],\n      onSuccess: {(json) in\n        let dictNew = NMGJson.jsonToDict(text: json!)\n        var versionOld:Int? = nil\n        let dataNew = dictNew![&quot;data&quot;] as! [String : Any]\n\n        let userDefault = NMGNSUserDefaults()\n        if userDefault.getNormalDefult(key: &quot;UD_VERSION_CODE&quot;) != nil  {\n            versionOld = userDefault.getNormalDefult(key: &quot;UD_VERSION_CODE&quot;) as? Int\n\n            let versionNew = dataNew[&quot;source_version_code&quot;] as? Int\n\n            if versionNew! &gt; versionOld!{\n                self.downloadFile(versionCode: versionNew)\n            }\n        }else{\n            self.downloadFile(versionCode: dataNew[&quot;source_version_code&quot;] as? Int)\n        }\n\n},\n      onFail: {(error) in self.downloadFile(versionCode: nil)})\n    }\n    private func downloadFile(versionCode: Int?){\n        _ = AlamofireUtils.downloadFile(url: ConfigsValues.API_DOWNLOAD,\n        onSuccess: {(destinationUrl) in\n            print(&quot;download success&quot;)\n\n            SSZipArchive.unzipFile(atPath: (destinationUrl?.absoluteString)!, \n            toDestination: (destinationUrl?.absoluteString)!)\n            let zipPath = ConfigsValues.WEB_SOURCE_PATH//(destinationUrl?.absoluteString)!\n            let unzipPath = ConfigsValues.WEB_SOURCE_DIR?.path\n\n            print(zipPath)\n            print(unzipPath!)\n\n            let success = SSZipArchive.unzipFile(atPath: zipPath, toDestination: unzipPath!)\n            if !success {\n                print(&quot;解压 fail&quot;)\n                return\n            }\n            if versionCode != nil{\n                let userDefault = NMGNSUserDefaults()\n                userDefault.setNormalDefault(key: &quot;UD_VERSION_CODE&quot;, value: versionCode as AnyObject)\n            }\n            print(&quot;解压成功---\\(unzipPath!)&quot;)},\n        onFail: {(error) in print(&quot;download error&quot;)})\n    }\n</code></pre>\n<h4 id=\"3-2-2-繼承-HybridViewController\"><a href=\"#3-2-2-繼承-HybridViewController\" class=\"headerlink\" title=\"3.2.2.繼承 HybridViewController\"></a>3.2.2.繼承 HybridViewController</h4><pre><code>//繼承 HybridViewController 填寫相應文件\nclass HomeViewController: HybridViewController {\n\n    @objc private func refreshWebView(sender: UIRefreshControl) {\n        self.webView.reload()\n        sender.endRefreshing()\n    }\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        let refreshControl = UIRefreshControl()\n        refreshControl.attributedTitle = NSAttributedString(string: &quot;下拉刷新数据&quot;)\n        refreshControl.addTarget(self, action: #selector(refreshWebView), for: UIControlEvents.valueChanged)\n\n        self.webView.scrollView.addSubview(refreshControl)\n        view.addSubview(self.webView)\n\n        self.webView.snp.makeConstraints { (make) -&gt; Void in\n            make.top.equalTo(view).offset(0)\n            make.left.equalTo(view).offset(0)\n            make.bottom.equalTo(view).offset(0)\n            make.right.equalTo(view).offset(0)\n        }\n\n        self.load(webFile: &quot;/views/hy_fg_home.html&quot;)\n\n//        self.registerCmd(cmd: HybridCommand)\n    }\n}\n</code></pre><h2 id=\"4-待完善功能\"><a href=\"#4-待完善功能\" class=\"headerlink\" title=\"4.待完善功能\"></a>4.待完善功能</h2><p>toolbar 的控制</p>\n<p>更多的權限和原生接口</p>\n<p>事件分發的處理</p>\n<p>數據庫</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"app-混合開發方案\"><a href=\"#app-混合開發方案\" class=\"headerlink\" title=\"app 混合開發方案\"></a>app 混合開發方案</h1><p>本方案基於 js 橋接方式作為混合開發，在線下載 html 模板更新 ui，適合在線更新。</p>\n<p>需要了解：前端異步請求，了解 html 作為模板與正常網頁製作的區別，了解 iOS Android 場景跳轉</p>\n<p>進階開發：js 與 iOS Android  通訊</p>\n<h2 id=\"1-設計方案\"><a href=\"#1-設計方案\" class=\"headerlink\" title=\"1.設計方案\"></a>1.設計方案</h2><h3 id=\"1-1-html下載模板流程\"><a href=\"#1-1-html下載模板流程\" class=\"headerlink\" title=\"1.1.html下載模板流程\"></a>1.1.html下載模板流程</h3><p><img src=\"/assets/html_download.png\" alt=\"\"></p>\n<h3 id=\"1-2-js-與-native-通訊流程\"><a href=\"#1-2-js-與-native-通訊流程\" class=\"headerlink\" title=\"1.2.js 與 native 通訊流程\"></a>1.2.js 與 native 通訊流程</h3><p><img src=\"blob:file:///ac20539a-0d43-479f-ba28-e811032391f9\" alt=\"\"></p>\n<h2 id=\"2-方案實現\"><a href=\"#2-方案實現\" class=\"headerlink\" title=\"2.方案實現\"></a>2.方案實現</h2><h3 id=\"2-1服務端開發\"><a href=\"#2-1服務端開發\" class=\"headerlink\" title=\"2.1服務端開發\"></a>2.1服務端開發</h3><h4 id=\"2-1-1-文件說明\"><a href=\"#2-1-1-文件說明\" class=\"headerlink\" title=\"2.1.1.文件說明\"></a>2.1.1.文件說明</h4><p>GlobalValue.js 配置 host，因為打包到手機本地需要完整的請求地址。</p>\n<p>HybridJs.js 是封裝好與 native 通訊。</p>\n<h4 id=\"2-1-2-現有接口\"><a href=\"#2-1-2-現有接口\" class=\"headerlink\" title=\"2.1.2.現有接口\"></a>2.1.2.現有接口</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">接口名稱</th>\n<th style=\"text-align:left\">功能說明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdGetH5Params</td>\n<td style=\"text-align:left\">獲取上一個頁面的參數。eg:列表進入詳細頁面，詳細頁面根據產品 id 獲取數據。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdLoadApi</td>\n<td style=\"text-align:left\">通過 native get 請求 api</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdLoadApiPost</td>\n<td style=\"text-align:left\">通過 native post 請求 api</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdGetContacts</td>\n<td style=\"text-align:left\">獲取手機通訊錄權限</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdPresentViewH5</td>\n<td style=\"text-align:left\">iOS 打開 h5 新頁；Android 打開 h5 activity</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdPushViewH5</td>\n<td style=\"text-align:left\">iOS push新頁；Android 添加 fragment</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdPopView</td>\n<td style=\"text-align:left\">iOS pop；Android pop fragment</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdPopViewToH5</td>\n<td style=\"text-align:left\">iOS pop and open new; Android pop fragment and open new</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdPopViewToRoot</td>\n<td style=\"text-align:left\">iOS pop to root view; Android pop fragment to first fragment</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdDismissView</td>\n<td style=\"text-align:left\">iOS dismiss view; Android finish Activity</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">HybridJs.nativeCmdLocalNotification</td>\n<td style=\"text-align:left\">call native notification</td>\n</tr>\n</tbody>\n</table>\n<p>接口數據格式：</p>\n<pre><code>{\n//固定格式，對應命令\n&quot;cmd&quot;:&quot;CmdLoadApiPost&quot;,\n//固定格式，js 新加命令（HYBRID_CALLBACK_+命令+時間+隨機數）\n&quot;cmd_callback&quot;:&quot;HYBRID_CALLBACK_CmdLoadApiPost_1527589130297_7809&quot;,\n//固定格式，cmd 參數\n&quot;cmd_params&quot;:\n    {\n        //api 或 對應文件\n        &quot;url&quot;:&quot;http://192.168.3.229:9999/api/testrr&quot;,\n        //api 或 對應文件參數\n        &quot;params&quot;:\n        {\n            //自定義結構\n            &quot;url&quot;:&quot;http://192.168.3.229:9999/api/product/1&quot;,\n            &quot;params&quot;:null\n        }\n    }\n}\n</code></pre><h4 id=\"2-1-3-HybridJs-callNativeMethod-自定義接口\"><a href=\"#2-1-3-HybridJs-callNativeMethod-自定義接口\" class=\"headerlink\" title=\"2.1.3.HybridJs.callNativeMethod 自定義接口\"></a>2.1.3.HybridJs.callNativeMethod 自定義接口</h4><p>js 調用 native 唯一接口，通過該接口可以實現更多個性化訂製接口，但必須在 native 上聲明協或繼承 HybridCommand，並在事件分發上添加該功能</p>\n<p>接口數據格式：</p>\n<pre><code>{\n//固定格式，對應命令&quot;cmd&quot;:&quot;CmdLoadApiPost&quot;,\n//固定格式，js 新加命令（HYBRID_CALLBACK_+命令+時間+隨機數）\n&quot;cmd_callback&quot;:&quot;HYBRID_CALLBACK_CmdLoadApiPost_1527589130297_7809&quot;,\n//固定格式，cmd 參數\n&quot;cmd_params&quot;:\n    {\n        //自定義參數結構\n        //api 或 對應文件\n        &quot;id&quot;:&quot;http://192.168.3.229:9999/api/testrr&quot;,\n        //api 或 對應文件參數\n        &quot;params&quot;:\n        {\n            &quot;url&quot;:&quot;http://192.168.3.229:9999/api/product/1&quot;,\n            &quot;params&quot;:null\n        }\n    }\n}\n</code></pre><h3 id=\"2-2-服務端開發流程（以-php-為例子）\"><a href=\"#2-2-服務端開發流程（以-php-為例子）\" class=\"headerlink\" title=\"2.2.服務端開發流程（以 php 為例子）\"></a>2.2.服務端開發流程（以 php 為例子）</h3><h4 id=\"2-2-1-版本控制接口\"><a href=\"#2-2-1-版本控制接口\" class=\"headerlink\" title=\"2.2.1.版本控制接口\"></a>2.2.1.版本控制接口</h4><pre><code class=\"php\">Route::get(&#39;/version&#39;, function () {\n    $version = array(\n        &#39;status&#39; =&gt; 1,\n        &#39;error_code&#39; =&gt; 1,\n        &#39;info&#39; =&gt; &#39;&#39;,\n        &#39;data&#39; =&gt; array(\n            &#39;app_name&#39; =&gt; &#39;v0.0.1&#39;,\n            &#39;last_force_update&#39; =&gt; 0,\n            &#39;version_code&#39; =&gt; 1,\n            &#39;source_version_code&#39; =&gt; 13,\n            &#39;debug_download&#39; =&gt; 1\n        )\n    );\n    return json_encode($version);\n});\n</code></pre>\n<h4 id=\"2-2-2-壓縮-html-資源和下載接口\"><a href=\"#2-2-2-壓縮-html-資源和下載接口\" class=\"headerlink\" title=\"2.2.2.壓縮 html 資源和下載接口\"></a>2.2.2.壓縮 html 資源和下載接口</h4><pre><code class=\"php\">function addFileToZip($path, $zip)\n{\n    $str_array = explode(&#39;/&#39;, $path);\n    $root_dir = &#39;&#39;;\n//    echo $str_array;\n    if (count($str_array) &gt; 0) {\n        $root_dir = $str_array[count($str_array) - 1];\n    }\n\n    $handler = opendir($path); //打开当前文件夹由$path指定。\n    while (($filename = readdir($handler)) !== false) {\n        if ($filename != &quot;.&quot; &amp;&amp; $filename != &quot;..&quot;) {//文件夹文件名字为&#39;.&#39;和‘..’，不要对他们进行操作\n            if (is_dir($path . &quot;/&quot; . $filename)) {// 如果读取的某个对象是文件夹，则递归\n                addFileToZip($path . &quot;/&quot; . $filename, $zip);\n            } else { //将文件加入zip对象\n                $zip-&gt;addFile($path . &quot;/&quot; . $filename, $root_dir . &#39;/&#39; . \n                str_replace(&#39;.blade.php&#39;, &#39;.html&#39;, $filename));\n            }\n        }\n    }\n    @closedir($path);\n}\n</code></pre>\n<pre><code class=\"php\">Route::get(&#39;/zip&#39;, function () {\n\n$dir = realpath(&#39;.&#39;);\n$a = scandir($dir);\n$path_parts = pathinfo(__FILE__);\n\n$dir = realpath(&#39;..&#39;) . &#39;/public/web_source.zip&#39;;\n$zip = new ZipArchive();\nif (file_exists($dir)) {\nunlink($dir);\n}\nif ($zip-&gt;open($dir, ZipArchive::CREATE) === TRUE) {\n// realpath(base_path(&#39;public&#39;))\naddFileToZip(realpath(&#39;..&#39;) . &#39;/resources/views&#39;, $zip); \naddFileToZip(realpath(&#39;..&#39;) . &#39;/public/css&#39;, $zip); \naddFileToZip(realpath(&#39;..&#39;) . &#39;/public/img&#39;, $zip); \naddFileToZip(realpath(&#39;..&#39;) . &#39;/public/js&#39;, $zip); \n$zip-&gt;close(); //关闭处理的zip文件\n}\n\nreturn $a;\n});\n</code></pre>\n<pre><code class=\"php\">Route::get(&#39;/download_source&#39;, function () {\n    return response()-&gt;download(realpath(base_path(&#39;public&#39;)) . &#39;/web_source.zip&#39;, &#39;web_source.zip&#39;);\n});\n</code></pre>\n<h4 id=\"2-2-3-構建-html-頁面\"><a href=\"#2-2-3-構建-html-頁面\" class=\"headerlink\" title=\"2.2.3.構建 html 頁面\"></a>2.2.3.構建 html 頁面</h4><pre><code class=\"html\">//引用相關資源\n&lt;script src=&quot;../js/GlobalValue.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;../js/HybridJs.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<pre><code class=\"js\">//使用 api 請求接口\nfunction testPost() {\n            HybridJs.nativeCmdLoadApiPost(GlobalValue.api_host + &quot;/api/testrr&quot;, {\n                    &quot;url&quot;: GlobalValue.api_host + &quot;/api/product/&quot; + page,\n                    &quot;params&quot;: &#39;ssss&#39;\n                },\n                function (data) {\n                    alert(&quot;ss=&quot;+data.callbackData);\n                },\n                function (data) {\n                    alert(&quot;error=&quot;+data.callbackData);\n                });\n        }\n//打開一個新頁面\nHybridJs.nativeCmdPushViewH5(&quot;/views/hy_fg_product_detail.html&quot;,\n                                {\n                                    &quot;product_id&quot;: this.product_id,\n                                    &quot;product_name&quot;: this.product_name,\n                                    &quot;link&quot;: this.link,\n                                    &quot;is_h5_open&quot;: this.is_h5_open,\n                                });\n</code></pre>\n<h2 id=\"3-app-端構建\"><a href=\"#3-app-端構建\" class=\"headerlink\" title=\"3. app 端構建\"></a>3. app 端構建</h2><h3 id=\"3-1-Android\"><a href=\"#3-1-Android\" class=\"headerlink\" title=\"3.1.Android\"></a>3.1.Android</h3><h4 id=\"3-1-1-添加版本控制和下載-html-資源\"><a href=\"#3-1-1-添加版本控制和下載-html-資源\" class=\"headerlink\" title=\"3.1.1.添加版本控制和下載 html 資源\"></a>3.1.1.添加版本控制和下載 html 資源</h4><p>Application 繼承 Application.ActivityLifecycleCallbacks，添加版本控制和下載代碼</p>\n<pre><code class=\"java\">public class HybridApp extends Application implements Application.ActivityLifecycleCallbacks {\n  private static final String  TAG             = &quot;hk.nmg.hybrid.HybridApp&quot;;\n  public static        boolean IS_DEBUG_ONLINE = true;\n\n  @Override public void onCreate() {\n    super.onCreate();\n    HybridConfigs.API_HOST = HybridValues.API_HOST;\n    registerActivityLifecycleCallbacks(this);\n  }\n\n  @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n\n  }\n\n  @Override public void onActivityStarted(Activity activity) {\n\n  }\n\n  @Override public void onActivityResumed(Activity activity) {\n    NMGLog.i(TAG, &quot;onActivityResumed&quot;);\n    checkVersion();\n  }\n\n  @Override public void onActivityPaused(Activity activity) {\n\n  }\n\n  @Override public void onActivityStopped(Activity activity) {\n\n  }\n\n  @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {\n\n  }\n\n  @Override public void onActivityDestroyed(Activity activity) {\n\n  }\n\n  //TODO 下載文件並保存\n  private void checkVersion() {\n    NMGSubscribe&lt;BaseEntity&lt;VersionEntity&gt;&gt; subscribe = new NMGSubscribe&lt;&gt;();\n    subscribe.onNMGSubscribe(d -&gt; {\n    });\n    subscribe.onNMGNext(d -&gt; {\n      //      if (oldVersion.getLast_force_update() &lt; newVersion.getLast_force_update()) {\n      //        //TODO force update app\n      //        return;\n      //      }\n\n      //      if (oldVersion.getVersion_code() &lt; newVersion.getVersion_code()) {\n      //        //TODO update app\n      //      }\n      int oldSourceVersionCode = CommonUtils.getSourceVersionCode(this);\n      int newSourceVersionCode = d.getData().getSource_version_code();\n      if (oldSourceVersionCode &lt; newSourceVersionCode) {\n        downloadHtmlSource(newSourceVersionCode);\n      }\n    });\n    subscribe.onNMGError(d -&gt; {\n    });\n    subscribe.onNMGFinal(() -&gt; {\n    });\n    CommonUtils.requestVersion(subscribe);\n  }\n\n  private void downloadHtmlSource(int newSourceVersionCode) {\n    NMGLog.i(&quot;downloadHtmlSource&quot;, &quot;downloadHtmlSource&quot;);\n    //获取当前程序路径 应用在内存上的目录 :/data/data/com.mufeng.toolproject/files\n    String filesDir = this.getFilesDir().toString();\n    NMGDownloadFileDelegate subscribe = new NMGDownloadFileDelegate() {\n      @Override public void onSubscribe(Disposable d) {\n\n      }\n\n      @Override public void onNext(String savePath) {\n        NMGZip zip = new NMGZip();\n        zip.decompress(filesDir + &quot;/web_source&quot;, filesDir + &quot;/web_source.zip&quot;, new NMGZip.NMGZipListener() {\n          @Override public void onCompleted(boolean b) {\n            NMGLog.i(&quot;downloadHtmlSource&quot;, &quot;onCompleted&quot;);\n            CommonUtils.saveSourceVersionCode(HybridApp.this, newSourceVersionCode);\n          }\n        });\n      }\n\n      @Override public void onError(Throwable e) {\n\n      }\n\n      @Override public void onFinal() {\n\n      }\n    };\n    NMGHttp.downloadFile(&quot;http://192.168.3.229:9999/download_source&quot;,\n        filesDir,\n        &quot;/web_source.zip&quot;,\n        subscribe);\n\n    //    CommonUtils.downloadFile(&quot;http://192.168.3.229:9999/download_source&quot;, subscribe);\n  }\n}\n</code></pre>\n<h4 id=\"3-1-2-繼承-BaseHybridFragment\"><a href=\"#3-1-2-繼承-BaseHybridFragment\" class=\"headerlink\" title=\"3.1.2.繼承 BaseHybridFragment\"></a>3.1.2.繼承 BaseHybridFragment</h4><p>創建 activity ，和 fragment，將 fragment 添加到 activity，fragment 繼承 BaseHybridFragment，運行即可</p>\n<pre><code class=\"java\">public class HomeHybridFragment extends BaseHybridFragment {\n  private static HomeHybridFragment instance;\n\n  public static synchronized HomeHybridFragment getInstance() {\n    if (instance == null)\n      instance = new HomeHybridFragment();\n    return instance;\n  }\n\n  @Override public void onCreate(@Nullable Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n  }\n\n  @Nullable @Override public View onCreateView(LayoutInflater inflater, \n  @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n//    BaseHybridFragment f = BaseHybridFragment.newInstance(mHost, &quot;/view/hy_fg_home.html&quot;, &quot;&quot;);\n    return setupUI(HybridValues.API_HOST, &quot;/views/hy_fg_home.html&quot;);\n  }\n}\n</code></pre>\n<h3 id=\"3-2-iOS\"><a href=\"#3-2-iOS\" class=\"headerlink\" title=\"3.2.iOS\"></a>3.2.iOS</h3><h4 id=\"3-2-1-添加版本控制和下載-html-資源\"><a href=\"#3-2-1-添加版本控制和下載-html-資源\" class=\"headerlink\" title=\"3.2.1.添加版本控制和下載 html 資源\"></a>3.2.1.添加版本控制和下載 html 資源</h4><p>在 AppDelegate 添加版本檢測和下載資源功能</p>\n<pre><code class=\"Swift\">private func checkVersion(){\n        _ = AlamofireUtils.requestUrl(url: ConfigsValues.API_VERSION, parameters: [:],\n      onSuccess: {(json) in\n        let dictNew = NMGJson.jsonToDict(text: json!)\n        var versionOld:Int? = nil\n        let dataNew = dictNew![&quot;data&quot;] as! [String : Any]\n\n        let userDefault = NMGNSUserDefaults()\n        if userDefault.getNormalDefult(key: &quot;UD_VERSION_CODE&quot;) != nil  {\n            versionOld = userDefault.getNormalDefult(key: &quot;UD_VERSION_CODE&quot;) as? Int\n\n            let versionNew = dataNew[&quot;source_version_code&quot;] as? Int\n\n            if versionNew! &gt; versionOld!{\n                self.downloadFile(versionCode: versionNew)\n            }\n        }else{\n            self.downloadFile(versionCode: dataNew[&quot;source_version_code&quot;] as? Int)\n        }\n\n},\n      onFail: {(error) in self.downloadFile(versionCode: nil)})\n    }\n    private func downloadFile(versionCode: Int?){\n        _ = AlamofireUtils.downloadFile(url: ConfigsValues.API_DOWNLOAD,\n        onSuccess: {(destinationUrl) in\n            print(&quot;download success&quot;)\n\n            SSZipArchive.unzipFile(atPath: (destinationUrl?.absoluteString)!, \n            toDestination: (destinationUrl?.absoluteString)!)\n            let zipPath = ConfigsValues.WEB_SOURCE_PATH//(destinationUrl?.absoluteString)!\n            let unzipPath = ConfigsValues.WEB_SOURCE_DIR?.path\n\n            print(zipPath)\n            print(unzipPath!)\n\n            let success = SSZipArchive.unzipFile(atPath: zipPath, toDestination: unzipPath!)\n            if !success {\n                print(&quot;解压 fail&quot;)\n                return\n            }\n            if versionCode != nil{\n                let userDefault = NMGNSUserDefaults()\n                userDefault.setNormalDefault(key: &quot;UD_VERSION_CODE&quot;, value: versionCode as AnyObject)\n            }\n            print(&quot;解压成功---\\(unzipPath!)&quot;)},\n        onFail: {(error) in print(&quot;download error&quot;)})\n    }\n</code></pre>\n<h4 id=\"3-2-2-繼承-HybridViewController\"><a href=\"#3-2-2-繼承-HybridViewController\" class=\"headerlink\" title=\"3.2.2.繼承 HybridViewController\"></a>3.2.2.繼承 HybridViewController</h4><pre><code>//繼承 HybridViewController 填寫相應文件\nclass HomeViewController: HybridViewController {\n\n    @objc private func refreshWebView(sender: UIRefreshControl) {\n        self.webView.reload()\n        sender.endRefreshing()\n    }\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        let refreshControl = UIRefreshControl()\n        refreshControl.attributedTitle = NSAttributedString(string: &quot;下拉刷新数据&quot;)\n        refreshControl.addTarget(self, action: #selector(refreshWebView), for: UIControlEvents.valueChanged)\n\n        self.webView.scrollView.addSubview(refreshControl)\n        view.addSubview(self.webView)\n\n        self.webView.snp.makeConstraints { (make) -&gt; Void in\n            make.top.equalTo(view).offset(0)\n            make.left.equalTo(view).offset(0)\n            make.bottom.equalTo(view).offset(0)\n            make.right.equalTo(view).offset(0)\n        }\n\n        self.load(webFile: &quot;/views/hy_fg_home.html&quot;)\n\n//        self.registerCmd(cmd: HybridCommand)\n    }\n}\n</code></pre><h2 id=\"4-待完善功能\"><a href=\"#4-待完善功能\" class=\"headerlink\" title=\"4.待完善功能\"></a>4.待完善功能</h2><p>toolbar 的控制</p>\n<p>更多的權限和原生接口</p>\n<p>事件分發的處理</p>\n<p>數據庫</p>\n"},{"title":"C#中的委托和事件","date":"2018-10-02T01:09:09.000Z","_content":"# C# 中的委托和事件\n---\n委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。\nC# 中的委托和事件\n---\n>引言\n>委托 和 事件在 .Net Framework中的应用非常广泛，然而，较好地理解委托和事件对很多接触C#时间不长的人来说并不容易。它们就像是一道槛儿，过了这个槛的人，觉得真是太容易了，而没有过去的人每次见到委托和事件就觉得心里别（biè）得慌，混身不自在。本文中，我将通过两个范例由浅入深地讲述什么是委托、为什么要使用委托、事件的由来、.Net Framework中的委托和事件、委托和事件对Observer设计模式的意义，对它们的中间代码也做了讨论。\n将方法作为方法的参数\n我们先不管这个标题如何的绕口，也不管委托究竟是个什么东西，来看下面这两个最简单的方法，它们不过是在屏幕上输出一句问候的话语：\n```c#\npublic void GreetPeople(string name) {\n // 做某些额外的事情，比如初始化之类，此处略\n EnglishGreeting(name);\n}\npublic void EnglishGreeting(string name) {\n Console.WriteLine(\"Morning, \" + name);\n}\n```\n暂且不管这两个方法有没有什么实际意义。GreetPeople用于向某人问好，当我们传递代表某人姓名的name参数，比如说“Jimmy”，进去的时候，在这个方法中，将调用EnglishGreeting方法，再次传递name参数，EnglishGreeting则用于向屏幕输出 “Morning, Jimmy”。\n现在假设这个程序需要进行全球化，哎呀，不好了，我是中国人，我不明白“Morning”是什么意思，怎么办呢？好吧，我们再加个中文版的问候方法：\n```c#\npublic void ChineseGreeting(string name){\n Console.WriteLine(\"早上好, \" + name);\n}\n```\n这时候，GreetPeople也需要改一改了，不然如何判断到底用哪个版本的Greeting问候方法合适呢？在进行这个之前，我们最好再定义一个枚举作为判断的依据：\n```c#\npublic enum Language{\n English, Chinese\n}\npublic void GreetPeople(string name, Language lang){\n //做某些额外的事情，比如初始化之类，此处略\n swith(lang){\n case Language.English:\n EnglishGreeting(name);\n break;\n case Language.Chinese:\n ChineseGreeting(name);\n break;\n }\n}\n```\nOK，尽管这样解决了问题，但我不说大家也很容易想到，这个解决方案的可扩展性很差，如果日后我们需要再添加韩文版、日文版，就不得不反复修改枚举和GreetPeople()方法，以适应新的需求。\n在考虑新的解决方案之前，我们先看看 GreetPeople的方法签名：\n```c#\npublic void GreetPeople(string name, Language lang)\n```\n我们仅看 string name，在这里，string 是参数类型，name 是参数变量，当我们赋给name字符串“jimmy”时，它就代表“jimmy”这个值；当我们赋给它“张子阳”时，它又代表着“张子阳”这个值。然后，我们可以在方法体内对这个name进行其他操作。哎，这简直是废话么，刚学程序就知道了。\n如果你再仔细想想，假如GreetPeople()方法可以接受一个参数变量，这个变量可以代表另一个方法，当我们给这个变量赋值 EnglishGreeting的时候，它代表着 EnglsihGreeting() 这个方法；当我们给它赋值ChineseGreeting 的时候，它又代表着ChineseGreeting()方法。我们将这个参数变量命名为 MakeGreeting，那么不是可以如同给name赋值时一样，在调用 GreetPeople()方法的时候，给这个MakeGreeting 参数也赋上值么(ChineseGreeting或者EnglsihGreeting等)？然后，我们在方法体内，也可以像使用别的参数一样使用MakeGreeting。但是，由于MakeGreeting代表着一个方法，它的使用方式应该和它被赋的方法(比如ChineseGreeting)是一样的，比如：\n```c#\nMakeGreeting(name);\n```\n好了，有了思路了，我们现在就来改改GreetPeople()方法，那么它应该是这个样子了：\n```c#\npublic void GreetPeople(string name, *** MakeGreeting){\n MakeGreeting(name);\n}\n```\n注意到 \\*** ，这个位置通常放置的应该是参数的类型，但到目前为止，我们仅仅是想到应该有个可以代表方法的参数，并按这个思路去改写GreetPeople方法，现在就出现了一个大问题：这个代表着方法的MakeGreeting参数应该是什么类型的？\nNOTE：这里已不再需要枚举了，因为在给MakeGreeting赋值的时候动态地决定使用哪个方法，是ChineseGreeting还是 EnglishGreeting，而在这个两个方法内部，已经对使用“morning”还是“早上好”作了区分。\n聪明的你应该已经想到了，现在是委托该出场的时候了，但讲述委托之前，我们再看看MakeGreeting参数所能代表的 ChineseGreeting()和EnglishGreeting()方法的签名：\n```c#\npublic void EnglishGreeting(string name)\npublic void ChineseGreeting(string name)\n```\n如同name可以接受String类型的“true”和“1”，但不能接受bool类型的true和int类型的1一样。MakeGreeting的 参数类型定义 应该能够确定 MakeGreeting可以代表的方法种类，再进一步讲，就是MakeGreeting可以代表的方法 的 参数类型和返回类型。\n于是，委托出现了：它定义了MakeGreeting参数所能代表的方法的种类，也就是MakeGreeting参数的类型。\nNOTE：如果上面这句话比较绕口，我把它翻译成这样：string 定义了name参数所能代表的值的种类，也就是name参数的类型。\n本例中委托的定义：\n```c#\npublic delegate void GreetingDelegate(string name);\n```\n可以与上面EnglishGreeting()方法的签名对比一下，除了加入了delegate关键字以外，其余的是不是完全一样？\n现在，让我们再次改动GreetPeople()方法，如下所示：\n```c#\npublic void GreetPeople(string name, GreetingDelegate MakeGreeting){\n MakeGreeting(name);\n}\n```\n如你所见，委托GreetingDelegate出现的位置与 string相同，string是一个类型，那么GreetingDelegate应该也是一个类型，或者叫类(Class)。但是委托的声明方式和类却完全不同，这是怎么一回事？实际上，委托在编译的时候确实会编译成类。因为Delegate是一个类，所以在任何可以声明类的地方都可以声明委托。更多的内容将在下面讲述，现在，请看看这个范例的完整代码：\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Delegate {\n //定义委托，它定义了可以代表的方法的类型\n public delegate void GreetingDelegate(string name);\n class Program {\n private static void EnglishGreeting(string name) {\n Console.WriteLine(\"Morning, \" + name);\n }\n private static void ChineseGreeting(string name) {\n Console.WriteLine(\"早上好, \" + name);\n }\n //注意此方法，它接受一个GreetingDelegate类型的方法作为参数\n private static void GreetPeople(string name, GreetingDelegate MakeGreeting) {\n MakeGreeting(name);\n }\n static void Main(string[] args) {\n GreetPeople(\"Jimmy Zhang\", EnglishGreeting);\n GreetPeople(\"张子阳\", ChineseGreeting);\n Console.ReadKey();\n }\n }\n }\n```\n输出如下：\n```\nMorning, Jimmy Zhang\n早上好, 张子阳\n```\n我们现在对委托做一个总结：\n委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。\n将方法绑定到委托\n看到这里，是不是有那么点如梦初醒的感觉？于是，你是不是在想：在上面的例子中，我不一定要直接在GreetPeople()方法中给 name参数赋值，我可以像这样使用变量：\n```c#\nstatic void Main(string[] args) {\n string name1, name2;\n name1 = \"Jimmy Zhang\";\n name2 = \"张子阳\";\n GreetPeople(name1, EnglishGreeting);\n GreetPeople(name2, ChineseGreeting);\n Console.ReadKey();\n}\n```\n而既然委托GreetingDelegate 和 类型 string 的地位一样，都是定义了一种参数类型，那么，我是不是也可以这么使用委托？\n```c#\nstatic void Main(string[] args) {\n GreetingDelegate delegate1, delegate2;\n delegate1 = EnglishGreeting;\n delegate2 = ChineseGreeting;\n GreetPeople(\"Jimmy Zhang\", delegate1);\n GreetPeople(\"张子阳\", delegate2);\n Console.ReadKey();\n}\n```\n如你所料，这样是没有问题的，程序一如预料的那样输出。这里，我想说的是委托不同于string的一个特性：可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。在这个例子中，语法如下：\n```c#\nstatic void Main(string[] args) {\n GreetingDelegate delegate1;\n delegate1 = EnglishGreeting; // 先给委托类型的变量赋值\n delegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法\n GreetPeople(\"Jimmy Zhang\", delegate1);\n Console.ReadKey();\n}\n```\n输出为：\n```\nMorning, Jimmy Zhang\n早上好, Jimmy Zhang\n```\n实际上，我们可以也可以绕过GreetPeople方法，通过委托来直接调用EnglishGreeting和ChineseGreeting：\n```c#\nstatic void Main(string[] args) {\n GreetingDelegate delegate1;\n delegate1 = EnglishGreeting; // 先给委托类型的变量赋值\n delegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法\n delegate1 (\"Jimmy Zhang\");\n Console.ReadKey();\n}\n```\n\nNOTE：这在本例中是没有问题的，但回头看下上面GreetPeople()的定义，在它之中可以做一些对于EnglshihGreeting和ChineseGreeting来说都需要进行的工作，为了简便我做了省略。\n注意这里，第一次用的“=”，是赋值的语法；第二次，用的是“+=”，是绑定的语法。如果第一次就使用“+=”，将出现“使用了未赋值的局部变量”的编译错误。\n我们也可以使用下面的代码来这样简化这一过程：\n```c#\nGreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting);\ndelegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n```\n看到这里，应该注意到，这段代码第一条语句与实例化一个类是何其的相似，你不禁想到：上面第一次绑定委托时不可以使用“+=”的编译错误，或许可以用这样的方法来避免：\n```c#\nGreetingDelegate delegate1 = new GreetingDelegate();\ndelegate1 += EnglishGreeting; // 这次用的是 “+=”，绑定语法。\ndelegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n```\n但实际上，这样会出现编译错误： “GreetingDelegate”方法没有采用“0”个参数的重载。尽管这样的结果让我们觉得有点沮丧，但是编译的提示：“没有0个参数的重载”再次让我们联想到了类的构造函数。我知道你一定按捺不住想探个究竟，但再此之前，我们需要先把基础知识和应用介绍完。\n既然给委托可以绑定一个方法，那么也应该有办法取消对方法的绑定，很容易想到，这个语法是“-=”：\n```c#\nstatic void Main(string[] args) {\n GreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting);\n delegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法\n GreetPeople(\"Jimmy Zhang\", delegate1);\n Console.WriteLine();\n delegate1 -= EnglishGreeting; //取消对EnglishGreeting方法的绑定\n // 将仅调用 ChineseGreeting\n GreetPeople(\"张子阳\", delegate1);\n Console.ReadKey();\n}\n```\n输出为：\n```\nMorning, Jimmy Zhang\n早上好, Jimmy Zhang\n早上好, 张子阳\n```\n让我们再次对委托作个总结：\n使用委托可以将多个方法绑定到同一个委托变量，当调用此变量时(这里用“调用”这个词，是因为此变量代表一个方法)，可以依次调用所有绑定的方法。\n事件的由来\n我们继续思考上面的程序：上面的三个方法都定义在Programe类中，这样做是为了理解的方便，实际应用中，通常都是 GreetPeople 在一个类中，ChineseGreeting和 EnglishGreeting 在另外的类中。现在你已经对委托有了初步了解，是时候对上面的例子做个改进了。假设我们将GreetingPeople()放在一个叫GreetingManager的类中，那么新程序应该是这个样子的：\n```c#\nnamespace Delegate {\n //定义委托，它定义了可以代表的方法的类型\n public delegate void GreetingDelegate(string name);\n\n //新建的GreetingManager类\n public class GreetingManager{\n public void GreetPeople(string name, GreetingDelegate MakeGreeting) {\n MakeGreeting(name);\n }\n }\n class Program {\n private static void EnglishGreeting(string name) {\n Console.WriteLine(\"Morning, \" + name);\n }\n private static void ChineseGreeting(string name) {\n Console.WriteLine(\"早上好, \" + name);\n }\n static void Main(string[] args) {\n // ... ...\n }\n }\n}\n```\n这个时候，如果要实现前面演示的输出效果，Main方法我想应该是这样的：\n```c#\nstatic void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.GreetPeople(\"Jimmy Zhang\", EnglishGreeting);\n gm.GreetPeople(\"张子阳\", ChineseGreeting);\n}\n```\n我们运行这段代码，嗯，没有任何问题。程序一如预料地那样输出了：\n```\nMorning, Jimmy Zhang\n早上好, 张子阳\n```\n现在，假设我们需要使用上一节学到的知识，将多个方法绑定到同一个委托变量，该如何做呢？让我们再次改写代码：\n```c#\nstatic void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n GreetingDelegate delegate1;\n delegate1 = EnglishGreeting;\n delegate1 += ChineseGreeting;\n gm.GreetPeople(\"Jimmy Zhang\", delegate1);\n}\n```\n输出：\n````\nMorning, Jimmy Zhang\n早上好, Jimmy Zhang\n```\n到了这里，我们不禁想到：面向对象设计，讲究的是对象的封装，既然可以声明委托类型的变量(在上例中是delegate1)，我们何不将这个变量封装到 GreetManager类中？在这个类的客户端中使用不是更方便么？于是，我们改写GreetManager类，像这样：\n```c#\npublic class GreetingManager{\n //在GreetingManager类的内部声明delegate1变量\n public GreetingDelegate delegate1;\n public void GreetPeople(string name, GreetingDelegate MakeGreeting) {\n MakeGreeting(name);\n }\n}\n```\n现在，我们可以这样使用这个委托变量：\n```c#\nstatic void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.delegate1 = EnglishGreeting;\n gm.delegate1 += ChineseGreeting;\n gm.GreetPeople(\"Jimmy Zhang\", gm.delegate1);\n}\n```\n输出为：\n```c#\nMorning, Jimmy Zhang\n早上好, Jimmy Zhang\n```\n尽管这样做没有任何问题，但我们发现这条语句很奇怪。在调用gm.GreetPeople方法的时候，再次传递了gm的delegate1字段：\n```c#\ngm.GreetPeople(\"Jimmy Zhang\", gm.delegate1);\n```\n既然如此，我们何不修改 GreetingManager 类成这样：\n```c#\npublic class GreetingManager{\n //在GreetingManager类的内部声明delegate1变量\n public GreetingDelegate delegate1;\n public void GreetPeople(string name) {\n if(delegate1!=null){ //如果有方法注册委托变量\n delegate1(name); //通过委托调用方法\n }\n }\n}\n```\n在客户端，调用看上去更简洁一些：\n```c#\nstatic void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.delegate1 = EnglishGreeting;\n gm.delegate1 += ChineseGreeting;\n gm.GreetPeople(\"Jimmy Zhang\"); //注意，这次不需要再传递 delegate1变量\n}\n```\n输出为：\n```\nMorning, Jimmy Zhang\n早上好, Jimmy Zhang\n```\n尽管这样达到了我们要的效果，但是还是存在着问题：\n在这里，delegate1和我们平时用的string类型的变量没有什么分别，而我们知道，并不是所有的字段都应该声明成public，合适的做法是应该public的时候public，应该private的时候private。\n我们先看看如果把 delegate1 声明为 private会怎样？结果就是：这简直就是在搞笑。因为声明委托的目的就是为了把它暴露在类的客户端进行方法的注册，你把它声明为private了，客户端对它根本就不可见，那它还有什么用？\n再看看把delegate1 声明为 public 会怎样？结果就是：在客户端可以对它进行随意的赋值等操作，严重破坏对象的封装性。\n最后，第一个方法注册用“=”，是赋值语法，因为要进行实例化，第二个方法注册则用的是“+=”。但是，不管是赋值还是注册，都是将方法绑定到委托上，除了调用时先后顺序不同，再没有任何的分别，这样不是让人觉得很别扭么？\n现在我们想想，如果delegate1不是一个委托类型，而是一个string类型，你会怎么做？答案是使用属性对字段进行封装。\n于是，Event出场了，它封装了委托类型的变量，使得：在类的内部，不管你声明它是public还是protected，它总是private的。在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同。\n我们改写GreetingManager类，它变成了这个样子：\n```c#\npublic class GreetingManager{\n //这一次我们在这里声明一个事件\n public event GreetingDelegate MakeGreet;\n public void GreetPeople(string name) {\n MakeGreet(name);\n }\n}\n```\n很容易注意到：MakeGreet 事件的声明与之前委托变量delegate1的声明唯一的区别是多了一个event关键字。看到这里，在结合上面的讲解，你应该明白到：事件其实没什么不好理解的，声明一个事件不过类似于声明一个进行了封装的委托类型的变量而已。\n为了证明上面的推论，如果我们像下面这样改写Main方法：\n```c#\nstatic void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.MakeGreet = EnglishGreeting; // 编译错误1\n gm.MakeGreet += ChineseGreeting;\n gm.GreetPeople(\"Jimmy Zhang\");\n}\n```\n会得到编译错误：事件“Delegate.GreetingManager.MakeGreet”只能出现在 += 或 -= 的左边(从类型“Delegate.GreetingManager”中使用时除外)。\n事件和委托的编译代码\n这时候，我们注释掉编译错误的行，然后重新进行编译，再借助Reflactor来对 event的声明语句做一探究，看看为什么会发生这样的错误：\n```c#\npublic event GreetingDelegate MakeGreet;\n ```\n可以看到，实际上尽管我们在GreetingManager里将 MakeGreet 声明为public，但是，实际上MakeGreet会被编译成 私有字段，难怪会发生上面的编译错误了，因为它根本就不允许在GreetingManager类的外面以赋值的方式访问，从而验证了我们上面所做的推论。\n我们再进一步看下MakeGreet所产生的代码：\n```c#\nprivate GreetingDelegate MakeGreet; //对事件的声明 实际是 声明一个私有的委托变量\n\n[MethodImpl(MethodImplOptions.Synchronized)]\npublic void add_MakeGreet(GreetingDelegate value){\n this.MakeGreet = (GreetingDelegate) Delegate.Combine(this.MakeGreet, value);\n}\n[MethodImpl(MethodImplOptions.Synchronized)]\npublic void remove_MakeGreet(GreetingDelegate value){\n this.MakeGreet = (GreetingDelegate) Delegate.Remove(this.MakeGreet, value);\n}\n```\n现在已经很明确了：MakeGreet事件确实是一个GreetingDelegate类型的委托，只不过不管是不是声明为public，它总是被声明为private。另外，它还有两个方法，分别是add_MakeGreet和remove_MakeGreet，这两个方法分别用于注册委托类型的方法和取消注册。实际上也就是： “+= ”对应 add_MakeGreet，“-=”对应remove_MakeGreet。而这两个方法的访问限制取决于声明事件时的访问限制符。\n在add_MakeGreet()方法内部，实际上调用了System.Delegate的Combine()静态方法，这个方法用于将当前的变量添加到委托链表中。我们前面提到过两次，说委托实际上是一个类，在我们定义委托的时候：\n```c#\npublic delegate void GreetingDelegate(string name);\n```\n当编译器遇到这段代码的时候，会生成下面这样一个完整的类：\n```c#\npublic sealed class GreetingDelegate:System.MulticastDelegate{\n public GreetingDelegate(object @object, IntPtr method);\n public virtual IAsyncResult BeginInvoke(string name, AsyncCallback callback, object @object);\n public virtual void EndInvoke(IAsyncResult result);\n public virtual void Invoke(string name);\n}\n```\n\n关于这个类的更深入内容，可以参阅《CLR Via C#》等相关书籍，这里就不再讨论了。\n委托、事件与Observer设计模式\n范例说明\n上面的例子已不足以再进行下面的讲解了，我们来看一个新的范例，因为之前已经介绍了很多的内容，所以本节的进度会稍微快一些：\n假设我们有个高档的热水器，我们给它通上电，当水温超过95度的时候：1、扬声器会开始发出语音，告诉你水的温度；2、液晶屏也会改变水温的显示，来提示水已经快烧开了。\n现在我们需要写个程序来模拟这个烧水的过程，我们将定义一个类来代表热水器，我们管它叫：Heater，它有代表水温的字段，叫做temperature；当然，还有必不可少的给水加热方法BoilWater()，一个发出语音警报的方法MakeAlert()，一个显示水温的方法，ShowMsg()。\n```c#\nnamespace Delegate {\n class Heater {\n private int temperature; // 水温\n // 烧水\n public void BoilWater() {\n for (int i = 0; i <= 100; i++) {\n temperature = i;\n if (temperature > 95) {\n MakeAlert(temperature);\n ShowMsg(temperature);\n }\n }\n }\n // 发出语音警报\n private void MakeAlert(int param) {\n Console.WriteLine(\"Alarm：嘀嘀嘀，水已经 {0} 度了：\" , param);\n }\n\n // 显示水温\n private void ShowMsg(int param) {\n Console.WriteLine(\"Display：水快开了，当前温度：{0}度。\" , param);\n }\n}\nclass Program {\n static void Main() {\n Heater ht = new Heater();\n ht.BoilWater();\n }\n}\n}\n```\nObserver设计模式简介\n上面的例子显然能完成我们之前描述的工作，但是却并不够好。现在假设热水器由三部分组成：热水器、警报器、显示器，它们来自于不同厂商并进行了组装。那么，应该是热水器仅仅负责烧水，它不能发出警报也不能显示水温；在水烧开时由警报器发出警报、显示器显示提示和水温。\n这时候，上面的例子就应该变成这个样子：\n```c#\n// 热水器\npublic class Heater {\n private int temperature;\n\n // 烧水\n private void BoilWater() {\n for (int i = 0; i <= 100; i++) {\n temperature = i;\n }\n }\n}\n// 警报器\npublic class Alarm{\n private void MakeAlert(int param) {\n Console.WriteLine(\"Alarm：嘀嘀嘀，水已经 {0} 度了：\" , param);\n }\n}\n// 显示器\npublic class Display{\n private void ShowMsg(int param) {\n Console.WriteLine(\"Display：水已烧开，当前温度：{0}度。\" , param);\n }\n}\n```\n这里就出现了一个问题：如何在水烧开的时候通知报警器和显示器？在继续进行之前，我们先了解一下Observer设计模式，Observer设计模式中主要包括如下两类对象：\nSubject：监视对象，它往往包含着其他对象所感兴趣的内容。在本范例中，热水器就是一个监视对象，它包含的其他对象所感兴趣的内容，就是temprature字段，当这个字段的值快到100时，会不断把数据发给监视它的对象。\nObserver：监视者，它监视Subject，当Subject中的某件事发生的时候，会告知Observer，而Observer则会采取相应的行动。在本范例中，Observer有警报器和显示器，它们采取的行动分别是发出警报和显示水温。\n在本例中，事情发生的顺序应该是这样的：\n警报器和显示器告诉热水器，它对它的温度比较感兴趣(注册)。\n热水器知道后保留对警报器和显示器的引用。\n热水器进行烧水这一动作，当水温超过95度时，通过对警报器和显示器的引用，自动调用警报器的MakeAlert()方法、显示器的ShowMsg()方法。\n类似这样的例子是很多的，GOF对它进行了抽象，称为Observer设计模式：Observer设计模式是为了定义对象间的一种一对多的依赖关系，以便于当一个对象的状态改变时，其他依赖于它的对象会被自动告知并更新。Observer模式是一种松耦合的设计模式。\n实现范例的Observer设计模式\n我们之前已经对委托和事件介绍很多了，现在写代码应该很容易了，现在在这里直接给出代码，并在注释中加以说明。\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Delegate {\n // 热水器\n public class Heater {\n private int temperature;\n public delegate void BoilHandler(int param); //声明委托\n public event BoilHandler BoilEvent; //声明事件\n // 烧水\n public void BoilWater() {\n for (int i = 0; i <= 100; i++) {\n temperature = i;\n if (temperature > 95) {\n if (BoilEvent != null) { //如果有对象注册\n BoilEvent(temperature); //调用所有注册对象的方法\n }\n }\n }\n }\n }\n // 警报器\n public class Alarm {\n public void MakeAlert(int param) {\n Console.WriteLine(\"Alarm：嘀嘀嘀，水已经 {0} 度了：\", param);\n }\n }\n // 显示器\n public class Display {\n public static void ShowMsg(int param) { //静态方法\n Console.WriteLine(\"Display：水快烧开了，当前温度：{0}度。\", param);\n }\n }\n\n class Program {\n static void Main() {\n Heater heater = new Heater();\n Alarm alarm = new Alarm();\n heater.BoilEvent += alarm.MakeAlert; //注册方法\n heater.BoilEvent += (new Alarm()).MakeAlert; //给匿名对象注册方法\n heater.BoilEvent += Display.ShowMsg; //注册静态方法\n heater.BoilWater(); //烧水，会自动调用注册过对象的方法\n }\n }\n}\n```\n输出为：\n```\nAlarm：嘀嘀嘀，水已经 96 度了：\nAlarm：嘀嘀嘀，水已经 96 度了：\nDisplay：水快烧开了，当前温度：96度。\n// 省略...\n```\n.Net Framework中的委托与事件\n尽管上面的范例很好地完成了我们想要完成的工作，但是我们不仅疑惑：为什么.Net Framework 中的事件模型和上面的不同？为什么有很多的EventArgs参数？\n在回答上面的问题之前，我们先搞懂 .Net Framework的编码规范：\n委托类型的名称都应该以EventHandler结束。\n委托的原型定义：有一个void返回值，并接受两个输入参数：一个Object 类型，一个 EventArgs类型(或继承自EventArgs)。\n事件的命名为 委托去掉 EventHandler之后剩余的部分。\n继承自EventArgs的类型应该以EventArgs结尾。\n再做一下说明：\n委托声明原型中的Object类型的参数代表了Subject，也就是监视对象，在本例中是 Heater(热水器)。回调函数(比如Alarm的MakeAlert)可以通过它访问触发事件的对象(Heater)。\nEventArgs 对象包含了Observer所感兴趣的数据，在本例中是temperature。\n上面这些其实不仅仅是为了编码规范而已，这样也使得程序有更大的灵活性。比如说，如果我们不光想获得热水器的温度，还想在Observer端(警报器或者显示器)方法中获得它的生产日期、型号、价格，那么委托和方法的声明都会变得很麻烦，而如果我们将热水器的引用传给警报器的方法，就可以在方法中直接访问热水器了。\n现在我们改写之前的范例，让它符合 .Net Framework 的规范：\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Delegate {\n // 热水器\n public class Heater {\n private int temperature;\n public string type = \"RealFire 001\"; // 添加型号作为演示\n public string area = \"China Xian\"; // 添加产地作为演示\n //声明委托\n public delegate void BoiledEventHandler(Object sender, BoiledEventArgs e);\n public event BoiledEventHandler Boiled; //声明事件\n // 定义BoiledEventArgs类，传递给Observer所感兴趣的信息\n public class BoiledEventArgs : EventArgs {\n public readonly int temperature;\n public BoiledEventArgs(int temperature) {\n this.temperature = temperature;\n }\n }\n // 可以供继承自 Heater 的类重写，以便继承类拒绝其他对象对它的监视\n protected virtual void OnBoiled(BoiledEventArgs e) {\n if (Boiled != null) { // 如果有对象注册\n Boiled(this, e); // 调用所有注册对象的方法\n }\n }\n\n // 烧水。\n public void BoilWater() {\n for (int i = 0; i <= 100; i++) {\n temperature = i;\n if (temperature > 95) {\n //建立BoiledEventArgs 对象。\n BoiledEventArgs e = new BoiledEventArgs(temperature);\n OnBoiled(e); // 调用 OnBolied方法\n }\n }\n }\n }\n // 警报器\n public class Alarm {\n public void MakeAlert(Object sender, Heater.BoiledEventArgs e) {\n Heater heater = (Heater)sender; //这里是不是很熟悉呢？\n //访问 sender 中的公共字段\n Console.WriteLine(\"Alarm：{0} - {1}: \", heater.area, heater.type);\n Console.WriteLine(\"Alarm: 嘀嘀嘀，水已经 {0} 度了：\", e.temperature);\n Console.WriteLine();\n }\n }\n // 显示器\n public class Display {\n public static void ShowMsg(Object sender, Heater.BoiledEventArgs e) { //静态方法\n Heater heater = (Heater)sender;\n Console.WriteLine(\"Display：{0} - {1}: \", heater.area, heater.type);\n Console.WriteLine(\"Display：水快烧开了，当前温度：{0}度。\", e.temperature);\n Console.WriteLine();\n }\n }\n class Program {\n static void Main() {\n Heater heater = new Heater();\n Alarm alarm = new Alarm();\n heater.Boiled += alarm.MakeAlert; //注册方法\n heater.Boiled += (new Alarm()).MakeAlert; //给匿名对象注册方法\n heater.Boiled += new Heater.BoiledEventHandler(alarm.MakeAlert); //也可以这么注册\n heater.Boiled += Display.ShowMsg; //注册静态方法\n heater.BoilWater(); //烧水，会自动调用注册过对象的方法\n }\n }\n}\n```\n输出为：\n```\nAlarm：China Xian - RealFire 001:\nAlarm: 嘀嘀嘀，水已经 96 度了：\nAlarm：China Xian - RealFire 001:\nAlarm: 嘀嘀嘀，水已经 96 度了：\nAlarm：China Xian - RealFire 001:\nAlarm: 嘀嘀嘀，水已经 96 度了：\nDisplay：China Xian - RealFire 001:\nDisplay：水快烧开了，当前温度：96度。\n// 省略 ...\n```\n总结\n在本文中我首先通过一个GreetingPeople的小程序向大家介绍了委托的概念、委托用来做什么，随后又引出了事件，接着对委托与事件所产生的中间代码做了粗略的讲述。\n在第二个稍微复杂点的热水器的范例中，我向大家简要介绍了 Observer设计模式，并通过实现这个范例完成了该模式，随后讲述了.Net Framework中委托、事件的实现方式。\n希望这篇文章能给你带来帮助。\n>来源：\n>[1]: <http://www.tracefact.net/csharp-programming/delegates-and-events-in-csharp.aspx>\n","source":"_posts/CShape/CShape中的委托和事件.md","raw":"---\ntitle: C#中的委托和事件\ndate: 2018-10-02 09:09:09\ncategories: CShape\n---\n# C# 中的委托和事件\n---\n委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。\nC# 中的委托和事件\n---\n>引言\n>委托 和 事件在 .Net Framework中的应用非常广泛，然而，较好地理解委托和事件对很多接触C#时间不长的人来说并不容易。它们就像是一道槛儿，过了这个槛的人，觉得真是太容易了，而没有过去的人每次见到委托和事件就觉得心里别（biè）得慌，混身不自在。本文中，我将通过两个范例由浅入深地讲述什么是委托、为什么要使用委托、事件的由来、.Net Framework中的委托和事件、委托和事件对Observer设计模式的意义，对它们的中间代码也做了讨论。\n将方法作为方法的参数\n我们先不管这个标题如何的绕口，也不管委托究竟是个什么东西，来看下面这两个最简单的方法，它们不过是在屏幕上输出一句问候的话语：\n```c#\npublic void GreetPeople(string name) {\n // 做某些额外的事情，比如初始化之类，此处略\n EnglishGreeting(name);\n}\npublic void EnglishGreeting(string name) {\n Console.WriteLine(\"Morning, \" + name);\n}\n```\n暂且不管这两个方法有没有什么实际意义。GreetPeople用于向某人问好，当我们传递代表某人姓名的name参数，比如说“Jimmy”，进去的时候，在这个方法中，将调用EnglishGreeting方法，再次传递name参数，EnglishGreeting则用于向屏幕输出 “Morning, Jimmy”。\n现在假设这个程序需要进行全球化，哎呀，不好了，我是中国人，我不明白“Morning”是什么意思，怎么办呢？好吧，我们再加个中文版的问候方法：\n```c#\npublic void ChineseGreeting(string name){\n Console.WriteLine(\"早上好, \" + name);\n}\n```\n这时候，GreetPeople也需要改一改了，不然如何判断到底用哪个版本的Greeting问候方法合适呢？在进行这个之前，我们最好再定义一个枚举作为判断的依据：\n```c#\npublic enum Language{\n English, Chinese\n}\npublic void GreetPeople(string name, Language lang){\n //做某些额外的事情，比如初始化之类，此处略\n swith(lang){\n case Language.English:\n EnglishGreeting(name);\n break;\n case Language.Chinese:\n ChineseGreeting(name);\n break;\n }\n}\n```\nOK，尽管这样解决了问题，但我不说大家也很容易想到，这个解决方案的可扩展性很差，如果日后我们需要再添加韩文版、日文版，就不得不反复修改枚举和GreetPeople()方法，以适应新的需求。\n在考虑新的解决方案之前，我们先看看 GreetPeople的方法签名：\n```c#\npublic void GreetPeople(string name, Language lang)\n```\n我们仅看 string name，在这里，string 是参数类型，name 是参数变量，当我们赋给name字符串“jimmy”时，它就代表“jimmy”这个值；当我们赋给它“张子阳”时，它又代表着“张子阳”这个值。然后，我们可以在方法体内对这个name进行其他操作。哎，这简直是废话么，刚学程序就知道了。\n如果你再仔细想想，假如GreetPeople()方法可以接受一个参数变量，这个变量可以代表另一个方法，当我们给这个变量赋值 EnglishGreeting的时候，它代表着 EnglsihGreeting() 这个方法；当我们给它赋值ChineseGreeting 的时候，它又代表着ChineseGreeting()方法。我们将这个参数变量命名为 MakeGreeting，那么不是可以如同给name赋值时一样，在调用 GreetPeople()方法的时候，给这个MakeGreeting 参数也赋上值么(ChineseGreeting或者EnglsihGreeting等)？然后，我们在方法体内，也可以像使用别的参数一样使用MakeGreeting。但是，由于MakeGreeting代表着一个方法，它的使用方式应该和它被赋的方法(比如ChineseGreeting)是一样的，比如：\n```c#\nMakeGreeting(name);\n```\n好了，有了思路了，我们现在就来改改GreetPeople()方法，那么它应该是这个样子了：\n```c#\npublic void GreetPeople(string name, *** MakeGreeting){\n MakeGreeting(name);\n}\n```\n注意到 \\*** ，这个位置通常放置的应该是参数的类型，但到目前为止，我们仅仅是想到应该有个可以代表方法的参数，并按这个思路去改写GreetPeople方法，现在就出现了一个大问题：这个代表着方法的MakeGreeting参数应该是什么类型的？\nNOTE：这里已不再需要枚举了，因为在给MakeGreeting赋值的时候动态地决定使用哪个方法，是ChineseGreeting还是 EnglishGreeting，而在这个两个方法内部，已经对使用“morning”还是“早上好”作了区分。\n聪明的你应该已经想到了，现在是委托该出场的时候了，但讲述委托之前，我们再看看MakeGreeting参数所能代表的 ChineseGreeting()和EnglishGreeting()方法的签名：\n```c#\npublic void EnglishGreeting(string name)\npublic void ChineseGreeting(string name)\n```\n如同name可以接受String类型的“true”和“1”，但不能接受bool类型的true和int类型的1一样。MakeGreeting的 参数类型定义 应该能够确定 MakeGreeting可以代表的方法种类，再进一步讲，就是MakeGreeting可以代表的方法 的 参数类型和返回类型。\n于是，委托出现了：它定义了MakeGreeting参数所能代表的方法的种类，也就是MakeGreeting参数的类型。\nNOTE：如果上面这句话比较绕口，我把它翻译成这样：string 定义了name参数所能代表的值的种类，也就是name参数的类型。\n本例中委托的定义：\n```c#\npublic delegate void GreetingDelegate(string name);\n```\n可以与上面EnglishGreeting()方法的签名对比一下，除了加入了delegate关键字以外，其余的是不是完全一样？\n现在，让我们再次改动GreetPeople()方法，如下所示：\n```c#\npublic void GreetPeople(string name, GreetingDelegate MakeGreeting){\n MakeGreeting(name);\n}\n```\n如你所见，委托GreetingDelegate出现的位置与 string相同，string是一个类型，那么GreetingDelegate应该也是一个类型，或者叫类(Class)。但是委托的声明方式和类却完全不同，这是怎么一回事？实际上，委托在编译的时候确实会编译成类。因为Delegate是一个类，所以在任何可以声明类的地方都可以声明委托。更多的内容将在下面讲述，现在，请看看这个范例的完整代码：\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Delegate {\n //定义委托，它定义了可以代表的方法的类型\n public delegate void GreetingDelegate(string name);\n class Program {\n private static void EnglishGreeting(string name) {\n Console.WriteLine(\"Morning, \" + name);\n }\n private static void ChineseGreeting(string name) {\n Console.WriteLine(\"早上好, \" + name);\n }\n //注意此方法，它接受一个GreetingDelegate类型的方法作为参数\n private static void GreetPeople(string name, GreetingDelegate MakeGreeting) {\n MakeGreeting(name);\n }\n static void Main(string[] args) {\n GreetPeople(\"Jimmy Zhang\", EnglishGreeting);\n GreetPeople(\"张子阳\", ChineseGreeting);\n Console.ReadKey();\n }\n }\n }\n```\n输出如下：\n```\nMorning, Jimmy Zhang\n早上好, 张子阳\n```\n我们现在对委托做一个总结：\n委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。\n将方法绑定到委托\n看到这里，是不是有那么点如梦初醒的感觉？于是，你是不是在想：在上面的例子中，我不一定要直接在GreetPeople()方法中给 name参数赋值，我可以像这样使用变量：\n```c#\nstatic void Main(string[] args) {\n string name1, name2;\n name1 = \"Jimmy Zhang\";\n name2 = \"张子阳\";\n GreetPeople(name1, EnglishGreeting);\n GreetPeople(name2, ChineseGreeting);\n Console.ReadKey();\n}\n```\n而既然委托GreetingDelegate 和 类型 string 的地位一样，都是定义了一种参数类型，那么，我是不是也可以这么使用委托？\n```c#\nstatic void Main(string[] args) {\n GreetingDelegate delegate1, delegate2;\n delegate1 = EnglishGreeting;\n delegate2 = ChineseGreeting;\n GreetPeople(\"Jimmy Zhang\", delegate1);\n GreetPeople(\"张子阳\", delegate2);\n Console.ReadKey();\n}\n```\n如你所料，这样是没有问题的，程序一如预料的那样输出。这里，我想说的是委托不同于string的一个特性：可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。在这个例子中，语法如下：\n```c#\nstatic void Main(string[] args) {\n GreetingDelegate delegate1;\n delegate1 = EnglishGreeting; // 先给委托类型的变量赋值\n delegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法\n GreetPeople(\"Jimmy Zhang\", delegate1);\n Console.ReadKey();\n}\n```\n输出为：\n```\nMorning, Jimmy Zhang\n早上好, Jimmy Zhang\n```\n实际上，我们可以也可以绕过GreetPeople方法，通过委托来直接调用EnglishGreeting和ChineseGreeting：\n```c#\nstatic void Main(string[] args) {\n GreetingDelegate delegate1;\n delegate1 = EnglishGreeting; // 先给委托类型的变量赋值\n delegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法\n delegate1 (\"Jimmy Zhang\");\n Console.ReadKey();\n}\n```\n\nNOTE：这在本例中是没有问题的，但回头看下上面GreetPeople()的定义，在它之中可以做一些对于EnglshihGreeting和ChineseGreeting来说都需要进行的工作，为了简便我做了省略。\n注意这里，第一次用的“=”，是赋值的语法；第二次，用的是“+=”，是绑定的语法。如果第一次就使用“+=”，将出现“使用了未赋值的局部变量”的编译错误。\n我们也可以使用下面的代码来这样简化这一过程：\n```c#\nGreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting);\ndelegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n```\n看到这里，应该注意到，这段代码第一条语句与实例化一个类是何其的相似，你不禁想到：上面第一次绑定委托时不可以使用“+=”的编译错误，或许可以用这样的方法来避免：\n```c#\nGreetingDelegate delegate1 = new GreetingDelegate();\ndelegate1 += EnglishGreeting; // 这次用的是 “+=”，绑定语法。\ndelegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n```\n但实际上，这样会出现编译错误： “GreetingDelegate”方法没有采用“0”个参数的重载。尽管这样的结果让我们觉得有点沮丧，但是编译的提示：“没有0个参数的重载”再次让我们联想到了类的构造函数。我知道你一定按捺不住想探个究竟，但再此之前，我们需要先把基础知识和应用介绍完。\n既然给委托可以绑定一个方法，那么也应该有办法取消对方法的绑定，很容易想到，这个语法是“-=”：\n```c#\nstatic void Main(string[] args) {\n GreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting);\n delegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法\n GreetPeople(\"Jimmy Zhang\", delegate1);\n Console.WriteLine();\n delegate1 -= EnglishGreeting; //取消对EnglishGreeting方法的绑定\n // 将仅调用 ChineseGreeting\n GreetPeople(\"张子阳\", delegate1);\n Console.ReadKey();\n}\n```\n输出为：\n```\nMorning, Jimmy Zhang\n早上好, Jimmy Zhang\n早上好, 张子阳\n```\n让我们再次对委托作个总结：\n使用委托可以将多个方法绑定到同一个委托变量，当调用此变量时(这里用“调用”这个词，是因为此变量代表一个方法)，可以依次调用所有绑定的方法。\n事件的由来\n我们继续思考上面的程序：上面的三个方法都定义在Programe类中，这样做是为了理解的方便，实际应用中，通常都是 GreetPeople 在一个类中，ChineseGreeting和 EnglishGreeting 在另外的类中。现在你已经对委托有了初步了解，是时候对上面的例子做个改进了。假设我们将GreetingPeople()放在一个叫GreetingManager的类中，那么新程序应该是这个样子的：\n```c#\nnamespace Delegate {\n //定义委托，它定义了可以代表的方法的类型\n public delegate void GreetingDelegate(string name);\n\n //新建的GreetingManager类\n public class GreetingManager{\n public void GreetPeople(string name, GreetingDelegate MakeGreeting) {\n MakeGreeting(name);\n }\n }\n class Program {\n private static void EnglishGreeting(string name) {\n Console.WriteLine(\"Morning, \" + name);\n }\n private static void ChineseGreeting(string name) {\n Console.WriteLine(\"早上好, \" + name);\n }\n static void Main(string[] args) {\n // ... ...\n }\n }\n}\n```\n这个时候，如果要实现前面演示的输出效果，Main方法我想应该是这样的：\n```c#\nstatic void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.GreetPeople(\"Jimmy Zhang\", EnglishGreeting);\n gm.GreetPeople(\"张子阳\", ChineseGreeting);\n}\n```\n我们运行这段代码，嗯，没有任何问题。程序一如预料地那样输出了：\n```\nMorning, Jimmy Zhang\n早上好, 张子阳\n```\n现在，假设我们需要使用上一节学到的知识，将多个方法绑定到同一个委托变量，该如何做呢？让我们再次改写代码：\n```c#\nstatic void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n GreetingDelegate delegate1;\n delegate1 = EnglishGreeting;\n delegate1 += ChineseGreeting;\n gm.GreetPeople(\"Jimmy Zhang\", delegate1);\n}\n```\n输出：\n````\nMorning, Jimmy Zhang\n早上好, Jimmy Zhang\n```\n到了这里，我们不禁想到：面向对象设计，讲究的是对象的封装，既然可以声明委托类型的变量(在上例中是delegate1)，我们何不将这个变量封装到 GreetManager类中？在这个类的客户端中使用不是更方便么？于是，我们改写GreetManager类，像这样：\n```c#\npublic class GreetingManager{\n //在GreetingManager类的内部声明delegate1变量\n public GreetingDelegate delegate1;\n public void GreetPeople(string name, GreetingDelegate MakeGreeting) {\n MakeGreeting(name);\n }\n}\n```\n现在，我们可以这样使用这个委托变量：\n```c#\nstatic void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.delegate1 = EnglishGreeting;\n gm.delegate1 += ChineseGreeting;\n gm.GreetPeople(\"Jimmy Zhang\", gm.delegate1);\n}\n```\n输出为：\n```c#\nMorning, Jimmy Zhang\n早上好, Jimmy Zhang\n```\n尽管这样做没有任何问题，但我们发现这条语句很奇怪。在调用gm.GreetPeople方法的时候，再次传递了gm的delegate1字段：\n```c#\ngm.GreetPeople(\"Jimmy Zhang\", gm.delegate1);\n```\n既然如此，我们何不修改 GreetingManager 类成这样：\n```c#\npublic class GreetingManager{\n //在GreetingManager类的内部声明delegate1变量\n public GreetingDelegate delegate1;\n public void GreetPeople(string name) {\n if(delegate1!=null){ //如果有方法注册委托变量\n delegate1(name); //通过委托调用方法\n }\n }\n}\n```\n在客户端，调用看上去更简洁一些：\n```c#\nstatic void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.delegate1 = EnglishGreeting;\n gm.delegate1 += ChineseGreeting;\n gm.GreetPeople(\"Jimmy Zhang\"); //注意，这次不需要再传递 delegate1变量\n}\n```\n输出为：\n```\nMorning, Jimmy Zhang\n早上好, Jimmy Zhang\n```\n尽管这样达到了我们要的效果，但是还是存在着问题：\n在这里，delegate1和我们平时用的string类型的变量没有什么分别，而我们知道，并不是所有的字段都应该声明成public，合适的做法是应该public的时候public，应该private的时候private。\n我们先看看如果把 delegate1 声明为 private会怎样？结果就是：这简直就是在搞笑。因为声明委托的目的就是为了把它暴露在类的客户端进行方法的注册，你把它声明为private了，客户端对它根本就不可见，那它还有什么用？\n再看看把delegate1 声明为 public 会怎样？结果就是：在客户端可以对它进行随意的赋值等操作，严重破坏对象的封装性。\n最后，第一个方法注册用“=”，是赋值语法，因为要进行实例化，第二个方法注册则用的是“+=”。但是，不管是赋值还是注册，都是将方法绑定到委托上，除了调用时先后顺序不同，再没有任何的分别，这样不是让人觉得很别扭么？\n现在我们想想，如果delegate1不是一个委托类型，而是一个string类型，你会怎么做？答案是使用属性对字段进行封装。\n于是，Event出场了，它封装了委托类型的变量，使得：在类的内部，不管你声明它是public还是protected，它总是private的。在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同。\n我们改写GreetingManager类，它变成了这个样子：\n```c#\npublic class GreetingManager{\n //这一次我们在这里声明一个事件\n public event GreetingDelegate MakeGreet;\n public void GreetPeople(string name) {\n MakeGreet(name);\n }\n}\n```\n很容易注意到：MakeGreet 事件的声明与之前委托变量delegate1的声明唯一的区别是多了一个event关键字。看到这里，在结合上面的讲解，你应该明白到：事件其实没什么不好理解的，声明一个事件不过类似于声明一个进行了封装的委托类型的变量而已。\n为了证明上面的推论，如果我们像下面这样改写Main方法：\n```c#\nstatic void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.MakeGreet = EnglishGreeting; // 编译错误1\n gm.MakeGreet += ChineseGreeting;\n gm.GreetPeople(\"Jimmy Zhang\");\n}\n```\n会得到编译错误：事件“Delegate.GreetingManager.MakeGreet”只能出现在 += 或 -= 的左边(从类型“Delegate.GreetingManager”中使用时除外)。\n事件和委托的编译代码\n这时候，我们注释掉编译错误的行，然后重新进行编译，再借助Reflactor来对 event的声明语句做一探究，看看为什么会发生这样的错误：\n```c#\npublic event GreetingDelegate MakeGreet;\n ```\n可以看到，实际上尽管我们在GreetingManager里将 MakeGreet 声明为public，但是，实际上MakeGreet会被编译成 私有字段，难怪会发生上面的编译错误了，因为它根本就不允许在GreetingManager类的外面以赋值的方式访问，从而验证了我们上面所做的推论。\n我们再进一步看下MakeGreet所产生的代码：\n```c#\nprivate GreetingDelegate MakeGreet; //对事件的声明 实际是 声明一个私有的委托变量\n\n[MethodImpl(MethodImplOptions.Synchronized)]\npublic void add_MakeGreet(GreetingDelegate value){\n this.MakeGreet = (GreetingDelegate) Delegate.Combine(this.MakeGreet, value);\n}\n[MethodImpl(MethodImplOptions.Synchronized)]\npublic void remove_MakeGreet(GreetingDelegate value){\n this.MakeGreet = (GreetingDelegate) Delegate.Remove(this.MakeGreet, value);\n}\n```\n现在已经很明确了：MakeGreet事件确实是一个GreetingDelegate类型的委托，只不过不管是不是声明为public，它总是被声明为private。另外，它还有两个方法，分别是add_MakeGreet和remove_MakeGreet，这两个方法分别用于注册委托类型的方法和取消注册。实际上也就是： “+= ”对应 add_MakeGreet，“-=”对应remove_MakeGreet。而这两个方法的访问限制取决于声明事件时的访问限制符。\n在add_MakeGreet()方法内部，实际上调用了System.Delegate的Combine()静态方法，这个方法用于将当前的变量添加到委托链表中。我们前面提到过两次，说委托实际上是一个类，在我们定义委托的时候：\n```c#\npublic delegate void GreetingDelegate(string name);\n```\n当编译器遇到这段代码的时候，会生成下面这样一个完整的类：\n```c#\npublic sealed class GreetingDelegate:System.MulticastDelegate{\n public GreetingDelegate(object @object, IntPtr method);\n public virtual IAsyncResult BeginInvoke(string name, AsyncCallback callback, object @object);\n public virtual void EndInvoke(IAsyncResult result);\n public virtual void Invoke(string name);\n}\n```\n\n关于这个类的更深入内容，可以参阅《CLR Via C#》等相关书籍，这里就不再讨论了。\n委托、事件与Observer设计模式\n范例说明\n上面的例子已不足以再进行下面的讲解了，我们来看一个新的范例，因为之前已经介绍了很多的内容，所以本节的进度会稍微快一些：\n假设我们有个高档的热水器，我们给它通上电，当水温超过95度的时候：1、扬声器会开始发出语音，告诉你水的温度；2、液晶屏也会改变水温的显示，来提示水已经快烧开了。\n现在我们需要写个程序来模拟这个烧水的过程，我们将定义一个类来代表热水器，我们管它叫：Heater，它有代表水温的字段，叫做temperature；当然，还有必不可少的给水加热方法BoilWater()，一个发出语音警报的方法MakeAlert()，一个显示水温的方法，ShowMsg()。\n```c#\nnamespace Delegate {\n class Heater {\n private int temperature; // 水温\n // 烧水\n public void BoilWater() {\n for (int i = 0; i <= 100; i++) {\n temperature = i;\n if (temperature > 95) {\n MakeAlert(temperature);\n ShowMsg(temperature);\n }\n }\n }\n // 发出语音警报\n private void MakeAlert(int param) {\n Console.WriteLine(\"Alarm：嘀嘀嘀，水已经 {0} 度了：\" , param);\n }\n\n // 显示水温\n private void ShowMsg(int param) {\n Console.WriteLine(\"Display：水快开了，当前温度：{0}度。\" , param);\n }\n}\nclass Program {\n static void Main() {\n Heater ht = new Heater();\n ht.BoilWater();\n }\n}\n}\n```\nObserver设计模式简介\n上面的例子显然能完成我们之前描述的工作，但是却并不够好。现在假设热水器由三部分组成：热水器、警报器、显示器，它们来自于不同厂商并进行了组装。那么，应该是热水器仅仅负责烧水，它不能发出警报也不能显示水温；在水烧开时由警报器发出警报、显示器显示提示和水温。\n这时候，上面的例子就应该变成这个样子：\n```c#\n// 热水器\npublic class Heater {\n private int temperature;\n\n // 烧水\n private void BoilWater() {\n for (int i = 0; i <= 100; i++) {\n temperature = i;\n }\n }\n}\n// 警报器\npublic class Alarm{\n private void MakeAlert(int param) {\n Console.WriteLine(\"Alarm：嘀嘀嘀，水已经 {0} 度了：\" , param);\n }\n}\n// 显示器\npublic class Display{\n private void ShowMsg(int param) {\n Console.WriteLine(\"Display：水已烧开，当前温度：{0}度。\" , param);\n }\n}\n```\n这里就出现了一个问题：如何在水烧开的时候通知报警器和显示器？在继续进行之前，我们先了解一下Observer设计模式，Observer设计模式中主要包括如下两类对象：\nSubject：监视对象，它往往包含着其他对象所感兴趣的内容。在本范例中，热水器就是一个监视对象，它包含的其他对象所感兴趣的内容，就是temprature字段，当这个字段的值快到100时，会不断把数据发给监视它的对象。\nObserver：监视者，它监视Subject，当Subject中的某件事发生的时候，会告知Observer，而Observer则会采取相应的行动。在本范例中，Observer有警报器和显示器，它们采取的行动分别是发出警报和显示水温。\n在本例中，事情发生的顺序应该是这样的：\n警报器和显示器告诉热水器，它对它的温度比较感兴趣(注册)。\n热水器知道后保留对警报器和显示器的引用。\n热水器进行烧水这一动作，当水温超过95度时，通过对警报器和显示器的引用，自动调用警报器的MakeAlert()方法、显示器的ShowMsg()方法。\n类似这样的例子是很多的，GOF对它进行了抽象，称为Observer设计模式：Observer设计模式是为了定义对象间的一种一对多的依赖关系，以便于当一个对象的状态改变时，其他依赖于它的对象会被自动告知并更新。Observer模式是一种松耦合的设计模式。\n实现范例的Observer设计模式\n我们之前已经对委托和事件介绍很多了，现在写代码应该很容易了，现在在这里直接给出代码，并在注释中加以说明。\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Delegate {\n // 热水器\n public class Heater {\n private int temperature;\n public delegate void BoilHandler(int param); //声明委托\n public event BoilHandler BoilEvent; //声明事件\n // 烧水\n public void BoilWater() {\n for (int i = 0; i <= 100; i++) {\n temperature = i;\n if (temperature > 95) {\n if (BoilEvent != null) { //如果有对象注册\n BoilEvent(temperature); //调用所有注册对象的方法\n }\n }\n }\n }\n }\n // 警报器\n public class Alarm {\n public void MakeAlert(int param) {\n Console.WriteLine(\"Alarm：嘀嘀嘀，水已经 {0} 度了：\", param);\n }\n }\n // 显示器\n public class Display {\n public static void ShowMsg(int param) { //静态方法\n Console.WriteLine(\"Display：水快烧开了，当前温度：{0}度。\", param);\n }\n }\n\n class Program {\n static void Main() {\n Heater heater = new Heater();\n Alarm alarm = new Alarm();\n heater.BoilEvent += alarm.MakeAlert; //注册方法\n heater.BoilEvent += (new Alarm()).MakeAlert; //给匿名对象注册方法\n heater.BoilEvent += Display.ShowMsg; //注册静态方法\n heater.BoilWater(); //烧水，会自动调用注册过对象的方法\n }\n }\n}\n```\n输出为：\n```\nAlarm：嘀嘀嘀，水已经 96 度了：\nAlarm：嘀嘀嘀，水已经 96 度了：\nDisplay：水快烧开了，当前温度：96度。\n// 省略...\n```\n.Net Framework中的委托与事件\n尽管上面的范例很好地完成了我们想要完成的工作，但是我们不仅疑惑：为什么.Net Framework 中的事件模型和上面的不同？为什么有很多的EventArgs参数？\n在回答上面的问题之前，我们先搞懂 .Net Framework的编码规范：\n委托类型的名称都应该以EventHandler结束。\n委托的原型定义：有一个void返回值，并接受两个输入参数：一个Object 类型，一个 EventArgs类型(或继承自EventArgs)。\n事件的命名为 委托去掉 EventHandler之后剩余的部分。\n继承自EventArgs的类型应该以EventArgs结尾。\n再做一下说明：\n委托声明原型中的Object类型的参数代表了Subject，也就是监视对象，在本例中是 Heater(热水器)。回调函数(比如Alarm的MakeAlert)可以通过它访问触发事件的对象(Heater)。\nEventArgs 对象包含了Observer所感兴趣的数据，在本例中是temperature。\n上面这些其实不仅仅是为了编码规范而已，这样也使得程序有更大的灵活性。比如说，如果我们不光想获得热水器的温度，还想在Observer端(警报器或者显示器)方法中获得它的生产日期、型号、价格，那么委托和方法的声明都会变得很麻烦，而如果我们将热水器的引用传给警报器的方法，就可以在方法中直接访问热水器了。\n现在我们改写之前的范例，让它符合 .Net Framework 的规范：\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Delegate {\n // 热水器\n public class Heater {\n private int temperature;\n public string type = \"RealFire 001\"; // 添加型号作为演示\n public string area = \"China Xian\"; // 添加产地作为演示\n //声明委托\n public delegate void BoiledEventHandler(Object sender, BoiledEventArgs e);\n public event BoiledEventHandler Boiled; //声明事件\n // 定义BoiledEventArgs类，传递给Observer所感兴趣的信息\n public class BoiledEventArgs : EventArgs {\n public readonly int temperature;\n public BoiledEventArgs(int temperature) {\n this.temperature = temperature;\n }\n }\n // 可以供继承自 Heater 的类重写，以便继承类拒绝其他对象对它的监视\n protected virtual void OnBoiled(BoiledEventArgs e) {\n if (Boiled != null) { // 如果有对象注册\n Boiled(this, e); // 调用所有注册对象的方法\n }\n }\n\n // 烧水。\n public void BoilWater() {\n for (int i = 0; i <= 100; i++) {\n temperature = i;\n if (temperature > 95) {\n //建立BoiledEventArgs 对象。\n BoiledEventArgs e = new BoiledEventArgs(temperature);\n OnBoiled(e); // 调用 OnBolied方法\n }\n }\n }\n }\n // 警报器\n public class Alarm {\n public void MakeAlert(Object sender, Heater.BoiledEventArgs e) {\n Heater heater = (Heater)sender; //这里是不是很熟悉呢？\n //访问 sender 中的公共字段\n Console.WriteLine(\"Alarm：{0} - {1}: \", heater.area, heater.type);\n Console.WriteLine(\"Alarm: 嘀嘀嘀，水已经 {0} 度了：\", e.temperature);\n Console.WriteLine();\n }\n }\n // 显示器\n public class Display {\n public static void ShowMsg(Object sender, Heater.BoiledEventArgs e) { //静态方法\n Heater heater = (Heater)sender;\n Console.WriteLine(\"Display：{0} - {1}: \", heater.area, heater.type);\n Console.WriteLine(\"Display：水快烧开了，当前温度：{0}度。\", e.temperature);\n Console.WriteLine();\n }\n }\n class Program {\n static void Main() {\n Heater heater = new Heater();\n Alarm alarm = new Alarm();\n heater.Boiled += alarm.MakeAlert; //注册方法\n heater.Boiled += (new Alarm()).MakeAlert; //给匿名对象注册方法\n heater.Boiled += new Heater.BoiledEventHandler(alarm.MakeAlert); //也可以这么注册\n heater.Boiled += Display.ShowMsg; //注册静态方法\n heater.BoilWater(); //烧水，会自动调用注册过对象的方法\n }\n }\n}\n```\n输出为：\n```\nAlarm：China Xian - RealFire 001:\nAlarm: 嘀嘀嘀，水已经 96 度了：\nAlarm：China Xian - RealFire 001:\nAlarm: 嘀嘀嘀，水已经 96 度了：\nAlarm：China Xian - RealFire 001:\nAlarm: 嘀嘀嘀，水已经 96 度了：\nDisplay：China Xian - RealFire 001:\nDisplay：水快烧开了，当前温度：96度。\n// 省略 ...\n```\n总结\n在本文中我首先通过一个GreetingPeople的小程序向大家介绍了委托的概念、委托用来做什么，随后又引出了事件，接着对委托与事件所产生的中间代码做了粗略的讲述。\n在第二个稍微复杂点的热水器的范例中，我向大家简要介绍了 Observer设计模式，并通过实现这个范例完成了该模式，随后讲述了.Net Framework中委托、事件的实现方式。\n希望这篇文章能给你带来帮助。\n>来源：\n>[1]: <http://www.tracefact.net/csharp-programming/delegates-and-events-in-csharp.aspx>\n","slug":"CShape/CShape中的委托和事件","published":1,"updated":"2018-10-02T05:07:59.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4oq005vntnb8i5vx6fd","content":"<h1 id=\"C-中的委托和事件\"><a href=\"#C-中的委托和事件\" class=\"headerlink\" title=\"C# 中的委托和事件\"></a>C# 中的委托和事件</h1><hr>\n<p>委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。</p>\n<h2 id=\"C-中的委托和事件-1\"><a href=\"#C-中的委托和事件-1\" class=\"headerlink\" title=\"C# 中的委托和事件\"></a>C# 中的委托和事件</h2><blockquote>\n<p>引言<br>委托 和 事件在 .Net Framework中的应用非常广泛，然而，较好地理解委托和事件对很多接触C#时间不长的人来说并不容易。它们就像是一道槛儿，过了这个槛的人，觉得真是太容易了，而没有过去的人每次见到委托和事件就觉得心里别（biè）得慌，混身不自在。本文中，我将通过两个范例由浅入深地讲述什么是委托、为什么要使用委托、事件的由来、.Net Framework中的委托和事件、委托和事件对Observer设计模式的意义，对它们的中间代码也做了讨论。<br>将方法作为方法的参数<br>我们先不管这个标题如何的绕口，也不管委托究竟是个什么东西，来看下面这两个最简单的方法，它们不过是在屏幕上输出一句问候的话语：</p>\n<pre><code class=\"c#\">public void GreetPeople(string name) {\n // 做某些额外的事情，比如初始化之类，此处略\n EnglishGreeting(name);\n}\npublic void EnglishGreeting(string name) {\n Console.WriteLine(&quot;Morning, &quot; + name);\n}\n</code></pre>\n<p>暂且不管这两个方法有没有什么实际意义。GreetPeople用于向某人问好，当我们传递代表某人姓名的name参数，比如说“Jimmy”，进去的时候，在这个方法中，将调用EnglishGreeting方法，再次传递name参数，EnglishGreeting则用于向屏幕输出 “Morning, Jimmy”。<br>现在假设这个程序需要进行全球化，哎呀，不好了，我是中国人，我不明白“Morning”是什么意思，怎么办呢？好吧，我们再加个中文版的问候方法：</p>\n<pre><code class=\"c#\">public void ChineseGreeting(string name){\n Console.WriteLine(&quot;早上好, &quot; + name);\n}\n</code></pre>\n<p>这时候，GreetPeople也需要改一改了，不然如何判断到底用哪个版本的Greeting问候方法合适呢？在进行这个之前，我们最好再定义一个枚举作为判断的依据：</p>\n<pre><code class=\"c#\">public enum Language{\n English, Chinese\n}\npublic void GreetPeople(string name, Language lang){\n //做某些额外的事情，比如初始化之类，此处略\n swith(lang){\n case Language.English:\n EnglishGreeting(name);\n break;\n case Language.Chinese:\n ChineseGreeting(name);\n break;\n }\n}\n</code></pre>\n<p>OK，尽管这样解决了问题，但我不说大家也很容易想到，这个解决方案的可扩展性很差，如果日后我们需要再添加韩文版、日文版，就不得不反复修改枚举和GreetPeople()方法，以适应新的需求。<br>在考虑新的解决方案之前，我们先看看 GreetPeople的方法签名：</p>\n<pre><code class=\"c#\">public void GreetPeople(string name, Language lang)\n</code></pre>\n<p>我们仅看 string name，在这里，string 是参数类型，name 是参数变量，当我们赋给name字符串“jimmy”时，它就代表“jimmy”这个值；当我们赋给它“张子阳”时，它又代表着“张子阳”这个值。然后，我们可以在方法体内对这个name进行其他操作。哎，这简直是废话么，刚学程序就知道了。<br>如果你再仔细想想，假如GreetPeople()方法可以接受一个参数变量，这个变量可以代表另一个方法，当我们给这个变量赋值 EnglishGreeting的时候，它代表着 EnglsihGreeting() 这个方法；当我们给它赋值ChineseGreeting 的时候，它又代表着ChineseGreeting()方法。我们将这个参数变量命名为 MakeGreeting，那么不是可以如同给name赋值时一样，在调用 GreetPeople()方法的时候，给这个MakeGreeting 参数也赋上值么(ChineseGreeting或者EnglsihGreeting等)？然后，我们在方法体内，也可以像使用别的参数一样使用MakeGreeting。但是，由于MakeGreeting代表着一个方法，它的使用方式应该和它被赋的方法(比如ChineseGreeting)是一样的，比如：</p>\n<pre><code class=\"c#\">MakeGreeting(name);\n</code></pre>\n<p>好了，有了思路了，我们现在就来改改GreetPeople()方法，那么它应该是这个样子了：</p>\n<pre><code class=\"c#\">public void GreetPeople(string name, *** MakeGreeting){\n MakeGreeting(name);\n}\n</code></pre>\n<p>注意到 *** ，这个位置通常放置的应该是参数的类型，但到目前为止，我们仅仅是想到应该有个可以代表方法的参数，并按这个思路去改写GreetPeople方法，现在就出现了一个大问题：这个代表着方法的MakeGreeting参数应该是什么类型的？<br>NOTE：这里已不再需要枚举了，因为在给MakeGreeting赋值的时候动态地决定使用哪个方法，是ChineseGreeting还是 EnglishGreeting，而在这个两个方法内部，已经对使用“morning”还是“早上好”作了区分。<br>聪明的你应该已经想到了，现在是委托该出场的时候了，但讲述委托之前，我们再看看MakeGreeting参数所能代表的 ChineseGreeting()和EnglishGreeting()方法的签名：</p>\n<pre><code class=\"c#\">public void EnglishGreeting(string name)\npublic void ChineseGreeting(string name)\n</code></pre>\n<p>如同name可以接受String类型的“true”和“1”，但不能接受bool类型的true和int类型的1一样。MakeGreeting的 参数类型定义 应该能够确定 MakeGreeting可以代表的方法种类，再进一步讲，就是MakeGreeting可以代表的方法 的 参数类型和返回类型。<br>于是，委托出现了：它定义了MakeGreeting参数所能代表的方法的种类，也就是MakeGreeting参数的类型。<br>NOTE：如果上面这句话比较绕口，我把它翻译成这样：string 定义了name参数所能代表的值的种类，也就是name参数的类型。<br>本例中委托的定义：</p>\n<pre><code class=\"c#\">public delegate void GreetingDelegate(string name);\n</code></pre>\n<p>可以与上面EnglishGreeting()方法的签名对比一下，除了加入了delegate关键字以外，其余的是不是完全一样？<br>现在，让我们再次改动GreetPeople()方法，如下所示：</p>\n<pre><code class=\"c#\">public void GreetPeople(string name, GreetingDelegate MakeGreeting){\n MakeGreeting(name);\n}\n</code></pre>\n<p>如你所见，委托GreetingDelegate出现的位置与 string相同，string是一个类型，那么GreetingDelegate应该也是一个类型，或者叫类(Class)。但是委托的声明方式和类却完全不同，这是怎么一回事？实际上，委托在编译的时候确实会编译成类。因为Delegate是一个类，所以在任何可以声明类的地方都可以声明委托。更多的内容将在下面讲述，现在，请看看这个范例的完整代码：</p>\n<pre><code class=\"c#\">using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Delegate {\n //定义委托，它定义了可以代表的方法的类型\n public delegate void GreetingDelegate(string name);\n class Program {\n private static void EnglishGreeting(string name) {\n Console.WriteLine(&quot;Morning, &quot; + name);\n }\n private static void ChineseGreeting(string name) {\n Console.WriteLine(&quot;早上好, &quot; + name);\n }\n //注意此方法，它接受一个GreetingDelegate类型的方法作为参数\n private static void GreetPeople(string name, GreetingDelegate MakeGreeting) {\n MakeGreeting(name);\n }\n static void Main(string[] args) {\n GreetPeople(&quot;Jimmy Zhang&quot;, EnglishGreeting);\n GreetPeople(&quot;张子阳&quot;, ChineseGreeting);\n Console.ReadKey();\n }\n }\n }\n</code></pre>\n<p>输出如下：</p>\n<pre><code>Morning, Jimmy Zhang\n早上好, 张子阳\n</code></pre><p>我们现在对委托做一个总结：<br>委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。<br>将方法绑定到委托<br>看到这里，是不是有那么点如梦初醒的感觉？于是，你是不是在想：在上面的例子中，我不一定要直接在GreetPeople()方法中给 name参数赋值，我可以像这样使用变量：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n string name1, name2;\n name1 = &quot;Jimmy Zhang&quot;;\n name2 = &quot;张子阳&quot;;\n GreetPeople(name1, EnglishGreeting);\n GreetPeople(name2, ChineseGreeting);\n Console.ReadKey();\n}\n</code></pre>\n<p>而既然委托GreetingDelegate 和 类型 string 的地位一样，都是定义了一种参数类型，那么，我是不是也可以这么使用委托？</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingDelegate delegate1, delegate2;\n delegate1 = EnglishGreeting;\n delegate2 = ChineseGreeting;\n GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);\n GreetPeople(&quot;张子阳&quot;, delegate2);\n Console.ReadKey();\n}\n</code></pre>\n<p>如你所料，这样是没有问题的，程序一如预料的那样输出。这里，我想说的是委托不同于string的一个特性：可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。在这个例子中，语法如下：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingDelegate delegate1;\n delegate1 = EnglishGreeting; // 先给委托类型的变量赋值\n delegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法\n GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);\n Console.ReadKey();\n}\n</code></pre>\n<p>输出为：</p>\n<pre><code>Morning, Jimmy Zhang\n早上好, Jimmy Zhang\n</code></pre><p>实际上，我们可以也可以绕过GreetPeople方法，通过委托来直接调用EnglishGreeting和ChineseGreeting：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingDelegate delegate1;\n delegate1 = EnglishGreeting; // 先给委托类型的变量赋值\n delegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法\n delegate1 (&quot;Jimmy Zhang&quot;);\n Console.ReadKey();\n}\n</code></pre>\n</blockquote>\n<p>NOTE：这在本例中是没有问题的，但回头看下上面GreetPeople()的定义，在它之中可以做一些对于EnglshihGreeting和ChineseGreeting来说都需要进行的工作，为了简便我做了省略。<br>注意这里，第一次用的“=”，是赋值的语法；第二次，用的是“+=”，是绑定的语法。如果第一次就使用“+=”，将出现“使用了未赋值的局部变量”的编译错误。<br>我们也可以使用下面的代码来这样简化这一过程：</p>\n<pre><code class=\"c#\">GreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting);\ndelegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n</code></pre>\n<p>看到这里，应该注意到，这段代码第一条语句与实例化一个类是何其的相似，你不禁想到：上面第一次绑定委托时不可以使用“+=”的编译错误，或许可以用这样的方法来避免：</p>\n<pre><code class=\"c#\">GreetingDelegate delegate1 = new GreetingDelegate();\ndelegate1 += EnglishGreeting; // 这次用的是 “+=”，绑定语法。\ndelegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n</code></pre>\n<p>但实际上，这样会出现编译错误： “GreetingDelegate”方法没有采用“0”个参数的重载。尽管这样的结果让我们觉得有点沮丧，但是编译的提示：“没有0个参数的重载”再次让我们联想到了类的构造函数。我知道你一定按捺不住想探个究竟，但再此之前，我们需要先把基础知识和应用介绍完。<br>既然给委托可以绑定一个方法，那么也应该有办法取消对方法的绑定，很容易想到，这个语法是“-=”：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting);\n delegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法\n GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);\n Console.WriteLine();\n delegate1 -= EnglishGreeting; //取消对EnglishGreeting方法的绑定\n // 将仅调用 ChineseGreeting\n GreetPeople(&quot;张子阳&quot;, delegate1);\n Console.ReadKey();\n}\n</code></pre>\n<p>输出为：</p>\n<pre><code>Morning, Jimmy Zhang\n早上好, Jimmy Zhang\n早上好, 张子阳\n</code></pre><p>让我们再次对委托作个总结：<br>使用委托可以将多个方法绑定到同一个委托变量，当调用此变量时(这里用“调用”这个词，是因为此变量代表一个方法)，可以依次调用所有绑定的方法。<br>事件的由来<br>我们继续思考上面的程序：上面的三个方法都定义在Programe类中，这样做是为了理解的方便，实际应用中，通常都是 GreetPeople 在一个类中，ChineseGreeting和 EnglishGreeting 在另外的类中。现在你已经对委托有了初步了解，是时候对上面的例子做个改进了。假设我们将GreetingPeople()放在一个叫GreetingManager的类中，那么新程序应该是这个样子的：</p>\n<pre><code class=\"c#\">namespace Delegate {\n //定义委托，它定义了可以代表的方法的类型\n public delegate void GreetingDelegate(string name);\n\n //新建的GreetingManager类\n public class GreetingManager{\n public void GreetPeople(string name, GreetingDelegate MakeGreeting) {\n MakeGreeting(name);\n }\n }\n class Program {\n private static void EnglishGreeting(string name) {\n Console.WriteLine(&quot;Morning, &quot; + name);\n }\n private static void ChineseGreeting(string name) {\n Console.WriteLine(&quot;早上好, &quot; + name);\n }\n static void Main(string[] args) {\n // ... ...\n }\n }\n}\n</code></pre>\n<p>这个时候，如果要实现前面演示的输出效果，Main方法我想应该是这样的：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.GreetPeople(&quot;Jimmy Zhang&quot;, EnglishGreeting);\n gm.GreetPeople(&quot;张子阳&quot;, ChineseGreeting);\n}\n</code></pre>\n<p>我们运行这段代码，嗯，没有任何问题。程序一如预料地那样输出了：</p>\n<pre><code>Morning, Jimmy Zhang\n早上好, 张子阳\n</code></pre><p>现在，假设我们需要使用上一节学到的知识，将多个方法绑定到同一个委托变量，该如何做呢？让我们再次改写代码：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n GreetingDelegate delegate1;\n delegate1 = EnglishGreeting;\n delegate1 += ChineseGreeting;\n gm.GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);\n}\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"`\">Morning, Jimmy Zhang\n早上好, Jimmy Zhang\n</code></pre>\n<p>到了这里，我们不禁想到：面向对象设计，讲究的是对象的封装，既然可以声明委托类型的变量(在上例中是delegate1)，我们何不将这个变量封装到 GreetManager类中？在这个类的客户端中使用不是更方便么？于是，我们改写GreetManager类，像这样：</p>\n<pre><code class=\"c#\">public class GreetingManager{\n //在GreetingManager类的内部声明delegate1变量\n public GreetingDelegate delegate1;\n public void GreetPeople(string name, GreetingDelegate MakeGreeting) {\n MakeGreeting(name);\n }\n}\n</code></pre>\n<p>现在，我们可以这样使用这个委托变量：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.delegate1 = EnglishGreeting;\n gm.delegate1 += ChineseGreeting;\n gm.GreetPeople(&quot;Jimmy Zhang&quot;, gm.delegate1);\n}\n</code></pre>\n<p>输出为：</p>\n<pre><code class=\"c#\">Morning, Jimmy Zhang\n早上好, Jimmy Zhang\n</code></pre>\n<p>尽管这样做没有任何问题，但我们发现这条语句很奇怪。在调用gm.GreetPeople方法的时候，再次传递了gm的delegate1字段：</p>\n<pre><code class=\"c#\">gm.GreetPeople(&quot;Jimmy Zhang&quot;, gm.delegate1);\n</code></pre>\n<p>既然如此，我们何不修改 GreetingManager 类成这样：</p>\n<pre><code class=\"c#\">public class GreetingManager{\n //在GreetingManager类的内部声明delegate1变量\n public GreetingDelegate delegate1;\n public void GreetPeople(string name) {\n if(delegate1!=null){ //如果有方法注册委托变量\n delegate1(name); //通过委托调用方法\n }\n }\n}\n</code></pre>\n<p>在客户端，调用看上去更简洁一些：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.delegate1 = EnglishGreeting;\n gm.delegate1 += ChineseGreeting;\n gm.GreetPeople(&quot;Jimmy Zhang&quot;); //注意，这次不需要再传递 delegate1变量\n}\n</code></pre>\n<p>输出为：</p>\n<pre><code>Morning, Jimmy Zhang\n早上好, Jimmy Zhang\n</code></pre><p>尽管这样达到了我们要的效果，但是还是存在着问题：<br>在这里，delegate1和我们平时用的string类型的变量没有什么分别，而我们知道，并不是所有的字段都应该声明成public，合适的做法是应该public的时候public，应该private的时候private。<br>我们先看看如果把 delegate1 声明为 private会怎样？结果就是：这简直就是在搞笑。因为声明委托的目的就是为了把它暴露在类的客户端进行方法的注册，你把它声明为private了，客户端对它根本就不可见，那它还有什么用？<br>再看看把delegate1 声明为 public 会怎样？结果就是：在客户端可以对它进行随意的赋值等操作，严重破坏对象的封装性。<br>最后，第一个方法注册用“=”，是赋值语法，因为要进行实例化，第二个方法注册则用的是“+=”。但是，不管是赋值还是注册，都是将方法绑定到委托上，除了调用时先后顺序不同，再没有任何的分别，这样不是让人觉得很别扭么？<br>现在我们想想，如果delegate1不是一个委托类型，而是一个string类型，你会怎么做？答案是使用属性对字段进行封装。<br>于是，Event出场了，它封装了委托类型的变量，使得：在类的内部，不管你声明它是public还是protected，它总是private的。在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同。<br>我们改写GreetingManager类，它变成了这个样子：</p>\n<pre><code class=\"c#\">public class GreetingManager{\n //这一次我们在这里声明一个事件\n public event GreetingDelegate MakeGreet;\n public void GreetPeople(string name) {\n MakeGreet(name);\n }\n}\n</code></pre>\n<p>很容易注意到：MakeGreet 事件的声明与之前委托变量delegate1的声明唯一的区别是多了一个event关键字。看到这里，在结合上面的讲解，你应该明白到：事件其实没什么不好理解的，声明一个事件不过类似于声明一个进行了封装的委托类型的变量而已。<br>为了证明上面的推论，如果我们像下面这样改写Main方法：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.MakeGreet = EnglishGreeting; // 编译错误1\n gm.MakeGreet += ChineseGreeting;\n gm.GreetPeople(&quot;Jimmy Zhang&quot;);\n}\n</code></pre>\n<p>会得到编译错误：事件“Delegate.GreetingManager.MakeGreet”只能出现在 += 或 -= 的左边(从类型“Delegate.GreetingManager”中使用时除外)。<br>事件和委托的编译代码<br>这时候，我们注释掉编译错误的行，然后重新进行编译，再借助Reflactor来对 event的声明语句做一探究，看看为什么会发生这样的错误：</p>\n<pre><code class=\"c#\">public event GreetingDelegate MakeGreet;\n</code></pre>\n<p>可以看到，实际上尽管我们在GreetingManager里将 MakeGreet 声明为public，但是，实际上MakeGreet会被编译成 私有字段，难怪会发生上面的编译错误了，因为它根本就不允许在GreetingManager类的外面以赋值的方式访问，从而验证了我们上面所做的推论。<br>我们再进一步看下MakeGreet所产生的代码：</p>\n<pre><code class=\"c#\">private GreetingDelegate MakeGreet; //对事件的声明 实际是 声明一个私有的委托变量\n\n[MethodImpl(MethodImplOptions.Synchronized)]\npublic void add_MakeGreet(GreetingDelegate value){\n this.MakeGreet = (GreetingDelegate) Delegate.Combine(this.MakeGreet, value);\n}\n[MethodImpl(MethodImplOptions.Synchronized)]\npublic void remove_MakeGreet(GreetingDelegate value){\n this.MakeGreet = (GreetingDelegate) Delegate.Remove(this.MakeGreet, value);\n}\n</code></pre>\n<p>现在已经很明确了：MakeGreet事件确实是一个GreetingDelegate类型的委托，只不过不管是不是声明为public，它总是被声明为private。另外，它还有两个方法，分别是add_MakeGreet和remove_MakeGreet，这两个方法分别用于注册委托类型的方法和取消注册。实际上也就是： “+= ”对应 add_MakeGreet，“-=”对应remove_MakeGreet。而这两个方法的访问限制取决于声明事件时的访问限制符。<br>在add_MakeGreet()方法内部，实际上调用了System.Delegate的Combine()静态方法，这个方法用于将当前的变量添加到委托链表中。我们前面提到过两次，说委托实际上是一个类，在我们定义委托的时候：</p>\n<pre><code class=\"c#\">public delegate void GreetingDelegate(string name);\n</code></pre>\n<p>当编译器遇到这段代码的时候，会生成下面这样一个完整的类：</p>\n<pre><code class=\"c#\">public sealed class GreetingDelegate:System.MulticastDelegate{\n public GreetingDelegate(object @object, IntPtr method);\n public virtual IAsyncResult BeginInvoke(string name, AsyncCallback callback, object @object);\n public virtual void EndInvoke(IAsyncResult result);\n public virtual void Invoke(string name);\n}\n</code></pre>\n<p>关于这个类的更深入内容，可以参阅《CLR Via C#》等相关书籍，这里就不再讨论了。<br>委托、事件与Observer设计模式<br>范例说明<br>上面的例子已不足以再进行下面的讲解了，我们来看一个新的范例，因为之前已经介绍了很多的内容，所以本节的进度会稍微快一些：<br>假设我们有个高档的热水器，我们给它通上电，当水温超过95度的时候：1、扬声器会开始发出语音，告诉你水的温度；2、液晶屏也会改变水温的显示，来提示水已经快烧开了。<br>现在我们需要写个程序来模拟这个烧水的过程，我们将定义一个类来代表热水器，我们管它叫：Heater，它有代表水温的字段，叫做temperature；当然，还有必不可少的给水加热方法BoilWater()，一个发出语音警报的方法MakeAlert()，一个显示水温的方法，ShowMsg()。</p>\n<pre><code class=\"c#\">namespace Delegate {\n class Heater {\n private int temperature; // 水温\n // 烧水\n public void BoilWater() {\n for (int i = 0; i &lt;= 100; i++) {\n temperature = i;\n if (temperature &gt; 95) {\n MakeAlert(temperature);\n ShowMsg(temperature);\n }\n }\n }\n // 发出语音警报\n private void MakeAlert(int param) {\n Console.WriteLine(&quot;Alarm：嘀嘀嘀，水已经 {0} 度了：&quot; , param);\n }\n\n // 显示水温\n private void ShowMsg(int param) {\n Console.WriteLine(&quot;Display：水快开了，当前温度：{0}度。&quot; , param);\n }\n}\nclass Program {\n static void Main() {\n Heater ht = new Heater();\n ht.BoilWater();\n }\n}\n}\n</code></pre>\n<p>Observer设计模式简介<br>上面的例子显然能完成我们之前描述的工作，但是却并不够好。现在假设热水器由三部分组成：热水器、警报器、显示器，它们来自于不同厂商并进行了组装。那么，应该是热水器仅仅负责烧水，它不能发出警报也不能显示水温；在水烧开时由警报器发出警报、显示器显示提示和水温。<br>这时候，上面的例子就应该变成这个样子：</p>\n<pre><code class=\"c#\">// 热水器\npublic class Heater {\n private int temperature;\n\n // 烧水\n private void BoilWater() {\n for (int i = 0; i &lt;= 100; i++) {\n temperature = i;\n }\n }\n}\n// 警报器\npublic class Alarm{\n private void MakeAlert(int param) {\n Console.WriteLine(&quot;Alarm：嘀嘀嘀，水已经 {0} 度了：&quot; , param);\n }\n}\n// 显示器\npublic class Display{\n private void ShowMsg(int param) {\n Console.WriteLine(&quot;Display：水已烧开，当前温度：{0}度。&quot; , param);\n }\n}\n</code></pre>\n<p>这里就出现了一个问题：如何在水烧开的时候通知报警器和显示器？在继续进行之前，我们先了解一下Observer设计模式，Observer设计模式中主要包括如下两类对象：<br>Subject：监视对象，它往往包含着其他对象所感兴趣的内容。在本范例中，热水器就是一个监视对象，它包含的其他对象所感兴趣的内容，就是temprature字段，当这个字段的值快到100时，会不断把数据发给监视它的对象。<br>Observer：监视者，它监视Subject，当Subject中的某件事发生的时候，会告知Observer，而Observer则会采取相应的行动。在本范例中，Observer有警报器和显示器，它们采取的行动分别是发出警报和显示水温。<br>在本例中，事情发生的顺序应该是这样的：<br>警报器和显示器告诉热水器，它对它的温度比较感兴趣(注册)。<br>热水器知道后保留对警报器和显示器的引用。<br>热水器进行烧水这一动作，当水温超过95度时，通过对警报器和显示器的引用，自动调用警报器的MakeAlert()方法、显示器的ShowMsg()方法。<br>类似这样的例子是很多的，GOF对它进行了抽象，称为Observer设计模式：Observer设计模式是为了定义对象间的一种一对多的依赖关系，以便于当一个对象的状态改变时，其他依赖于它的对象会被自动告知并更新。Observer模式是一种松耦合的设计模式。<br>实现范例的Observer设计模式<br>我们之前已经对委托和事件介绍很多了，现在写代码应该很容易了，现在在这里直接给出代码，并在注释中加以说明。</p>\n<pre><code class=\"c#\">using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Delegate {\n // 热水器\n public class Heater {\n private int temperature;\n public delegate void BoilHandler(int param); //声明委托\n public event BoilHandler BoilEvent; //声明事件\n // 烧水\n public void BoilWater() {\n for (int i = 0; i &lt;= 100; i++) {\n temperature = i;\n if (temperature &gt; 95) {\n if (BoilEvent != null) { //如果有对象注册\n BoilEvent(temperature); //调用所有注册对象的方法\n }\n }\n }\n }\n }\n // 警报器\n public class Alarm {\n public void MakeAlert(int param) {\n Console.WriteLine(&quot;Alarm：嘀嘀嘀，水已经 {0} 度了：&quot;, param);\n }\n }\n // 显示器\n public class Display {\n public static void ShowMsg(int param) { //静态方法\n Console.WriteLine(&quot;Display：水快烧开了，当前温度：{0}度。&quot;, param);\n }\n }\n\n class Program {\n static void Main() {\n Heater heater = new Heater();\n Alarm alarm = new Alarm();\n heater.BoilEvent += alarm.MakeAlert; //注册方法\n heater.BoilEvent += (new Alarm()).MakeAlert; //给匿名对象注册方法\n heater.BoilEvent += Display.ShowMsg; //注册静态方法\n heater.BoilWater(); //烧水，会自动调用注册过对象的方法\n }\n }\n}\n</code></pre>\n<p>输出为：</p>\n<pre><code>Alarm：嘀嘀嘀，水已经 96 度了：\nAlarm：嘀嘀嘀，水已经 96 度了：\nDisplay：水快烧开了，当前温度：96度。\n// 省略...\n</code></pre><p>.Net Framework中的委托与事件<br>尽管上面的范例很好地完成了我们想要完成的工作，但是我们不仅疑惑：为什么.Net Framework 中的事件模型和上面的不同？为什么有很多的EventArgs参数？<br>在回答上面的问题之前，我们先搞懂 .Net Framework的编码规范：<br>委托类型的名称都应该以EventHandler结束。<br>委托的原型定义：有一个void返回值，并接受两个输入参数：一个Object 类型，一个 EventArgs类型(或继承自EventArgs)。<br>事件的命名为 委托去掉 EventHandler之后剩余的部分。<br>继承自EventArgs的类型应该以EventArgs结尾。<br>再做一下说明：<br>委托声明原型中的Object类型的参数代表了Subject，也就是监视对象，在本例中是 Heater(热水器)。回调函数(比如Alarm的MakeAlert)可以通过它访问触发事件的对象(Heater)。<br>EventArgs 对象包含了Observer所感兴趣的数据，在本例中是temperature。<br>上面这些其实不仅仅是为了编码规范而已，这样也使得程序有更大的灵活性。比如说，如果我们不光想获得热水器的温度，还想在Observer端(警报器或者显示器)方法中获得它的生产日期、型号、价格，那么委托和方法的声明都会变得很麻烦，而如果我们将热水器的引用传给警报器的方法，就可以在方法中直接访问热水器了。<br>现在我们改写之前的范例，让它符合 .Net Framework 的规范：</p>\n<pre><code class=\"c#\">using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Delegate {\n // 热水器\n public class Heater {\n private int temperature;\n public string type = &quot;RealFire 001&quot;; // 添加型号作为演示\n public string area = &quot;China Xian&quot;; // 添加产地作为演示\n //声明委托\n public delegate void BoiledEventHandler(Object sender, BoiledEventArgs e);\n public event BoiledEventHandler Boiled; //声明事件\n // 定义BoiledEventArgs类，传递给Observer所感兴趣的信息\n public class BoiledEventArgs : EventArgs {\n public readonly int temperature;\n public BoiledEventArgs(int temperature) {\n this.temperature = temperature;\n }\n }\n // 可以供继承自 Heater 的类重写，以便继承类拒绝其他对象对它的监视\n protected virtual void OnBoiled(BoiledEventArgs e) {\n if (Boiled != null) { // 如果有对象注册\n Boiled(this, e); // 调用所有注册对象的方法\n }\n }\n\n // 烧水。\n public void BoilWater() {\n for (int i = 0; i &lt;= 100; i++) {\n temperature = i;\n if (temperature &gt; 95) {\n //建立BoiledEventArgs 对象。\n BoiledEventArgs e = new BoiledEventArgs(temperature);\n OnBoiled(e); // 调用 OnBolied方法\n }\n }\n }\n }\n // 警报器\n public class Alarm {\n public void MakeAlert(Object sender, Heater.BoiledEventArgs e) {\n Heater heater = (Heater)sender; //这里是不是很熟悉呢？\n //访问 sender 中的公共字段\n Console.WriteLine(&quot;Alarm：{0} - {1}: &quot;, heater.area, heater.type);\n Console.WriteLine(&quot;Alarm: 嘀嘀嘀，水已经 {0} 度了：&quot;, e.temperature);\n Console.WriteLine();\n }\n }\n // 显示器\n public class Display {\n public static void ShowMsg(Object sender, Heater.BoiledEventArgs e) { //静态方法\n Heater heater = (Heater)sender;\n Console.WriteLine(&quot;Display：{0} - {1}: &quot;, heater.area, heater.type);\n Console.WriteLine(&quot;Display：水快烧开了，当前温度：{0}度。&quot;, e.temperature);\n Console.WriteLine();\n }\n }\n class Program {\n static void Main() {\n Heater heater = new Heater();\n Alarm alarm = new Alarm();\n heater.Boiled += alarm.MakeAlert; //注册方法\n heater.Boiled += (new Alarm()).MakeAlert; //给匿名对象注册方法\n heater.Boiled += new Heater.BoiledEventHandler(alarm.MakeAlert); //也可以这么注册\n heater.Boiled += Display.ShowMsg; //注册静态方法\n heater.BoilWater(); //烧水，会自动调用注册过对象的方法\n }\n }\n}\n</code></pre>\n<p>输出为：</p>\n<pre><code>Alarm：China Xian - RealFire 001:\nAlarm: 嘀嘀嘀，水已经 96 度了：\nAlarm：China Xian - RealFire 001:\nAlarm: 嘀嘀嘀，水已经 96 度了：\nAlarm：China Xian - RealFire 001:\nAlarm: 嘀嘀嘀，水已经 96 度了：\nDisplay：China Xian - RealFire 001:\nDisplay：水快烧开了，当前温度：96度。\n// 省略 ...\n</code></pre><p>总结<br>在本文中我首先通过一个GreetingPeople的小程序向大家介绍了委托的概念、委托用来做什么，随后又引出了事件，接着对委托与事件所产生的中间代码做了粗略的讲述。<br>在第二个稍微复杂点的热水器的范例中，我向大家简要介绍了 Observer设计模式，并通过实现这个范例完成了该模式，随后讲述了.Net Framework中委托、事件的实现方式。<br>希望这篇文章能给你带来帮助。</p>\n<blockquote>\n<p>来源：<br>[1]: <a href=\"http://www.tracefact.net/csharp-programming/delegates-and-events-in-csharp.aspx\" target=\"_blank\" rel=\"noopener\">http://www.tracefact.net/csharp-programming/delegates-and-events-in-csharp.aspx</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C-中的委托和事件\"><a href=\"#C-中的委托和事件\" class=\"headerlink\" title=\"C# 中的委托和事件\"></a>C# 中的委托和事件</h1><hr>\n<p>委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。</p>\n<h2 id=\"C-中的委托和事件-1\"><a href=\"#C-中的委托和事件-1\" class=\"headerlink\" title=\"C# 中的委托和事件\"></a>C# 中的委托和事件</h2><blockquote>\n<p>引言<br>委托 和 事件在 .Net Framework中的应用非常广泛，然而，较好地理解委托和事件对很多接触C#时间不长的人来说并不容易。它们就像是一道槛儿，过了这个槛的人，觉得真是太容易了，而没有过去的人每次见到委托和事件就觉得心里别（biè）得慌，混身不自在。本文中，我将通过两个范例由浅入深地讲述什么是委托、为什么要使用委托、事件的由来、.Net Framework中的委托和事件、委托和事件对Observer设计模式的意义，对它们的中间代码也做了讨论。<br>将方法作为方法的参数<br>我们先不管这个标题如何的绕口，也不管委托究竟是个什么东西，来看下面这两个最简单的方法，它们不过是在屏幕上输出一句问候的话语：</p>\n<pre><code class=\"c#\">public void GreetPeople(string name) {\n // 做某些额外的事情，比如初始化之类，此处略\n EnglishGreeting(name);\n}\npublic void EnglishGreeting(string name) {\n Console.WriteLine(&quot;Morning, &quot; + name);\n}\n</code></pre>\n<p>暂且不管这两个方法有没有什么实际意义。GreetPeople用于向某人问好，当我们传递代表某人姓名的name参数，比如说“Jimmy”，进去的时候，在这个方法中，将调用EnglishGreeting方法，再次传递name参数，EnglishGreeting则用于向屏幕输出 “Morning, Jimmy”。<br>现在假设这个程序需要进行全球化，哎呀，不好了，我是中国人，我不明白“Morning”是什么意思，怎么办呢？好吧，我们再加个中文版的问候方法：</p>\n<pre><code class=\"c#\">public void ChineseGreeting(string name){\n Console.WriteLine(&quot;早上好, &quot; + name);\n}\n</code></pre>\n<p>这时候，GreetPeople也需要改一改了，不然如何判断到底用哪个版本的Greeting问候方法合适呢？在进行这个之前，我们最好再定义一个枚举作为判断的依据：</p>\n<pre><code class=\"c#\">public enum Language{\n English, Chinese\n}\npublic void GreetPeople(string name, Language lang){\n //做某些额外的事情，比如初始化之类，此处略\n swith(lang){\n case Language.English:\n EnglishGreeting(name);\n break;\n case Language.Chinese:\n ChineseGreeting(name);\n break;\n }\n}\n</code></pre>\n<p>OK，尽管这样解决了问题，但我不说大家也很容易想到，这个解决方案的可扩展性很差，如果日后我们需要再添加韩文版、日文版，就不得不反复修改枚举和GreetPeople()方法，以适应新的需求。<br>在考虑新的解决方案之前，我们先看看 GreetPeople的方法签名：</p>\n<pre><code class=\"c#\">public void GreetPeople(string name, Language lang)\n</code></pre>\n<p>我们仅看 string name，在这里，string 是参数类型，name 是参数变量，当我们赋给name字符串“jimmy”时，它就代表“jimmy”这个值；当我们赋给它“张子阳”时，它又代表着“张子阳”这个值。然后，我们可以在方法体内对这个name进行其他操作。哎，这简直是废话么，刚学程序就知道了。<br>如果你再仔细想想，假如GreetPeople()方法可以接受一个参数变量，这个变量可以代表另一个方法，当我们给这个变量赋值 EnglishGreeting的时候，它代表着 EnglsihGreeting() 这个方法；当我们给它赋值ChineseGreeting 的时候，它又代表着ChineseGreeting()方法。我们将这个参数变量命名为 MakeGreeting，那么不是可以如同给name赋值时一样，在调用 GreetPeople()方法的时候，给这个MakeGreeting 参数也赋上值么(ChineseGreeting或者EnglsihGreeting等)？然后，我们在方法体内，也可以像使用别的参数一样使用MakeGreeting。但是，由于MakeGreeting代表着一个方法，它的使用方式应该和它被赋的方法(比如ChineseGreeting)是一样的，比如：</p>\n<pre><code class=\"c#\">MakeGreeting(name);\n</code></pre>\n<p>好了，有了思路了，我们现在就来改改GreetPeople()方法，那么它应该是这个样子了：</p>\n<pre><code class=\"c#\">public void GreetPeople(string name, *** MakeGreeting){\n MakeGreeting(name);\n}\n</code></pre>\n<p>注意到 *** ，这个位置通常放置的应该是参数的类型，但到目前为止，我们仅仅是想到应该有个可以代表方法的参数，并按这个思路去改写GreetPeople方法，现在就出现了一个大问题：这个代表着方法的MakeGreeting参数应该是什么类型的？<br>NOTE：这里已不再需要枚举了，因为在给MakeGreeting赋值的时候动态地决定使用哪个方法，是ChineseGreeting还是 EnglishGreeting，而在这个两个方法内部，已经对使用“morning”还是“早上好”作了区分。<br>聪明的你应该已经想到了，现在是委托该出场的时候了，但讲述委托之前，我们再看看MakeGreeting参数所能代表的 ChineseGreeting()和EnglishGreeting()方法的签名：</p>\n<pre><code class=\"c#\">public void EnglishGreeting(string name)\npublic void ChineseGreeting(string name)\n</code></pre>\n<p>如同name可以接受String类型的“true”和“1”，但不能接受bool类型的true和int类型的1一样。MakeGreeting的 参数类型定义 应该能够确定 MakeGreeting可以代表的方法种类，再进一步讲，就是MakeGreeting可以代表的方法 的 参数类型和返回类型。<br>于是，委托出现了：它定义了MakeGreeting参数所能代表的方法的种类，也就是MakeGreeting参数的类型。<br>NOTE：如果上面这句话比较绕口，我把它翻译成这样：string 定义了name参数所能代表的值的种类，也就是name参数的类型。<br>本例中委托的定义：</p>\n<pre><code class=\"c#\">public delegate void GreetingDelegate(string name);\n</code></pre>\n<p>可以与上面EnglishGreeting()方法的签名对比一下，除了加入了delegate关键字以外，其余的是不是完全一样？<br>现在，让我们再次改动GreetPeople()方法，如下所示：</p>\n<pre><code class=\"c#\">public void GreetPeople(string name, GreetingDelegate MakeGreeting){\n MakeGreeting(name);\n}\n</code></pre>\n<p>如你所见，委托GreetingDelegate出现的位置与 string相同，string是一个类型，那么GreetingDelegate应该也是一个类型，或者叫类(Class)。但是委托的声明方式和类却完全不同，这是怎么一回事？实际上，委托在编译的时候确实会编译成类。因为Delegate是一个类，所以在任何可以声明类的地方都可以声明委托。更多的内容将在下面讲述，现在，请看看这个范例的完整代码：</p>\n<pre><code class=\"c#\">using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Delegate {\n //定义委托，它定义了可以代表的方法的类型\n public delegate void GreetingDelegate(string name);\n class Program {\n private static void EnglishGreeting(string name) {\n Console.WriteLine(&quot;Morning, &quot; + name);\n }\n private static void ChineseGreeting(string name) {\n Console.WriteLine(&quot;早上好, &quot; + name);\n }\n //注意此方法，它接受一个GreetingDelegate类型的方法作为参数\n private static void GreetPeople(string name, GreetingDelegate MakeGreeting) {\n MakeGreeting(name);\n }\n static void Main(string[] args) {\n GreetPeople(&quot;Jimmy Zhang&quot;, EnglishGreeting);\n GreetPeople(&quot;张子阳&quot;, ChineseGreeting);\n Console.ReadKey();\n }\n }\n }\n</code></pre>\n<p>输出如下：</p>\n<pre><code>Morning, Jimmy Zhang\n早上好, 张子阳\n</code></pre><p>我们现在对委托做一个总结：<br>委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。<br>将方法绑定到委托<br>看到这里，是不是有那么点如梦初醒的感觉？于是，你是不是在想：在上面的例子中，我不一定要直接在GreetPeople()方法中给 name参数赋值，我可以像这样使用变量：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n string name1, name2;\n name1 = &quot;Jimmy Zhang&quot;;\n name2 = &quot;张子阳&quot;;\n GreetPeople(name1, EnglishGreeting);\n GreetPeople(name2, ChineseGreeting);\n Console.ReadKey();\n}\n</code></pre>\n<p>而既然委托GreetingDelegate 和 类型 string 的地位一样，都是定义了一种参数类型，那么，我是不是也可以这么使用委托？</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingDelegate delegate1, delegate2;\n delegate1 = EnglishGreeting;\n delegate2 = ChineseGreeting;\n GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);\n GreetPeople(&quot;张子阳&quot;, delegate2);\n Console.ReadKey();\n}\n</code></pre>\n<p>如你所料，这样是没有问题的，程序一如预料的那样输出。这里，我想说的是委托不同于string的一个特性：可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。在这个例子中，语法如下：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingDelegate delegate1;\n delegate1 = EnglishGreeting; // 先给委托类型的变量赋值\n delegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法\n GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);\n Console.ReadKey();\n}\n</code></pre>\n<p>输出为：</p>\n<pre><code>Morning, Jimmy Zhang\n早上好, Jimmy Zhang\n</code></pre><p>实际上，我们可以也可以绕过GreetPeople方法，通过委托来直接调用EnglishGreeting和ChineseGreeting：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingDelegate delegate1;\n delegate1 = EnglishGreeting; // 先给委托类型的变量赋值\n delegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法\n delegate1 (&quot;Jimmy Zhang&quot;);\n Console.ReadKey();\n}\n</code></pre>\n</blockquote>\n<p>NOTE：这在本例中是没有问题的，但回头看下上面GreetPeople()的定义，在它之中可以做一些对于EnglshihGreeting和ChineseGreeting来说都需要进行的工作，为了简便我做了省略。<br>注意这里，第一次用的“=”，是赋值的语法；第二次，用的是“+=”，是绑定的语法。如果第一次就使用“+=”，将出现“使用了未赋值的局部变量”的编译错误。<br>我们也可以使用下面的代码来这样简化这一过程：</p>\n<pre><code class=\"c#\">GreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting);\ndelegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n</code></pre>\n<p>看到这里，应该注意到，这段代码第一条语句与实例化一个类是何其的相似，你不禁想到：上面第一次绑定委托时不可以使用“+=”的编译错误，或许可以用这样的方法来避免：</p>\n<pre><code class=\"c#\">GreetingDelegate delegate1 = new GreetingDelegate();\ndelegate1 += EnglishGreeting; // 这次用的是 “+=”，绑定语法。\ndelegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n</code></pre>\n<p>但实际上，这样会出现编译错误： “GreetingDelegate”方法没有采用“0”个参数的重载。尽管这样的结果让我们觉得有点沮丧，但是编译的提示：“没有0个参数的重载”再次让我们联想到了类的构造函数。我知道你一定按捺不住想探个究竟，但再此之前，我们需要先把基础知识和应用介绍完。<br>既然给委托可以绑定一个方法，那么也应该有办法取消对方法的绑定，很容易想到，这个语法是“-=”：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting);\n delegate1 += ChineseGreeting; // 给此委托变量再绑定一个方法\n // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法\n GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);\n Console.WriteLine();\n delegate1 -= EnglishGreeting; //取消对EnglishGreeting方法的绑定\n // 将仅调用 ChineseGreeting\n GreetPeople(&quot;张子阳&quot;, delegate1);\n Console.ReadKey();\n}\n</code></pre>\n<p>输出为：</p>\n<pre><code>Morning, Jimmy Zhang\n早上好, Jimmy Zhang\n早上好, 张子阳\n</code></pre><p>让我们再次对委托作个总结：<br>使用委托可以将多个方法绑定到同一个委托变量，当调用此变量时(这里用“调用”这个词，是因为此变量代表一个方法)，可以依次调用所有绑定的方法。<br>事件的由来<br>我们继续思考上面的程序：上面的三个方法都定义在Programe类中，这样做是为了理解的方便，实际应用中，通常都是 GreetPeople 在一个类中，ChineseGreeting和 EnglishGreeting 在另外的类中。现在你已经对委托有了初步了解，是时候对上面的例子做个改进了。假设我们将GreetingPeople()放在一个叫GreetingManager的类中，那么新程序应该是这个样子的：</p>\n<pre><code class=\"c#\">namespace Delegate {\n //定义委托，它定义了可以代表的方法的类型\n public delegate void GreetingDelegate(string name);\n\n //新建的GreetingManager类\n public class GreetingManager{\n public void GreetPeople(string name, GreetingDelegate MakeGreeting) {\n MakeGreeting(name);\n }\n }\n class Program {\n private static void EnglishGreeting(string name) {\n Console.WriteLine(&quot;Morning, &quot; + name);\n }\n private static void ChineseGreeting(string name) {\n Console.WriteLine(&quot;早上好, &quot; + name);\n }\n static void Main(string[] args) {\n // ... ...\n }\n }\n}\n</code></pre>\n<p>这个时候，如果要实现前面演示的输出效果，Main方法我想应该是这样的：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.GreetPeople(&quot;Jimmy Zhang&quot;, EnglishGreeting);\n gm.GreetPeople(&quot;张子阳&quot;, ChineseGreeting);\n}\n</code></pre>\n<p>我们运行这段代码，嗯，没有任何问题。程序一如预料地那样输出了：</p>\n<pre><code>Morning, Jimmy Zhang\n早上好, 张子阳\n</code></pre><p>现在，假设我们需要使用上一节学到的知识，将多个方法绑定到同一个委托变量，该如何做呢？让我们再次改写代码：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n GreetingDelegate delegate1;\n delegate1 = EnglishGreeting;\n delegate1 += ChineseGreeting;\n gm.GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);\n}\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"`\">Morning, Jimmy Zhang\n早上好, Jimmy Zhang\n</code></pre>\n<p>到了这里，我们不禁想到：面向对象设计，讲究的是对象的封装，既然可以声明委托类型的变量(在上例中是delegate1)，我们何不将这个变量封装到 GreetManager类中？在这个类的客户端中使用不是更方便么？于是，我们改写GreetManager类，像这样：</p>\n<pre><code class=\"c#\">public class GreetingManager{\n //在GreetingManager类的内部声明delegate1变量\n public GreetingDelegate delegate1;\n public void GreetPeople(string name, GreetingDelegate MakeGreeting) {\n MakeGreeting(name);\n }\n}\n</code></pre>\n<p>现在，我们可以这样使用这个委托变量：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.delegate1 = EnglishGreeting;\n gm.delegate1 += ChineseGreeting;\n gm.GreetPeople(&quot;Jimmy Zhang&quot;, gm.delegate1);\n}\n</code></pre>\n<p>输出为：</p>\n<pre><code class=\"c#\">Morning, Jimmy Zhang\n早上好, Jimmy Zhang\n</code></pre>\n<p>尽管这样做没有任何问题，但我们发现这条语句很奇怪。在调用gm.GreetPeople方法的时候，再次传递了gm的delegate1字段：</p>\n<pre><code class=\"c#\">gm.GreetPeople(&quot;Jimmy Zhang&quot;, gm.delegate1);\n</code></pre>\n<p>既然如此，我们何不修改 GreetingManager 类成这样：</p>\n<pre><code class=\"c#\">public class GreetingManager{\n //在GreetingManager类的内部声明delegate1变量\n public GreetingDelegate delegate1;\n public void GreetPeople(string name) {\n if(delegate1!=null){ //如果有方法注册委托变量\n delegate1(name); //通过委托调用方法\n }\n }\n}\n</code></pre>\n<p>在客户端，调用看上去更简洁一些：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.delegate1 = EnglishGreeting;\n gm.delegate1 += ChineseGreeting;\n gm.GreetPeople(&quot;Jimmy Zhang&quot;); //注意，这次不需要再传递 delegate1变量\n}\n</code></pre>\n<p>输出为：</p>\n<pre><code>Morning, Jimmy Zhang\n早上好, Jimmy Zhang\n</code></pre><p>尽管这样达到了我们要的效果，但是还是存在着问题：<br>在这里，delegate1和我们平时用的string类型的变量没有什么分别，而我们知道，并不是所有的字段都应该声明成public，合适的做法是应该public的时候public，应该private的时候private。<br>我们先看看如果把 delegate1 声明为 private会怎样？结果就是：这简直就是在搞笑。因为声明委托的目的就是为了把它暴露在类的客户端进行方法的注册，你把它声明为private了，客户端对它根本就不可见，那它还有什么用？<br>再看看把delegate1 声明为 public 会怎样？结果就是：在客户端可以对它进行随意的赋值等操作，严重破坏对象的封装性。<br>最后，第一个方法注册用“=”，是赋值语法，因为要进行实例化，第二个方法注册则用的是“+=”。但是，不管是赋值还是注册，都是将方法绑定到委托上，除了调用时先后顺序不同，再没有任何的分别，这样不是让人觉得很别扭么？<br>现在我们想想，如果delegate1不是一个委托类型，而是一个string类型，你会怎么做？答案是使用属性对字段进行封装。<br>于是，Event出场了，它封装了委托类型的变量，使得：在类的内部，不管你声明它是public还是protected，它总是private的。在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同。<br>我们改写GreetingManager类，它变成了这个样子：</p>\n<pre><code class=\"c#\">public class GreetingManager{\n //这一次我们在这里声明一个事件\n public event GreetingDelegate MakeGreet;\n public void GreetPeople(string name) {\n MakeGreet(name);\n }\n}\n</code></pre>\n<p>很容易注意到：MakeGreet 事件的声明与之前委托变量delegate1的声明唯一的区别是多了一个event关键字。看到这里，在结合上面的讲解，你应该明白到：事件其实没什么不好理解的，声明一个事件不过类似于声明一个进行了封装的委托类型的变量而已。<br>为了证明上面的推论，如果我们像下面这样改写Main方法：</p>\n<pre><code class=\"c#\">static void Main(string[] args) {\n GreetingManager gm = new GreetingManager();\n gm.MakeGreet = EnglishGreeting; // 编译错误1\n gm.MakeGreet += ChineseGreeting;\n gm.GreetPeople(&quot;Jimmy Zhang&quot;);\n}\n</code></pre>\n<p>会得到编译错误：事件“Delegate.GreetingManager.MakeGreet”只能出现在 += 或 -= 的左边(从类型“Delegate.GreetingManager”中使用时除外)。<br>事件和委托的编译代码<br>这时候，我们注释掉编译错误的行，然后重新进行编译，再借助Reflactor来对 event的声明语句做一探究，看看为什么会发生这样的错误：</p>\n<pre><code class=\"c#\">public event GreetingDelegate MakeGreet;\n</code></pre>\n<p>可以看到，实际上尽管我们在GreetingManager里将 MakeGreet 声明为public，但是，实际上MakeGreet会被编译成 私有字段，难怪会发生上面的编译错误了，因为它根本就不允许在GreetingManager类的外面以赋值的方式访问，从而验证了我们上面所做的推论。<br>我们再进一步看下MakeGreet所产生的代码：</p>\n<pre><code class=\"c#\">private GreetingDelegate MakeGreet; //对事件的声明 实际是 声明一个私有的委托变量\n\n[MethodImpl(MethodImplOptions.Synchronized)]\npublic void add_MakeGreet(GreetingDelegate value){\n this.MakeGreet = (GreetingDelegate) Delegate.Combine(this.MakeGreet, value);\n}\n[MethodImpl(MethodImplOptions.Synchronized)]\npublic void remove_MakeGreet(GreetingDelegate value){\n this.MakeGreet = (GreetingDelegate) Delegate.Remove(this.MakeGreet, value);\n}\n</code></pre>\n<p>现在已经很明确了：MakeGreet事件确实是一个GreetingDelegate类型的委托，只不过不管是不是声明为public，它总是被声明为private。另外，它还有两个方法，分别是add_MakeGreet和remove_MakeGreet，这两个方法分别用于注册委托类型的方法和取消注册。实际上也就是： “+= ”对应 add_MakeGreet，“-=”对应remove_MakeGreet。而这两个方法的访问限制取决于声明事件时的访问限制符。<br>在add_MakeGreet()方法内部，实际上调用了System.Delegate的Combine()静态方法，这个方法用于将当前的变量添加到委托链表中。我们前面提到过两次，说委托实际上是一个类，在我们定义委托的时候：</p>\n<pre><code class=\"c#\">public delegate void GreetingDelegate(string name);\n</code></pre>\n<p>当编译器遇到这段代码的时候，会生成下面这样一个完整的类：</p>\n<pre><code class=\"c#\">public sealed class GreetingDelegate:System.MulticastDelegate{\n public GreetingDelegate(object @object, IntPtr method);\n public virtual IAsyncResult BeginInvoke(string name, AsyncCallback callback, object @object);\n public virtual void EndInvoke(IAsyncResult result);\n public virtual void Invoke(string name);\n}\n</code></pre>\n<p>关于这个类的更深入内容，可以参阅《CLR Via C#》等相关书籍，这里就不再讨论了。<br>委托、事件与Observer设计模式<br>范例说明<br>上面的例子已不足以再进行下面的讲解了，我们来看一个新的范例，因为之前已经介绍了很多的内容，所以本节的进度会稍微快一些：<br>假设我们有个高档的热水器，我们给它通上电，当水温超过95度的时候：1、扬声器会开始发出语音，告诉你水的温度；2、液晶屏也会改变水温的显示，来提示水已经快烧开了。<br>现在我们需要写个程序来模拟这个烧水的过程，我们将定义一个类来代表热水器，我们管它叫：Heater，它有代表水温的字段，叫做temperature；当然，还有必不可少的给水加热方法BoilWater()，一个发出语音警报的方法MakeAlert()，一个显示水温的方法，ShowMsg()。</p>\n<pre><code class=\"c#\">namespace Delegate {\n class Heater {\n private int temperature; // 水温\n // 烧水\n public void BoilWater() {\n for (int i = 0; i &lt;= 100; i++) {\n temperature = i;\n if (temperature &gt; 95) {\n MakeAlert(temperature);\n ShowMsg(temperature);\n }\n }\n }\n // 发出语音警报\n private void MakeAlert(int param) {\n Console.WriteLine(&quot;Alarm：嘀嘀嘀，水已经 {0} 度了：&quot; , param);\n }\n\n // 显示水温\n private void ShowMsg(int param) {\n Console.WriteLine(&quot;Display：水快开了，当前温度：{0}度。&quot; , param);\n }\n}\nclass Program {\n static void Main() {\n Heater ht = new Heater();\n ht.BoilWater();\n }\n}\n}\n</code></pre>\n<p>Observer设计模式简介<br>上面的例子显然能完成我们之前描述的工作，但是却并不够好。现在假设热水器由三部分组成：热水器、警报器、显示器，它们来自于不同厂商并进行了组装。那么，应该是热水器仅仅负责烧水，它不能发出警报也不能显示水温；在水烧开时由警报器发出警报、显示器显示提示和水温。<br>这时候，上面的例子就应该变成这个样子：</p>\n<pre><code class=\"c#\">// 热水器\npublic class Heater {\n private int temperature;\n\n // 烧水\n private void BoilWater() {\n for (int i = 0; i &lt;= 100; i++) {\n temperature = i;\n }\n }\n}\n// 警报器\npublic class Alarm{\n private void MakeAlert(int param) {\n Console.WriteLine(&quot;Alarm：嘀嘀嘀，水已经 {0} 度了：&quot; , param);\n }\n}\n// 显示器\npublic class Display{\n private void ShowMsg(int param) {\n Console.WriteLine(&quot;Display：水已烧开，当前温度：{0}度。&quot; , param);\n }\n}\n</code></pre>\n<p>这里就出现了一个问题：如何在水烧开的时候通知报警器和显示器？在继续进行之前，我们先了解一下Observer设计模式，Observer设计模式中主要包括如下两类对象：<br>Subject：监视对象，它往往包含着其他对象所感兴趣的内容。在本范例中，热水器就是一个监视对象，它包含的其他对象所感兴趣的内容，就是temprature字段，当这个字段的值快到100时，会不断把数据发给监视它的对象。<br>Observer：监视者，它监视Subject，当Subject中的某件事发生的时候，会告知Observer，而Observer则会采取相应的行动。在本范例中，Observer有警报器和显示器，它们采取的行动分别是发出警报和显示水温。<br>在本例中，事情发生的顺序应该是这样的：<br>警报器和显示器告诉热水器，它对它的温度比较感兴趣(注册)。<br>热水器知道后保留对警报器和显示器的引用。<br>热水器进行烧水这一动作，当水温超过95度时，通过对警报器和显示器的引用，自动调用警报器的MakeAlert()方法、显示器的ShowMsg()方法。<br>类似这样的例子是很多的，GOF对它进行了抽象，称为Observer设计模式：Observer设计模式是为了定义对象间的一种一对多的依赖关系，以便于当一个对象的状态改变时，其他依赖于它的对象会被自动告知并更新。Observer模式是一种松耦合的设计模式。<br>实现范例的Observer设计模式<br>我们之前已经对委托和事件介绍很多了，现在写代码应该很容易了，现在在这里直接给出代码，并在注释中加以说明。</p>\n<pre><code class=\"c#\">using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Delegate {\n // 热水器\n public class Heater {\n private int temperature;\n public delegate void BoilHandler(int param); //声明委托\n public event BoilHandler BoilEvent; //声明事件\n // 烧水\n public void BoilWater() {\n for (int i = 0; i &lt;= 100; i++) {\n temperature = i;\n if (temperature &gt; 95) {\n if (BoilEvent != null) { //如果有对象注册\n BoilEvent(temperature); //调用所有注册对象的方法\n }\n }\n }\n }\n }\n // 警报器\n public class Alarm {\n public void MakeAlert(int param) {\n Console.WriteLine(&quot;Alarm：嘀嘀嘀，水已经 {0} 度了：&quot;, param);\n }\n }\n // 显示器\n public class Display {\n public static void ShowMsg(int param) { //静态方法\n Console.WriteLine(&quot;Display：水快烧开了，当前温度：{0}度。&quot;, param);\n }\n }\n\n class Program {\n static void Main() {\n Heater heater = new Heater();\n Alarm alarm = new Alarm();\n heater.BoilEvent += alarm.MakeAlert; //注册方法\n heater.BoilEvent += (new Alarm()).MakeAlert; //给匿名对象注册方法\n heater.BoilEvent += Display.ShowMsg; //注册静态方法\n heater.BoilWater(); //烧水，会自动调用注册过对象的方法\n }\n }\n}\n</code></pre>\n<p>输出为：</p>\n<pre><code>Alarm：嘀嘀嘀，水已经 96 度了：\nAlarm：嘀嘀嘀，水已经 96 度了：\nDisplay：水快烧开了，当前温度：96度。\n// 省略...\n</code></pre><p>.Net Framework中的委托与事件<br>尽管上面的范例很好地完成了我们想要完成的工作，但是我们不仅疑惑：为什么.Net Framework 中的事件模型和上面的不同？为什么有很多的EventArgs参数？<br>在回答上面的问题之前，我们先搞懂 .Net Framework的编码规范：<br>委托类型的名称都应该以EventHandler结束。<br>委托的原型定义：有一个void返回值，并接受两个输入参数：一个Object 类型，一个 EventArgs类型(或继承自EventArgs)。<br>事件的命名为 委托去掉 EventHandler之后剩余的部分。<br>继承自EventArgs的类型应该以EventArgs结尾。<br>再做一下说明：<br>委托声明原型中的Object类型的参数代表了Subject，也就是监视对象，在本例中是 Heater(热水器)。回调函数(比如Alarm的MakeAlert)可以通过它访问触发事件的对象(Heater)。<br>EventArgs 对象包含了Observer所感兴趣的数据，在本例中是temperature。<br>上面这些其实不仅仅是为了编码规范而已，这样也使得程序有更大的灵活性。比如说，如果我们不光想获得热水器的温度，还想在Observer端(警报器或者显示器)方法中获得它的生产日期、型号、价格，那么委托和方法的声明都会变得很麻烦，而如果我们将热水器的引用传给警报器的方法，就可以在方法中直接访问热水器了。<br>现在我们改写之前的范例，让它符合 .Net Framework 的规范：</p>\n<pre><code class=\"c#\">using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Delegate {\n // 热水器\n public class Heater {\n private int temperature;\n public string type = &quot;RealFire 001&quot;; // 添加型号作为演示\n public string area = &quot;China Xian&quot;; // 添加产地作为演示\n //声明委托\n public delegate void BoiledEventHandler(Object sender, BoiledEventArgs e);\n public event BoiledEventHandler Boiled; //声明事件\n // 定义BoiledEventArgs类，传递给Observer所感兴趣的信息\n public class BoiledEventArgs : EventArgs {\n public readonly int temperature;\n public BoiledEventArgs(int temperature) {\n this.temperature = temperature;\n }\n }\n // 可以供继承自 Heater 的类重写，以便继承类拒绝其他对象对它的监视\n protected virtual void OnBoiled(BoiledEventArgs e) {\n if (Boiled != null) { // 如果有对象注册\n Boiled(this, e); // 调用所有注册对象的方法\n }\n }\n\n // 烧水。\n public void BoilWater() {\n for (int i = 0; i &lt;= 100; i++) {\n temperature = i;\n if (temperature &gt; 95) {\n //建立BoiledEventArgs 对象。\n BoiledEventArgs e = new BoiledEventArgs(temperature);\n OnBoiled(e); // 调用 OnBolied方法\n }\n }\n }\n }\n // 警报器\n public class Alarm {\n public void MakeAlert(Object sender, Heater.BoiledEventArgs e) {\n Heater heater = (Heater)sender; //这里是不是很熟悉呢？\n //访问 sender 中的公共字段\n Console.WriteLine(&quot;Alarm：{0} - {1}: &quot;, heater.area, heater.type);\n Console.WriteLine(&quot;Alarm: 嘀嘀嘀，水已经 {0} 度了：&quot;, e.temperature);\n Console.WriteLine();\n }\n }\n // 显示器\n public class Display {\n public static void ShowMsg(Object sender, Heater.BoiledEventArgs e) { //静态方法\n Heater heater = (Heater)sender;\n Console.WriteLine(&quot;Display：{0} - {1}: &quot;, heater.area, heater.type);\n Console.WriteLine(&quot;Display：水快烧开了，当前温度：{0}度。&quot;, e.temperature);\n Console.WriteLine();\n }\n }\n class Program {\n static void Main() {\n Heater heater = new Heater();\n Alarm alarm = new Alarm();\n heater.Boiled += alarm.MakeAlert; //注册方法\n heater.Boiled += (new Alarm()).MakeAlert; //给匿名对象注册方法\n heater.Boiled += new Heater.BoiledEventHandler(alarm.MakeAlert); //也可以这么注册\n heater.Boiled += Display.ShowMsg; //注册静态方法\n heater.BoilWater(); //烧水，会自动调用注册过对象的方法\n }\n }\n}\n</code></pre>\n<p>输出为：</p>\n<pre><code>Alarm：China Xian - RealFire 001:\nAlarm: 嘀嘀嘀，水已经 96 度了：\nAlarm：China Xian - RealFire 001:\nAlarm: 嘀嘀嘀，水已经 96 度了：\nAlarm：China Xian - RealFire 001:\nAlarm: 嘀嘀嘀，水已经 96 度了：\nDisplay：China Xian - RealFire 001:\nDisplay：水快烧开了，当前温度：96度。\n// 省略 ...\n</code></pre><p>总结<br>在本文中我首先通过一个GreetingPeople的小程序向大家介绍了委托的概念、委托用来做什么，随后又引出了事件，接着对委托与事件所产生的中间代码做了粗略的讲述。<br>在第二个稍微复杂点的热水器的范例中，我向大家简要介绍了 Observer设计模式，并通过实现这个范例完成了该模式，随后讲述了.Net Framework中委托、事件的实现方式。<br>希望这篇文章能给你带来帮助。</p>\n<blockquote>\n<p>来源：<br>[1]: <a href=\"http://www.tracefact.net/csharp-programming/delegates-and-events-in-csharp.aspx\" target=\"_blank\" rel=\"noopener\">http://www.tracefact.net/csharp-programming/delegates-and-events-in-csharp.aspx</a></p>\n</blockquote>\n"},{"title":"Android Studio Plugins","date":"2018-10-02T01:09:09.000Z","_content":"[https://ydmmocoo.github.io/2016/06/28/Android-Studio插件整理/](https://ydmmocoo.github.io/2016/06/28/Android-Studio插件整理/)\n\n[GsonFormat](http://plugins.jetbrains.com/plugin/7654?pr=androidstudio)\n\n[Android Code Generator](http://plugins.jetbrains.com/plugin/7595?pr=androidstudio)\n\n根据布局文件快速生成对应的Activity，Fragment，Adapter，Menu。\n\n[Android Parcelable code generator](http://plugins.jetbrains.com/plugin/7332?pr=androidstudio)\n\nJavaBean序列化，快速实现Parcelable接口。\n\n[Lifecycle Sorter](http://plugins.jetbrains.com/plugin/7742?pr=androidstudio)\n\n可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序，快捷键Ctrl + alt + K\n\n[CodeGlance](http://plugins.jetbrains.com/plugin/7275?pr=androidstudio)\n\n在右边可以预览代码，实现快速定位\n\n[dagger-intellij-plugin](https://github.com/square/dagger-intellij-plugin)\n\ndagger可視化\n\n[JsonOnlineViewer](http://plugins.jetbrains.com/plugin/7838?pr=androidstudio)\n\n[GradleDependenciesHelperPlugin](https://github.com/ligi/GradleDependenciesHelperPlugin)\n\nmaven gradle 依赖支持自动补全\n\n[AndroidProguardPlugin](https://github.com/zhonghanwen/AndroidProguardPlugin)\n\n[Android-DPI-Calculator](https://github.com/JerzyPuchalski/Android-DPI-Calculator)\n\nDPI计算插件\n\n[idea-markdown](https://github.com/nicoulaj/idea-markdown)\n\nmarkdown插件\n\n[Material Theme UI](https://plugins.jetbrains.com/plugin/8006?pr=)\n\n添加Material主题到你的AS\n\n[.ignore](https://plugins.jetbrains.com/plugin/7495?pr=)\n\n[CheckStyle-IDEA](https://plugins.jetbrains.com/plugin/1065?pr=)\n\nCheckStyle-IDEA 是一个检查代码风格的插件，比如像命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，你们可以遵从像Google Oracle 的Java 代码指南 ，当然也可以按照自己的规则来设置配置文件，从而有效约束你自己更好地遵循代码编写规范。\n\ngoogle style\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<code_scheme name=\"GoogleStyle\">\n  <option name=\"OTHER_INDENT_OPTIONS\">\n    <value>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n      <option name=\"USE_TAB_CHARACTER\" value=\"false\" />\n      <option name=\"SMART_TABS\" value=\"false\" />\n      <option name=\"LABEL_INDENT_SIZE\" value=\"0\" />\n      <option name=\"LABEL_INDENT_ABSOLUTE\" value=\"false\" />\n      <option name=\"USE_RELATIVE_INDENTS\" value=\"false\" />\n    </value>\n  </option>\n  <option name=\"INSERT_INNER_CLASS_IMPORTS\" value=\"true\" />\n  <option name=\"CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND\" value=\"999\" />\n  <option name=\"NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND\" value=\"999\" />\n  <option name=\"PACKAGES_TO_USE_IMPORT_ON_DEMAND\">\n    <value />\n  </option>\n  <option name=\"IMPORT_LAYOUT_TABLE\">\n    <value>\n      <package name=\"\" withSubpackages=\"true\" static=\"true\" />\n      <emptyLine />\n      <package name=\"\" withSubpackages=\"true\" static=\"false\" />\n    </value>\n  </option>\n  <option name=\"RIGHT_MARGIN\" value=\"100\" />\n  <option name=\"JD_ALIGN_PARAM_COMMENTS\" value=\"false\" />\n  <option name=\"JD_ALIGN_EXCEPTION_COMMENTS\" value=\"false\" />\n  <option name=\"JD_P_AT_EMPTY_LINES\" value=\"false\" />\n  <option name=\"JD_KEEP_EMPTY_PARAMETER\" value=\"false\" />\n  <option name=\"JD_KEEP_EMPTY_EXCEPTION\" value=\"false\" />\n  <option name=\"JD_KEEP_EMPTY_RETURN\" value=\"false\" />\n  <option name=\"KEEP_CONTROL_STATEMENT_IN_ONE_LINE\" value=\"false\" />\n  <option name=\"KEEP_BLANK_LINES_IN_CODE\" value=\"1\" />\n  <option name=\"BLANK_LINES_AFTER_CLASS_HEADER\" value=\"1\" />\n  <option name=\"ALIGN_MULTILINE_PARAMETERS\" value=\"false\" />\n  <option name=\"ALIGN_MULTILINE_FOR\" value=\"false\" />\n  <option name=\"CALL_PARAMETERS_WRAP\" value=\"1\" />\n  <option name=\"METHOD_PARAMETERS_WRAP\" value=\"1\" />\n  <option name=\"EXTENDS_LIST_WRAP\" value=\"1\" />\n  <option name=\"THROWS_KEYWORD_WRAP\" value=\"1\" />\n  <option name=\"METHOD_CALL_CHAIN_WRAP\" value=\"1\" />\n  <option name=\"BINARY_OPERATION_WRAP\" value=\"1\" />\n  <option name=\"BINARY_OPERATION_SIGN_ON_NEXT_LINE\" value=\"true\" />\n  <option name=\"TERNARY_OPERATION_WRAP\" value=\"1\" />\n  <option name=\"TERNARY_OPERATION_SIGNS_ON_NEXT_LINE\" value=\"true\" />\n  <option name=\"FOR_STATEMENT_WRAP\" value=\"1\" />\n  <option name=\"ARRAY_INITIALIZER_WRAP\" value=\"1\" />\n  <option name=\"WRAP_COMMENTS\" value=\"true\" />\n  <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n  <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n  <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n  <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n  <AndroidXmlCodeStyleSettings>\n    <option name=\"USE_CUSTOM_SETTINGS\" value=\"true\" />\n    <option name=\"LAYOUT_SETTINGS\">\n      <value>\n        <option name=\"INSERT_BLANK_LINE_BEFORE_TAG\" value=\"false\" />\n      </value>\n    </option>\n  </AndroidXmlCodeStyleSettings>\n  <JSCodeStyleSettings>\n    <option name=\"INDENT_CHAINED_CALLS\" value=\"false\" />\n  </JSCodeStyleSettings>\n  <Python>\n    <option name=\"USE_CONTINUATION_INDENT_FOR_ARGUMENTS\" value=\"true\" />\n  </Python>\n  <TypeScriptCodeStyleSettings>\n    <option name=\"INDENT_CHAINED_CALLS\" value=\"false\" />\n  </TypeScriptCodeStyleSettings>\n  <XML>\n    <option name=\"XML_ALIGN_ATTRIBUTES\" value=\"false\" />\n    <option name=\"XML_LEGACY_SETTINGS_IMPORTED\" value=\"true\" />\n  </XML>\n  <codeStyleSettings language=\"CSS\">\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"ECMA Script Level 4\">\n    <option name=\"KEEP_BLANK_LINES_IN_CODE\" value=\"1\" />\n    <option name=\"ALIGN_MULTILINE_PARAMETERS\" value=\"false\" />\n    <option name=\"ALIGN_MULTILINE_FOR\" value=\"false\" />\n    <option name=\"CALL_PARAMETERS_WRAP\" value=\"1\" />\n    <option name=\"METHOD_PARAMETERS_WRAP\" value=\"1\" />\n    <option name=\"EXTENDS_LIST_WRAP\" value=\"1\" />\n    <option name=\"BINARY_OPERATION_WRAP\" value=\"1\" />\n    <option name=\"BINARY_OPERATION_SIGN_ON_NEXT_LINE\" value=\"true\" />\n    <option name=\"TERNARY_OPERATION_WRAP\" value=\"1\" />\n    <option name=\"TERNARY_OPERATION_SIGNS_ON_NEXT_LINE\" value=\"true\" />\n    <option name=\"FOR_STATEMENT_WRAP\" value=\"1\" />\n    <option name=\"ARRAY_INITIALIZER_WRAP\" value=\"1\" />\n    <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n    <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n    <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n    <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n    <option name=\"PARENT_SETTINGS_INSTALLED\" value=\"true\" />\n  </codeStyleSettings>\n  <codeStyleSettings language=\"HTML\">\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"JAVA\">\n    <option name=\"KEEP_CONTROL_STATEMENT_IN_ONE_LINE\" value=\"false\" />\n    <option name=\"KEEP_BLANK_LINES_IN_CODE\" value=\"1\" />\n    <option name=\"BLANK_LINES_AFTER_CLASS_HEADER\" value=\"1\" />\n    <option name=\"ALIGN_MULTILINE_PARAMETERS\" value=\"false\" />\n    <option name=\"ALIGN_MULTILINE_RESOURCES\" value=\"false\" />\n    <option name=\"ALIGN_MULTILINE_FOR\" value=\"false\" />\n    <option name=\"CALL_PARAMETERS_WRAP\" value=\"1\" />\n    <option name=\"METHOD_PARAMETERS_WRAP\" value=\"1\" />\n    <option name=\"EXTENDS_LIST_WRAP\" value=\"1\" />\n    <option name=\"THROWS_KEYWORD_WRAP\" value=\"1\" />\n    <option name=\"METHOD_CALL_CHAIN_WRAP\" value=\"1\" />\n    <option name=\"BINARY_OPERATION_WRAP\" value=\"1\" />\n    <option name=\"BINARY_OPERATION_SIGN_ON_NEXT_LINE\" value=\"true\" />\n    <option name=\"TERNARY_OPERATION_WRAP\" value=\"1\" />\n    <option name=\"TERNARY_OPERATION_SIGNS_ON_NEXT_LINE\" value=\"true\" />\n    <option name=\"FOR_STATEMENT_WRAP\" value=\"1\" />\n    <option name=\"ARRAY_INITIALIZER_WRAP\" value=\"1\" />\n    <option name=\"WRAP_COMMENTS\" value=\"true\" />\n    <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n    <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n    <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n    <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n    <option name=\"PARENT_SETTINGS_INSTALLED\" value=\"true\" />\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"JSON\">\n    <indentOptions>\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"JavaScript\">\n    <option name=\"RIGHT_MARGIN\" value=\"80\" />\n    <option name=\"KEEP_BLANK_LINES_IN_CODE\" value=\"1\" />\n    <option name=\"ALIGN_MULTILINE_PARAMETERS\" value=\"false\" />\n    <option name=\"ALIGN_MULTILINE_FOR\" value=\"false\" />\n    <option name=\"CALL_PARAMETERS_WRAP\" value=\"1\" />\n    <option name=\"METHOD_PARAMETERS_WRAP\" value=\"1\" />\n    <option name=\"BINARY_OPERATION_WRAP\" value=\"1\" />\n    <option name=\"BINARY_OPERATION_SIGN_ON_NEXT_LINE\" value=\"true\" />\n    <option name=\"TERNARY_OPERATION_WRAP\" value=\"1\" />\n    <option name=\"TERNARY_OPERATION_SIGNS_ON_NEXT_LINE\" value=\"true\" />\n    <option name=\"FOR_STATEMENT_WRAP\" value=\"1\" />\n    <option name=\"ARRAY_INITIALIZER_WRAP\" value=\"1\" />\n    <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n    <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n    <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n    <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n    <option name=\"PARENT_SETTINGS_INSTALLED\" value=\"true\" />\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"PROTO\">\n    <option name=\"RIGHT_MARGIN\" value=\"80\" />\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"2\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"protobuf\">\n    <option name=\"RIGHT_MARGIN\" value=\"80\" />\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"2\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"Python\">\n    <option name=\"KEEP_BLANK_LINES_IN_CODE\" value=\"1\" />\n    <option name=\"RIGHT_MARGIN\" value=\"80\" />\n    <option name=\"ALIGN_MULTILINE_PARAMETERS\" value=\"false\" />\n    <option name=\"PARENT_SETTINGS_INSTALLED\" value=\"true\" />\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"SASS\">\n    <indentOptions>\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"SCSS\">\n    <indentOptions>\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"TypeScript\">\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"XML\">\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"2\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n    <arrangement>\n      <rules>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>xmlns:android</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>^$</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>xmlns:.*</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>^$</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:id</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>style</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>^$</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>^$</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:.*Style</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_width</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_height</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_weight</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_margin</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_marginTop</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_marginBottom</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_marginStart</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_marginEnd</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_marginLeft</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_marginRight</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_.*</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:padding</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:paddingTop</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:paddingBottom</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:paddingStart</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:paddingEnd</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:paddingLeft</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:paddingRight</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*</NAME>\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*</NAME>\n                <XML_NAMESPACE>http://schemas.android.com/apk/res-auto</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*</NAME>\n                <XML_NAMESPACE>http://schemas.android.com/tools</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*</NAME>\n                <XML_NAMESPACE>.*</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n      </rules>\n    </arrangement>\n  </codeStyleSettings>\n  <Objective-C>\n    <option name=\"INDENT_NAMESPACE_MEMBERS\" value=\"0\" />\n    <option name=\"INDENT_C_STRUCT_MEMBERS\" value=\"2\" />\n    <option name=\"INDENT_CLASS_MEMBERS\" value=\"2\" />\n    <option name=\"INDENT_VISIBILITY_KEYWORDS\" value=\"1\" />\n    <option name=\"INDENT_INSIDE_CODE_BLOCK\" value=\"2\" />\n    <option name=\"KEEP_STRUCTURES_IN_ONE_LINE\" value=\"true\" />\n    <option name=\"FUNCTION_PARAMETERS_WRAP\" value=\"5\" />\n    <option name=\"FUNCTION_CALL_ARGUMENTS_WRAP\" value=\"5\" />\n    <option name=\"TEMPLATE_CALL_ARGUMENTS_WRAP\" value=\"5\" />\n    <option name=\"TEMPLATE_CALL_ARGUMENTS_ALIGN_MULTILINE\" value=\"true\" />\n    <option name=\"ALIGN_INIT_LIST_IN_COLUMNS\" value=\"false\" />\n    <option name=\"SPACE_BEFORE_SUPERCLASS_COLON\" value=\"false\" />\n  </Objective-C>\n  <Objective-C-extensions>\n    <option name=\"GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES\" value=\"ASK\" />\n    <option name=\"RELEASE_STYLE\" value=\"IVAR\" />\n    <option name=\"TYPE_QUALIFIERS_PLACEMENT\" value=\"BEFORE\" />\n    <file>\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Import\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Macro\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Typedef\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Enum\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Constant\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Global\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Struct\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"FunctionPredecl\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Function\" />\n    </file>\n    <class>\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Property\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Synthesize\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"InitMethod\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"StaticMethod\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"InstanceMethod\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"DeallocMethod\" />\n    </class>\n    <extensions>\n      <pair source=\"cc\" header=\"h\" />\n      <pair source=\"c\" header=\"h\" />\n    </extensions>\n  </Objective-C-extensions>\n  <codeStyleSettings language=\"ObjectiveC\">\n    <option name=\"RIGHT_MARGIN\" value=\"80\" />\n    <option name=\"KEEP_BLANK_LINES_BEFORE_RBRACE\" value=\"1\" />\n    <option name=\"BLANK_LINES_BEFORE_IMPORTS\" value=\"0\" />\n    <option name=\"BLANK_LINES_AFTER_IMPORTS\" value=\"0\" />\n    <option name=\"BLANK_LINES_AROUND_CLASS\" value=\"0\" />\n    <option name=\"BLANK_LINES_AROUND_METHOD\" value=\"0\" />\n    <option name=\"BLANK_LINES_AROUND_METHOD_IN_INTERFACE\" value=\"0\" />\n    <option name=\"ALIGN_MULTILINE_BINARY_OPERATION\" value=\"false\" />\n    <option name=\"BINARY_OPERATION_SIGN_ON_NEXT_LINE\" value=\"true\" />\n    <option name=\"FOR_STATEMENT_WRAP\" value=\"1\" />\n    <option name=\"ASSIGNMENT_WRAP\" value=\"1\" />\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n    </indentOptions>\n  </codeStyleSettings>\n</code_scheme>\n```\n\ncheckstyle\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE module PUBLIC\n          \"-//Puppy Crawl//DTD Check Configuration 1.3//EN\"\n          \"http://www.puppycrawl.com/dtds/configuration_1_3.dtd\">\n\n<!--\n    Checkstyle configuration that checks the Google coding conventions from Google Java Style\n    that can be found at https://google.github.io/styleguide/javaguide.html.\n    Checkstyle is very configurable. Be sure to read the documentation at\n    http://checkstyle.sf.net (or in your downloaded distribution).\n    To completely disable a check, just comment it out or delete it from the file.\n    Authors: Max Vetrenko, Ruslan Diachenko, Roman Ivanov.\n -->\n\n<module name = \"Checker\">\n    <property name=\"charset\" value=\"UTF-8\"/>\n\n    <property name=\"severity\" value=\"warning\"/>\n\n    <property name=\"fileExtensions\" value=\"java, properties, xml\"/>\n    <!-- Checks for whitespace                               -->\n    <!-- See http://checkstyle.sf.net/config_whitespace.html -->\n        <module name=\"FileTabCharacter\">\n            <property name=\"eachLine\" value=\"true\"/>\n        </module>\n\n    <module name=\"TreeWalker\">\n        <module name=\"OuterTypeFilename\"/>\n        <module name=\"IllegalTokenText\">\n            <property name=\"tokens\" value=\"STRING_LITERAL, CHAR_LITERAL\"/>\n            <property name=\"format\" value=\"\\\\u00(09|0(a|A)|0(c|C)|0(d|D)|22|27|5(C|c))|\\\\(0(10|11|12|14|15|42|47)|134)\"/>\n            <property name=\"message\" value=\"Consider using special escape sequence instead of octal value or Unicode escaped value.\"/>\n        </module>\n        <module name=\"AvoidEscapedUnicodeCharacters\">\n            <property name=\"allowEscapesForControlCharacters\" value=\"true\"/>\n            <property name=\"allowByTailComment\" value=\"true\"/>\n            <property name=\"allowNonPrintableEscapes\" value=\"true\"/>\n        </module>\n        <module name=\"LineLength\">\n            <property name=\"max\" value=\"100\"/>\n            <property name=\"ignorePattern\" value=\"^package.*|^import.*|a href|href|http://|https://|ftp://\"/>\n        </module>\n        <module name=\"AvoidStarImport\"/>\n        <module name=\"OneTopLevelClass\"/>\n        <module name=\"NoLineWrap\"/>\n        <module name=\"EmptyBlock\">\n            <property name=\"option\" value=\"TEXT\"/>\n            <property name=\"tokens\" value=\"LITERAL_TRY, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_SWITCH\"/>\n        </module>\n        <module name=\"NeedBraces\"/>\n        <module name=\"LeftCurly\">\n            <property name=\"maxLineLength\" value=\"100\"/>\n        </module>\n        <module name=\"RightCurly\">\n            <property name=\"id\" value=\"RightCurlySame\"/>\n            <property name=\"tokens\" value=\"LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_DO\"/>\n        </module>\n        <module name=\"RightCurly\">\n            <property name=\"id\" value=\"RightCurlyAlone\"/>\n            <property name=\"option\" value=\"alone\"/>\n            <property name=\"tokens\" value=\"CLASS_DEF, METHOD_DEF, CTOR_DEF, LITERAL_FOR, LITERAL_WHILE, STATIC_INIT, INSTANCE_INIT\"/>\n        </module>\n        <module name=\"WhitespaceAround\">\n            <property name=\"allowEmptyConstructors\" value=\"true\"/>\n            <property name=\"allowEmptyMethods\" value=\"true\"/>\n            <property name=\"allowEmptyTypes\" value=\"true\"/>\n            <property name=\"allowEmptyLoops\" value=\"true\"/>\n            <message key=\"ws.notFollowed\"\n             value=\"WhitespaceAround: ''{0}'' is not followed by whitespace. Empty blocks may only be represented as '{}' when not part of a multi-block statement (4.1.3)\"/>\n             <message key=\"ws.notPreceded\"\n             value=\"WhitespaceAround: ''{0}'' is not preceded with whitespace.\"/>\n        </module>\n        <module name=\"OneStatementPerLine\"/>\n        <module name=\"MultipleVariableDeclarations\"/>\n        <module name=\"ArrayTypeStyle\"/>\n        <module name=\"MissingSwitchDefault\"/>\n        <module name=\"FallThrough\"/>\n        <module name=\"UpperEll\"/>\n        <module name=\"ModifierOrder\"/>\n        <module name=\"EmptyLineSeparator\">\n            <property name=\"allowNoEmptyLineBetweenFields\" value=\"true\"/>\n        </module>\n        <module name=\"SeparatorWrap\">\n            <property name=\"id\" value=\"SeparatorWrapDot\"/>\n            <property name=\"tokens\" value=\"DOT\"/>\n            <property name=\"option\" value=\"nl\"/>\n        </module>\n        <module name=\"SeparatorWrap\">\n            <property name=\"id\" value=\"SeparatorWrapComma\"/>\n            <property name=\"tokens\" value=\"COMMA\"/>\n            <property name=\"option\" value=\"EOL\"/>\n        </module>\n        <module name=\"PackageName\">\n            <property name=\"format\" value=\"^[a-z]+(\\.[a-z][a-z0-9]*)*$\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Package name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"TypeName\">\n            <message key=\"name.invalidPattern\"\n             value=\"Type name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"MemberName\">\n            <property name=\"format\" value=\"^[a-z][a-z0-9][a-zA-Z0-9]*$\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Member name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"ParameterName\">\n            <property name=\"format\" value=\"^[a-z]([a-z0-9][a-zA-Z0-9]*)?$\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Parameter name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"CatchParameterName\">\n            <property name=\"format\" value=\"^[a-z]([a-z0-9][a-zA-Z0-9]*)?$\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Catch parameter name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"LocalVariableName\">\n            <property name=\"tokens\" value=\"VARIABLE_DEF\"/>\n            <property name=\"format\" value=\"^[a-z]([a-z0-9][a-zA-Z0-9]*)?$\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Local variable name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"ClassTypeParameterName\">\n            <property name=\"format\" value=\"(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Class type name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"MethodTypeParameterName\">\n            <property name=\"format\" value=\"(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Method type name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"InterfaceTypeParameterName\">\n            <property name=\"format\" value=\"(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Interface type name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"NoFinalizer\"/>\n        <module name=\"GenericWhitespace\">\n            <message key=\"ws.followed\"\n             value=\"GenericWhitespace ''{0}'' is followed by whitespace.\"/>\n             <message key=\"ws.preceded\"\n             value=\"GenericWhitespace ''{0}'' is preceded with whitespace.\"/>\n             <message key=\"ws.illegalFollow\"\n             value=\"GenericWhitespace ''{0}'' should followed by whitespace.\"/>\n             <message key=\"ws.notPreceded\"\n             value=\"GenericWhitespace ''{0}'' is not preceded with whitespace.\"/>\n        </module>\n        <module name=\"Indentation\">\n            <property name=\"basicOffset\" value=\"2\"/>\n            <property name=\"braceAdjustment\" value=\"0\"/>\n            <property name=\"caseIndent\" value=\"2\"/>\n            <property name=\"throwsIndent\" value=\"4\"/>\n            <property name=\"lineWrappingIndentation\" value=\"4\"/>\n            <property name=\"arrayInitIndent\" value=\"2\"/>\n        </module>\n        <module name=\"AbbreviationAsWordInName\">\n            <property name=\"ignoreFinal\" value=\"false\"/>\n            <property name=\"allowedAbbreviationLength\" value=\"1\"/>\n        </module>\n        <module name=\"OverloadMethodsDeclarationOrder\"/>\n        <module name=\"VariableDeclarationUsageDistance\"/>\n        <module name=\"CustomImportOrder\">\n            <property name=\"sortImportsInGroupAlphabetically\" value=\"true\"/>\n            <property name=\"separateLineBetweenGroups\" value=\"true\"/>\n            <property name=\"customImportOrderRules\" value=\"STATIC###THIRD_PARTY_PACKAGE\"/>\n        </module>\n        <module name=\"MethodParamPad\"/>\n        <module name=\"ParenPad\"/>\n        <module name=\"OperatorWrap\">\n            <property name=\"option\" value=\"NL\"/>\n            <property name=\"tokens\" value=\"BAND, BOR, BSR, BXOR, DIV, EQUAL, GE, GT, LAND, LE, LITERAL_INSTANCEOF, LOR, LT, MINUS, MOD, NOT_EQUAL, PLUS, QUESTION, SL, SR, STAR, METHOD_REF \"/>\n        </module>\n        <module name=\"AnnotationLocation\">\n            <property name=\"id\" value=\"AnnotationLocationMostCases\"/>\n            <property name=\"tokens\" value=\"CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF\"/>\n        </module>\n        <module name=\"AnnotationLocation\">\n            <property name=\"id\" value=\"AnnotationLocationVariables\"/>\n            <property name=\"tokens\" value=\"VARIABLE_DEF\"/>\n            <property name=\"allowSamelineMultipleAnnotations\" value=\"true\"/>\n        </module>\n        <module name=\"NonEmptyAtclauseDescription\"/>\n        <module name=\"JavadocTagContinuationIndentation\"/>\n        <module name=\"SummaryJavadoc\">\n            <property name=\"forbiddenSummaryFragments\" value=\"^@return the *|^This method returns |^A [{]@code [a-zA-Z0-9]+[}]( is a )\"/>\n        </module>\n        <module name=\"JavadocParagraph\"/>\n        <module name=\"AtclauseOrder\">\n            <property name=\"tagOrder\" value=\"@param, @return, @throws, @deprecated\"/>\n            <property name=\"target\" value=\"CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF, VARIABLE_DEF\"/>\n        </module>\n        <module name=\"JavadocMethod\">\n            <property name=\"scope\" value=\"public\"/>\n            <property name=\"allowMissingParamTags\" value=\"true\"/>\n            <property name=\"allowMissingThrowsTags\" value=\"true\"/>\n            <property name=\"allowMissingReturnTag\" value=\"true\"/>\n            <property name=\"minLineCount\" value=\"2\"/>\n            <property name=\"allowedAnnotations\" value=\"Override, Test\"/>\n            <property name=\"allowThrowsTagsForSubclasses\" value=\"true\"/>\n        </module>\n        <module name=\"MethodName\">\n            <property name=\"format\" value=\"^[a-z][a-z0-9][a-zA-Z0-9_]*$\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Method name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"SingleLineJavadoc\">\n            <property name=\"ignoreInlineTags\" value=\"false\"/>\n        </module>\n        <module name=\"EmptyCatchBlock\">\n            <property name=\"exceptionVariableName\" value=\"expected\"/>\n        </module>\n        <module name=\"CommentsIndentation\"/>\n    </module>\n</module>\n```\n\nLayoutFormatter\n\n此插件是XML格式化插件，自动排序，能够根据正确的排序顺序进行排序\n\nFindBugs-IDEA\n\n","source":"_posts/android/android-studio-tui-jian-cha-jian.md","raw":"---\ntitle: Android Studio Plugins\ndate: 2018-10-02 09:09:09\ncategories: Android\n---\n[https://ydmmocoo.github.io/2016/06/28/Android-Studio插件整理/](https://ydmmocoo.github.io/2016/06/28/Android-Studio插件整理/)\n\n[GsonFormat](http://plugins.jetbrains.com/plugin/7654?pr=androidstudio)\n\n[Android Code Generator](http://plugins.jetbrains.com/plugin/7595?pr=androidstudio)\n\n根据布局文件快速生成对应的Activity，Fragment，Adapter，Menu。\n\n[Android Parcelable code generator](http://plugins.jetbrains.com/plugin/7332?pr=androidstudio)\n\nJavaBean序列化，快速实现Parcelable接口。\n\n[Lifecycle Sorter](http://plugins.jetbrains.com/plugin/7742?pr=androidstudio)\n\n可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序，快捷键Ctrl + alt + K\n\n[CodeGlance](http://plugins.jetbrains.com/plugin/7275?pr=androidstudio)\n\n在右边可以预览代码，实现快速定位\n\n[dagger-intellij-plugin](https://github.com/square/dagger-intellij-plugin)\n\ndagger可視化\n\n[JsonOnlineViewer](http://plugins.jetbrains.com/plugin/7838?pr=androidstudio)\n\n[GradleDependenciesHelperPlugin](https://github.com/ligi/GradleDependenciesHelperPlugin)\n\nmaven gradle 依赖支持自动补全\n\n[AndroidProguardPlugin](https://github.com/zhonghanwen/AndroidProguardPlugin)\n\n[Android-DPI-Calculator](https://github.com/JerzyPuchalski/Android-DPI-Calculator)\n\nDPI计算插件\n\n[idea-markdown](https://github.com/nicoulaj/idea-markdown)\n\nmarkdown插件\n\n[Material Theme UI](https://plugins.jetbrains.com/plugin/8006?pr=)\n\n添加Material主题到你的AS\n\n[.ignore](https://plugins.jetbrains.com/plugin/7495?pr=)\n\n[CheckStyle-IDEA](https://plugins.jetbrains.com/plugin/1065?pr=)\n\nCheckStyle-IDEA 是一个检查代码风格的插件，比如像命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，你们可以遵从像Google Oracle 的Java 代码指南 ，当然也可以按照自己的规则来设置配置文件，从而有效约束你自己更好地遵循代码编写规范。\n\ngoogle style\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<code_scheme name=\"GoogleStyle\">\n  <option name=\"OTHER_INDENT_OPTIONS\">\n    <value>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n      <option name=\"USE_TAB_CHARACTER\" value=\"false\" />\n      <option name=\"SMART_TABS\" value=\"false\" />\n      <option name=\"LABEL_INDENT_SIZE\" value=\"0\" />\n      <option name=\"LABEL_INDENT_ABSOLUTE\" value=\"false\" />\n      <option name=\"USE_RELATIVE_INDENTS\" value=\"false\" />\n    </value>\n  </option>\n  <option name=\"INSERT_INNER_CLASS_IMPORTS\" value=\"true\" />\n  <option name=\"CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND\" value=\"999\" />\n  <option name=\"NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND\" value=\"999\" />\n  <option name=\"PACKAGES_TO_USE_IMPORT_ON_DEMAND\">\n    <value />\n  </option>\n  <option name=\"IMPORT_LAYOUT_TABLE\">\n    <value>\n      <package name=\"\" withSubpackages=\"true\" static=\"true\" />\n      <emptyLine />\n      <package name=\"\" withSubpackages=\"true\" static=\"false\" />\n    </value>\n  </option>\n  <option name=\"RIGHT_MARGIN\" value=\"100\" />\n  <option name=\"JD_ALIGN_PARAM_COMMENTS\" value=\"false\" />\n  <option name=\"JD_ALIGN_EXCEPTION_COMMENTS\" value=\"false\" />\n  <option name=\"JD_P_AT_EMPTY_LINES\" value=\"false\" />\n  <option name=\"JD_KEEP_EMPTY_PARAMETER\" value=\"false\" />\n  <option name=\"JD_KEEP_EMPTY_EXCEPTION\" value=\"false\" />\n  <option name=\"JD_KEEP_EMPTY_RETURN\" value=\"false\" />\n  <option name=\"KEEP_CONTROL_STATEMENT_IN_ONE_LINE\" value=\"false\" />\n  <option name=\"KEEP_BLANK_LINES_IN_CODE\" value=\"1\" />\n  <option name=\"BLANK_LINES_AFTER_CLASS_HEADER\" value=\"1\" />\n  <option name=\"ALIGN_MULTILINE_PARAMETERS\" value=\"false\" />\n  <option name=\"ALIGN_MULTILINE_FOR\" value=\"false\" />\n  <option name=\"CALL_PARAMETERS_WRAP\" value=\"1\" />\n  <option name=\"METHOD_PARAMETERS_WRAP\" value=\"1\" />\n  <option name=\"EXTENDS_LIST_WRAP\" value=\"1\" />\n  <option name=\"THROWS_KEYWORD_WRAP\" value=\"1\" />\n  <option name=\"METHOD_CALL_CHAIN_WRAP\" value=\"1\" />\n  <option name=\"BINARY_OPERATION_WRAP\" value=\"1\" />\n  <option name=\"BINARY_OPERATION_SIGN_ON_NEXT_LINE\" value=\"true\" />\n  <option name=\"TERNARY_OPERATION_WRAP\" value=\"1\" />\n  <option name=\"TERNARY_OPERATION_SIGNS_ON_NEXT_LINE\" value=\"true\" />\n  <option name=\"FOR_STATEMENT_WRAP\" value=\"1\" />\n  <option name=\"ARRAY_INITIALIZER_WRAP\" value=\"1\" />\n  <option name=\"WRAP_COMMENTS\" value=\"true\" />\n  <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n  <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n  <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n  <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n  <AndroidXmlCodeStyleSettings>\n    <option name=\"USE_CUSTOM_SETTINGS\" value=\"true\" />\n    <option name=\"LAYOUT_SETTINGS\">\n      <value>\n        <option name=\"INSERT_BLANK_LINE_BEFORE_TAG\" value=\"false\" />\n      </value>\n    </option>\n  </AndroidXmlCodeStyleSettings>\n  <JSCodeStyleSettings>\n    <option name=\"INDENT_CHAINED_CALLS\" value=\"false\" />\n  </JSCodeStyleSettings>\n  <Python>\n    <option name=\"USE_CONTINUATION_INDENT_FOR_ARGUMENTS\" value=\"true\" />\n  </Python>\n  <TypeScriptCodeStyleSettings>\n    <option name=\"INDENT_CHAINED_CALLS\" value=\"false\" />\n  </TypeScriptCodeStyleSettings>\n  <XML>\n    <option name=\"XML_ALIGN_ATTRIBUTES\" value=\"false\" />\n    <option name=\"XML_LEGACY_SETTINGS_IMPORTED\" value=\"true\" />\n  </XML>\n  <codeStyleSettings language=\"CSS\">\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"ECMA Script Level 4\">\n    <option name=\"KEEP_BLANK_LINES_IN_CODE\" value=\"1\" />\n    <option name=\"ALIGN_MULTILINE_PARAMETERS\" value=\"false\" />\n    <option name=\"ALIGN_MULTILINE_FOR\" value=\"false\" />\n    <option name=\"CALL_PARAMETERS_WRAP\" value=\"1\" />\n    <option name=\"METHOD_PARAMETERS_WRAP\" value=\"1\" />\n    <option name=\"EXTENDS_LIST_WRAP\" value=\"1\" />\n    <option name=\"BINARY_OPERATION_WRAP\" value=\"1\" />\n    <option name=\"BINARY_OPERATION_SIGN_ON_NEXT_LINE\" value=\"true\" />\n    <option name=\"TERNARY_OPERATION_WRAP\" value=\"1\" />\n    <option name=\"TERNARY_OPERATION_SIGNS_ON_NEXT_LINE\" value=\"true\" />\n    <option name=\"FOR_STATEMENT_WRAP\" value=\"1\" />\n    <option name=\"ARRAY_INITIALIZER_WRAP\" value=\"1\" />\n    <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n    <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n    <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n    <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n    <option name=\"PARENT_SETTINGS_INSTALLED\" value=\"true\" />\n  </codeStyleSettings>\n  <codeStyleSettings language=\"HTML\">\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"JAVA\">\n    <option name=\"KEEP_CONTROL_STATEMENT_IN_ONE_LINE\" value=\"false\" />\n    <option name=\"KEEP_BLANK_LINES_IN_CODE\" value=\"1\" />\n    <option name=\"BLANK_LINES_AFTER_CLASS_HEADER\" value=\"1\" />\n    <option name=\"ALIGN_MULTILINE_PARAMETERS\" value=\"false\" />\n    <option name=\"ALIGN_MULTILINE_RESOURCES\" value=\"false\" />\n    <option name=\"ALIGN_MULTILINE_FOR\" value=\"false\" />\n    <option name=\"CALL_PARAMETERS_WRAP\" value=\"1\" />\n    <option name=\"METHOD_PARAMETERS_WRAP\" value=\"1\" />\n    <option name=\"EXTENDS_LIST_WRAP\" value=\"1\" />\n    <option name=\"THROWS_KEYWORD_WRAP\" value=\"1\" />\n    <option name=\"METHOD_CALL_CHAIN_WRAP\" value=\"1\" />\n    <option name=\"BINARY_OPERATION_WRAP\" value=\"1\" />\n    <option name=\"BINARY_OPERATION_SIGN_ON_NEXT_LINE\" value=\"true\" />\n    <option name=\"TERNARY_OPERATION_WRAP\" value=\"1\" />\n    <option name=\"TERNARY_OPERATION_SIGNS_ON_NEXT_LINE\" value=\"true\" />\n    <option name=\"FOR_STATEMENT_WRAP\" value=\"1\" />\n    <option name=\"ARRAY_INITIALIZER_WRAP\" value=\"1\" />\n    <option name=\"WRAP_COMMENTS\" value=\"true\" />\n    <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n    <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n    <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n    <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n    <option name=\"PARENT_SETTINGS_INSTALLED\" value=\"true\" />\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"JSON\">\n    <indentOptions>\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"JavaScript\">\n    <option name=\"RIGHT_MARGIN\" value=\"80\" />\n    <option name=\"KEEP_BLANK_LINES_IN_CODE\" value=\"1\" />\n    <option name=\"ALIGN_MULTILINE_PARAMETERS\" value=\"false\" />\n    <option name=\"ALIGN_MULTILINE_FOR\" value=\"false\" />\n    <option name=\"CALL_PARAMETERS_WRAP\" value=\"1\" />\n    <option name=\"METHOD_PARAMETERS_WRAP\" value=\"1\" />\n    <option name=\"BINARY_OPERATION_WRAP\" value=\"1\" />\n    <option name=\"BINARY_OPERATION_SIGN_ON_NEXT_LINE\" value=\"true\" />\n    <option name=\"TERNARY_OPERATION_WRAP\" value=\"1\" />\n    <option name=\"TERNARY_OPERATION_SIGNS_ON_NEXT_LINE\" value=\"true\" />\n    <option name=\"FOR_STATEMENT_WRAP\" value=\"1\" />\n    <option name=\"ARRAY_INITIALIZER_WRAP\" value=\"1\" />\n    <option name=\"IF_BRACE_FORCE\" value=\"3\" />\n    <option name=\"DOWHILE_BRACE_FORCE\" value=\"3\" />\n    <option name=\"WHILE_BRACE_FORCE\" value=\"3\" />\n    <option name=\"FOR_BRACE_FORCE\" value=\"3\" />\n    <option name=\"PARENT_SETTINGS_INSTALLED\" value=\"true\" />\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"PROTO\">\n    <option name=\"RIGHT_MARGIN\" value=\"80\" />\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"2\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"protobuf\">\n    <option name=\"RIGHT_MARGIN\" value=\"80\" />\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"2\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"Python\">\n    <option name=\"KEEP_BLANK_LINES_IN_CODE\" value=\"1\" />\n    <option name=\"RIGHT_MARGIN\" value=\"80\" />\n    <option name=\"ALIGN_MULTILINE_PARAMETERS\" value=\"false\" />\n    <option name=\"PARENT_SETTINGS_INSTALLED\" value=\"true\" />\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"SASS\">\n    <indentOptions>\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"SCSS\">\n    <indentOptions>\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"TypeScript\">\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n  </codeStyleSettings>\n  <codeStyleSettings language=\"XML\">\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"2\" />\n      <option name=\"TAB_SIZE\" value=\"2\" />\n    </indentOptions>\n    <arrangement>\n      <rules>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>xmlns:android</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>^$</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>xmlns:.*</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>^$</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:id</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>style</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>^$</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>^$</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:.*Style</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_width</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_height</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_weight</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_margin</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_marginTop</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_marginBottom</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_marginStart</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_marginEnd</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_marginLeft</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_marginRight</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:layout_.*</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:padding</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:paddingTop</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:paddingBottom</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:paddingStart</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:paddingEnd</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:paddingLeft</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*:paddingRight</NAME>\n                <XML_ATTRIBUTE />\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*</NAME>\n                <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*</NAME>\n                <XML_NAMESPACE>http://schemas.android.com/apk/res-auto</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*</NAME>\n                <XML_NAMESPACE>http://schemas.android.com/tools</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n        <section>\n          <rule>\n            <match>\n              <AND>\n                <NAME>.*</NAME>\n                <XML_NAMESPACE>.*</XML_NAMESPACE>\n              </AND>\n            </match>\n            <order>BY_NAME</order>\n          </rule>\n        </section>\n      </rules>\n    </arrangement>\n  </codeStyleSettings>\n  <Objective-C>\n    <option name=\"INDENT_NAMESPACE_MEMBERS\" value=\"0\" />\n    <option name=\"INDENT_C_STRUCT_MEMBERS\" value=\"2\" />\n    <option name=\"INDENT_CLASS_MEMBERS\" value=\"2\" />\n    <option name=\"INDENT_VISIBILITY_KEYWORDS\" value=\"1\" />\n    <option name=\"INDENT_INSIDE_CODE_BLOCK\" value=\"2\" />\n    <option name=\"KEEP_STRUCTURES_IN_ONE_LINE\" value=\"true\" />\n    <option name=\"FUNCTION_PARAMETERS_WRAP\" value=\"5\" />\n    <option name=\"FUNCTION_CALL_ARGUMENTS_WRAP\" value=\"5\" />\n    <option name=\"TEMPLATE_CALL_ARGUMENTS_WRAP\" value=\"5\" />\n    <option name=\"TEMPLATE_CALL_ARGUMENTS_ALIGN_MULTILINE\" value=\"true\" />\n    <option name=\"ALIGN_INIT_LIST_IN_COLUMNS\" value=\"false\" />\n    <option name=\"SPACE_BEFORE_SUPERCLASS_COLON\" value=\"false\" />\n  </Objective-C>\n  <Objective-C-extensions>\n    <option name=\"GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES\" value=\"ASK\" />\n    <option name=\"RELEASE_STYLE\" value=\"IVAR\" />\n    <option name=\"TYPE_QUALIFIERS_PLACEMENT\" value=\"BEFORE\" />\n    <file>\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Import\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Macro\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Typedef\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Enum\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Constant\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Global\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Struct\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"FunctionPredecl\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Function\" />\n    </file>\n    <class>\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Property\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"Synthesize\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"InitMethod\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"StaticMethod\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"InstanceMethod\" />\n      <option name=\"com.jetbrains.cidr.lang.util.OCDeclarationKind\" value=\"DeallocMethod\" />\n    </class>\n    <extensions>\n      <pair source=\"cc\" header=\"h\" />\n      <pair source=\"c\" header=\"h\" />\n    </extensions>\n  </Objective-C-extensions>\n  <codeStyleSettings language=\"ObjectiveC\">\n    <option name=\"RIGHT_MARGIN\" value=\"80\" />\n    <option name=\"KEEP_BLANK_LINES_BEFORE_RBRACE\" value=\"1\" />\n    <option name=\"BLANK_LINES_BEFORE_IMPORTS\" value=\"0\" />\n    <option name=\"BLANK_LINES_AFTER_IMPORTS\" value=\"0\" />\n    <option name=\"BLANK_LINES_AROUND_CLASS\" value=\"0\" />\n    <option name=\"BLANK_LINES_AROUND_METHOD\" value=\"0\" />\n    <option name=\"BLANK_LINES_AROUND_METHOD_IN_INTERFACE\" value=\"0\" />\n    <option name=\"ALIGN_MULTILINE_BINARY_OPERATION\" value=\"false\" />\n    <option name=\"BINARY_OPERATION_SIGN_ON_NEXT_LINE\" value=\"true\" />\n    <option name=\"FOR_STATEMENT_WRAP\" value=\"1\" />\n    <option name=\"ASSIGNMENT_WRAP\" value=\"1\" />\n    <indentOptions>\n      <option name=\"INDENT_SIZE\" value=\"2\" />\n      <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n    </indentOptions>\n  </codeStyleSettings>\n</code_scheme>\n```\n\ncheckstyle\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE module PUBLIC\n          \"-//Puppy Crawl//DTD Check Configuration 1.3//EN\"\n          \"http://www.puppycrawl.com/dtds/configuration_1_3.dtd\">\n\n<!--\n    Checkstyle configuration that checks the Google coding conventions from Google Java Style\n    that can be found at https://google.github.io/styleguide/javaguide.html.\n    Checkstyle is very configurable. Be sure to read the documentation at\n    http://checkstyle.sf.net (or in your downloaded distribution).\n    To completely disable a check, just comment it out or delete it from the file.\n    Authors: Max Vetrenko, Ruslan Diachenko, Roman Ivanov.\n -->\n\n<module name = \"Checker\">\n    <property name=\"charset\" value=\"UTF-8\"/>\n\n    <property name=\"severity\" value=\"warning\"/>\n\n    <property name=\"fileExtensions\" value=\"java, properties, xml\"/>\n    <!-- Checks for whitespace                               -->\n    <!-- See http://checkstyle.sf.net/config_whitespace.html -->\n        <module name=\"FileTabCharacter\">\n            <property name=\"eachLine\" value=\"true\"/>\n        </module>\n\n    <module name=\"TreeWalker\">\n        <module name=\"OuterTypeFilename\"/>\n        <module name=\"IllegalTokenText\">\n            <property name=\"tokens\" value=\"STRING_LITERAL, CHAR_LITERAL\"/>\n            <property name=\"format\" value=\"\\\\u00(09|0(a|A)|0(c|C)|0(d|D)|22|27|5(C|c))|\\\\(0(10|11|12|14|15|42|47)|134)\"/>\n            <property name=\"message\" value=\"Consider using special escape sequence instead of octal value or Unicode escaped value.\"/>\n        </module>\n        <module name=\"AvoidEscapedUnicodeCharacters\">\n            <property name=\"allowEscapesForControlCharacters\" value=\"true\"/>\n            <property name=\"allowByTailComment\" value=\"true\"/>\n            <property name=\"allowNonPrintableEscapes\" value=\"true\"/>\n        </module>\n        <module name=\"LineLength\">\n            <property name=\"max\" value=\"100\"/>\n            <property name=\"ignorePattern\" value=\"^package.*|^import.*|a href|href|http://|https://|ftp://\"/>\n        </module>\n        <module name=\"AvoidStarImport\"/>\n        <module name=\"OneTopLevelClass\"/>\n        <module name=\"NoLineWrap\"/>\n        <module name=\"EmptyBlock\">\n            <property name=\"option\" value=\"TEXT\"/>\n            <property name=\"tokens\" value=\"LITERAL_TRY, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_SWITCH\"/>\n        </module>\n        <module name=\"NeedBraces\"/>\n        <module name=\"LeftCurly\">\n            <property name=\"maxLineLength\" value=\"100\"/>\n        </module>\n        <module name=\"RightCurly\">\n            <property name=\"id\" value=\"RightCurlySame\"/>\n            <property name=\"tokens\" value=\"LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_DO\"/>\n        </module>\n        <module name=\"RightCurly\">\n            <property name=\"id\" value=\"RightCurlyAlone\"/>\n            <property name=\"option\" value=\"alone\"/>\n            <property name=\"tokens\" value=\"CLASS_DEF, METHOD_DEF, CTOR_DEF, LITERAL_FOR, LITERAL_WHILE, STATIC_INIT, INSTANCE_INIT\"/>\n        </module>\n        <module name=\"WhitespaceAround\">\n            <property name=\"allowEmptyConstructors\" value=\"true\"/>\n            <property name=\"allowEmptyMethods\" value=\"true\"/>\n            <property name=\"allowEmptyTypes\" value=\"true\"/>\n            <property name=\"allowEmptyLoops\" value=\"true\"/>\n            <message key=\"ws.notFollowed\"\n             value=\"WhitespaceAround: ''{0}'' is not followed by whitespace. Empty blocks may only be represented as '{}' when not part of a multi-block statement (4.1.3)\"/>\n             <message key=\"ws.notPreceded\"\n             value=\"WhitespaceAround: ''{0}'' is not preceded with whitespace.\"/>\n        </module>\n        <module name=\"OneStatementPerLine\"/>\n        <module name=\"MultipleVariableDeclarations\"/>\n        <module name=\"ArrayTypeStyle\"/>\n        <module name=\"MissingSwitchDefault\"/>\n        <module name=\"FallThrough\"/>\n        <module name=\"UpperEll\"/>\n        <module name=\"ModifierOrder\"/>\n        <module name=\"EmptyLineSeparator\">\n            <property name=\"allowNoEmptyLineBetweenFields\" value=\"true\"/>\n        </module>\n        <module name=\"SeparatorWrap\">\n            <property name=\"id\" value=\"SeparatorWrapDot\"/>\n            <property name=\"tokens\" value=\"DOT\"/>\n            <property name=\"option\" value=\"nl\"/>\n        </module>\n        <module name=\"SeparatorWrap\">\n            <property name=\"id\" value=\"SeparatorWrapComma\"/>\n            <property name=\"tokens\" value=\"COMMA\"/>\n            <property name=\"option\" value=\"EOL\"/>\n        </module>\n        <module name=\"PackageName\">\n            <property name=\"format\" value=\"^[a-z]+(\\.[a-z][a-z0-9]*)*$\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Package name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"TypeName\">\n            <message key=\"name.invalidPattern\"\n             value=\"Type name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"MemberName\">\n            <property name=\"format\" value=\"^[a-z][a-z0-9][a-zA-Z0-9]*$\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Member name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"ParameterName\">\n            <property name=\"format\" value=\"^[a-z]([a-z0-9][a-zA-Z0-9]*)?$\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Parameter name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"CatchParameterName\">\n            <property name=\"format\" value=\"^[a-z]([a-z0-9][a-zA-Z0-9]*)?$\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Catch parameter name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"LocalVariableName\">\n            <property name=\"tokens\" value=\"VARIABLE_DEF\"/>\n            <property name=\"format\" value=\"^[a-z]([a-z0-9][a-zA-Z0-9]*)?$\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Local variable name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"ClassTypeParameterName\">\n            <property name=\"format\" value=\"(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Class type name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"MethodTypeParameterName\">\n            <property name=\"format\" value=\"(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Method type name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"InterfaceTypeParameterName\">\n            <property name=\"format\" value=\"(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Interface type name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"NoFinalizer\"/>\n        <module name=\"GenericWhitespace\">\n            <message key=\"ws.followed\"\n             value=\"GenericWhitespace ''{0}'' is followed by whitespace.\"/>\n             <message key=\"ws.preceded\"\n             value=\"GenericWhitespace ''{0}'' is preceded with whitespace.\"/>\n             <message key=\"ws.illegalFollow\"\n             value=\"GenericWhitespace ''{0}'' should followed by whitespace.\"/>\n             <message key=\"ws.notPreceded\"\n             value=\"GenericWhitespace ''{0}'' is not preceded with whitespace.\"/>\n        </module>\n        <module name=\"Indentation\">\n            <property name=\"basicOffset\" value=\"2\"/>\n            <property name=\"braceAdjustment\" value=\"0\"/>\n            <property name=\"caseIndent\" value=\"2\"/>\n            <property name=\"throwsIndent\" value=\"4\"/>\n            <property name=\"lineWrappingIndentation\" value=\"4\"/>\n            <property name=\"arrayInitIndent\" value=\"2\"/>\n        </module>\n        <module name=\"AbbreviationAsWordInName\">\n            <property name=\"ignoreFinal\" value=\"false\"/>\n            <property name=\"allowedAbbreviationLength\" value=\"1\"/>\n        </module>\n        <module name=\"OverloadMethodsDeclarationOrder\"/>\n        <module name=\"VariableDeclarationUsageDistance\"/>\n        <module name=\"CustomImportOrder\">\n            <property name=\"sortImportsInGroupAlphabetically\" value=\"true\"/>\n            <property name=\"separateLineBetweenGroups\" value=\"true\"/>\n            <property name=\"customImportOrderRules\" value=\"STATIC###THIRD_PARTY_PACKAGE\"/>\n        </module>\n        <module name=\"MethodParamPad\"/>\n        <module name=\"ParenPad\"/>\n        <module name=\"OperatorWrap\">\n            <property name=\"option\" value=\"NL\"/>\n            <property name=\"tokens\" value=\"BAND, BOR, BSR, BXOR, DIV, EQUAL, GE, GT, LAND, LE, LITERAL_INSTANCEOF, LOR, LT, MINUS, MOD, NOT_EQUAL, PLUS, QUESTION, SL, SR, STAR, METHOD_REF \"/>\n        </module>\n        <module name=\"AnnotationLocation\">\n            <property name=\"id\" value=\"AnnotationLocationMostCases\"/>\n            <property name=\"tokens\" value=\"CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF\"/>\n        </module>\n        <module name=\"AnnotationLocation\">\n            <property name=\"id\" value=\"AnnotationLocationVariables\"/>\n            <property name=\"tokens\" value=\"VARIABLE_DEF\"/>\n            <property name=\"allowSamelineMultipleAnnotations\" value=\"true\"/>\n        </module>\n        <module name=\"NonEmptyAtclauseDescription\"/>\n        <module name=\"JavadocTagContinuationIndentation\"/>\n        <module name=\"SummaryJavadoc\">\n            <property name=\"forbiddenSummaryFragments\" value=\"^@return the *|^This method returns |^A [{]@code [a-zA-Z0-9]+[}]( is a )\"/>\n        </module>\n        <module name=\"JavadocParagraph\"/>\n        <module name=\"AtclauseOrder\">\n            <property name=\"tagOrder\" value=\"@param, @return, @throws, @deprecated\"/>\n            <property name=\"target\" value=\"CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF, VARIABLE_DEF\"/>\n        </module>\n        <module name=\"JavadocMethod\">\n            <property name=\"scope\" value=\"public\"/>\n            <property name=\"allowMissingParamTags\" value=\"true\"/>\n            <property name=\"allowMissingThrowsTags\" value=\"true\"/>\n            <property name=\"allowMissingReturnTag\" value=\"true\"/>\n            <property name=\"minLineCount\" value=\"2\"/>\n            <property name=\"allowedAnnotations\" value=\"Override, Test\"/>\n            <property name=\"allowThrowsTagsForSubclasses\" value=\"true\"/>\n        </module>\n        <module name=\"MethodName\">\n            <property name=\"format\" value=\"^[a-z][a-z0-9][a-zA-Z0-9_]*$\"/>\n            <message key=\"name.invalidPattern\"\n             value=\"Method name ''{0}'' must match pattern ''{1}''.\"/>\n        </module>\n        <module name=\"SingleLineJavadoc\">\n            <property name=\"ignoreInlineTags\" value=\"false\"/>\n        </module>\n        <module name=\"EmptyCatchBlock\">\n            <property name=\"exceptionVariableName\" value=\"expected\"/>\n        </module>\n        <module name=\"CommentsIndentation\"/>\n    </module>\n</module>\n```\n\nLayoutFormatter\n\n此插件是XML格式化插件，自动排序，能够根据正确的排序顺序进行排序\n\nFindBugs-IDEA\n\n","slug":"android/android-studio-tui-jian-cha-jian","published":1,"updated":"2018-10-02T02:52:44.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4os005xntnbzqdrapz2","content":"<p><a href=\"https://ydmmocoo.github.io/2016/06/28/Android-Studio插件整理/\" target=\"_blank\" rel=\"noopener\">https://ydmmocoo.github.io/2016/06/28/Android-Studio插件整理/</a></p>\n<p><a href=\"http://plugins.jetbrains.com/plugin/7654?pr=androidstudio\" target=\"_blank\" rel=\"noopener\">GsonFormat</a></p>\n<p><a href=\"http://plugins.jetbrains.com/plugin/7595?pr=androidstudio\" target=\"_blank\" rel=\"noopener\">Android Code Generator</a></p>\n<p>根据布局文件快速生成对应的Activity，Fragment，Adapter，Menu。</p>\n<p><a href=\"http://plugins.jetbrains.com/plugin/7332?pr=androidstudio\" target=\"_blank\" rel=\"noopener\">Android Parcelable code generator</a></p>\n<p>JavaBean序列化，快速实现Parcelable接口。</p>\n<p><a href=\"http://plugins.jetbrains.com/plugin/7742?pr=androidstudio\" target=\"_blank\" rel=\"noopener\">Lifecycle Sorter</a></p>\n<p>可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序，快捷键Ctrl + alt + K</p>\n<p><a href=\"http://plugins.jetbrains.com/plugin/7275?pr=androidstudio\" target=\"_blank\" rel=\"noopener\">CodeGlance</a></p>\n<p>在右边可以预览代码，实现快速定位</p>\n<p><a href=\"https://github.com/square/dagger-intellij-plugin\" target=\"_blank\" rel=\"noopener\">dagger-intellij-plugin</a></p>\n<p>dagger可視化</p>\n<p><a href=\"http://plugins.jetbrains.com/plugin/7838?pr=androidstudio\" target=\"_blank\" rel=\"noopener\">JsonOnlineViewer</a></p>\n<p><a href=\"https://github.com/ligi/GradleDependenciesHelperPlugin\" target=\"_blank\" rel=\"noopener\">GradleDependenciesHelperPlugin</a></p>\n<p>maven gradle 依赖支持自动补全</p>\n<p><a href=\"https://github.com/zhonghanwen/AndroidProguardPlugin\" target=\"_blank\" rel=\"noopener\">AndroidProguardPlugin</a></p>\n<p><a href=\"https://github.com/JerzyPuchalski/Android-DPI-Calculator\" target=\"_blank\" rel=\"noopener\">Android-DPI-Calculator</a></p>\n<p>DPI计算插件</p>\n<p><a href=\"https://github.com/nicoulaj/idea-markdown\" target=\"_blank\" rel=\"noopener\">idea-markdown</a></p>\n<p>markdown插件</p>\n<p><a href=\"https://plugins.jetbrains.com/plugin/8006?pr=\" target=\"_blank\" rel=\"noopener\">Material Theme UI</a></p>\n<p>添加Material主题到你的AS</p>\n<p><a href=\"https://plugins.jetbrains.com/plugin/7495?pr=\" target=\"_blank\" rel=\"noopener\">.ignore</a></p>\n<p><a href=\"https://plugins.jetbrains.com/plugin/1065?pr=\" target=\"_blank\" rel=\"noopener\">CheckStyle-IDEA</a></p>\n<p>CheckStyle-IDEA 是一个检查代码风格的插件，比如像命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，你们可以遵从像Google Oracle 的Java 代码指南 ，当然也可以按照自己的规则来设置配置文件，从而有效约束你自己更好地遵循代码编写规范。</p>\n<p>google style</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;code_scheme name=&quot;GoogleStyle&quot;&gt;\n  &lt;option name=&quot;OTHER_INDENT_OPTIONS&quot;&gt;\n    &lt;value&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;USE_TAB_CHARACTER&quot; value=&quot;false&quot; /&gt;\n      &lt;option name=&quot;SMART_TABS&quot; value=&quot;false&quot; /&gt;\n      &lt;option name=&quot;LABEL_INDENT_SIZE&quot; value=&quot;0&quot; /&gt;\n      &lt;option name=&quot;LABEL_INDENT_ABSOLUTE&quot; value=&quot;false&quot; /&gt;\n      &lt;option name=&quot;USE_RELATIVE_INDENTS&quot; value=&quot;false&quot; /&gt;\n    &lt;/value&gt;\n  &lt;/option&gt;\n  &lt;option name=&quot;INSERT_INNER_CLASS_IMPORTS&quot; value=&quot;true&quot; /&gt;\n  &lt;option name=&quot;CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND&quot; value=&quot;999&quot; /&gt;\n  &lt;option name=&quot;NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND&quot; value=&quot;999&quot; /&gt;\n  &lt;option name=&quot;PACKAGES_TO_USE_IMPORT_ON_DEMAND&quot;&gt;\n    &lt;value /&gt;\n  &lt;/option&gt;\n  &lt;option name=&quot;IMPORT_LAYOUT_TABLE&quot;&gt;\n    &lt;value&gt;\n      &lt;package name=&quot;&quot; withSubpackages=&quot;true&quot; static=&quot;true&quot; /&gt;\n      &lt;emptyLine /&gt;\n      &lt;package name=&quot;&quot; withSubpackages=&quot;true&quot; static=&quot;false&quot; /&gt;\n    &lt;/value&gt;\n  &lt;/option&gt;\n  &lt;option name=&quot;RIGHT_MARGIN&quot; value=&quot;100&quot; /&gt;\n  &lt;option name=&quot;JD_ALIGN_PARAM_COMMENTS&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;JD_ALIGN_EXCEPTION_COMMENTS&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;JD_P_AT_EMPTY_LINES&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;JD_KEEP_EMPTY_PARAMETER&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;JD_KEEP_EMPTY_EXCEPTION&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;JD_KEEP_EMPTY_RETURN&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;KEEP_CONTROL_STATEMENT_IN_ONE_LINE&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;KEEP_BLANK_LINES_IN_CODE&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;BLANK_LINES_AFTER_CLASS_HEADER&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;ALIGN_MULTILINE_PARAMETERS&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;ALIGN_MULTILINE_FOR&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;CALL_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;METHOD_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;EXTENDS_LIST_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;THROWS_KEYWORD_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;METHOD_CALL_CHAIN_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;BINARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;BINARY_OPERATION_SIGN_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n  &lt;option name=&quot;TERNARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;TERNARY_OPERATION_SIGNS_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n  &lt;option name=&quot;FOR_STATEMENT_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;ARRAY_INITIALIZER_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;WRAP_COMMENTS&quot; value=&quot;true&quot; /&gt;\n  &lt;option name=&quot;IF_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n  &lt;option name=&quot;DOWHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n  &lt;option name=&quot;WHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n  &lt;option name=&quot;FOR_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n  &lt;AndroidXmlCodeStyleSettings&gt;\n    &lt;option name=&quot;USE_CUSTOM_SETTINGS&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;LAYOUT_SETTINGS&quot;&gt;\n      &lt;value&gt;\n        &lt;option name=&quot;INSERT_BLANK_LINE_BEFORE_TAG&quot; value=&quot;false&quot; /&gt;\n      &lt;/value&gt;\n    &lt;/option&gt;\n  &lt;/AndroidXmlCodeStyleSettings&gt;\n  &lt;JSCodeStyleSettings&gt;\n    &lt;option name=&quot;INDENT_CHAINED_CALLS&quot; value=&quot;false&quot; /&gt;\n  &lt;/JSCodeStyleSettings&gt;\n  &lt;Python&gt;\n    &lt;option name=&quot;USE_CONTINUATION_INDENT_FOR_ARGUMENTS&quot; value=&quot;true&quot; /&gt;\n  &lt;/Python&gt;\n  &lt;TypeScriptCodeStyleSettings&gt;\n    &lt;option name=&quot;INDENT_CHAINED_CALLS&quot; value=&quot;false&quot; /&gt;\n  &lt;/TypeScriptCodeStyleSettings&gt;\n  &lt;XML&gt;\n    &lt;option name=&quot;XML_ALIGN_ATTRIBUTES&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;XML_LEGACY_SETTINGS_IMPORTED&quot; value=&quot;true&quot; /&gt;\n  &lt;/XML&gt;\n  &lt;codeStyleSettings language=&quot;CSS&quot;&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;ECMA Script Level 4&quot;&gt;\n    &lt;option name=&quot;KEEP_BLANK_LINES_IN_CODE&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_PARAMETERS&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_FOR&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;CALL_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;METHOD_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;EXTENDS_LIST_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BINARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BINARY_OPERATION_SIGN_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;TERNARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;TERNARY_OPERATION_SIGNS_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;FOR_STATEMENT_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;ARRAY_INITIALIZER_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;IF_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;DOWHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;WHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;FOR_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;PARENT_SETTINGS_INSTALLED&quot; value=&quot;true&quot; /&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;HTML&quot;&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;JAVA&quot;&gt;\n    &lt;option name=&quot;KEEP_CONTROL_STATEMENT_IN_ONE_LINE&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;KEEP_BLANK_LINES_IN_CODE&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BLANK_LINES_AFTER_CLASS_HEADER&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_PARAMETERS&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_RESOURCES&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_FOR&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;CALL_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;METHOD_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;EXTENDS_LIST_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;THROWS_KEYWORD_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;METHOD_CALL_CHAIN_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BINARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BINARY_OPERATION_SIGN_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;TERNARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;TERNARY_OPERATION_SIGNS_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;FOR_STATEMENT_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;ARRAY_INITIALIZER_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;WRAP_COMMENTS&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;IF_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;DOWHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;WHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;FOR_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;PARENT_SETTINGS_INSTALLED&quot; value=&quot;true&quot; /&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;JSON&quot;&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;JavaScript&quot;&gt;\n    &lt;option name=&quot;RIGHT_MARGIN&quot; value=&quot;80&quot; /&gt;\n    &lt;option name=&quot;KEEP_BLANK_LINES_IN_CODE&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_PARAMETERS&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_FOR&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;CALL_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;METHOD_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BINARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BINARY_OPERATION_SIGN_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;TERNARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;TERNARY_OPERATION_SIGNS_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;FOR_STATEMENT_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;ARRAY_INITIALIZER_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;IF_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;DOWHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;WHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;FOR_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;PARENT_SETTINGS_INSTALLED&quot; value=&quot;true&quot; /&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;PROTO&quot;&gt;\n    &lt;option name=&quot;RIGHT_MARGIN&quot; value=&quot;80&quot; /&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;protobuf&quot;&gt;\n    &lt;option name=&quot;RIGHT_MARGIN&quot; value=&quot;80&quot; /&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;Python&quot;&gt;\n    &lt;option name=&quot;KEEP_BLANK_LINES_IN_CODE&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;RIGHT_MARGIN&quot; value=&quot;80&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_PARAMETERS&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;PARENT_SETTINGS_INSTALLED&quot; value=&quot;true&quot; /&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;SASS&quot;&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;SCSS&quot;&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;TypeScript&quot;&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;XML&quot;&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n    &lt;arrangement&gt;\n      &lt;rules&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;xmlns:android&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;^$&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;xmlns:.*&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;^$&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:id&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;style&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;^$&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;^$&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:.*Style&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_width&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_height&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_weight&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_margin&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_marginTop&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_marginBottom&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_marginStart&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_marginEnd&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_marginLeft&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_marginRight&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_.*&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:padding&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:paddingTop&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:paddingBottom&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:paddingStart&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:paddingEnd&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:paddingLeft&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:paddingRight&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*&lt;/NAME&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*&lt;/NAME&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res-auto&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*&lt;/NAME&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/tools&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*&lt;/NAME&gt;\n                &lt;XML_NAMESPACE&gt;.*&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n      &lt;/rules&gt;\n    &lt;/arrangement&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;Objective-C&gt;\n    &lt;option name=&quot;INDENT_NAMESPACE_MEMBERS&quot; value=&quot;0&quot; /&gt;\n    &lt;option name=&quot;INDENT_C_STRUCT_MEMBERS&quot; value=&quot;2&quot; /&gt;\n    &lt;option name=&quot;INDENT_CLASS_MEMBERS&quot; value=&quot;2&quot; /&gt;\n    &lt;option name=&quot;INDENT_VISIBILITY_KEYWORDS&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;INDENT_INSIDE_CODE_BLOCK&quot; value=&quot;2&quot; /&gt;\n    &lt;option name=&quot;KEEP_STRUCTURES_IN_ONE_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;FUNCTION_PARAMETERS_WRAP&quot; value=&quot;5&quot; /&gt;\n    &lt;option name=&quot;FUNCTION_CALL_ARGUMENTS_WRAP&quot; value=&quot;5&quot; /&gt;\n    &lt;option name=&quot;TEMPLATE_CALL_ARGUMENTS_WRAP&quot; value=&quot;5&quot; /&gt;\n    &lt;option name=&quot;TEMPLATE_CALL_ARGUMENTS_ALIGN_MULTILINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;ALIGN_INIT_LIST_IN_COLUMNS&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;SPACE_BEFORE_SUPERCLASS_COLON&quot; value=&quot;false&quot; /&gt;\n  &lt;/Objective-C&gt;\n  &lt;Objective-C-extensions&gt;\n    &lt;option name=&quot;GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES&quot; value=&quot;ASK&quot; /&gt;\n    &lt;option name=&quot;RELEASE_STYLE&quot; value=&quot;IVAR&quot; /&gt;\n    &lt;option name=&quot;TYPE_QUALIFIERS_PLACEMENT&quot; value=&quot;BEFORE&quot; /&gt;\n    &lt;file&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Import&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Macro&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Typedef&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Enum&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Constant&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Global&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Struct&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;FunctionPredecl&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Function&quot; /&gt;\n    &lt;/file&gt;\n    &lt;class&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Property&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Synthesize&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;InitMethod&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;StaticMethod&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;InstanceMethod&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;DeallocMethod&quot; /&gt;\n    &lt;/class&gt;\n    &lt;extensions&gt;\n      &lt;pair source=&quot;cc&quot; header=&quot;h&quot; /&gt;\n      &lt;pair source=&quot;c&quot; header=&quot;h&quot; /&gt;\n    &lt;/extensions&gt;\n  &lt;/Objective-C-extensions&gt;\n  &lt;codeStyleSettings language=&quot;ObjectiveC&quot;&gt;\n    &lt;option name=&quot;RIGHT_MARGIN&quot; value=&quot;80&quot; /&gt;\n    &lt;option name=&quot;KEEP_BLANK_LINES_BEFORE_RBRACE&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BLANK_LINES_BEFORE_IMPORTS&quot; value=&quot;0&quot; /&gt;\n    &lt;option name=&quot;BLANK_LINES_AFTER_IMPORTS&quot; value=&quot;0&quot; /&gt;\n    &lt;option name=&quot;BLANK_LINES_AROUND_CLASS&quot; value=&quot;0&quot; /&gt;\n    &lt;option name=&quot;BLANK_LINES_AROUND_METHOD&quot; value=&quot;0&quot; /&gt;\n    &lt;option name=&quot;BLANK_LINES_AROUND_METHOD_IN_INTERFACE&quot; value=&quot;0&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_BINARY_OPERATION&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;BINARY_OPERATION_SIGN_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;FOR_STATEMENT_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;ASSIGNMENT_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n&lt;/code_scheme&gt;\n</code></pre>\n<p>checkstyle</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE module PUBLIC\n          &quot;-//Puppy Crawl//DTD Check Configuration 1.3//EN&quot;\n          &quot;http://www.puppycrawl.com/dtds/configuration_1_3.dtd&quot;&gt;\n\n&lt;!--\n    Checkstyle configuration that checks the Google coding conventions from Google Java Style\n    that can be found at https://google.github.io/styleguide/javaguide.html.\n    Checkstyle is very configurable. Be sure to read the documentation at\n    http://checkstyle.sf.net (or in your downloaded distribution).\n    To completely disable a check, just comment it out or delete it from the file.\n    Authors: Max Vetrenko, Ruslan Diachenko, Roman Ivanov.\n --&gt;\n\n&lt;module name = &quot;Checker&quot;&gt;\n    &lt;property name=&quot;charset&quot; value=&quot;UTF-8&quot;/&gt;\n\n    &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt;\n\n    &lt;property name=&quot;fileExtensions&quot; value=&quot;java, properties, xml&quot;/&gt;\n    &lt;!-- Checks for whitespace                               --&gt;\n    &lt;!-- See http://checkstyle.sf.net/config_whitespace.html --&gt;\n        &lt;module name=&quot;FileTabCharacter&quot;&gt;\n            &lt;property name=&quot;eachLine&quot; value=&quot;true&quot;/&gt;\n        &lt;/module&gt;\n\n    &lt;module name=&quot;TreeWalker&quot;&gt;\n        &lt;module name=&quot;OuterTypeFilename&quot;/&gt;\n        &lt;module name=&quot;IllegalTokenText&quot;&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;STRING_LITERAL, CHAR_LITERAL&quot;/&gt;\n            &lt;property name=&quot;format&quot; value=&quot;\\\\u00(09|0(a|A)|0(c|C)|0(d|D)|22|27|5(C|c))|\\\\(0(10|11|12|14|15|42|47)|134)&quot;/&gt;\n            &lt;property name=&quot;message&quot; value=&quot;Consider using special escape sequence instead of octal value or Unicode escaped value.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;AvoidEscapedUnicodeCharacters&quot;&gt;\n            &lt;property name=&quot;allowEscapesForControlCharacters&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;allowByTailComment&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;allowNonPrintableEscapes&quot; value=&quot;true&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;LineLength&quot;&gt;\n            &lt;property name=&quot;max&quot; value=&quot;100&quot;/&gt;\n            &lt;property name=&quot;ignorePattern&quot; value=&quot;^package.*|^import.*|a href|href|http://|https://|ftp://&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;AvoidStarImport&quot;/&gt;\n        &lt;module name=&quot;OneTopLevelClass&quot;/&gt;\n        &lt;module name=&quot;NoLineWrap&quot;/&gt;\n        &lt;module name=&quot;EmptyBlock&quot;&gt;\n            &lt;property name=&quot;option&quot; value=&quot;TEXT&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;LITERAL_TRY, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_SWITCH&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;NeedBraces&quot;/&gt;\n        &lt;module name=&quot;LeftCurly&quot;&gt;\n            &lt;property name=&quot;maxLineLength&quot; value=&quot;100&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;RightCurly&quot;&gt;\n            &lt;property name=&quot;id&quot; value=&quot;RightCurlySame&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_DO&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;RightCurly&quot;&gt;\n            &lt;property name=&quot;id&quot; value=&quot;RightCurlyAlone&quot;/&gt;\n            &lt;property name=&quot;option&quot; value=&quot;alone&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;CLASS_DEF, METHOD_DEF, CTOR_DEF, LITERAL_FOR, LITERAL_WHILE, STATIC_INIT, INSTANCE_INIT&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;WhitespaceAround&quot;&gt;\n            &lt;property name=&quot;allowEmptyConstructors&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;allowEmptyMethods&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;allowEmptyTypes&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;allowEmptyLoops&quot; value=&quot;true&quot;/&gt;\n            &lt;message key=&quot;ws.notFollowed&quot;\n             value=&quot;WhitespaceAround: &#39;&#39;{0}&#39;&#39; is not followed by whitespace. Empty blocks may only be represented as &#39;{}&#39; when not part of a multi-block statement (4.1.3)&quot;/&gt;\n             &lt;message key=&quot;ws.notPreceded&quot;\n             value=&quot;WhitespaceAround: &#39;&#39;{0}&#39;&#39; is not preceded with whitespace.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;OneStatementPerLine&quot;/&gt;\n        &lt;module name=&quot;MultipleVariableDeclarations&quot;/&gt;\n        &lt;module name=&quot;ArrayTypeStyle&quot;/&gt;\n        &lt;module name=&quot;MissingSwitchDefault&quot;/&gt;\n        &lt;module name=&quot;FallThrough&quot;/&gt;\n        &lt;module name=&quot;UpperEll&quot;/&gt;\n        &lt;module name=&quot;ModifierOrder&quot;/&gt;\n        &lt;module name=&quot;EmptyLineSeparator&quot;&gt;\n            &lt;property name=&quot;allowNoEmptyLineBetweenFields&quot; value=&quot;true&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;SeparatorWrap&quot;&gt;\n            &lt;property name=&quot;id&quot; value=&quot;SeparatorWrapDot&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;DOT&quot;/&gt;\n            &lt;property name=&quot;option&quot; value=&quot;nl&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;SeparatorWrap&quot;&gt;\n            &lt;property name=&quot;id&quot; value=&quot;SeparatorWrapComma&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;COMMA&quot;/&gt;\n            &lt;property name=&quot;option&quot; value=&quot;EOL&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;PackageName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;^[a-z]+(\\.[a-z][a-z0-9]*)*$&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Package name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;TypeName&quot;&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Type name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;MemberName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;^[a-z][a-z0-9][a-zA-Z0-9]*$&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Member name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;ParameterName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;^[a-z]([a-z0-9][a-zA-Z0-9]*)?$&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Parameter name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;CatchParameterName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;^[a-z]([a-z0-9][a-zA-Z0-9]*)?$&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Catch parameter name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;LocalVariableName&quot;&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;VARIABLE_DEF&quot;/&gt;\n            &lt;property name=&quot;format&quot; value=&quot;^[a-z]([a-z0-9][a-zA-Z0-9]*)?$&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Local variable name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;ClassTypeParameterName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Class type name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;MethodTypeParameterName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Method type name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;InterfaceTypeParameterName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Interface type name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;NoFinalizer&quot;/&gt;\n        &lt;module name=&quot;GenericWhitespace&quot;&gt;\n            &lt;message key=&quot;ws.followed&quot;\n             value=&quot;GenericWhitespace &#39;&#39;{0}&#39;&#39; is followed by whitespace.&quot;/&gt;\n             &lt;message key=&quot;ws.preceded&quot;\n             value=&quot;GenericWhitespace &#39;&#39;{0}&#39;&#39; is preceded with whitespace.&quot;/&gt;\n             &lt;message key=&quot;ws.illegalFollow&quot;\n             value=&quot;GenericWhitespace &#39;&#39;{0}&#39;&#39; should followed by whitespace.&quot;/&gt;\n             &lt;message key=&quot;ws.notPreceded&quot;\n             value=&quot;GenericWhitespace &#39;&#39;{0}&#39;&#39; is not preceded with whitespace.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;Indentation&quot;&gt;\n            &lt;property name=&quot;basicOffset&quot; value=&quot;2&quot;/&gt;\n            &lt;property name=&quot;braceAdjustment&quot; value=&quot;0&quot;/&gt;\n            &lt;property name=&quot;caseIndent&quot; value=&quot;2&quot;/&gt;\n            &lt;property name=&quot;throwsIndent&quot; value=&quot;4&quot;/&gt;\n            &lt;property name=&quot;lineWrappingIndentation&quot; value=&quot;4&quot;/&gt;\n            &lt;property name=&quot;arrayInitIndent&quot; value=&quot;2&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;AbbreviationAsWordInName&quot;&gt;\n            &lt;property name=&quot;ignoreFinal&quot; value=&quot;false&quot;/&gt;\n            &lt;property name=&quot;allowedAbbreviationLength&quot; value=&quot;1&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;OverloadMethodsDeclarationOrder&quot;/&gt;\n        &lt;module name=&quot;VariableDeclarationUsageDistance&quot;/&gt;\n        &lt;module name=&quot;CustomImportOrder&quot;&gt;\n            &lt;property name=&quot;sortImportsInGroupAlphabetically&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;separateLineBetweenGroups&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;customImportOrderRules&quot; value=&quot;STATIC###THIRD_PARTY_PACKAGE&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;MethodParamPad&quot;/&gt;\n        &lt;module name=&quot;ParenPad&quot;/&gt;\n        &lt;module name=&quot;OperatorWrap&quot;&gt;\n            &lt;property name=&quot;option&quot; value=&quot;NL&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;BAND, BOR, BSR, BXOR, DIV, EQUAL, GE, GT, LAND, LE, LITERAL_INSTANCEOF, LOR, LT, MINUS, MOD, NOT_EQUAL, PLUS, QUESTION, SL, SR, STAR, METHOD_REF &quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;AnnotationLocation&quot;&gt;\n            &lt;property name=&quot;id&quot; value=&quot;AnnotationLocationMostCases&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;AnnotationLocation&quot;&gt;\n            &lt;property name=&quot;id&quot; value=&quot;AnnotationLocationVariables&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;VARIABLE_DEF&quot;/&gt;\n            &lt;property name=&quot;allowSamelineMultipleAnnotations&quot; value=&quot;true&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;NonEmptyAtclauseDescription&quot;/&gt;\n        &lt;module name=&quot;JavadocTagContinuationIndentation&quot;/&gt;\n        &lt;module name=&quot;SummaryJavadoc&quot;&gt;\n            &lt;property name=&quot;forbiddenSummaryFragments&quot; value=&quot;^@return the *|^This method returns |^A [{]@code [a-zA-Z0-9]+[}]( is a )&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;JavadocParagraph&quot;/&gt;\n        &lt;module name=&quot;AtclauseOrder&quot;&gt;\n            &lt;property name=&quot;tagOrder&quot; value=&quot;@param, @return, @throws, @deprecated&quot;/&gt;\n            &lt;property name=&quot;target&quot; value=&quot;CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF, VARIABLE_DEF&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;JavadocMethod&quot;&gt;\n            &lt;property name=&quot;scope&quot; value=&quot;public&quot;/&gt;\n            &lt;property name=&quot;allowMissingParamTags&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;allowMissingThrowsTags&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;allowMissingReturnTag&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;minLineCount&quot; value=&quot;2&quot;/&gt;\n            &lt;property name=&quot;allowedAnnotations&quot; value=&quot;Override, Test&quot;/&gt;\n            &lt;property name=&quot;allowThrowsTagsForSubclasses&quot; value=&quot;true&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;MethodName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;^[a-z][a-z0-9][a-zA-Z0-9_]*$&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Method name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;SingleLineJavadoc&quot;&gt;\n            &lt;property name=&quot;ignoreInlineTags&quot; value=&quot;false&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;EmptyCatchBlock&quot;&gt;\n            &lt;property name=&quot;exceptionVariableName&quot; value=&quot;expected&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;CommentsIndentation&quot;/&gt;\n    &lt;/module&gt;\n&lt;/module&gt;\n</code></pre>\n<p>LayoutFormatter</p>\n<p>此插件是XML格式化插件，自动排序，能够根据正确的排序顺序进行排序</p>\n<p>FindBugs-IDEA</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://ydmmocoo.github.io/2016/06/28/Android-Studio插件整理/\" target=\"_blank\" rel=\"noopener\">https://ydmmocoo.github.io/2016/06/28/Android-Studio插件整理/</a></p>\n<p><a href=\"http://plugins.jetbrains.com/plugin/7654?pr=androidstudio\" target=\"_blank\" rel=\"noopener\">GsonFormat</a></p>\n<p><a href=\"http://plugins.jetbrains.com/plugin/7595?pr=androidstudio\" target=\"_blank\" rel=\"noopener\">Android Code Generator</a></p>\n<p>根据布局文件快速生成对应的Activity，Fragment，Adapter，Menu。</p>\n<p><a href=\"http://plugins.jetbrains.com/plugin/7332?pr=androidstudio\" target=\"_blank\" rel=\"noopener\">Android Parcelable code generator</a></p>\n<p>JavaBean序列化，快速实现Parcelable接口。</p>\n<p><a href=\"http://plugins.jetbrains.com/plugin/7742?pr=androidstudio\" target=\"_blank\" rel=\"noopener\">Lifecycle Sorter</a></p>\n<p>可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序，快捷键Ctrl + alt + K</p>\n<p><a href=\"http://plugins.jetbrains.com/plugin/7275?pr=androidstudio\" target=\"_blank\" rel=\"noopener\">CodeGlance</a></p>\n<p>在右边可以预览代码，实现快速定位</p>\n<p><a href=\"https://github.com/square/dagger-intellij-plugin\" target=\"_blank\" rel=\"noopener\">dagger-intellij-plugin</a></p>\n<p>dagger可視化</p>\n<p><a href=\"http://plugins.jetbrains.com/plugin/7838?pr=androidstudio\" target=\"_blank\" rel=\"noopener\">JsonOnlineViewer</a></p>\n<p><a href=\"https://github.com/ligi/GradleDependenciesHelperPlugin\" target=\"_blank\" rel=\"noopener\">GradleDependenciesHelperPlugin</a></p>\n<p>maven gradle 依赖支持自动补全</p>\n<p><a href=\"https://github.com/zhonghanwen/AndroidProguardPlugin\" target=\"_blank\" rel=\"noopener\">AndroidProguardPlugin</a></p>\n<p><a href=\"https://github.com/JerzyPuchalski/Android-DPI-Calculator\" target=\"_blank\" rel=\"noopener\">Android-DPI-Calculator</a></p>\n<p>DPI计算插件</p>\n<p><a href=\"https://github.com/nicoulaj/idea-markdown\" target=\"_blank\" rel=\"noopener\">idea-markdown</a></p>\n<p>markdown插件</p>\n<p><a href=\"https://plugins.jetbrains.com/plugin/8006?pr=\" target=\"_blank\" rel=\"noopener\">Material Theme UI</a></p>\n<p>添加Material主题到你的AS</p>\n<p><a href=\"https://plugins.jetbrains.com/plugin/7495?pr=\" target=\"_blank\" rel=\"noopener\">.ignore</a></p>\n<p><a href=\"https://plugins.jetbrains.com/plugin/1065?pr=\" target=\"_blank\" rel=\"noopener\">CheckStyle-IDEA</a></p>\n<p>CheckStyle-IDEA 是一个检查代码风格的插件，比如像命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，你们可以遵从像Google Oracle 的Java 代码指南 ，当然也可以按照自己的规则来设置配置文件，从而有效约束你自己更好地遵循代码编写规范。</p>\n<p>google style</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;code_scheme name=&quot;GoogleStyle&quot;&gt;\n  &lt;option name=&quot;OTHER_INDENT_OPTIONS&quot;&gt;\n    &lt;value&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;USE_TAB_CHARACTER&quot; value=&quot;false&quot; /&gt;\n      &lt;option name=&quot;SMART_TABS&quot; value=&quot;false&quot; /&gt;\n      &lt;option name=&quot;LABEL_INDENT_SIZE&quot; value=&quot;0&quot; /&gt;\n      &lt;option name=&quot;LABEL_INDENT_ABSOLUTE&quot; value=&quot;false&quot; /&gt;\n      &lt;option name=&quot;USE_RELATIVE_INDENTS&quot; value=&quot;false&quot; /&gt;\n    &lt;/value&gt;\n  &lt;/option&gt;\n  &lt;option name=&quot;INSERT_INNER_CLASS_IMPORTS&quot; value=&quot;true&quot; /&gt;\n  &lt;option name=&quot;CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND&quot; value=&quot;999&quot; /&gt;\n  &lt;option name=&quot;NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND&quot; value=&quot;999&quot; /&gt;\n  &lt;option name=&quot;PACKAGES_TO_USE_IMPORT_ON_DEMAND&quot;&gt;\n    &lt;value /&gt;\n  &lt;/option&gt;\n  &lt;option name=&quot;IMPORT_LAYOUT_TABLE&quot;&gt;\n    &lt;value&gt;\n      &lt;package name=&quot;&quot; withSubpackages=&quot;true&quot; static=&quot;true&quot; /&gt;\n      &lt;emptyLine /&gt;\n      &lt;package name=&quot;&quot; withSubpackages=&quot;true&quot; static=&quot;false&quot; /&gt;\n    &lt;/value&gt;\n  &lt;/option&gt;\n  &lt;option name=&quot;RIGHT_MARGIN&quot; value=&quot;100&quot; /&gt;\n  &lt;option name=&quot;JD_ALIGN_PARAM_COMMENTS&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;JD_ALIGN_EXCEPTION_COMMENTS&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;JD_P_AT_EMPTY_LINES&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;JD_KEEP_EMPTY_PARAMETER&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;JD_KEEP_EMPTY_EXCEPTION&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;JD_KEEP_EMPTY_RETURN&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;KEEP_CONTROL_STATEMENT_IN_ONE_LINE&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;KEEP_BLANK_LINES_IN_CODE&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;BLANK_LINES_AFTER_CLASS_HEADER&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;ALIGN_MULTILINE_PARAMETERS&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;ALIGN_MULTILINE_FOR&quot; value=&quot;false&quot; /&gt;\n  &lt;option name=&quot;CALL_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;METHOD_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;EXTENDS_LIST_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;THROWS_KEYWORD_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;METHOD_CALL_CHAIN_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;BINARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;BINARY_OPERATION_SIGN_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n  &lt;option name=&quot;TERNARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;TERNARY_OPERATION_SIGNS_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n  &lt;option name=&quot;FOR_STATEMENT_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;ARRAY_INITIALIZER_WRAP&quot; value=&quot;1&quot; /&gt;\n  &lt;option name=&quot;WRAP_COMMENTS&quot; value=&quot;true&quot; /&gt;\n  &lt;option name=&quot;IF_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n  &lt;option name=&quot;DOWHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n  &lt;option name=&quot;WHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n  &lt;option name=&quot;FOR_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n  &lt;AndroidXmlCodeStyleSettings&gt;\n    &lt;option name=&quot;USE_CUSTOM_SETTINGS&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;LAYOUT_SETTINGS&quot;&gt;\n      &lt;value&gt;\n        &lt;option name=&quot;INSERT_BLANK_LINE_BEFORE_TAG&quot; value=&quot;false&quot; /&gt;\n      &lt;/value&gt;\n    &lt;/option&gt;\n  &lt;/AndroidXmlCodeStyleSettings&gt;\n  &lt;JSCodeStyleSettings&gt;\n    &lt;option name=&quot;INDENT_CHAINED_CALLS&quot; value=&quot;false&quot; /&gt;\n  &lt;/JSCodeStyleSettings&gt;\n  &lt;Python&gt;\n    &lt;option name=&quot;USE_CONTINUATION_INDENT_FOR_ARGUMENTS&quot; value=&quot;true&quot; /&gt;\n  &lt;/Python&gt;\n  &lt;TypeScriptCodeStyleSettings&gt;\n    &lt;option name=&quot;INDENT_CHAINED_CALLS&quot; value=&quot;false&quot; /&gt;\n  &lt;/TypeScriptCodeStyleSettings&gt;\n  &lt;XML&gt;\n    &lt;option name=&quot;XML_ALIGN_ATTRIBUTES&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;XML_LEGACY_SETTINGS_IMPORTED&quot; value=&quot;true&quot; /&gt;\n  &lt;/XML&gt;\n  &lt;codeStyleSettings language=&quot;CSS&quot;&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;ECMA Script Level 4&quot;&gt;\n    &lt;option name=&quot;KEEP_BLANK_LINES_IN_CODE&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_PARAMETERS&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_FOR&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;CALL_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;METHOD_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;EXTENDS_LIST_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BINARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BINARY_OPERATION_SIGN_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;TERNARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;TERNARY_OPERATION_SIGNS_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;FOR_STATEMENT_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;ARRAY_INITIALIZER_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;IF_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;DOWHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;WHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;FOR_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;PARENT_SETTINGS_INSTALLED&quot; value=&quot;true&quot; /&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;HTML&quot;&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;JAVA&quot;&gt;\n    &lt;option name=&quot;KEEP_CONTROL_STATEMENT_IN_ONE_LINE&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;KEEP_BLANK_LINES_IN_CODE&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BLANK_LINES_AFTER_CLASS_HEADER&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_PARAMETERS&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_RESOURCES&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_FOR&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;CALL_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;METHOD_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;EXTENDS_LIST_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;THROWS_KEYWORD_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;METHOD_CALL_CHAIN_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BINARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BINARY_OPERATION_SIGN_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;TERNARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;TERNARY_OPERATION_SIGNS_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;FOR_STATEMENT_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;ARRAY_INITIALIZER_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;WRAP_COMMENTS&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;IF_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;DOWHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;WHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;FOR_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;PARENT_SETTINGS_INSTALLED&quot; value=&quot;true&quot; /&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;JSON&quot;&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;JavaScript&quot;&gt;\n    &lt;option name=&quot;RIGHT_MARGIN&quot; value=&quot;80&quot; /&gt;\n    &lt;option name=&quot;KEEP_BLANK_LINES_IN_CODE&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_PARAMETERS&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_FOR&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;CALL_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;METHOD_PARAMETERS_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BINARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BINARY_OPERATION_SIGN_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;TERNARY_OPERATION_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;TERNARY_OPERATION_SIGNS_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;FOR_STATEMENT_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;ARRAY_INITIALIZER_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;IF_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;DOWHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;WHILE_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;FOR_BRACE_FORCE&quot; value=&quot;3&quot; /&gt;\n    &lt;option name=&quot;PARENT_SETTINGS_INSTALLED&quot; value=&quot;true&quot; /&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;PROTO&quot;&gt;\n    &lt;option name=&quot;RIGHT_MARGIN&quot; value=&quot;80&quot; /&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;protobuf&quot;&gt;\n    &lt;option name=&quot;RIGHT_MARGIN&quot; value=&quot;80&quot; /&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;Python&quot;&gt;\n    &lt;option name=&quot;KEEP_BLANK_LINES_IN_CODE&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;RIGHT_MARGIN&quot; value=&quot;80&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_PARAMETERS&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;PARENT_SETTINGS_INSTALLED&quot; value=&quot;true&quot; /&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;SASS&quot;&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;SCSS&quot;&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;TypeScript&quot;&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;codeStyleSettings language=&quot;XML&quot;&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;TAB_SIZE&quot; value=&quot;2&quot; /&gt;\n    &lt;/indentOptions&gt;\n    &lt;arrangement&gt;\n      &lt;rules&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;xmlns:android&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;^$&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;xmlns:.*&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;^$&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:id&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;style&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;^$&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;^$&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:.*Style&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_width&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_height&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_weight&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_margin&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_marginTop&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_marginBottom&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_marginStart&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_marginEnd&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_marginLeft&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_marginRight&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:layout_.*&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:padding&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:paddingTop&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:paddingBottom&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:paddingStart&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:paddingEnd&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:paddingLeft&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*:paddingRight&lt;/NAME&gt;\n                &lt;XML_ATTRIBUTE /&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*&lt;/NAME&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res/android&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*&lt;/NAME&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/apk/res-auto&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*&lt;/NAME&gt;\n                &lt;XML_NAMESPACE&gt;http://schemas.android.com/tools&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n        &lt;section&gt;\n          &lt;rule&gt;\n            &lt;match&gt;\n              &lt;AND&gt;\n                &lt;NAME&gt;.*&lt;/NAME&gt;\n                &lt;XML_NAMESPACE&gt;.*&lt;/XML_NAMESPACE&gt;\n              &lt;/AND&gt;\n            &lt;/match&gt;\n            &lt;order&gt;BY_NAME&lt;/order&gt;\n          &lt;/rule&gt;\n        &lt;/section&gt;\n      &lt;/rules&gt;\n    &lt;/arrangement&gt;\n  &lt;/codeStyleSettings&gt;\n  &lt;Objective-C&gt;\n    &lt;option name=&quot;INDENT_NAMESPACE_MEMBERS&quot; value=&quot;0&quot; /&gt;\n    &lt;option name=&quot;INDENT_C_STRUCT_MEMBERS&quot; value=&quot;2&quot; /&gt;\n    &lt;option name=&quot;INDENT_CLASS_MEMBERS&quot; value=&quot;2&quot; /&gt;\n    &lt;option name=&quot;INDENT_VISIBILITY_KEYWORDS&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;INDENT_INSIDE_CODE_BLOCK&quot; value=&quot;2&quot; /&gt;\n    &lt;option name=&quot;KEEP_STRUCTURES_IN_ONE_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;FUNCTION_PARAMETERS_WRAP&quot; value=&quot;5&quot; /&gt;\n    &lt;option name=&quot;FUNCTION_CALL_ARGUMENTS_WRAP&quot; value=&quot;5&quot; /&gt;\n    &lt;option name=&quot;TEMPLATE_CALL_ARGUMENTS_WRAP&quot; value=&quot;5&quot; /&gt;\n    &lt;option name=&quot;TEMPLATE_CALL_ARGUMENTS_ALIGN_MULTILINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;ALIGN_INIT_LIST_IN_COLUMNS&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;SPACE_BEFORE_SUPERCLASS_COLON&quot; value=&quot;false&quot; /&gt;\n  &lt;/Objective-C&gt;\n  &lt;Objective-C-extensions&gt;\n    &lt;option name=&quot;GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES&quot; value=&quot;ASK&quot; /&gt;\n    &lt;option name=&quot;RELEASE_STYLE&quot; value=&quot;IVAR&quot; /&gt;\n    &lt;option name=&quot;TYPE_QUALIFIERS_PLACEMENT&quot; value=&quot;BEFORE&quot; /&gt;\n    &lt;file&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Import&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Macro&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Typedef&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Enum&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Constant&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Global&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Struct&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;FunctionPredecl&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Function&quot; /&gt;\n    &lt;/file&gt;\n    &lt;class&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Property&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;Synthesize&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;InitMethod&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;StaticMethod&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;InstanceMethod&quot; /&gt;\n      &lt;option name=&quot;com.jetbrains.cidr.lang.util.OCDeclarationKind&quot; value=&quot;DeallocMethod&quot; /&gt;\n    &lt;/class&gt;\n    &lt;extensions&gt;\n      &lt;pair source=&quot;cc&quot; header=&quot;h&quot; /&gt;\n      &lt;pair source=&quot;c&quot; header=&quot;h&quot; /&gt;\n    &lt;/extensions&gt;\n  &lt;/Objective-C-extensions&gt;\n  &lt;codeStyleSettings language=&quot;ObjectiveC&quot;&gt;\n    &lt;option name=&quot;RIGHT_MARGIN&quot; value=&quot;80&quot; /&gt;\n    &lt;option name=&quot;KEEP_BLANK_LINES_BEFORE_RBRACE&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;BLANK_LINES_BEFORE_IMPORTS&quot; value=&quot;0&quot; /&gt;\n    &lt;option name=&quot;BLANK_LINES_AFTER_IMPORTS&quot; value=&quot;0&quot; /&gt;\n    &lt;option name=&quot;BLANK_LINES_AROUND_CLASS&quot; value=&quot;0&quot; /&gt;\n    &lt;option name=&quot;BLANK_LINES_AROUND_METHOD&quot; value=&quot;0&quot; /&gt;\n    &lt;option name=&quot;BLANK_LINES_AROUND_METHOD_IN_INTERFACE&quot; value=&quot;0&quot; /&gt;\n    &lt;option name=&quot;ALIGN_MULTILINE_BINARY_OPERATION&quot; value=&quot;false&quot; /&gt;\n    &lt;option name=&quot;BINARY_OPERATION_SIGN_ON_NEXT_LINE&quot; value=&quot;true&quot; /&gt;\n    &lt;option name=&quot;FOR_STATEMENT_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;option name=&quot;ASSIGNMENT_WRAP&quot; value=&quot;1&quot; /&gt;\n    &lt;indentOptions&gt;\n      &lt;option name=&quot;INDENT_SIZE&quot; value=&quot;2&quot; /&gt;\n      &lt;option name=&quot;CONTINUATION_INDENT_SIZE&quot; value=&quot;4&quot; /&gt;\n    &lt;/indentOptions&gt;\n  &lt;/codeStyleSettings&gt;\n&lt;/code_scheme&gt;\n</code></pre>\n<p>checkstyle</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE module PUBLIC\n          &quot;-//Puppy Crawl//DTD Check Configuration 1.3//EN&quot;\n          &quot;http://www.puppycrawl.com/dtds/configuration_1_3.dtd&quot;&gt;\n\n&lt;!--\n    Checkstyle configuration that checks the Google coding conventions from Google Java Style\n    that can be found at https://google.github.io/styleguide/javaguide.html.\n    Checkstyle is very configurable. Be sure to read the documentation at\n    http://checkstyle.sf.net (or in your downloaded distribution).\n    To completely disable a check, just comment it out or delete it from the file.\n    Authors: Max Vetrenko, Ruslan Diachenko, Roman Ivanov.\n --&gt;\n\n&lt;module name = &quot;Checker&quot;&gt;\n    &lt;property name=&quot;charset&quot; value=&quot;UTF-8&quot;/&gt;\n\n    &lt;property name=&quot;severity&quot; value=&quot;warning&quot;/&gt;\n\n    &lt;property name=&quot;fileExtensions&quot; value=&quot;java, properties, xml&quot;/&gt;\n    &lt;!-- Checks for whitespace                               --&gt;\n    &lt;!-- See http://checkstyle.sf.net/config_whitespace.html --&gt;\n        &lt;module name=&quot;FileTabCharacter&quot;&gt;\n            &lt;property name=&quot;eachLine&quot; value=&quot;true&quot;/&gt;\n        &lt;/module&gt;\n\n    &lt;module name=&quot;TreeWalker&quot;&gt;\n        &lt;module name=&quot;OuterTypeFilename&quot;/&gt;\n        &lt;module name=&quot;IllegalTokenText&quot;&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;STRING_LITERAL, CHAR_LITERAL&quot;/&gt;\n            &lt;property name=&quot;format&quot; value=&quot;\\\\u00(09|0(a|A)|0(c|C)|0(d|D)|22|27|5(C|c))|\\\\(0(10|11|12|14|15|42|47)|134)&quot;/&gt;\n            &lt;property name=&quot;message&quot; value=&quot;Consider using special escape sequence instead of octal value or Unicode escaped value.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;AvoidEscapedUnicodeCharacters&quot;&gt;\n            &lt;property name=&quot;allowEscapesForControlCharacters&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;allowByTailComment&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;allowNonPrintableEscapes&quot; value=&quot;true&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;LineLength&quot;&gt;\n            &lt;property name=&quot;max&quot; value=&quot;100&quot;/&gt;\n            &lt;property name=&quot;ignorePattern&quot; value=&quot;^package.*|^import.*|a href|href|http://|https://|ftp://&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;AvoidStarImport&quot;/&gt;\n        &lt;module name=&quot;OneTopLevelClass&quot;/&gt;\n        &lt;module name=&quot;NoLineWrap&quot;/&gt;\n        &lt;module name=&quot;EmptyBlock&quot;&gt;\n            &lt;property name=&quot;option&quot; value=&quot;TEXT&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;LITERAL_TRY, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_SWITCH&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;NeedBraces&quot;/&gt;\n        &lt;module name=&quot;LeftCurly&quot;&gt;\n            &lt;property name=&quot;maxLineLength&quot; value=&quot;100&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;RightCurly&quot;&gt;\n            &lt;property name=&quot;id&quot; value=&quot;RightCurlySame&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;LITERAL_TRY, LITERAL_CATCH, LITERAL_FINALLY, LITERAL_IF, LITERAL_ELSE, LITERAL_DO&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;RightCurly&quot;&gt;\n            &lt;property name=&quot;id&quot; value=&quot;RightCurlyAlone&quot;/&gt;\n            &lt;property name=&quot;option&quot; value=&quot;alone&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;CLASS_DEF, METHOD_DEF, CTOR_DEF, LITERAL_FOR, LITERAL_WHILE, STATIC_INIT, INSTANCE_INIT&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;WhitespaceAround&quot;&gt;\n            &lt;property name=&quot;allowEmptyConstructors&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;allowEmptyMethods&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;allowEmptyTypes&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;allowEmptyLoops&quot; value=&quot;true&quot;/&gt;\n            &lt;message key=&quot;ws.notFollowed&quot;\n             value=&quot;WhitespaceAround: &#39;&#39;{0}&#39;&#39; is not followed by whitespace. Empty blocks may only be represented as &#39;{}&#39; when not part of a multi-block statement (4.1.3)&quot;/&gt;\n             &lt;message key=&quot;ws.notPreceded&quot;\n             value=&quot;WhitespaceAround: &#39;&#39;{0}&#39;&#39; is not preceded with whitespace.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;OneStatementPerLine&quot;/&gt;\n        &lt;module name=&quot;MultipleVariableDeclarations&quot;/&gt;\n        &lt;module name=&quot;ArrayTypeStyle&quot;/&gt;\n        &lt;module name=&quot;MissingSwitchDefault&quot;/&gt;\n        &lt;module name=&quot;FallThrough&quot;/&gt;\n        &lt;module name=&quot;UpperEll&quot;/&gt;\n        &lt;module name=&quot;ModifierOrder&quot;/&gt;\n        &lt;module name=&quot;EmptyLineSeparator&quot;&gt;\n            &lt;property name=&quot;allowNoEmptyLineBetweenFields&quot; value=&quot;true&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;SeparatorWrap&quot;&gt;\n            &lt;property name=&quot;id&quot; value=&quot;SeparatorWrapDot&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;DOT&quot;/&gt;\n            &lt;property name=&quot;option&quot; value=&quot;nl&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;SeparatorWrap&quot;&gt;\n            &lt;property name=&quot;id&quot; value=&quot;SeparatorWrapComma&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;COMMA&quot;/&gt;\n            &lt;property name=&quot;option&quot; value=&quot;EOL&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;PackageName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;^[a-z]+(\\.[a-z][a-z0-9]*)*$&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Package name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;TypeName&quot;&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Type name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;MemberName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;^[a-z][a-z0-9][a-zA-Z0-9]*$&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Member name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;ParameterName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;^[a-z]([a-z0-9][a-zA-Z0-9]*)?$&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Parameter name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;CatchParameterName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;^[a-z]([a-z0-9][a-zA-Z0-9]*)?$&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Catch parameter name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;LocalVariableName&quot;&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;VARIABLE_DEF&quot;/&gt;\n            &lt;property name=&quot;format&quot; value=&quot;^[a-z]([a-z0-9][a-zA-Z0-9]*)?$&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Local variable name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;ClassTypeParameterName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Class type name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;MethodTypeParameterName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Method type name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;InterfaceTypeParameterName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;(^[A-Z][0-9]?)$|([A-Z][a-zA-Z0-9]*[T]$)&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Interface type name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;NoFinalizer&quot;/&gt;\n        &lt;module name=&quot;GenericWhitespace&quot;&gt;\n            &lt;message key=&quot;ws.followed&quot;\n             value=&quot;GenericWhitespace &#39;&#39;{0}&#39;&#39; is followed by whitespace.&quot;/&gt;\n             &lt;message key=&quot;ws.preceded&quot;\n             value=&quot;GenericWhitespace &#39;&#39;{0}&#39;&#39; is preceded with whitespace.&quot;/&gt;\n             &lt;message key=&quot;ws.illegalFollow&quot;\n             value=&quot;GenericWhitespace &#39;&#39;{0}&#39;&#39; should followed by whitespace.&quot;/&gt;\n             &lt;message key=&quot;ws.notPreceded&quot;\n             value=&quot;GenericWhitespace &#39;&#39;{0}&#39;&#39; is not preceded with whitespace.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;Indentation&quot;&gt;\n            &lt;property name=&quot;basicOffset&quot; value=&quot;2&quot;/&gt;\n            &lt;property name=&quot;braceAdjustment&quot; value=&quot;0&quot;/&gt;\n            &lt;property name=&quot;caseIndent&quot; value=&quot;2&quot;/&gt;\n            &lt;property name=&quot;throwsIndent&quot; value=&quot;4&quot;/&gt;\n            &lt;property name=&quot;lineWrappingIndentation&quot; value=&quot;4&quot;/&gt;\n            &lt;property name=&quot;arrayInitIndent&quot; value=&quot;2&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;AbbreviationAsWordInName&quot;&gt;\n            &lt;property name=&quot;ignoreFinal&quot; value=&quot;false&quot;/&gt;\n            &lt;property name=&quot;allowedAbbreviationLength&quot; value=&quot;1&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;OverloadMethodsDeclarationOrder&quot;/&gt;\n        &lt;module name=&quot;VariableDeclarationUsageDistance&quot;/&gt;\n        &lt;module name=&quot;CustomImportOrder&quot;&gt;\n            &lt;property name=&quot;sortImportsInGroupAlphabetically&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;separateLineBetweenGroups&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;customImportOrderRules&quot; value=&quot;STATIC###THIRD_PARTY_PACKAGE&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;MethodParamPad&quot;/&gt;\n        &lt;module name=&quot;ParenPad&quot;/&gt;\n        &lt;module name=&quot;OperatorWrap&quot;&gt;\n            &lt;property name=&quot;option&quot; value=&quot;NL&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;BAND, BOR, BSR, BXOR, DIV, EQUAL, GE, GT, LAND, LE, LITERAL_INSTANCEOF, LOR, LT, MINUS, MOD, NOT_EQUAL, PLUS, QUESTION, SL, SR, STAR, METHOD_REF &quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;AnnotationLocation&quot;&gt;\n            &lt;property name=&quot;id&quot; value=&quot;AnnotationLocationMostCases&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;AnnotationLocation&quot;&gt;\n            &lt;property name=&quot;id&quot; value=&quot;AnnotationLocationVariables&quot;/&gt;\n            &lt;property name=&quot;tokens&quot; value=&quot;VARIABLE_DEF&quot;/&gt;\n            &lt;property name=&quot;allowSamelineMultipleAnnotations&quot; value=&quot;true&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;NonEmptyAtclauseDescription&quot;/&gt;\n        &lt;module name=&quot;JavadocTagContinuationIndentation&quot;/&gt;\n        &lt;module name=&quot;SummaryJavadoc&quot;&gt;\n            &lt;property name=&quot;forbiddenSummaryFragments&quot; value=&quot;^@return the *|^This method returns |^A [{]@code [a-zA-Z0-9]+[}]( is a )&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;JavadocParagraph&quot;/&gt;\n        &lt;module name=&quot;AtclauseOrder&quot;&gt;\n            &lt;property name=&quot;tagOrder&quot; value=&quot;@param, @return, @throws, @deprecated&quot;/&gt;\n            &lt;property name=&quot;target&quot; value=&quot;CLASS_DEF, INTERFACE_DEF, ENUM_DEF, METHOD_DEF, CTOR_DEF, VARIABLE_DEF&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;JavadocMethod&quot;&gt;\n            &lt;property name=&quot;scope&quot; value=&quot;public&quot;/&gt;\n            &lt;property name=&quot;allowMissingParamTags&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;allowMissingThrowsTags&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;allowMissingReturnTag&quot; value=&quot;true&quot;/&gt;\n            &lt;property name=&quot;minLineCount&quot; value=&quot;2&quot;/&gt;\n            &lt;property name=&quot;allowedAnnotations&quot; value=&quot;Override, Test&quot;/&gt;\n            &lt;property name=&quot;allowThrowsTagsForSubclasses&quot; value=&quot;true&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;MethodName&quot;&gt;\n            &lt;property name=&quot;format&quot; value=&quot;^[a-z][a-z0-9][a-zA-Z0-9_]*$&quot;/&gt;\n            &lt;message key=&quot;name.invalidPattern&quot;\n             value=&quot;Method name &#39;&#39;{0}&#39;&#39; must match pattern &#39;&#39;{1}&#39;&#39;.&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;SingleLineJavadoc&quot;&gt;\n            &lt;property name=&quot;ignoreInlineTags&quot; value=&quot;false&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;EmptyCatchBlock&quot;&gt;\n            &lt;property name=&quot;exceptionVariableName&quot; value=&quot;expected&quot;/&gt;\n        &lt;/module&gt;\n        &lt;module name=&quot;CommentsIndentation&quot;/&gt;\n    &lt;/module&gt;\n&lt;/module&gt;\n</code></pre>\n<p>LayoutFormatter</p>\n<p>此插件是XML格式化插件，自动排序，能够根据正确的排序顺序进行排序</p>\n<p>FindBugs-IDEA</p>\n"},{"title":"Android Code Style","date":"2018-10-02T01:09:09.000Z","_content":"## Android參考規範\n\n[https://google.github.io/styleguide/javaguide.html](https://google.github.io/styleguide/javaguide.html)\n\n### 基本的命名法\n\nJava編程比較常見的有下面三種命名方式\n\n1.駝峰\\(Camel\\)命名法:又稱小駝峰命名法，除首單詞外，其余所有單詞的第一個字母大寫。\n\n2.帕斯卡\\(pascal\\)命名法:又稱大駝峰命名法，所有單詞的第一個字母大寫\n\n3.下劃線命名法:單詞與單詞間用下劃線做間隔\n\n一般建議拿來做命名的單詞要比較精悍短小，這樣即使兩三個單詞一起拼裝成一個命名，也不至於顯得很冗長。當然有些單詞我們也可以直接寫成一些約定俗成的縮寫。諸如：msg\\(message\\)、init\\(initial\\)、img\\(image\\)等.....\n\n個人認為，這些縮寫可參照業界常見的縮寫命名，也可以根據當前項目中的風格，進行團隊成員間的約定。這樣相對比較靈活，也方便團隊成員之間相互理解。\n\n### 包命名\n\n采用反域名命名規則，全部使用小寫字母，一般為3層\n\n一級包名為com;\n\n二級包名為xx（可以是公司或則個人的隨便）;\n\n三級包名應用的英文名app\\_name;\n\n四級包名為模塊名或層級名;\n\n如：www.ziines.com\n\n正常-&gt;com.ziines.www\n\n參考-&gt;com.ziines.android或com.ziines.it\n\n如：framework.com.hk\n\n正常-&gt;hk.nmg.framework\n\n| 命名格式 | 作用 |\n| :--- | :--- |\n| com.xx.app\\_name.activities\\(或com.xx.app\\_name.activity\\) | 存放app所有的Activity |\n| com.xx.app\\_name.service | 存放app所有的Service |\n| com.xx.app\\_name.receiver | 存放app所有的BroadcastReceiver |\n| com.xx.app\\_name.provider | 存放app所有的ContentProvider |\n| com.xx.app\\_name.fragment | 存放app所有的Fragment |\n| com.xx.app\\_name.dialog | 存放app所有的Dialog |\n| com.xx.app\\_name.base | 存放app一些共有的基礎模塊，諸如BaseActivity、BaseContentProvider、BaseService，BaseFragment等 |\n| com.xx.app\\_name.utils | 存放app的工具類,諸如格式化日期的DateFormatUtils，處理字符串的StringUtils等 |\n| com.xx.app\\_name.bean\\(或com.xx.app\\_name.unity\\) | 存放app自定義的實體類 |\n| com.xx.app\\_name.db\\) | 存放app數據庫操作相關的類 |\n| com.xx.app\\_name.view\\) | 存放app自定義的控件 |\n| com.xx.app\\_name.adapter\\) | 存放app所有的適配器類 |\n\n### 類命名\n\n| 類 | 命名格式 | 示例 |\n| :--- | :--- | :--- |\n| Activity | XXX功能+Activity | 如主界面HomeActivity,啟動頁LauncherActivity |\n| Service | XXX功能+Service | 如消息推送的Service，PushService或PushMessageService |\n| BroadcastReceiver | XXX功能+Receiver | 如在線的消息廣播接受者，OnlineReceiver |\n| ContentProvider | XXX功能+Provider | 如聯系人的內容提供者，ContactsProvider |\n| Fragment | XXX功能+Fragment | 如顯示聯系人的Fragment，ContactsFragment |\n| Dialog | XXX功能+Dialog | 如普通的選擇提示對話框，ChoiceDialog |\n| Adapter | XXX功能+XX类型控件Adapter | 如聯系人列表，ContactsListAdapter |\n| 基础功能类 | Base+XX父类名 | 如BaseActivity，BaseFragment |\n| 工具类 | XXX功能+Utils | 如處理字符串的工具類，StringUtils |\n| 管理类 | XXX功能+Manager | 如管理聯系人的類，ContactsManager |\n\n### 接口命名\n\n和類名基本一致。也可以在接口名前面再加一個大寫的I，表明這是一個接口Interface。\n\n### 方法\n\n動詞或動名詞，采用小駝峰命名法。\n\n| 命名風格 | 含義 |\n| :--- | :--- |\n| initXX\\(\\) | 初始化，如初始化所有控件initView\\(\\) |\n| isXX\\(\\) | 是否滿足某種要求，如是否為註冊用戶isRegister\\(\\) |\n| processXX\\(\\) | 對數據做某些處理，可以以process作為前綴 |\n| displayXX\\(\\) | 顯示提示信息，如displayXXDialog，displayToast，displayXXPopupWindow |\n| saveXX\\(\\) | 保存XX數據 |\n| resetXX\\(\\) | 重置XX數據 |\n| addXX\\(\\)/insertXX\\(\\) | 添加XX數據 |\n| deleteXX\\(\\)/removeXX\\(\\) | 刪除XX數據 |\n| updateXX\\(\\) | 更新XX數據 |\n| searchXX\\(\\)/findXX\\(\\)/queryXX\\(\\) | 查找XX數據 |\n| draw\\(\\) | 控件裏面使用居多，例如繪制文本drawText |\n\n### 變量\n\n采采用小駝峰命名法。同樣比較簡單，但為了更好表明含義，我建議做一下的的區分\n\n成員變量命名前面加m（member，表示成員變量之意），如，控件的寬高 mWidth，mHeight\n\n靜態類變量前面加s（static，表示靜態變量之意），如，一個靜態的單例 sSingleInstance\n\n### 常量\n\n同樣較為簡單，全部大寫,采用下劃線命名法.如：MIN\\_WIDTH,MAX\\_SIZE\n\n### 布局資源文件\\(layout文件夾下\\)\n\n全部小寫，采用下劃線命名法\n\n| 布局類型 | 命名風格 |\n| :--- | :--- |\n| Activity的xml布局 | activity\\_+XX功能，如主頁面activity\\_home |\n| Fragment的xml布局 | fragment\\_+XX功能，如聯繫人模塊fragment\\_contacts |\n| Dialog的xml布局 | dialog\\_+XX功能，如選擇日期dialog\\_select\\_date |\n| 抽取出來重用的xml布局（include） | include\\_+XX功能，如底部tab欄include\\_bottom\\_tabs |\n| ListView或者RecyclerView的item xml布局 | XX功能+\\_list\\_item，如聯繫人的contact\\_info\\_list\\_item |\n| GridView的item xml布局 | XX功能+\\_grid\\_item，如相冊的album\\_grid\\_item |\n\n### 動畫資源文件\\(anim文件夾下\\)\n\n全部小寫，采用下劃線命名法，加前綴區分.\n\n| 動畫效果 | 命名風格 |\n| :--- | :--- |\n| 淡入/淡出 | fade\\_in/fade\\_out |\n| 从某個方向淡入/淡出 | fade\\_方向\\_in\\(out\\),右边淡入淡出fade\\_right\\_in\\(out\\) |\n| 从某個方向彈入/彈出 | push\\_方向\\_in\\(out\\),右边推入推出push\\_right\\_in\\(out\\) |\n| 从某個方向滑入/滑出 | slide\\_in\\(out\\)_from_方向,右边滑入滑出slide\\_in\\(out\\)\\_from\\_right |\n\n### strings和colors資源文件\n\n小駝峰命名法,命名風格大致如下：\n\nstring命名格式：XX界面\\_XX功能\\_str,如 activity\\_home\\_welcome\\_str\n\ncolor命名格式：color\\_16進制顏色值，如紅色 color\\_ff0000\n\n像string通常建議把同一個界面的所有string都放到一起，方便查找。而color的命名則省去我們頭疼的想這個顏色怎麽命名。\n\n### selecor、drawable、layer-list資源文件\n\n小駝峰命名法。命名風格通常都是XX\\_selector、XX\\_drawable、XX\\_layer。\n\n下面舉兩個比較常用的栗子：\n\n按鈕按壓效果button\\_selector，正常狀態命名為button\\_normal\\(XX\\_normal\\)，按壓狀態命名為button\\_pressed\\(XX\\_pressed\\)\n\n選擇效果checkbox\\_selector,未選中狀態命名為checkbox\\_unchecked\\(XX\\_unchecked\\),選中狀態為checkbox\\_checked\\(XX\\_checked\\)\n\n### styles、dimens資源文件\n\nstyle采用大駝峰命名法，主題可以命名為XXTheme,控件的風格可以命名為XXStyle\n\ndimen采用小駝峰命名法，如所有Activity的titlebar的高度，activity\\_title\\_height\\_dimen\n\n### 控件id命名\n\n| 控件 | java前綴縮寫 | xml |\n| :--- | :--- | :--- |\n| RelativeLayout | rly | rly |\n| LinearLayout | lly | lly |\n| FrameLayout | fly | fly |\n| TextView | tv | tv |\n| Button | btn | btn |\n| ImageButton | imgBtn | img\\_btn |\n| ImageView | iv | iv |\n| CheckBox | chk | chk |\n| RadioButton | rb | rb |\n| analogClock | anaClk | ana\\_clk |\n| DigtalClock | dgtClk | dgt\\_clk |\n| DatePicker | dtPk | dt\\_pk |\n| EditText | edt | edt |\n| TimePicker | tmPk | tm\\_pk |\n| toggleButton | tglBtn | tgl\\_btn |\n| ProgressBar | proBar / progressBar | pro\\_bar / progress\\_bar |\n| SeekBar | skBar / seekBar | sk\\_bar / seek\\_bar |\n| AutoCompleteTextView | autoTv | auto\\_tv |\n| ZoomControl | zmCtl | zm\\_ctl |\n| VideoView | videoView | video\\_view |\n| WebView | webView | web\\_view |\n| Spinner | spn | spn |\n| Chronometer | cmt | cmt |\n| ScollView | scollView | scoll\\_view |\n| TextSwitch | txtSwitch | txt\\_swt |\n| ImageSwitch | imgSwt | img\\_swt |\n| ListView | lv | lv |\n| GridView | gv | gv |\n| ExpandableList | epdLt | epd\\_lt |\n| MapView | mapView | map\\_view |\n\n前言\n\n這份文檔是Google Java編程風格規範的完整定義。當且僅當一個Java源文件符合此文檔中的規則， 我們才認為它符合Google的Java編程風格。\n\n與其它的編程風格指南一樣，這裏所討論的不僅僅是編碼格式美不美觀的問題， 同時也討論一些約定及編碼標準。然而，這份文檔主要側重於我們所普遍遵循的規則， 對於那些不是明確強制要求的，我們盡量避免提供意見。\n\n1.1 術語說明\n\n在本文檔中，除非另有說明：\n\n術語class可表示一個普通類，枚舉類，接口或是annotation類型\\(@interface\\)\n\n術語comment只用來指代實現的註釋\\(implementation comments\\)，我們不使用“documentation comments”一詞，而是用Javadoc。\n\n其他的術語說明會偶爾在後面的文檔出現。\n\n1.2 指南說明\n\n本文檔中的示例代碼並不作為規範。也就是說，雖然示例代碼是遵循Google編程風格，但並不意味著這是展現這些代碼的唯一方式。 示例中的格式選擇不應該被強制定為規則。\n\n源文件基礎\n\n2.1 文件名\n\n源文件以其最頂層的類名來命名，大小寫敏感，文件擴展名為.java。\n\n2.2 文件編碼：UTF-8\n\n源文件編碼格式為UTF-8。\n\n2.3 特殊字符\n\n2.3.1 空白字符\n\n除了行結束符序列，ASCII水平空格字符\\(0x20，即空格\\)是源文件中唯一允許出現的空白字符，這意味著：\n\n所有其它字符串中的空白字符都要進行轉義。\n\n制表符不用於縮進。\n\n2.3.2 特殊轉義序列\n\n對於具有特殊轉義序列的任何字符\\(\\b, \\t, \\n, \\f, \\r, \", '及\\\\)，我們使用它的轉義序列，而不是相應的八進制\\(比如\\012\\)或Unicode\\(比如\\u000a\\)轉義。\n\n2.3.3 非ASCII字符\n\n對於剩余的非ASCII字符，是使用實際的Unicode字符\\(比如∞\\)，還是使用等價的Unicode轉義符\\(比如\\u221e\\)，取決於哪個能讓代碼更易於閱讀和理解。\n\nTip: 在使用Unicode轉義符或是一些實際的Unicode字符時，建議做些註釋給出解釋，這有助於別人閱讀和理解。\n\n例如：\n\nString unitAbbrev = \"μs\"; \\| 贊，即使沒有註釋也非常清晰\n\nString unitAbbrev = \"\\u03bcs\"; // \"μs\" \\| 允許，但沒有理由要這樣做\n\nString unitAbbrev = \"\\u03bcs\"; // Greek letter mu, \"s\" \\| 允許，但這樣做顯得笨拙還容易出錯\n\nString unitAbbrev = \"\\u03bcs\"; \\| 很糟，讀者根本看不出這是什麽\n\nreturn '\\ufeff' + content; // byte order mark \\| Good，對於非打印字符，使用轉義，並在必要時寫上註釋\n\nTip: 永遠不要由於害怕某些程序可能無法正確處理非ASCII字符而讓你的代碼可讀性變差。當程序無法正確處理非ASCII字符時，它自然無法正確運行， 你就會去fix這些問題的了。\\(言下之意就是大膽去用非ASCII字符，如果真的有需要的話\\)\n\n源文件結構\n\n一個源文件包含\\(按順序地\\)：\n\n許可證或版權信息\\(如有需要\\)\n\npackage語句\n\nimport語句\n\n一個頂級類\\(只有一個\\)\n\n以上每個部分之間用一個空行隔開。\n\n3.1 許可證或版權信息\n\n如果一個文件包含許可證或版權信息，那麽它應當被放在文件最前面。\n\n3.2 package語句\n\npackage語句不換行，列限制\\(4.4節\\)並不適用於package語句。\\(即package語句寫在一行裏\\)\n\n3.3 import語句\n\n3.3.1 import不要使用通配符\n\n即，不要出現類似這樣的import語句：import java.util.\\*;\n\n3.3.2 不要換行\n\nimport語句不換行，列限制\\(4.4節\\)並不適用於import語句。\\(每個import語句獨立成行\\)\n\n3.3.3 順序和間距\n\nimport語句可分為以下幾組，按照這個順序，每組由一個空行分隔：\n\n所有的靜態導入獨立成組\n\ncom.google imports\\(僅當這個源文件是在com.google包下\\)\n\n第三方的包。每個頂級包為一組，字典序。例如：android, com, junit, org, sun\n\njava imports\n\njavax imports\n\n組內不空行，按字典序排列。\n\n3.4 類聲明\n\n3.4.1 只有一個頂級類聲明\n\n每個頂級類都在一個與它同名的源文件中\\(當然，還包含.java後綴\\)。\n\n例外：package-info.java，該文件中可沒有package-info類。\n\n3.4.2 類成員順序\n\n類的成員順序對易學性有很大的影響，但這也不存在唯一的通用法則。不同的類對成員的排序可能是不同的。 最重要的一點，每個類應該以某種邏輯去排序它的成員，維護者應該要能解釋這種排序邏輯。比如， 新的方法不能總是習慣性地添加到類的結尾，因為這樣就是按時間順序而非某種邏輯來排序的。\n\n3.4.2.1 重載：永不分離\n\n當一個類有多個構造函數，或是多個同名方法，這些函數/方法應該按順序出現在一起，中間不要放進其它函數/方法。\n\n格式\n\n術語說明：塊狀結構\\(block-like construct\\)指的是一個類，方法或構造函數的主體。需要註意的是，數組初始化中的初始值可被選擇性地視為塊狀結構\\(4.8.3.1節\\)。\n\n4.1 大括號\n\n4.1.1 使用大括號\\(即使是可選的\\)\n\n大括號與if, else, for, do, while語句一起使用，即使只有一條語句\\(或是空\\)，也應該把大括號寫上。\n\n4.1.2 非空塊：K \n\n&\n\n R 風格\n\n對於非空塊和塊狀結構，大括號遵循Kernighan和Ritchie風格 \\(Egyptian brackets\\):\n\n左大括號前不換行\n\n左大括號後換行\n\n右大括號前換行\n\n如果右大括號是一個語句、函數體或類的終止，則右大括號後換行; 否則不換行。例如，如果右大括號後面是else或逗號，則不換行。\n\n示例：\n\nreturn new MyClass\\(\\) {\n\n@Override public void method\\(\\) {\n\nif \\(condition\\(\\)\\) {\n\ntry {\n\nsomething\\(\\);\n\n} catch \\(ProblemException e\\) {\n\nrecover\\(\\);\n\n}\n\n}\n\n}\n\n};\n\n4.8.1節給出了enum類的一些例外。\n\n4.1.3 空塊：可以用簡潔版本\n\n一個空的塊狀結構裏什麽也不包含，大括號可以簡潔地寫成{}，不需要換行。例外：如果它是一個多塊語句的一部分\\(if/else 或 try/catch/finally\\) ，即使大括號內沒內容，右大括號也要換行。\n\n示例：\n\nvoid doNothing\\(\\) {}\n\n4.2 塊縮進：2個空格\n\n每當開始一個新的塊，縮進增加2個空格，當塊結束時，縮進返回先前的縮進級別。縮進級別適用於代碼和註釋。\\(見4.1.2節中的代碼示例\\)\n\n4.3 一行一個語句\n\n每個語句後要換行。\n\n4.4 列限制：80或100\n\n一個項目可以選擇一行80個字符或100個字符的列限制，除了下述例外，任何一行如果超過這個字符數限制，必須自動換行。\n\n例外：\n\n不可能滿足列限制的行\\(例如，Javadoc中的一個長URL，或是一個長的JSNI方法參考\\)。\n\npackage和import語句\\(見3.2節和3.3節\\)。\n\n註釋中那些可能被剪切並粘貼到shell中的命令行。\n\n4.5 自動換行\n\n術語說明：一般情況下，一行長代碼為了避免超出列限制\\(80或100個字符\\)而被分為多行，我們稱之為自動換行\\(line-wrapping\\)。\n\n我們並沒有全面，確定性的準則來決定在每一種情況下如何自動換行。很多時候，對於同一段代碼會有好幾種有效的自動換行方式。\n\nTip: 提取方法或局部變量可以在不換行的情況下解決代碼過長的問題\\(是合理縮短命名長度吧\\)\n\n4.5.1 從哪裏斷開\n\n自動換行的基本準則是：更傾向於在更高的語法級別處斷開。\n\n如果在非賦值運算符處斷開，那麽在該符號前斷開\\(比如+，它將位於下一行\\)。註意：這一點與Google其它語言的編程風格不同\\(如C++和JavaScript\\)。 這條規則也適用於以下“類運算符”符號：點分隔符\\(.\\)，類型界限中的\n\n&\n\n（\n\n&lt;\n\nT extends Foo \n\n&\n\n Bar\n\n&gt;\n\n\\)，catch塊中的管道符號\\(catch \\(FooException \\| BarException e\\)\n\n如果在賦值運算符處斷開，通常的做法是在該符號後斷開\\(比如=，它與前面的內容留在同一行\\)。這條規則也適用於foreach語句中的分號。\n\n方法名或構造函數名與左括號留在同一行。\n\n逗號\\(,\\)與其前面的內容留在同一行。\n\n4.5.2 自動換行時縮進至少+4個空格\n\n自動換行時，第一行後的每一行至少比第一行多縮進4個空格\\(註意：制表符不用於縮進。見2.3.1節\\)。\n\n當存在連續自動換行時，縮進可能會多縮進不只4個空格\\(語法元素存在多級時\\)。一般而言，兩個連續行使用相同的縮進當且僅當它們開始於同級語法元素。\n\n第4.6.3水平對齊一節中指出，不鼓勵使用可變數目的空格來對齊前面行的符號。\n\n4.6 空白\n\n4.6.1 垂直空白\n\n以下情況需要使用一個空行：\n\n類內連續的成員之間：字段，構造函數，方法，嵌套類，靜態初始化塊，實例初始化塊。\n\n例外：兩個連續字段之間的空行是可選的，用於字段的空行主要用來對字段進行邏輯分組。\n\n在函數體內，語句的邏輯分組間使用空行。\n\n類內的第一個成員前或最後一個成員後的空行是可選的\\(既不鼓勵也不反對這樣做，視個人喜好而定\\)。\n\n要滿足本文檔中其他節的空行要求\\(比如3.3節：import語句\\)\n\n多個連續的空行是允許的，但沒有必要這樣做\\(我們也不鼓勵這樣做\\)。\n\n4.6.2 水平空白\n\n除了語言需求和其它規則，並且除了文字，註釋和Javadoc用到單個空格，單個ASCII空格也出現在以下幾個地方：\n\n分隔任何保留字與緊隨其後的左括號\\(\\(\\)\\(如if, for catch等\\)。\n\n分隔任何保留字與其前面的右大括號\\(}\\)\\(如else, catch\\)。\n\n在任何左大括號前\\({\\)，兩個例外：\n\n@SomeAnnotation\\({a, b}\\)\\(不使用空格\\)。\n\nString\n\n\\[\\]\\[\\]\n\n x = foo;\\(大括號間沒有空格，見下面的Note\\)。\n\n在任何二元或三元運算符的兩側。這也適用於以下“類運算符”符號：\n\n類型界限中的\n\n&\n\n\\(\n\n&lt;\n\nT extends Foo \n\n&\n\n Bar\n\n&gt;\n\n\\)。\n\ncatch塊中的管道符號\\(catch \\(FooException \\| BarException e\\)。\n\nforeach語句中的分號。\n\n在, : ;及右括號\\(\\)\\)後\n\n如果在一條語句後做註釋，則雙斜杠\\(//\\)兩邊都要空格。這裏可以允許多個空格，但沒有必要。\n\n類型和變量之間：List list。\n\n數組初始化中，大括號內的空格是可選的，即new int\\[\\] {5, 6}和new int\\[\\] { 5, 6 }都是可以的。\n\nNote：這個規則並不要求或禁止一行的開關或結尾需要額外的空格，只對內部空格做要求。\n\n4.6.3 水平對齊：不做要求\n\n術語說明：水平對齊指的是通過增加可變數量的空格來使某一行的字符與上一行的相應字符對齊。\n\n這是允許的\\(而且在不少地方可以看到這樣的代碼\\)，但Google編程風格對此不做要求。即使對於已經使用水平對齊的代碼，我們也不需要去保持這種風格。\n\n以下示例先展示未對齊的代碼，然後是對齊的代碼：\n\nprivate int x; // this is fine\n\nprivate Color color; // this too\n\nprivate int x; // permitted, but future edits\n\nprivate Color color; // may leave it unaligned\n\nTip：對齊可增加代碼可讀性，但它為日後的維護帶來問題。考慮未來某個時候，我們需要修改一堆對齊的代碼中的一行。 這可能導致原本很漂亮的對齊代碼變得錯位。很可能它會提示你調整周圍代碼的空白來使這一堆代碼重新水平對齊\\(比如程序員想保持這種水平對齊的風格\\)， 這就會讓你做許多的無用功，增加了reviewer的工作並且可能導致更多的合並沖突。\n\n4.7 用小括號來限定組：推薦\n\n除非作者和reviewer都認為去掉小括號也不會使代碼被誤解，或是去掉小括號能讓代碼更易於閱讀，否則我們不應該去掉小括號。 我們沒有理由假設讀者能記住整個Java運算符優先級表。\n\n4.8 具體結構\n\n4.8.1 枚舉類\n\n枚舉常量間用逗號隔開，換行可選。\n\n沒有方法和文檔的枚舉類可寫成數組初始化的格式：\n\nprivate enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }\n\n由於枚舉類也是一個類，因此所有適用於其它類的格式規則也適用於枚舉類。\n\n4.8.2 變量聲明\n\n4.8.2.1 每次只聲明一個變量\n\n不要使用組合聲明，比如int a, b;。\n\n4.8.2.2 需要時才聲明，並盡快進行初始化\n\n不要在一個代碼塊的開頭把局部變量一次性都聲明了\\(這是c語言的做法\\)，而是在第一次需要使用它時才聲明。 局部變量在聲明時最好就進行初始化，或者聲明後盡快進行初始化。\n\n4.8.3 數組\n\n4.8.3.1 數組初始化：可寫成塊狀結構\n\n數組初始化可以寫成塊狀結構，比如，下面的寫法都是OK的：\n\nnew int\\[\\] {\n\n0, 1, 2, 3\n\n}\n\nnew int\\[\\] {\n\n0,\n\n1,\n\n2,\n\n3\n\n}\n\nnew int\\[\\] {\n\n0, 1,\n\n2, 3\n\n}\n\nnew int\\[\\]{0, 1, 2, 3}\n\n4.8.3.2 非C風格的數組聲明\n\n中括號是類型的一部分：String\\[\\] args， 而非String args\\[\\]。\n\n4.8.4 switch語句\n\n術語說明：switch塊的大括號內是一個或多個語句組。每個語句組包含一個或多個switch標簽\\(case FOO:或default:\\)，後面跟著一條或多條語句。\n\n4.8.4.1 縮進\n\n與其它塊狀結構一致，switch塊中的內容縮進為2個空格。\n\n每個switch標簽後新起一行，再縮進2個空格，寫下一條或多條語句。\n\n4.8.4.2 Fall-through：註釋\n\n在一個switch塊內，每個語句組要麽通過break, continue, return或拋出異常來終止，要麽通過一條註釋來說明程序將繼續執行到下一個語句組， 任何能表達這個意思的註釋都是OK的\\(典型的是用// fall through\\)。這個特殊的註釋並不需要在最後一個語句組\\(一般是default\\)中出現。示例：\n\nswitch \\(input\\) {\n\ncase 1:\n\ncase 2:\n\nprepareOneOrTwo\\(\\);\n\n// fall through\n\ncase 3:\n\nhandleOneTwoOrThree\\(\\);\n\nbreak;\n\ndefault:\n\nhandleLargeNumber\\(input\\);\n\n}\n\n4.8.4.3 default的情況要寫出來\n\n每個switch語句都包含一個default語句組，即使它什麽代碼也不包含。\n\n4.8.5 註解\\(Annotations\\)\n\n註解緊跟在文檔塊後面，應用於類、方法和構造函數，一個註解獨占一行。這些換行不屬於自動換行\\(第4.5節，自動換行\\)，因此縮進級別不變。例如：\n\n@Override\n\n@Nullable\n\npublic String getNameIfPresent\\(\\) { ... }\n\n例外：單個的註解可以和簽名的第一行出現在同一行。例如：\n\n@Override public int hashCode\\(\\) { ... }\n\n應用於字段的註解緊隨文檔塊出現，應用於字段的多個註解允許與字段出現在同一行。例如：\n\n@Partial @Mock DataLoader loader;\n\n參數和局部變量註解沒有特定規則。\n\n4.8.6 註釋\n\n4.8.6.1 塊註釋風格\n\n塊註釋與其周圍的代碼在同一縮進級別。它們可以是/\\* ... \n\n\\*\n\n/風格，也可以是// ...風格。對於多行的/\n\n\\*\n\n ... \n\n\\*\n\n/註釋，後續行必須從\n\n\\*\n\n開始， 並且與前一行的\\*對齊。以下示例註釋都是OK的。\n\n/\\*\n\n\\*\n\n This is // And so /\\* Or you can\n\n\\*\n\n okay. // is this. \\* even do this. \\*/\n\n \\*/\n\n註釋不要封閉在由星號或其它字符繪制的框架裏。\n\nTip：在寫多行註釋時，如果你希望在必要時能重新換行\\(即註釋像段落風格一樣\\)，那麽使用/\\* ... \\*/。\n\n4.8.7 Modifiers\n\n類和成員的modifiers如果存在，則按Java語言規範中推薦的順序出現。\n\npublic protected private abstract static final transient volatile synchronized native strictfp\n\n命名約定\n\n5.1 對所有標識符都通用的規則\n\n標識符只能使用ASCII字母和數字，因此每個有效的標識符名稱都能匹配正則表達式\\w+。\n\n在Google其它編程語言風格中使用的特殊前綴或後綴，如name\n\n\\_\n\n, mName, s\n\n\\_\n\nname和kName，在Java編程風格中都不再使用。\n\n5.2 標識符類型的規則\n\n5.2.1 包名\n\n包名全部小寫，連續的單詞只是簡單地連接起來，不使用下劃線。\n\n5.2.2 類名\n\n類名都以UpperCamelCase風格編寫。\n\n類名通常是名詞或名詞短語，接口名稱有時可能是形容詞或形容詞短語。現在還沒有特定的規則或行之有效的約定來命名註解類型。\n\n測試類的命名以它要測試的類的名稱開始，以Test結束。例如，HashTest或HashIntegrationTest。\n\n5.2.3 方法名\n\n方法名都以lowerCamelCase風格編寫。\n\n方法名通常是動詞或動詞短語。\n\n下劃線可能出現在JUnit測試方法名稱中用以分隔名稱的邏輯組件。一個典型的模式是：test\n\n&lt;\n\nMethodUnderTest\n\n&gt;\n\n\\_\n\n&lt;\n\nstate\n\n&gt;\n\n，例如testPop\n\n\\_\n\nemptyStack。 並不存在唯一正確的方式來命名測試方法。\n\n5.2.4 常量名\n\n常量名命名模式為CONSTANT\\_CASE，全部字母大寫，用下劃線分隔單詞。那，到底什麽算是一個常量？\n\n每個常量都是一個靜態final字段，但不是所有靜態final字段都是常量。在決定一個字段是否是一個常量時， 考慮它是否真的感覺像是一個常量。例如，如果任何一個該實例的觀測狀態是可變的，則它幾乎肯定不會是一個常量。 只是永遠不打算改變對象一般是不夠的，它要真的一直不變才能將它示為常量。\n\n// Constants\n\nstatic final int NUMBER = 5;\n\nstatic final ImmutableList\n\n&lt;\n\nString\n\n&gt;\n\n NAMES = ImmutableList.of\\(\"Ed\", \"Ann\"\\);\n\nstatic final Joiner COMMA\\_JOINER = Joiner.on\\(','\\); // because Joiner is immutable\n\nstatic final SomeMutableType\\[\\] EMPTY\\_ARRAY = {};\n\nenum SomeEnum { ENUM\\_CONSTANT }\n\n// Not constants\n\nstatic String nonFinal = \"non-final\";\n\nfinal String nonStatic = \"non-static\";\n\nstatic final Set\n\n&lt;\n\nString\n\n&gt;\n\n mutableCollection = new HashSet\n\n&lt;\n\nString\n\n&gt;\n\n\\(\\);\n\nstatic final ImmutableSet\n\n&lt;\n\nSomeMutableType\n\n&gt;\n\n mutableElements = ImmutableSet.of\\(mutable\\);\n\nstatic final Logger logger = Logger.getLogger\\(MyClass.getName\\(\\)\\);\n\nstatic final String\\[\\] nonEmptyArray = {\"these\", \"can\", \"change\"};\n\n這些名字通常是名詞或名詞短語。\n\n5.2.5 非常量字段名\n\n非常量字段名以lowerCamelCase風格編寫。\n\n這些名字通常是名詞或名詞短語。\n\n5.2.6 參數名\n\n參數名以lowerCamelCase風格編寫。\n\n參數應該避免用單個字符命名。\n\n5.2.7 局部變量名\n\n局部變量名以lowerCamelCase風格編寫，比起其它類型的名稱，局部變量名可以有更為寬松的縮寫。\n\n雖然縮寫更寬松，但還是要避免用單字符進行命名，除了臨時變量和循環變量。\n\n即使局部變量是final和不可改變的，也不應該把它示為常量，自然也不能用常量的規則去命名它。\n\n5.2.8 類型變量名\n\n類型變量可用以下兩種風格之一進行命名：\n\n單個的大寫字母，後面可以跟一個數字\\(如：E, T, X, T2\\)。\n\n以類命名方式\\(5.2.2節\\)，後面加個大寫的T\\(如：RequestT, FooBarT\\)。\n\n5.3 駝峰式命名法\\(CamelCase\\)\n\n駝峰式命名法分大駝峰式命名法\\(UpperCamelCase\\)和小駝峰式命名法\\(lowerCamelCase\\)。 有時，我們有不只一種合理的方式將一個英語詞組轉換成駝峰形式，如縮略語或不尋常的結構\\(例如”IPv6”或”iOS”\\)。Google指定了以下的轉換方案。\n\n名字從散文形式\\(prose form\\)開始:\n\n把短語轉換為純ASCII碼，並且移除任何單引號。例如：”Müller’s algorithm”將變成”Muellers algorithm”。\n\n把這個結果切分成單詞，在空格或其它標點符號\\(通常是連字符\\)處分割開。\n\n推薦：如果某個單詞已經有了常用的駝峰表示形式，按它的組成將它分割開\\(如”AdWords”將分割成”ad words”\\)。 需要註意的是”iOS”並不是一個真正的駝峰表示形式，因此該推薦對它並不適用。\n\n現在將所有字母都小寫\\(包括縮寫\\)，然後將單詞的第一個字母大寫：\n\n每個單詞的第一個字母都大寫，來得到大駝峰式命名。\n\n除了第一個單詞，每個單詞的第一個字母都大寫，來得到小駝峰式命名。\n\n最後將所有的單詞連接起來得到一個標識符。\n\n示例：\n\nProse form Correct Incorrect ------------------------------------------------------------------\n\n\"XML HTTP request\" XmlHttpRequest XMLHTTPRequest\n\n\"new customer ID\" newCustomerId newCustomerID\n\n\"inner stopwatch\" innerStopwatch innerStopWatch\n\n\"supports IPv6 on iOS?\" supportsIpv6OnIos supportsIPv6OnIOS\n\n\"YouTube importer\" YouTubeImporter\n\nYoutubeImporter\\*\n\n加星號處表示可以，但不推薦。\n\nNote：在英語中，某些帶有連字符的單詞形式不唯一。例如：”nonempty”和”non-empty”都是正確的，因此方法名checkNonempty和checkNonEmpty也都是正確的。\n\n編程實踐\n\n6.1 @Override：能用則用\n\n只要是合法的，就把@Override註解給用上。\n\n6.2 捕獲的異常：不能忽視\n\n除了下面的例子，對捕獲的異常不做響應是極少正確的。\\(典型的響應方式是打印日誌，或者如果它被認為是不可能的，則把它當作一個AssertionError重新拋出。\\)\n\n如果它確實是不需要在catch塊中做任何響應，需要做註釋加以說明\\(如下面的例子\\)。\n\ntry {\n\nint i = Integer.parseInt\\(response\\);\n\nreturn handleNumericResponse\\(i\\);\n\n} catch \\(NumberFormatException ok\\) {\n\n// it's not numeric; that's fine, just continue\n\n}\n\nreturn handleTextResponse\\(response\\);\n\n例外：在測試中，如果一個捕獲的異常被命名為expected，則它可以被不加註釋地忽略。下面是一種非常常見的情形，用以確保所測試的方法會拋出一個期望中的異常， 因此在這裏就沒有必要加註釋。\n\ntry {\n\nemptyStack.pop\\(\\);\n\nfail\\(\\);\n\n} catch \\(NoSuchElementException expected\\) {\n\n}\n\n6.3 靜態成員：使用類進行調用\n\n使用類名調用靜態的類成員，而不是具體某個對象或表達式。\n\nFoo aFoo = ...;\n\nFoo.aStaticMethod\\(\\); // good\n\naFoo.aStaticMethod\\(\\); // bad\n\nsomethingThatYieldsAFoo\\(\\).aStaticMethod\\(\\); // very bad\n\n6.4 Finalizers: 禁用\n\n極少會去重寫Object.finalize。\n\nTip：不要使用finalize。如果你非要使用它，請先仔細閱讀和理解Effective Java 第7條款：“Avoid Finalizers”，然後不要使用它。\n\nJavadoc\n\n7.1 格式\n\n7.1.1 一般形式\n\nJavadoc塊的基本格式如下所示：\n\n/\\*\\*\n\n\\*\n\n Multiple lines of Javadoc text are written here,\n\n\\*\n\n wrapped normally...\n\n \\*/\n\npublic int method\\(String p1\\) { ... }\n\n或者是以下單行形式：\n\n/\\*\\* An especially short bit of Javadoc. \\*/\n\n基本格式總是OK的。當整個Javadoc塊能容納於一行時\\(且沒有Javadoc標記@XXX\\)，可以使用單行形式。\n\n7.1.2 段落\n\n空行\\(即，只包含最左側星號的行\\)會出現在段落之間和Javadoc標記\\(@XXX\\)之前\\(如果有的話\\)。 除了第一個段落，每個段落第一個單詞前都有標簽\n\n&lt;\n\np\n\n&gt;\n\n，並且它和第一個單詞間沒有空格。\n\n7.1.3 Javadoc標記\n\n標準的Javadoc標記按以下順序出現：@param, @return, @throws, @deprecated, 前面這4種標記如果出現，描述都不能為空。 當描述無法在一行中容納，連續行需要至少再縮進4個空格。\n\n7.2 摘要片段\n\n每個類或成員的Javadoc以一個簡短的摘要片段開始。這個片段是非常重要的，在某些情況下，它是唯一出現的文本，比如在類和方法索引中。\n\n這只是一個小片段，可以是一個名詞短語或動詞短語，但不是一個完整的句子。它不會以A {@code Foo} is a...或This method returns...開頭, 它也不會是一個完整的祈使句，如Save the record...。然而，由於開頭大寫及被加了標點，它看起來就像是個完整的句子。\n\nTip：一個常見的錯誤是把簡單的Javadoc寫成/\n\n\\*\\*\n\n @return the customer ID \\*/，這是不正確的。它應該寫成/\n\n\\*\\*\n\n Returns the customer ID. \\*/。\n\n7.3 哪裏需要使用Javadoc\n\n至少在每個public類及它的每個public和protected成員處使用Javadoc，以下是一些例外：\n\n7.3.1 例外：不言自明的方法\n\n對於簡單明顯的方法如getFoo，Javadoc是可選的\\(即，是可以不寫的\\)。這種情況下除了寫“Returns the foo”，確實也沒有什麽值得寫了。\n\n單元測試類中的測試方法可能是不言自明的最常見例子了，我們通常可以從這些方法的描述性命名中知道它是幹什麽的，因此不需要額外的文檔說明。\n\nTip：如果有一些相關信息是需要讀者了解的，那麽以上的例外不應作為忽視這些信息的理由。例如，對於方法名getCanonicalName， 就不應該忽視文檔說明，因為讀者很可能不知道詞語canonical name指的是什麽。\n\n7.3.2 例外：重寫\n\n如果一個方法重寫了超類中的方法，那麽Javadoc並非必需的。\n\n7.3.3 可選的Javadoc\n\n對於包外不可見的類和方法，如有需要，也是要使用Javadoc的。如果一個註釋是用來定義一個類，方法，字段的整體目的或行為， 那麽這個註釋應該寫成Javadoc，這樣更統一更友好。\n\n\n\n","source":"_posts/android/androidcan-kao-gui-fan.md","raw":"---\ntitle: Android Code Style\ndate: 2018-10-02 09:09:09\ncategories: Android\n---\n## Android參考規範\n\n[https://google.github.io/styleguide/javaguide.html](https://google.github.io/styleguide/javaguide.html)\n\n### 基本的命名法\n\nJava編程比較常見的有下面三種命名方式\n\n1.駝峰\\(Camel\\)命名法:又稱小駝峰命名法，除首單詞外，其余所有單詞的第一個字母大寫。\n\n2.帕斯卡\\(pascal\\)命名法:又稱大駝峰命名法，所有單詞的第一個字母大寫\n\n3.下劃線命名法:單詞與單詞間用下劃線做間隔\n\n一般建議拿來做命名的單詞要比較精悍短小，這樣即使兩三個單詞一起拼裝成一個命名，也不至於顯得很冗長。當然有些單詞我們也可以直接寫成一些約定俗成的縮寫。諸如：msg\\(message\\)、init\\(initial\\)、img\\(image\\)等.....\n\n個人認為，這些縮寫可參照業界常見的縮寫命名，也可以根據當前項目中的風格，進行團隊成員間的約定。這樣相對比較靈活，也方便團隊成員之間相互理解。\n\n### 包命名\n\n采用反域名命名規則，全部使用小寫字母，一般為3層\n\n一級包名為com;\n\n二級包名為xx（可以是公司或則個人的隨便）;\n\n三級包名應用的英文名app\\_name;\n\n四級包名為模塊名或層級名;\n\n如：www.ziines.com\n\n正常-&gt;com.ziines.www\n\n參考-&gt;com.ziines.android或com.ziines.it\n\n如：framework.com.hk\n\n正常-&gt;hk.nmg.framework\n\n| 命名格式 | 作用 |\n| :--- | :--- |\n| com.xx.app\\_name.activities\\(或com.xx.app\\_name.activity\\) | 存放app所有的Activity |\n| com.xx.app\\_name.service | 存放app所有的Service |\n| com.xx.app\\_name.receiver | 存放app所有的BroadcastReceiver |\n| com.xx.app\\_name.provider | 存放app所有的ContentProvider |\n| com.xx.app\\_name.fragment | 存放app所有的Fragment |\n| com.xx.app\\_name.dialog | 存放app所有的Dialog |\n| com.xx.app\\_name.base | 存放app一些共有的基礎模塊，諸如BaseActivity、BaseContentProvider、BaseService，BaseFragment等 |\n| com.xx.app\\_name.utils | 存放app的工具類,諸如格式化日期的DateFormatUtils，處理字符串的StringUtils等 |\n| com.xx.app\\_name.bean\\(或com.xx.app\\_name.unity\\) | 存放app自定義的實體類 |\n| com.xx.app\\_name.db\\) | 存放app數據庫操作相關的類 |\n| com.xx.app\\_name.view\\) | 存放app自定義的控件 |\n| com.xx.app\\_name.adapter\\) | 存放app所有的適配器類 |\n\n### 類命名\n\n| 類 | 命名格式 | 示例 |\n| :--- | :--- | :--- |\n| Activity | XXX功能+Activity | 如主界面HomeActivity,啟動頁LauncherActivity |\n| Service | XXX功能+Service | 如消息推送的Service，PushService或PushMessageService |\n| BroadcastReceiver | XXX功能+Receiver | 如在線的消息廣播接受者，OnlineReceiver |\n| ContentProvider | XXX功能+Provider | 如聯系人的內容提供者，ContactsProvider |\n| Fragment | XXX功能+Fragment | 如顯示聯系人的Fragment，ContactsFragment |\n| Dialog | XXX功能+Dialog | 如普通的選擇提示對話框，ChoiceDialog |\n| Adapter | XXX功能+XX类型控件Adapter | 如聯系人列表，ContactsListAdapter |\n| 基础功能类 | Base+XX父类名 | 如BaseActivity，BaseFragment |\n| 工具类 | XXX功能+Utils | 如處理字符串的工具類，StringUtils |\n| 管理类 | XXX功能+Manager | 如管理聯系人的類，ContactsManager |\n\n### 接口命名\n\n和類名基本一致。也可以在接口名前面再加一個大寫的I，表明這是一個接口Interface。\n\n### 方法\n\n動詞或動名詞，采用小駝峰命名法。\n\n| 命名風格 | 含義 |\n| :--- | :--- |\n| initXX\\(\\) | 初始化，如初始化所有控件initView\\(\\) |\n| isXX\\(\\) | 是否滿足某種要求，如是否為註冊用戶isRegister\\(\\) |\n| processXX\\(\\) | 對數據做某些處理，可以以process作為前綴 |\n| displayXX\\(\\) | 顯示提示信息，如displayXXDialog，displayToast，displayXXPopupWindow |\n| saveXX\\(\\) | 保存XX數據 |\n| resetXX\\(\\) | 重置XX數據 |\n| addXX\\(\\)/insertXX\\(\\) | 添加XX數據 |\n| deleteXX\\(\\)/removeXX\\(\\) | 刪除XX數據 |\n| updateXX\\(\\) | 更新XX數據 |\n| searchXX\\(\\)/findXX\\(\\)/queryXX\\(\\) | 查找XX數據 |\n| draw\\(\\) | 控件裏面使用居多，例如繪制文本drawText |\n\n### 變量\n\n采采用小駝峰命名法。同樣比較簡單，但為了更好表明含義，我建議做一下的的區分\n\n成員變量命名前面加m（member，表示成員變量之意），如，控件的寬高 mWidth，mHeight\n\n靜態類變量前面加s（static，表示靜態變量之意），如，一個靜態的單例 sSingleInstance\n\n### 常量\n\n同樣較為簡單，全部大寫,采用下劃線命名法.如：MIN\\_WIDTH,MAX\\_SIZE\n\n### 布局資源文件\\(layout文件夾下\\)\n\n全部小寫，采用下劃線命名法\n\n| 布局類型 | 命名風格 |\n| :--- | :--- |\n| Activity的xml布局 | activity\\_+XX功能，如主頁面activity\\_home |\n| Fragment的xml布局 | fragment\\_+XX功能，如聯繫人模塊fragment\\_contacts |\n| Dialog的xml布局 | dialog\\_+XX功能，如選擇日期dialog\\_select\\_date |\n| 抽取出來重用的xml布局（include） | include\\_+XX功能，如底部tab欄include\\_bottom\\_tabs |\n| ListView或者RecyclerView的item xml布局 | XX功能+\\_list\\_item，如聯繫人的contact\\_info\\_list\\_item |\n| GridView的item xml布局 | XX功能+\\_grid\\_item，如相冊的album\\_grid\\_item |\n\n### 動畫資源文件\\(anim文件夾下\\)\n\n全部小寫，采用下劃線命名法，加前綴區分.\n\n| 動畫效果 | 命名風格 |\n| :--- | :--- |\n| 淡入/淡出 | fade\\_in/fade\\_out |\n| 从某個方向淡入/淡出 | fade\\_方向\\_in\\(out\\),右边淡入淡出fade\\_right\\_in\\(out\\) |\n| 从某個方向彈入/彈出 | push\\_方向\\_in\\(out\\),右边推入推出push\\_right\\_in\\(out\\) |\n| 从某個方向滑入/滑出 | slide\\_in\\(out\\)_from_方向,右边滑入滑出slide\\_in\\(out\\)\\_from\\_right |\n\n### strings和colors資源文件\n\n小駝峰命名法,命名風格大致如下：\n\nstring命名格式：XX界面\\_XX功能\\_str,如 activity\\_home\\_welcome\\_str\n\ncolor命名格式：color\\_16進制顏色值，如紅色 color\\_ff0000\n\n像string通常建議把同一個界面的所有string都放到一起，方便查找。而color的命名則省去我們頭疼的想這個顏色怎麽命名。\n\n### selecor、drawable、layer-list資源文件\n\n小駝峰命名法。命名風格通常都是XX\\_selector、XX\\_drawable、XX\\_layer。\n\n下面舉兩個比較常用的栗子：\n\n按鈕按壓效果button\\_selector，正常狀態命名為button\\_normal\\(XX\\_normal\\)，按壓狀態命名為button\\_pressed\\(XX\\_pressed\\)\n\n選擇效果checkbox\\_selector,未選中狀態命名為checkbox\\_unchecked\\(XX\\_unchecked\\),選中狀態為checkbox\\_checked\\(XX\\_checked\\)\n\n### styles、dimens資源文件\n\nstyle采用大駝峰命名法，主題可以命名為XXTheme,控件的風格可以命名為XXStyle\n\ndimen采用小駝峰命名法，如所有Activity的titlebar的高度，activity\\_title\\_height\\_dimen\n\n### 控件id命名\n\n| 控件 | java前綴縮寫 | xml |\n| :--- | :--- | :--- |\n| RelativeLayout | rly | rly |\n| LinearLayout | lly | lly |\n| FrameLayout | fly | fly |\n| TextView | tv | tv |\n| Button | btn | btn |\n| ImageButton | imgBtn | img\\_btn |\n| ImageView | iv | iv |\n| CheckBox | chk | chk |\n| RadioButton | rb | rb |\n| analogClock | anaClk | ana\\_clk |\n| DigtalClock | dgtClk | dgt\\_clk |\n| DatePicker | dtPk | dt\\_pk |\n| EditText | edt | edt |\n| TimePicker | tmPk | tm\\_pk |\n| toggleButton | tglBtn | tgl\\_btn |\n| ProgressBar | proBar / progressBar | pro\\_bar / progress\\_bar |\n| SeekBar | skBar / seekBar | sk\\_bar / seek\\_bar |\n| AutoCompleteTextView | autoTv | auto\\_tv |\n| ZoomControl | zmCtl | zm\\_ctl |\n| VideoView | videoView | video\\_view |\n| WebView | webView | web\\_view |\n| Spinner | spn | spn |\n| Chronometer | cmt | cmt |\n| ScollView | scollView | scoll\\_view |\n| TextSwitch | txtSwitch | txt\\_swt |\n| ImageSwitch | imgSwt | img\\_swt |\n| ListView | lv | lv |\n| GridView | gv | gv |\n| ExpandableList | epdLt | epd\\_lt |\n| MapView | mapView | map\\_view |\n\n前言\n\n這份文檔是Google Java編程風格規範的完整定義。當且僅當一個Java源文件符合此文檔中的規則， 我們才認為它符合Google的Java編程風格。\n\n與其它的編程風格指南一樣，這裏所討論的不僅僅是編碼格式美不美觀的問題， 同時也討論一些約定及編碼標準。然而，這份文檔主要側重於我們所普遍遵循的規則， 對於那些不是明確強制要求的，我們盡量避免提供意見。\n\n1.1 術語說明\n\n在本文檔中，除非另有說明：\n\n術語class可表示一個普通類，枚舉類，接口或是annotation類型\\(@interface\\)\n\n術語comment只用來指代實現的註釋\\(implementation comments\\)，我們不使用“documentation comments”一詞，而是用Javadoc。\n\n其他的術語說明會偶爾在後面的文檔出現。\n\n1.2 指南說明\n\n本文檔中的示例代碼並不作為規範。也就是說，雖然示例代碼是遵循Google編程風格，但並不意味著這是展現這些代碼的唯一方式。 示例中的格式選擇不應該被強制定為規則。\n\n源文件基礎\n\n2.1 文件名\n\n源文件以其最頂層的類名來命名，大小寫敏感，文件擴展名為.java。\n\n2.2 文件編碼：UTF-8\n\n源文件編碼格式為UTF-8。\n\n2.3 特殊字符\n\n2.3.1 空白字符\n\n除了行結束符序列，ASCII水平空格字符\\(0x20，即空格\\)是源文件中唯一允許出現的空白字符，這意味著：\n\n所有其它字符串中的空白字符都要進行轉義。\n\n制表符不用於縮進。\n\n2.3.2 特殊轉義序列\n\n對於具有特殊轉義序列的任何字符\\(\\b, \\t, \\n, \\f, \\r, \", '及\\\\)，我們使用它的轉義序列，而不是相應的八進制\\(比如\\012\\)或Unicode\\(比如\\u000a\\)轉義。\n\n2.3.3 非ASCII字符\n\n對於剩余的非ASCII字符，是使用實際的Unicode字符\\(比如∞\\)，還是使用等價的Unicode轉義符\\(比如\\u221e\\)，取決於哪個能讓代碼更易於閱讀和理解。\n\nTip: 在使用Unicode轉義符或是一些實際的Unicode字符時，建議做些註釋給出解釋，這有助於別人閱讀和理解。\n\n例如：\n\nString unitAbbrev = \"μs\"; \\| 贊，即使沒有註釋也非常清晰\n\nString unitAbbrev = \"\\u03bcs\"; // \"μs\" \\| 允許，但沒有理由要這樣做\n\nString unitAbbrev = \"\\u03bcs\"; // Greek letter mu, \"s\" \\| 允許，但這樣做顯得笨拙還容易出錯\n\nString unitAbbrev = \"\\u03bcs\"; \\| 很糟，讀者根本看不出這是什麽\n\nreturn '\\ufeff' + content; // byte order mark \\| Good，對於非打印字符，使用轉義，並在必要時寫上註釋\n\nTip: 永遠不要由於害怕某些程序可能無法正確處理非ASCII字符而讓你的代碼可讀性變差。當程序無法正確處理非ASCII字符時，它自然無法正確運行， 你就會去fix這些問題的了。\\(言下之意就是大膽去用非ASCII字符，如果真的有需要的話\\)\n\n源文件結構\n\n一個源文件包含\\(按順序地\\)：\n\n許可證或版權信息\\(如有需要\\)\n\npackage語句\n\nimport語句\n\n一個頂級類\\(只有一個\\)\n\n以上每個部分之間用一個空行隔開。\n\n3.1 許可證或版權信息\n\n如果一個文件包含許可證或版權信息，那麽它應當被放在文件最前面。\n\n3.2 package語句\n\npackage語句不換行，列限制\\(4.4節\\)並不適用於package語句。\\(即package語句寫在一行裏\\)\n\n3.3 import語句\n\n3.3.1 import不要使用通配符\n\n即，不要出現類似這樣的import語句：import java.util.\\*;\n\n3.3.2 不要換行\n\nimport語句不換行，列限制\\(4.4節\\)並不適用於import語句。\\(每個import語句獨立成行\\)\n\n3.3.3 順序和間距\n\nimport語句可分為以下幾組，按照這個順序，每組由一個空行分隔：\n\n所有的靜態導入獨立成組\n\ncom.google imports\\(僅當這個源文件是在com.google包下\\)\n\n第三方的包。每個頂級包為一組，字典序。例如：android, com, junit, org, sun\n\njava imports\n\njavax imports\n\n組內不空行，按字典序排列。\n\n3.4 類聲明\n\n3.4.1 只有一個頂級類聲明\n\n每個頂級類都在一個與它同名的源文件中\\(當然，還包含.java後綴\\)。\n\n例外：package-info.java，該文件中可沒有package-info類。\n\n3.4.2 類成員順序\n\n類的成員順序對易學性有很大的影響，但這也不存在唯一的通用法則。不同的類對成員的排序可能是不同的。 最重要的一點，每個類應該以某種邏輯去排序它的成員，維護者應該要能解釋這種排序邏輯。比如， 新的方法不能總是習慣性地添加到類的結尾，因為這樣就是按時間順序而非某種邏輯來排序的。\n\n3.4.2.1 重載：永不分離\n\n當一個類有多個構造函數，或是多個同名方法，這些函數/方法應該按順序出現在一起，中間不要放進其它函數/方法。\n\n格式\n\n術語說明：塊狀結構\\(block-like construct\\)指的是一個類，方法或構造函數的主體。需要註意的是，數組初始化中的初始值可被選擇性地視為塊狀結構\\(4.8.3.1節\\)。\n\n4.1 大括號\n\n4.1.1 使用大括號\\(即使是可選的\\)\n\n大括號與if, else, for, do, while語句一起使用，即使只有一條語句\\(或是空\\)，也應該把大括號寫上。\n\n4.1.2 非空塊：K \n\n&\n\n R 風格\n\n對於非空塊和塊狀結構，大括號遵循Kernighan和Ritchie風格 \\(Egyptian brackets\\):\n\n左大括號前不換行\n\n左大括號後換行\n\n右大括號前換行\n\n如果右大括號是一個語句、函數體或類的終止，則右大括號後換行; 否則不換行。例如，如果右大括號後面是else或逗號，則不換行。\n\n示例：\n\nreturn new MyClass\\(\\) {\n\n@Override public void method\\(\\) {\n\nif \\(condition\\(\\)\\) {\n\ntry {\n\nsomething\\(\\);\n\n} catch \\(ProblemException e\\) {\n\nrecover\\(\\);\n\n}\n\n}\n\n}\n\n};\n\n4.8.1節給出了enum類的一些例外。\n\n4.1.3 空塊：可以用簡潔版本\n\n一個空的塊狀結構裏什麽也不包含，大括號可以簡潔地寫成{}，不需要換行。例外：如果它是一個多塊語句的一部分\\(if/else 或 try/catch/finally\\) ，即使大括號內沒內容，右大括號也要換行。\n\n示例：\n\nvoid doNothing\\(\\) {}\n\n4.2 塊縮進：2個空格\n\n每當開始一個新的塊，縮進增加2個空格，當塊結束時，縮進返回先前的縮進級別。縮進級別適用於代碼和註釋。\\(見4.1.2節中的代碼示例\\)\n\n4.3 一行一個語句\n\n每個語句後要換行。\n\n4.4 列限制：80或100\n\n一個項目可以選擇一行80個字符或100個字符的列限制，除了下述例外，任何一行如果超過這個字符數限制，必須自動換行。\n\n例外：\n\n不可能滿足列限制的行\\(例如，Javadoc中的一個長URL，或是一個長的JSNI方法參考\\)。\n\npackage和import語句\\(見3.2節和3.3節\\)。\n\n註釋中那些可能被剪切並粘貼到shell中的命令行。\n\n4.5 自動換行\n\n術語說明：一般情況下，一行長代碼為了避免超出列限制\\(80或100個字符\\)而被分為多行，我們稱之為自動換行\\(line-wrapping\\)。\n\n我們並沒有全面，確定性的準則來決定在每一種情況下如何自動換行。很多時候，對於同一段代碼會有好幾種有效的自動換行方式。\n\nTip: 提取方法或局部變量可以在不換行的情況下解決代碼過長的問題\\(是合理縮短命名長度吧\\)\n\n4.5.1 從哪裏斷開\n\n自動換行的基本準則是：更傾向於在更高的語法級別處斷開。\n\n如果在非賦值運算符處斷開，那麽在該符號前斷開\\(比如+，它將位於下一行\\)。註意：這一點與Google其它語言的編程風格不同\\(如C++和JavaScript\\)。 這條規則也適用於以下“類運算符”符號：點分隔符\\(.\\)，類型界限中的\n\n&\n\n（\n\n&lt;\n\nT extends Foo \n\n&\n\n Bar\n\n&gt;\n\n\\)，catch塊中的管道符號\\(catch \\(FooException \\| BarException e\\)\n\n如果在賦值運算符處斷開，通常的做法是在該符號後斷開\\(比如=，它與前面的內容留在同一行\\)。這條規則也適用於foreach語句中的分號。\n\n方法名或構造函數名與左括號留在同一行。\n\n逗號\\(,\\)與其前面的內容留在同一行。\n\n4.5.2 自動換行時縮進至少+4個空格\n\n自動換行時，第一行後的每一行至少比第一行多縮進4個空格\\(註意：制表符不用於縮進。見2.3.1節\\)。\n\n當存在連續自動換行時，縮進可能會多縮進不只4個空格\\(語法元素存在多級時\\)。一般而言，兩個連續行使用相同的縮進當且僅當它們開始於同級語法元素。\n\n第4.6.3水平對齊一節中指出，不鼓勵使用可變數目的空格來對齊前面行的符號。\n\n4.6 空白\n\n4.6.1 垂直空白\n\n以下情況需要使用一個空行：\n\n類內連續的成員之間：字段，構造函數，方法，嵌套類，靜態初始化塊，實例初始化塊。\n\n例外：兩個連續字段之間的空行是可選的，用於字段的空行主要用來對字段進行邏輯分組。\n\n在函數體內，語句的邏輯分組間使用空行。\n\n類內的第一個成員前或最後一個成員後的空行是可選的\\(既不鼓勵也不反對這樣做，視個人喜好而定\\)。\n\n要滿足本文檔中其他節的空行要求\\(比如3.3節：import語句\\)\n\n多個連續的空行是允許的，但沒有必要這樣做\\(我們也不鼓勵這樣做\\)。\n\n4.6.2 水平空白\n\n除了語言需求和其它規則，並且除了文字，註釋和Javadoc用到單個空格，單個ASCII空格也出現在以下幾個地方：\n\n分隔任何保留字與緊隨其後的左括號\\(\\(\\)\\(如if, for catch等\\)。\n\n分隔任何保留字與其前面的右大括號\\(}\\)\\(如else, catch\\)。\n\n在任何左大括號前\\({\\)，兩個例外：\n\n@SomeAnnotation\\({a, b}\\)\\(不使用空格\\)。\n\nString\n\n\\[\\]\\[\\]\n\n x = foo;\\(大括號間沒有空格，見下面的Note\\)。\n\n在任何二元或三元運算符的兩側。這也適用於以下“類運算符”符號：\n\n類型界限中的\n\n&\n\n\\(\n\n&lt;\n\nT extends Foo \n\n&\n\n Bar\n\n&gt;\n\n\\)。\n\ncatch塊中的管道符號\\(catch \\(FooException \\| BarException e\\)。\n\nforeach語句中的分號。\n\n在, : ;及右括號\\(\\)\\)後\n\n如果在一條語句後做註釋，則雙斜杠\\(//\\)兩邊都要空格。這裏可以允許多個空格，但沒有必要。\n\n類型和變量之間：List list。\n\n數組初始化中，大括號內的空格是可選的，即new int\\[\\] {5, 6}和new int\\[\\] { 5, 6 }都是可以的。\n\nNote：這個規則並不要求或禁止一行的開關或結尾需要額外的空格，只對內部空格做要求。\n\n4.6.3 水平對齊：不做要求\n\n術語說明：水平對齊指的是通過增加可變數量的空格來使某一行的字符與上一行的相應字符對齊。\n\n這是允許的\\(而且在不少地方可以看到這樣的代碼\\)，但Google編程風格對此不做要求。即使對於已經使用水平對齊的代碼，我們也不需要去保持這種風格。\n\n以下示例先展示未對齊的代碼，然後是對齊的代碼：\n\nprivate int x; // this is fine\n\nprivate Color color; // this too\n\nprivate int x; // permitted, but future edits\n\nprivate Color color; // may leave it unaligned\n\nTip：對齊可增加代碼可讀性，但它為日後的維護帶來問題。考慮未來某個時候，我們需要修改一堆對齊的代碼中的一行。 這可能導致原本很漂亮的對齊代碼變得錯位。很可能它會提示你調整周圍代碼的空白來使這一堆代碼重新水平對齊\\(比如程序員想保持這種水平對齊的風格\\)， 這就會讓你做許多的無用功，增加了reviewer的工作並且可能導致更多的合並沖突。\n\n4.7 用小括號來限定組：推薦\n\n除非作者和reviewer都認為去掉小括號也不會使代碼被誤解，或是去掉小括號能讓代碼更易於閱讀，否則我們不應該去掉小括號。 我們沒有理由假設讀者能記住整個Java運算符優先級表。\n\n4.8 具體結構\n\n4.8.1 枚舉類\n\n枚舉常量間用逗號隔開，換行可選。\n\n沒有方法和文檔的枚舉類可寫成數組初始化的格式：\n\nprivate enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }\n\n由於枚舉類也是一個類，因此所有適用於其它類的格式規則也適用於枚舉類。\n\n4.8.2 變量聲明\n\n4.8.2.1 每次只聲明一個變量\n\n不要使用組合聲明，比如int a, b;。\n\n4.8.2.2 需要時才聲明，並盡快進行初始化\n\n不要在一個代碼塊的開頭把局部變量一次性都聲明了\\(這是c語言的做法\\)，而是在第一次需要使用它時才聲明。 局部變量在聲明時最好就進行初始化，或者聲明後盡快進行初始化。\n\n4.8.3 數組\n\n4.8.3.1 數組初始化：可寫成塊狀結構\n\n數組初始化可以寫成塊狀結構，比如，下面的寫法都是OK的：\n\nnew int\\[\\] {\n\n0, 1, 2, 3\n\n}\n\nnew int\\[\\] {\n\n0,\n\n1,\n\n2,\n\n3\n\n}\n\nnew int\\[\\] {\n\n0, 1,\n\n2, 3\n\n}\n\nnew int\\[\\]{0, 1, 2, 3}\n\n4.8.3.2 非C風格的數組聲明\n\n中括號是類型的一部分：String\\[\\] args， 而非String args\\[\\]。\n\n4.8.4 switch語句\n\n術語說明：switch塊的大括號內是一個或多個語句組。每個語句組包含一個或多個switch標簽\\(case FOO:或default:\\)，後面跟著一條或多條語句。\n\n4.8.4.1 縮進\n\n與其它塊狀結構一致，switch塊中的內容縮進為2個空格。\n\n每個switch標簽後新起一行，再縮進2個空格，寫下一條或多條語句。\n\n4.8.4.2 Fall-through：註釋\n\n在一個switch塊內，每個語句組要麽通過break, continue, return或拋出異常來終止，要麽通過一條註釋來說明程序將繼續執行到下一個語句組， 任何能表達這個意思的註釋都是OK的\\(典型的是用// fall through\\)。這個特殊的註釋並不需要在最後一個語句組\\(一般是default\\)中出現。示例：\n\nswitch \\(input\\) {\n\ncase 1:\n\ncase 2:\n\nprepareOneOrTwo\\(\\);\n\n// fall through\n\ncase 3:\n\nhandleOneTwoOrThree\\(\\);\n\nbreak;\n\ndefault:\n\nhandleLargeNumber\\(input\\);\n\n}\n\n4.8.4.3 default的情況要寫出來\n\n每個switch語句都包含一個default語句組，即使它什麽代碼也不包含。\n\n4.8.5 註解\\(Annotations\\)\n\n註解緊跟在文檔塊後面，應用於類、方法和構造函數，一個註解獨占一行。這些換行不屬於自動換行\\(第4.5節，自動換行\\)，因此縮進級別不變。例如：\n\n@Override\n\n@Nullable\n\npublic String getNameIfPresent\\(\\) { ... }\n\n例外：單個的註解可以和簽名的第一行出現在同一行。例如：\n\n@Override public int hashCode\\(\\) { ... }\n\n應用於字段的註解緊隨文檔塊出現，應用於字段的多個註解允許與字段出現在同一行。例如：\n\n@Partial @Mock DataLoader loader;\n\n參數和局部變量註解沒有特定規則。\n\n4.8.6 註釋\n\n4.8.6.1 塊註釋風格\n\n塊註釋與其周圍的代碼在同一縮進級別。它們可以是/\\* ... \n\n\\*\n\n/風格，也可以是// ...風格。對於多行的/\n\n\\*\n\n ... \n\n\\*\n\n/註釋，後續行必須從\n\n\\*\n\n開始， 並且與前一行的\\*對齊。以下示例註釋都是OK的。\n\n/\\*\n\n\\*\n\n This is // And so /\\* Or you can\n\n\\*\n\n okay. // is this. \\* even do this. \\*/\n\n \\*/\n\n註釋不要封閉在由星號或其它字符繪制的框架裏。\n\nTip：在寫多行註釋時，如果你希望在必要時能重新換行\\(即註釋像段落風格一樣\\)，那麽使用/\\* ... \\*/。\n\n4.8.7 Modifiers\n\n類和成員的modifiers如果存在，則按Java語言規範中推薦的順序出現。\n\npublic protected private abstract static final transient volatile synchronized native strictfp\n\n命名約定\n\n5.1 對所有標識符都通用的規則\n\n標識符只能使用ASCII字母和數字，因此每個有效的標識符名稱都能匹配正則表達式\\w+。\n\n在Google其它編程語言風格中使用的特殊前綴或後綴，如name\n\n\\_\n\n, mName, s\n\n\\_\n\nname和kName，在Java編程風格中都不再使用。\n\n5.2 標識符類型的規則\n\n5.2.1 包名\n\n包名全部小寫，連續的單詞只是簡單地連接起來，不使用下劃線。\n\n5.2.2 類名\n\n類名都以UpperCamelCase風格編寫。\n\n類名通常是名詞或名詞短語，接口名稱有時可能是形容詞或形容詞短語。現在還沒有特定的規則或行之有效的約定來命名註解類型。\n\n測試類的命名以它要測試的類的名稱開始，以Test結束。例如，HashTest或HashIntegrationTest。\n\n5.2.3 方法名\n\n方法名都以lowerCamelCase風格編寫。\n\n方法名通常是動詞或動詞短語。\n\n下劃線可能出現在JUnit測試方法名稱中用以分隔名稱的邏輯組件。一個典型的模式是：test\n\n&lt;\n\nMethodUnderTest\n\n&gt;\n\n\\_\n\n&lt;\n\nstate\n\n&gt;\n\n，例如testPop\n\n\\_\n\nemptyStack。 並不存在唯一正確的方式來命名測試方法。\n\n5.2.4 常量名\n\n常量名命名模式為CONSTANT\\_CASE，全部字母大寫，用下劃線分隔單詞。那，到底什麽算是一個常量？\n\n每個常量都是一個靜態final字段，但不是所有靜態final字段都是常量。在決定一個字段是否是一個常量時， 考慮它是否真的感覺像是一個常量。例如，如果任何一個該實例的觀測狀態是可變的，則它幾乎肯定不會是一個常量。 只是永遠不打算改變對象一般是不夠的，它要真的一直不變才能將它示為常量。\n\n// Constants\n\nstatic final int NUMBER = 5;\n\nstatic final ImmutableList\n\n&lt;\n\nString\n\n&gt;\n\n NAMES = ImmutableList.of\\(\"Ed\", \"Ann\"\\);\n\nstatic final Joiner COMMA\\_JOINER = Joiner.on\\(','\\); // because Joiner is immutable\n\nstatic final SomeMutableType\\[\\] EMPTY\\_ARRAY = {};\n\nenum SomeEnum { ENUM\\_CONSTANT }\n\n// Not constants\n\nstatic String nonFinal = \"non-final\";\n\nfinal String nonStatic = \"non-static\";\n\nstatic final Set\n\n&lt;\n\nString\n\n&gt;\n\n mutableCollection = new HashSet\n\n&lt;\n\nString\n\n&gt;\n\n\\(\\);\n\nstatic final ImmutableSet\n\n&lt;\n\nSomeMutableType\n\n&gt;\n\n mutableElements = ImmutableSet.of\\(mutable\\);\n\nstatic final Logger logger = Logger.getLogger\\(MyClass.getName\\(\\)\\);\n\nstatic final String\\[\\] nonEmptyArray = {\"these\", \"can\", \"change\"};\n\n這些名字通常是名詞或名詞短語。\n\n5.2.5 非常量字段名\n\n非常量字段名以lowerCamelCase風格編寫。\n\n這些名字通常是名詞或名詞短語。\n\n5.2.6 參數名\n\n參數名以lowerCamelCase風格編寫。\n\n參數應該避免用單個字符命名。\n\n5.2.7 局部變量名\n\n局部變量名以lowerCamelCase風格編寫，比起其它類型的名稱，局部變量名可以有更為寬松的縮寫。\n\n雖然縮寫更寬松，但還是要避免用單字符進行命名，除了臨時變量和循環變量。\n\n即使局部變量是final和不可改變的，也不應該把它示為常量，自然也不能用常量的規則去命名它。\n\n5.2.8 類型變量名\n\n類型變量可用以下兩種風格之一進行命名：\n\n單個的大寫字母，後面可以跟一個數字\\(如：E, T, X, T2\\)。\n\n以類命名方式\\(5.2.2節\\)，後面加個大寫的T\\(如：RequestT, FooBarT\\)。\n\n5.3 駝峰式命名法\\(CamelCase\\)\n\n駝峰式命名法分大駝峰式命名法\\(UpperCamelCase\\)和小駝峰式命名法\\(lowerCamelCase\\)。 有時，我們有不只一種合理的方式將一個英語詞組轉換成駝峰形式，如縮略語或不尋常的結構\\(例如”IPv6”或”iOS”\\)。Google指定了以下的轉換方案。\n\n名字從散文形式\\(prose form\\)開始:\n\n把短語轉換為純ASCII碼，並且移除任何單引號。例如：”Müller’s algorithm”將變成”Muellers algorithm”。\n\n把這個結果切分成單詞，在空格或其它標點符號\\(通常是連字符\\)處分割開。\n\n推薦：如果某個單詞已經有了常用的駝峰表示形式，按它的組成將它分割開\\(如”AdWords”將分割成”ad words”\\)。 需要註意的是”iOS”並不是一個真正的駝峰表示形式，因此該推薦對它並不適用。\n\n現在將所有字母都小寫\\(包括縮寫\\)，然後將單詞的第一個字母大寫：\n\n每個單詞的第一個字母都大寫，來得到大駝峰式命名。\n\n除了第一個單詞，每個單詞的第一個字母都大寫，來得到小駝峰式命名。\n\n最後將所有的單詞連接起來得到一個標識符。\n\n示例：\n\nProse form Correct Incorrect ------------------------------------------------------------------\n\n\"XML HTTP request\" XmlHttpRequest XMLHTTPRequest\n\n\"new customer ID\" newCustomerId newCustomerID\n\n\"inner stopwatch\" innerStopwatch innerStopWatch\n\n\"supports IPv6 on iOS?\" supportsIpv6OnIos supportsIPv6OnIOS\n\n\"YouTube importer\" YouTubeImporter\n\nYoutubeImporter\\*\n\n加星號處表示可以，但不推薦。\n\nNote：在英語中，某些帶有連字符的單詞形式不唯一。例如：”nonempty”和”non-empty”都是正確的，因此方法名checkNonempty和checkNonEmpty也都是正確的。\n\n編程實踐\n\n6.1 @Override：能用則用\n\n只要是合法的，就把@Override註解給用上。\n\n6.2 捕獲的異常：不能忽視\n\n除了下面的例子，對捕獲的異常不做響應是極少正確的。\\(典型的響應方式是打印日誌，或者如果它被認為是不可能的，則把它當作一個AssertionError重新拋出。\\)\n\n如果它確實是不需要在catch塊中做任何響應，需要做註釋加以說明\\(如下面的例子\\)。\n\ntry {\n\nint i = Integer.parseInt\\(response\\);\n\nreturn handleNumericResponse\\(i\\);\n\n} catch \\(NumberFormatException ok\\) {\n\n// it's not numeric; that's fine, just continue\n\n}\n\nreturn handleTextResponse\\(response\\);\n\n例外：在測試中，如果一個捕獲的異常被命名為expected，則它可以被不加註釋地忽略。下面是一種非常常見的情形，用以確保所測試的方法會拋出一個期望中的異常， 因此在這裏就沒有必要加註釋。\n\ntry {\n\nemptyStack.pop\\(\\);\n\nfail\\(\\);\n\n} catch \\(NoSuchElementException expected\\) {\n\n}\n\n6.3 靜態成員：使用類進行調用\n\n使用類名調用靜態的類成員，而不是具體某個對象或表達式。\n\nFoo aFoo = ...;\n\nFoo.aStaticMethod\\(\\); // good\n\naFoo.aStaticMethod\\(\\); // bad\n\nsomethingThatYieldsAFoo\\(\\).aStaticMethod\\(\\); // very bad\n\n6.4 Finalizers: 禁用\n\n極少會去重寫Object.finalize。\n\nTip：不要使用finalize。如果你非要使用它，請先仔細閱讀和理解Effective Java 第7條款：“Avoid Finalizers”，然後不要使用它。\n\nJavadoc\n\n7.1 格式\n\n7.1.1 一般形式\n\nJavadoc塊的基本格式如下所示：\n\n/\\*\\*\n\n\\*\n\n Multiple lines of Javadoc text are written here,\n\n\\*\n\n wrapped normally...\n\n \\*/\n\npublic int method\\(String p1\\) { ... }\n\n或者是以下單行形式：\n\n/\\*\\* An especially short bit of Javadoc. \\*/\n\n基本格式總是OK的。當整個Javadoc塊能容納於一行時\\(且沒有Javadoc標記@XXX\\)，可以使用單行形式。\n\n7.1.2 段落\n\n空行\\(即，只包含最左側星號的行\\)會出現在段落之間和Javadoc標記\\(@XXX\\)之前\\(如果有的話\\)。 除了第一個段落，每個段落第一個單詞前都有標簽\n\n&lt;\n\np\n\n&gt;\n\n，並且它和第一個單詞間沒有空格。\n\n7.1.3 Javadoc標記\n\n標準的Javadoc標記按以下順序出現：@param, @return, @throws, @deprecated, 前面這4種標記如果出現，描述都不能為空。 當描述無法在一行中容納，連續行需要至少再縮進4個空格。\n\n7.2 摘要片段\n\n每個類或成員的Javadoc以一個簡短的摘要片段開始。這個片段是非常重要的，在某些情況下，它是唯一出現的文本，比如在類和方法索引中。\n\n這只是一個小片段，可以是一個名詞短語或動詞短語，但不是一個完整的句子。它不會以A {@code Foo} is a...或This method returns...開頭, 它也不會是一個完整的祈使句，如Save the record...。然而，由於開頭大寫及被加了標點，它看起來就像是個完整的句子。\n\nTip：一個常見的錯誤是把簡單的Javadoc寫成/\n\n\\*\\*\n\n @return the customer ID \\*/，這是不正確的。它應該寫成/\n\n\\*\\*\n\n Returns the customer ID. \\*/。\n\n7.3 哪裏需要使用Javadoc\n\n至少在每個public類及它的每個public和protected成員處使用Javadoc，以下是一些例外：\n\n7.3.1 例外：不言自明的方法\n\n對於簡單明顯的方法如getFoo，Javadoc是可選的\\(即，是可以不寫的\\)。這種情況下除了寫“Returns the foo”，確實也沒有什麽值得寫了。\n\n單元測試類中的測試方法可能是不言自明的最常見例子了，我們通常可以從這些方法的描述性命名中知道它是幹什麽的，因此不需要額外的文檔說明。\n\nTip：如果有一些相關信息是需要讀者了解的，那麽以上的例外不應作為忽視這些信息的理由。例如，對於方法名getCanonicalName， 就不應該忽視文檔說明，因為讀者很可能不知道詞語canonical name指的是什麽。\n\n7.3.2 例外：重寫\n\n如果一個方法重寫了超類中的方法，那麽Javadoc並非必需的。\n\n7.3.3 可選的Javadoc\n\n對於包外不可見的類和方法，如有需要，也是要使用Javadoc的。如果一個註釋是用來定義一個類，方法，字段的整體目的或行為， 那麽這個註釋應該寫成Javadoc，這樣更統一更友好。\n\n\n\n","slug":"android/androidcan-kao-gui-fan","published":1,"updated":"2018-10-02T02:52:44.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4ot005yntnbyatzaiwf","content":"<h2 id=\"Android參考規範\"><a href=\"#Android參考規範\" class=\"headerlink\" title=\"Android參考規範\"></a>Android參考規範</h2><p><a href=\"https://google.github.io/styleguide/javaguide.html\" target=\"_blank\" rel=\"noopener\">https://google.github.io/styleguide/javaguide.html</a></p>\n<h3 id=\"基本的命名法\"><a href=\"#基本的命名法\" class=\"headerlink\" title=\"基本的命名法\"></a>基本的命名法</h3><p>Java編程比較常見的有下面三種命名方式</p>\n<p>1.駝峰(Camel)命名法:又稱小駝峰命名法，除首單詞外，其余所有單詞的第一個字母大寫。</p>\n<p>2.帕斯卡(pascal)命名法:又稱大駝峰命名法，所有單詞的第一個字母大寫</p>\n<p>3.下劃線命名法:單詞與單詞間用下劃線做間隔</p>\n<p>一般建議拿來做命名的單詞要比較精悍短小，這樣即使兩三個單詞一起拼裝成一個命名，也不至於顯得很冗長。當然有些單詞我們也可以直接寫成一些約定俗成的縮寫。諸如：msg(message)、init(initial)、img(image)等…..</p>\n<p>個人認為，這些縮寫可參照業界常見的縮寫命名，也可以根據當前項目中的風格，進行團隊成員間的約定。這樣相對比較靈活，也方便團隊成員之間相互理解。</p>\n<h3 id=\"包命名\"><a href=\"#包命名\" class=\"headerlink\" title=\"包命名\"></a>包命名</h3><p>采用反域名命名規則，全部使用小寫字母，一般為3層</p>\n<p>一級包名為com;</p>\n<p>二級包名為xx（可以是公司或則個人的隨便）;</p>\n<p>三級包名應用的英文名app_name;</p>\n<p>四級包名為模塊名或層級名;</p>\n<p>如：<a href=\"http://www.ziines.com\" target=\"_blank\" rel=\"noopener\">www.ziines.com</a></p>\n<p>正常-&gt;com.ziines.www</p>\n<p>參考-&gt;com.ziines.android或com.ziines.it</p>\n<p>如：framework.com.hk</p>\n<p>正常-&gt;hk.nmg.framework</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命名格式</th>\n<th style=\"text-align:left\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.activities(或com.xx.app_name.activity)</td>\n<td style=\"text-align:left\">存放app所有的Activity</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.service</td>\n<td style=\"text-align:left\">存放app所有的Service</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.receiver</td>\n<td style=\"text-align:left\">存放app所有的BroadcastReceiver</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.provider</td>\n<td style=\"text-align:left\">存放app所有的ContentProvider</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.fragment</td>\n<td style=\"text-align:left\">存放app所有的Fragment</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.dialog</td>\n<td style=\"text-align:left\">存放app所有的Dialog</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.base</td>\n<td style=\"text-align:left\">存放app一些共有的基礎模塊，諸如BaseActivity、BaseContentProvider、BaseService，BaseFragment等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.utils</td>\n<td style=\"text-align:left\">存放app的工具類,諸如格式化日期的DateFormatUtils，處理字符串的StringUtils等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.bean(或com.xx.app_name.unity)</td>\n<td style=\"text-align:left\">存放app自定義的實體類</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.db)</td>\n<td style=\"text-align:left\">存放app數據庫操作相關的類</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.view)</td>\n<td style=\"text-align:left\">存放app自定義的控件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.adapter)</td>\n<td style=\"text-align:left\">存放app所有的適配器類</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"類命名\"><a href=\"#類命名\" class=\"headerlink\" title=\"類命名\"></a>類命名</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">類</th>\n<th style=\"text-align:left\">命名格式</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Activity</td>\n<td style=\"text-align:left\">XXX功能+Activity</td>\n<td style=\"text-align:left\">如主界面HomeActivity,啟動頁LauncherActivity</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Service</td>\n<td style=\"text-align:left\">XXX功能+Service</td>\n<td style=\"text-align:left\">如消息推送的Service，PushService或PushMessageService</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">BroadcastReceiver</td>\n<td style=\"text-align:left\">XXX功能+Receiver</td>\n<td style=\"text-align:left\">如在線的消息廣播接受者，OnlineReceiver</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ContentProvider</td>\n<td style=\"text-align:left\">XXX功能+Provider</td>\n<td style=\"text-align:left\">如聯系人的內容提供者，ContactsProvider</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fragment</td>\n<td style=\"text-align:left\">XXX功能+Fragment</td>\n<td style=\"text-align:left\">如顯示聯系人的Fragment，ContactsFragment</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Dialog</td>\n<td style=\"text-align:left\">XXX功能+Dialog</td>\n<td style=\"text-align:left\">如普通的選擇提示對話框，ChoiceDialog</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Adapter</td>\n<td style=\"text-align:left\">XXX功能+XX类型控件Adapter</td>\n<td style=\"text-align:left\">如聯系人列表，ContactsListAdapter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">基础功能类</td>\n<td style=\"text-align:left\">Base+XX父类名</td>\n<td style=\"text-align:left\">如BaseActivity，BaseFragment</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">工具类</td>\n<td style=\"text-align:left\">XXX功能+Utils</td>\n<td style=\"text-align:left\">如處理字符串的工具類，StringUtils</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">管理类</td>\n<td style=\"text-align:left\">XXX功能+Manager</td>\n<td style=\"text-align:left\">如管理聯系人的類，ContactsManager</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"接口命名\"><a href=\"#接口命名\" class=\"headerlink\" title=\"接口命名\"></a>接口命名</h3><p>和類名基本一致。也可以在接口名前面再加一個大寫的I，表明這是一個接口Interface。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>動詞或動名詞，采用小駝峰命名法。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命名風格</th>\n<th style=\"text-align:left\">含義</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">initXX()</td>\n<td style=\"text-align:left\">初始化，如初始化所有控件initView()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">isXX()</td>\n<td style=\"text-align:left\">是否滿足某種要求，如是否為註冊用戶isRegister()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">processXX()</td>\n<td style=\"text-align:left\">對數據做某些處理，可以以process作為前綴</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">displayXX()</td>\n<td style=\"text-align:left\">顯示提示信息，如displayXXDialog，displayToast，displayXXPopupWindow</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">saveXX()</td>\n<td style=\"text-align:left\">保存XX數據</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">resetXX()</td>\n<td style=\"text-align:left\">重置XX數據</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">addXX()/insertXX()</td>\n<td style=\"text-align:left\">添加XX數據</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">deleteXX()/removeXX()</td>\n<td style=\"text-align:left\">刪除XX數據</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">updateXX()</td>\n<td style=\"text-align:left\">更新XX數據</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">searchXX()/findXX()/queryXX()</td>\n<td style=\"text-align:left\">查找XX數據</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">draw()</td>\n<td style=\"text-align:left\">控件裏面使用居多，例如繪制文本drawText</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"變量\"><a href=\"#變量\" class=\"headerlink\" title=\"變量\"></a>變量</h3><p>采采用小駝峰命名法。同樣比較簡單，但為了更好表明含義，我建議做一下的的區分</p>\n<p>成員變量命名前面加m（member，表示成員變量之意），如，控件的寬高 mWidth，mHeight</p>\n<p>靜態類變量前面加s（static，表示靜態變量之意），如，一個靜態的單例 sSingleInstance</p>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>同樣較為簡單，全部大寫,采用下劃線命名法.如：MIN_WIDTH,MAX_SIZE</p>\n<h3 id=\"布局資源文件-layout文件夾下\"><a href=\"#布局資源文件-layout文件夾下\" class=\"headerlink\" title=\"布局資源文件(layout文件夾下)\"></a>布局資源文件(layout文件夾下)</h3><p>全部小寫，采用下劃線命名法</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">布局類型</th>\n<th style=\"text-align:left\">命名風格</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Activity的xml布局</td>\n<td style=\"text-align:left\">activity_+XX功能，如主頁面activity_home</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fragment的xml布局</td>\n<td style=\"text-align:left\">fragment_+XX功能，如聯繫人模塊fragment_contacts</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Dialog的xml布局</td>\n<td style=\"text-align:left\">dialog_+XX功能，如選擇日期dialog_select_date</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">抽取出來重用的xml布局（include）</td>\n<td style=\"text-align:left\">include_+XX功能，如底部tab欄include_bottom_tabs</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ListView或者RecyclerView的item xml布局</td>\n<td style=\"text-align:left\">XX功能+_list_item，如聯繫人的contact_info_list_item</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GridView的item xml布局</td>\n<td style=\"text-align:left\">XX功能+_grid_item，如相冊的album_grid_item</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"動畫資源文件-anim文件夾下\"><a href=\"#動畫資源文件-anim文件夾下\" class=\"headerlink\" title=\"動畫資源文件(anim文件夾下)\"></a>動畫資源文件(anim文件夾下)</h3><p>全部小寫，采用下劃線命名法，加前綴區分.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">動畫效果</th>\n<th style=\"text-align:left\">命名風格</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">淡入/淡出</td>\n<td style=\"text-align:left\">fade_in/fade_out</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从某個方向淡入/淡出</td>\n<td style=\"text-align:left\">fade_方向_in(out),右边淡入淡出fade_right_in(out)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从某個方向彈入/彈出</td>\n<td style=\"text-align:left\">push_方向_in(out),右边推入推出push_right_in(out)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从某個方向滑入/滑出</td>\n<td style=\"text-align:left\">slide_in(out)<em>from</em>方向,右边滑入滑出slide_in(out)_from_right</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"strings和colors資源文件\"><a href=\"#strings和colors資源文件\" class=\"headerlink\" title=\"strings和colors資源文件\"></a>strings和colors資源文件</h3><p>小駝峰命名法,命名風格大致如下：</p>\n<p>string命名格式：XX界面_XX功能_str,如 activity_home_welcome_str</p>\n<p>color命名格式：color_16進制顏色值，如紅色 color_ff0000</p>\n<p>像string通常建議把同一個界面的所有string都放到一起，方便查找。而color的命名則省去我們頭疼的想這個顏色怎麽命名。</p>\n<h3 id=\"selecor、drawable、layer-list資源文件\"><a href=\"#selecor、drawable、layer-list資源文件\" class=\"headerlink\" title=\"selecor、drawable、layer-list資源文件\"></a>selecor、drawable、layer-list資源文件</h3><p>小駝峰命名法。命名風格通常都是XX_selector、XX_drawable、XX_layer。</p>\n<p>下面舉兩個比較常用的栗子：</p>\n<p>按鈕按壓效果button_selector，正常狀態命名為button_normal(XX_normal)，按壓狀態命名為button_pressed(XX_pressed)</p>\n<p>選擇效果checkbox_selector,未選中狀態命名為checkbox_unchecked(XX_unchecked),選中狀態為checkbox_checked(XX_checked)</p>\n<h3 id=\"styles、dimens資源文件\"><a href=\"#styles、dimens資源文件\" class=\"headerlink\" title=\"styles、dimens資源文件\"></a>styles、dimens資源文件</h3><p>style采用大駝峰命名法，主題可以命名為XXTheme,控件的風格可以命名為XXStyle</p>\n<p>dimen采用小駝峰命名法，如所有Activity的titlebar的高度，activity_title_height_dimen</p>\n<h3 id=\"控件id命名\"><a href=\"#控件id命名\" class=\"headerlink\" title=\"控件id命名\"></a>控件id命名</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">控件</th>\n<th style=\"text-align:left\">java前綴縮寫</th>\n<th style=\"text-align:left\">xml</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">RelativeLayout</td>\n<td style=\"text-align:left\">rly</td>\n<td style=\"text-align:left\">rly</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinearLayout</td>\n<td style=\"text-align:left\">lly</td>\n<td style=\"text-align:left\">lly</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FrameLayout</td>\n<td style=\"text-align:left\">fly</td>\n<td style=\"text-align:left\">fly</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TextView</td>\n<td style=\"text-align:left\">tv</td>\n<td style=\"text-align:left\">tv</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Button</td>\n<td style=\"text-align:left\">btn</td>\n<td style=\"text-align:left\">btn</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ImageButton</td>\n<td style=\"text-align:left\">imgBtn</td>\n<td style=\"text-align:left\">img_btn</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ImageView</td>\n<td style=\"text-align:left\">iv</td>\n<td style=\"text-align:left\">iv</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CheckBox</td>\n<td style=\"text-align:left\">chk</td>\n<td style=\"text-align:left\">chk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RadioButton</td>\n<td style=\"text-align:left\">rb</td>\n<td style=\"text-align:left\">rb</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">analogClock</td>\n<td style=\"text-align:left\">anaClk</td>\n<td style=\"text-align:left\">ana_clk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DigtalClock</td>\n<td style=\"text-align:left\">dgtClk</td>\n<td style=\"text-align:left\">dgt_clk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DatePicker</td>\n<td style=\"text-align:left\">dtPk</td>\n<td style=\"text-align:left\">dt_pk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">EditText</td>\n<td style=\"text-align:left\">edt</td>\n<td style=\"text-align:left\">edt</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TimePicker</td>\n<td style=\"text-align:left\">tmPk</td>\n<td style=\"text-align:left\">tm_pk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">toggleButton</td>\n<td style=\"text-align:left\">tglBtn</td>\n<td style=\"text-align:left\">tgl_btn</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ProgressBar</td>\n<td style=\"text-align:left\">proBar / progressBar</td>\n<td style=\"text-align:left\">pro_bar / progress_bar</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SeekBar</td>\n<td style=\"text-align:left\">skBar / seekBar</td>\n<td style=\"text-align:left\">sk_bar / seek_bar</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">AutoCompleteTextView</td>\n<td style=\"text-align:left\">autoTv</td>\n<td style=\"text-align:left\">auto_tv</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZoomControl</td>\n<td style=\"text-align:left\">zmCtl</td>\n<td style=\"text-align:left\">zm_ctl</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">VideoView</td>\n<td style=\"text-align:left\">videoView</td>\n<td style=\"text-align:left\">video_view</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WebView</td>\n<td style=\"text-align:left\">webView</td>\n<td style=\"text-align:left\">web_view</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Spinner</td>\n<td style=\"text-align:left\">spn</td>\n<td style=\"text-align:left\">spn</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Chronometer</td>\n<td style=\"text-align:left\">cmt</td>\n<td style=\"text-align:left\">cmt</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ScollView</td>\n<td style=\"text-align:left\">scollView</td>\n<td style=\"text-align:left\">scoll_view</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TextSwitch</td>\n<td style=\"text-align:left\">txtSwitch</td>\n<td style=\"text-align:left\">txt_swt</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ImageSwitch</td>\n<td style=\"text-align:left\">imgSwt</td>\n<td style=\"text-align:left\">img_swt</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ListView</td>\n<td style=\"text-align:left\">lv</td>\n<td style=\"text-align:left\">lv</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GridView</td>\n<td style=\"text-align:left\">gv</td>\n<td style=\"text-align:left\">gv</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ExpandableList</td>\n<td style=\"text-align:left\">epdLt</td>\n<td style=\"text-align:left\">epd_lt</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">MapView</td>\n<td style=\"text-align:left\">mapView</td>\n<td style=\"text-align:left\">map_view</td>\n</tr>\n</tbody>\n</table>\n<p>前言</p>\n<p>這份文檔是Google Java編程風格規範的完整定義。當且僅當一個Java源文件符合此文檔中的規則， 我們才認為它符合Google的Java編程風格。</p>\n<p>與其它的編程風格指南一樣，這裏所討論的不僅僅是編碼格式美不美觀的問題， 同時也討論一些約定及編碼標準。然而，這份文檔主要側重於我們所普遍遵循的規則， 對於那些不是明確強制要求的，我們盡量避免提供意見。</p>\n<p>1.1 術語說明</p>\n<p>在本文檔中，除非另有說明：</p>\n<p>術語class可表示一個普通類，枚舉類，接口或是annotation類型(@interface)</p>\n<p>術語comment只用來指代實現的註釋(implementation comments)，我們不使用“documentation comments”一詞，而是用Javadoc。</p>\n<p>其他的術語說明會偶爾在後面的文檔出現。</p>\n<p>1.2 指南說明</p>\n<p>本文檔中的示例代碼並不作為規範。也就是說，雖然示例代碼是遵循Google編程風格，但並不意味著這是展現這些代碼的唯一方式。 示例中的格式選擇不應該被強制定為規則。</p>\n<p>源文件基礎</p>\n<p>2.1 文件名</p>\n<p>源文件以其最頂層的類名來命名，大小寫敏感，文件擴展名為.java。</p>\n<p>2.2 文件編碼：UTF-8</p>\n<p>源文件編碼格式為UTF-8。</p>\n<p>2.3 特殊字符</p>\n<p>2.3.1 空白字符</p>\n<p>除了行結束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允許出現的空白字符，這意味著：</p>\n<p>所有其它字符串中的空白字符都要進行轉義。</p>\n<p>制表符不用於縮進。</p>\n<p>2.3.2 特殊轉義序列</p>\n<p>對於具有特殊轉義序列的任何字符(\\b, \\t, \\n, \\f, \\r, “, ‘及\\)，我們使用它的轉義序列，而不是相應的八進制(比如\\012)或Unicode(比如\\u000a)轉義。</p>\n<p>2.3.3 非ASCII字符</p>\n<p>對於剩余的非ASCII字符，是使用實際的Unicode字符(比如∞)，還是使用等價的Unicode轉義符(比如\\u221e)，取決於哪個能讓代碼更易於閱讀和理解。</p>\n<p>Tip: 在使用Unicode轉義符或是一些實際的Unicode字符時，建議做些註釋給出解釋，這有助於別人閱讀和理解。</p>\n<p>例如：</p>\n<p>String unitAbbrev = “μs”; | 贊，即使沒有註釋也非常清晰</p>\n<p>String unitAbbrev = “\\u03bcs”; // “μs” | 允許，但沒有理由要這樣做</p>\n<p>String unitAbbrev = “\\u03bcs”; // Greek letter mu, “s” | 允許，但這樣做顯得笨拙還容易出錯</p>\n<p>String unitAbbrev = “\\u03bcs”; | 很糟，讀者根本看不出這是什麽</p>\n<p>return ‘\\ufeff’ + content; // byte order mark | Good，對於非打印字符，使用轉義，並在必要時寫上註釋</p>\n<p>Tip: 永遠不要由於害怕某些程序可能無法正確處理非ASCII字符而讓你的代碼可讀性變差。當程序無法正確處理非ASCII字符時，它自然無法正確運行， 你就會去fix這些問題的了。(言下之意就是大膽去用非ASCII字符，如果真的有需要的話)</p>\n<p>源文件結構</p>\n<p>一個源文件包含(按順序地)：</p>\n<p>許可證或版權信息(如有需要)</p>\n<p>package語句</p>\n<p>import語句</p>\n<p>一個頂級類(只有一個)</p>\n<p>以上每個部分之間用一個空行隔開。</p>\n<p>3.1 許可證或版權信息</p>\n<p>如果一個文件包含許可證或版權信息，那麽它應當被放在文件最前面。</p>\n<p>3.2 package語句</p>\n<p>package語句不換行，列限制(4.4節)並不適用於package語句。(即package語句寫在一行裏)</p>\n<p>3.3 import語句</p>\n<p>3.3.1 import不要使用通配符</p>\n<p>即，不要出現類似這樣的import語句：import java.util.*;</p>\n<p>3.3.2 不要換行</p>\n<p>import語句不換行，列限制(4.4節)並不適用於import語句。(每個import語句獨立成行)</p>\n<p>3.3.3 順序和間距</p>\n<p>import語句可分為以下幾組，按照這個順序，每組由一個空行分隔：</p>\n<p>所有的靜態導入獨立成組</p>\n<p>com.google imports(僅當這個源文件是在com.google包下)</p>\n<p>第三方的包。每個頂級包為一組，字典序。例如：android, com, junit, org, sun</p>\n<p>java imports</p>\n<p>javax imports</p>\n<p>組內不空行，按字典序排列。</p>\n<p>3.4 類聲明</p>\n<p>3.4.1 只有一個頂級類聲明</p>\n<p>每個頂級類都在一個與它同名的源文件中(當然，還包含.java後綴)。</p>\n<p>例外：package-info.java，該文件中可沒有package-info類。</p>\n<p>3.4.2 類成員順序</p>\n<p>類的成員順序對易學性有很大的影響，但這也不存在唯一的通用法則。不同的類對成員的排序可能是不同的。 最重要的一點，每個類應該以某種邏輯去排序它的成員，維護者應該要能解釋這種排序邏輯。比如， 新的方法不能總是習慣性地添加到類的結尾，因為這樣就是按時間順序而非某種邏輯來排序的。</p>\n<p>3.4.2.1 重載：永不分離</p>\n<p>當一個類有多個構造函數，或是多個同名方法，這些函數/方法應該按順序出現在一起，中間不要放進其它函數/方法。</p>\n<p>格式</p>\n<p>術語說明：塊狀結構(block-like construct)指的是一個類，方法或構造函數的主體。需要註意的是，數組初始化中的初始值可被選擇性地視為塊狀結構(4.8.3.1節)。</p>\n<p>4.1 大括號</p>\n<p>4.1.1 使用大括號(即使是可選的)</p>\n<p>大括號與if, else, for, do, while語句一起使用，即使只有一條語句(或是空)，也應該把大括號寫上。</p>\n<p>4.1.2 非空塊：K </p>\n<p>&amp;</p>\n<p> R 風格</p>\n<p>對於非空塊和塊狀結構，大括號遵循Kernighan和Ritchie風格 (Egyptian brackets):</p>\n<p>左大括號前不換行</p>\n<p>左大括號後換行</p>\n<p>右大括號前換行</p>\n<p>如果右大括號是一個語句、函數體或類的終止，則右大括號後換行; 否則不換行。例如，如果右大括號後面是else或逗號，則不換行。</p>\n<p>示例：</p>\n<p>return new MyClass() {</p>\n<p>@Override public void method() {</p>\n<p>if (condition()) {</p>\n<p>try {</p>\n<p>something();</p>\n<p>} catch (ProblemException e) {</p>\n<p>recover();</p>\n<p>}</p>\n<p>}</p>\n<p>}</p>\n<p>};</p>\n<p>4.8.1節給出了enum類的一些例外。</p>\n<p>4.1.3 空塊：可以用簡潔版本</p>\n<p>一個空的塊狀結構裏什麽也不包含，大括號可以簡潔地寫成{}，不需要換行。例外：如果它是一個多塊語句的一部分(if/else 或 try/catch/finally) ，即使大括號內沒內容，右大括號也要換行。</p>\n<p>示例：</p>\n<p>void doNothing() {}</p>\n<p>4.2 塊縮進：2個空格</p>\n<p>每當開始一個新的塊，縮進增加2個空格，當塊結束時，縮進返回先前的縮進級別。縮進級別適用於代碼和註釋。(見4.1.2節中的代碼示例)</p>\n<p>4.3 一行一個語句</p>\n<p>每個語句後要換行。</p>\n<p>4.4 列限制：80或100</p>\n<p>一個項目可以選擇一行80個字符或100個字符的列限制，除了下述例外，任何一行如果超過這個字符數限制，必須自動換行。</p>\n<p>例外：</p>\n<p>不可能滿足列限制的行(例如，Javadoc中的一個長URL，或是一個長的JSNI方法參考)。</p>\n<p>package和import語句(見3.2節和3.3節)。</p>\n<p>註釋中那些可能被剪切並粘貼到shell中的命令行。</p>\n<p>4.5 自動換行</p>\n<p>術語說明：一般情況下，一行長代碼為了避免超出列限制(80或100個字符)而被分為多行，我們稱之為自動換行(line-wrapping)。</p>\n<p>我們並沒有全面，確定性的準則來決定在每一種情況下如何自動換行。很多時候，對於同一段代碼會有好幾種有效的自動換行方式。</p>\n<p>Tip: 提取方法或局部變量可以在不換行的情況下解決代碼過長的問題(是合理縮短命名長度吧)</p>\n<p>4.5.1 從哪裏斷開</p>\n<p>自動換行的基本準則是：更傾向於在更高的語法級別處斷開。</p>\n<p>如果在非賦值運算符處斷開，那麽在該符號前斷開(比如+，它將位於下一行)。註意：這一點與Google其它語言的編程風格不同(如C++和JavaScript)。 這條規則也適用於以下“類運算符”符號：點分隔符(.)，類型界限中的</p>\n<p>&amp;</p>\n<p>（</p>\n<p>&lt;</p>\n<p>T extends Foo </p>\n<p>&amp;</p>\n<p> Bar</p>\n<p>&gt;</p>\n<p>)，catch塊中的管道符號(catch (FooException | BarException e)</p>\n<p>如果在賦值運算符處斷開，通常的做法是在該符號後斷開(比如=，它與前面的內容留在同一行)。這條規則也適用於foreach語句中的分號。</p>\n<p>方法名或構造函數名與左括號留在同一行。</p>\n<p>逗號(,)與其前面的內容留在同一行。</p>\n<p>4.5.2 自動換行時縮進至少+4個空格</p>\n<p>自動換行時，第一行後的每一行至少比第一行多縮進4個空格(註意：制表符不用於縮進。見2.3.1節)。</p>\n<p>當存在連續自動換行時，縮進可能會多縮進不只4個空格(語法元素存在多級時)。一般而言，兩個連續行使用相同的縮進當且僅當它們開始於同級語法元素。</p>\n<p>第4.6.3水平對齊一節中指出，不鼓勵使用可變數目的空格來對齊前面行的符號。</p>\n<p>4.6 空白</p>\n<p>4.6.1 垂直空白</p>\n<p>以下情況需要使用一個空行：</p>\n<p>類內連續的成員之間：字段，構造函數，方法，嵌套類，靜態初始化塊，實例初始化塊。</p>\n<p>例外：兩個連續字段之間的空行是可選的，用於字段的空行主要用來對字段進行邏輯分組。</p>\n<p>在函數體內，語句的邏輯分組間使用空行。</p>\n<p>類內的第一個成員前或最後一個成員後的空行是可選的(既不鼓勵也不反對這樣做，視個人喜好而定)。</p>\n<p>要滿足本文檔中其他節的空行要求(比如3.3節：import語句)</p>\n<p>多個連續的空行是允許的，但沒有必要這樣做(我們也不鼓勵這樣做)。</p>\n<p>4.6.2 水平空白</p>\n<p>除了語言需求和其它規則，並且除了文字，註釋和Javadoc用到單個空格，單個ASCII空格也出現在以下幾個地方：</p>\n<p>分隔任何保留字與緊隨其後的左括號(()(如if, for catch等)。</p>\n<p>分隔任何保留字與其前面的右大括號(})(如else, catch)。</p>\n<p>在任何左大括號前({)，兩個例外：</p>\n<p>@SomeAnnotation({a, b})(不使用空格)。</p>\n<p>String</p>\n<p>[][]</p>\n<p> x = foo;(大括號間沒有空格，見下面的Note)。</p>\n<p>在任何二元或三元運算符的兩側。這也適用於以下“類運算符”符號：</p>\n<p>類型界限中的</p>\n<p>&amp;</p>\n<p>(</p>\n<p>&lt;</p>\n<p>T extends Foo </p>\n<p>&amp;</p>\n<p> Bar</p>\n<p>&gt;</p>\n<p>)。</p>\n<p>catch塊中的管道符號(catch (FooException | BarException e)。</p>\n<p>foreach語句中的分號。</p>\n<p>在, : ;及右括號())後</p>\n<p>如果在一條語句後做註釋，則雙斜杠(//)兩邊都要空格。這裏可以允許多個空格，但沒有必要。</p>\n<p>類型和變量之間：List list。</p>\n<p>數組初始化中，大括號內的空格是可選的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。</p>\n<p>Note：這個規則並不要求或禁止一行的開關或結尾需要額外的空格，只對內部空格做要求。</p>\n<p>4.6.3 水平對齊：不做要求</p>\n<p>術語說明：水平對齊指的是通過增加可變數量的空格來使某一行的字符與上一行的相應字符對齊。</p>\n<p>這是允許的(而且在不少地方可以看到這樣的代碼)，但Google編程風格對此不做要求。即使對於已經使用水平對齊的代碼，我們也不需要去保持這種風格。</p>\n<p>以下示例先展示未對齊的代碼，然後是對齊的代碼：</p>\n<p>private int x; // this is fine</p>\n<p>private Color color; // this too</p>\n<p>private int x; // permitted, but future edits</p>\n<p>private Color color; // may leave it unaligned</p>\n<p>Tip：對齊可增加代碼可讀性，但它為日後的維護帶來問題。考慮未來某個時候，我們需要修改一堆對齊的代碼中的一行。 這可能導致原本很漂亮的對齊代碼變得錯位。很可能它會提示你調整周圍代碼的空白來使這一堆代碼重新水平對齊(比如程序員想保持這種水平對齊的風格)， 這就會讓你做許多的無用功，增加了reviewer的工作並且可能導致更多的合並沖突。</p>\n<p>4.7 用小括號來限定組：推薦</p>\n<p>除非作者和reviewer都認為去掉小括號也不會使代碼被誤解，或是去掉小括號能讓代碼更易於閱讀，否則我們不應該去掉小括號。 我們沒有理由假設讀者能記住整個Java運算符優先級表。</p>\n<p>4.8 具體結構</p>\n<p>4.8.1 枚舉類</p>\n<p>枚舉常量間用逗號隔開，換行可選。</p>\n<p>沒有方法和文檔的枚舉類可寫成數組初始化的格式：</p>\n<p>private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }</p>\n<p>由於枚舉類也是一個類，因此所有適用於其它類的格式規則也適用於枚舉類。</p>\n<p>4.8.2 變量聲明</p>\n<p>4.8.2.1 每次只聲明一個變量</p>\n<p>不要使用組合聲明，比如int a, b;。</p>\n<p>4.8.2.2 需要時才聲明，並盡快進行初始化</p>\n<p>不要在一個代碼塊的開頭把局部變量一次性都聲明了(這是c語言的做法)，而是在第一次需要使用它時才聲明。 局部變量在聲明時最好就進行初始化，或者聲明後盡快進行初始化。</p>\n<p>4.8.3 數組</p>\n<p>4.8.3.1 數組初始化：可寫成塊狀結構</p>\n<p>數組初始化可以寫成塊狀結構，比如，下面的寫法都是OK的：</p>\n<p>new int[] {</p>\n<p>0, 1, 2, 3</p>\n<p>}</p>\n<p>new int[] {</p>\n<p>0,</p>\n<p>1,</p>\n<p>2,</p>\n<p>3</p>\n<p>}</p>\n<p>new int[] {</p>\n<p>0, 1,</p>\n<p>2, 3</p>\n<p>}</p>\n<p>new int[]{0, 1, 2, 3}</p>\n<p>4.8.3.2 非C風格的數組聲明</p>\n<p>中括號是類型的一部分：String[] args， 而非String args[]。</p>\n<p>4.8.4 switch語句</p>\n<p>術語說明：switch塊的大括號內是一個或多個語句組。每個語句組包含一個或多個switch標簽(case FOO:或default:)，後面跟著一條或多條語句。</p>\n<p>4.8.4.1 縮進</p>\n<p>與其它塊狀結構一致，switch塊中的內容縮進為2個空格。</p>\n<p>每個switch標簽後新起一行，再縮進2個空格，寫下一條或多條語句。</p>\n<p>4.8.4.2 Fall-through：註釋</p>\n<p>在一個switch塊內，每個語句組要麽通過break, continue, return或拋出異常來終止，要麽通過一條註釋來說明程序將繼續執行到下一個語句組， 任何能表達這個意思的註釋都是OK的(典型的是用// fall through)。這個特殊的註釋並不需要在最後一個語句組(一般是default)中出現。示例：</p>\n<p>switch (input) {</p>\n<p>case 1:</p>\n<p>case 2:</p>\n<p>prepareOneOrTwo();</p>\n<p>// fall through</p>\n<p>case 3:</p>\n<p>handleOneTwoOrThree();</p>\n<p>break;</p>\n<p>default:</p>\n<p>handleLargeNumber(input);</p>\n<p>}</p>\n<p>4.8.4.3 default的情況要寫出來</p>\n<p>每個switch語句都包含一個default語句組，即使它什麽代碼也不包含。</p>\n<p>4.8.5 註解(Annotations)</p>\n<p>註解緊跟在文檔塊後面，應用於類、方法和構造函數，一個註解獨占一行。這些換行不屬於自動換行(第4.5節，自動換行)，因此縮進級別不變。例如：</p>\n<p>@Override</p>\n<p>@Nullable</p>\n<p>public String getNameIfPresent() { … }</p>\n<p>例外：單個的註解可以和簽名的第一行出現在同一行。例如：</p>\n<p>@Override public int hashCode() { … }</p>\n<p>應用於字段的註解緊隨文檔塊出現，應用於字段的多個註解允許與字段出現在同一行。例如：</p>\n<p>@Partial @Mock DataLoader loader;</p>\n<p>參數和局部變量註解沒有特定規則。</p>\n<p>4.8.6 註釋</p>\n<p>4.8.6.1 塊註釋風格</p>\n<p>塊註釋與其周圍的代碼在同一縮進級別。它們可以是/* … </p>\n<p>*</p>\n<p>/風格，也可以是// …風格。對於多行的/</p>\n<p>*</p>\n<p> … </p>\n<p>*</p>\n<p>/註釋，後續行必須從</p>\n<p>*</p>\n<p>開始， 並且與前一行的*對齊。以下示例註釋都是OK的。</p>\n<p>/*</p>\n<p>*</p>\n<p> This is // And so /* Or you can</p>\n<p>*</p>\n<p> okay. // is this. * even do this. */</p>\n<p> */</p>\n<p>註釋不要封閉在由星號或其它字符繪制的框架裏。</p>\n<p>Tip：在寫多行註釋時，如果你希望在必要時能重新換行(即註釋像段落風格一樣)，那麽使用/* … */。</p>\n<p>4.8.7 Modifiers</p>\n<p>類和成員的modifiers如果存在，則按Java語言規範中推薦的順序出現。</p>\n<p>public protected private abstract static final transient volatile synchronized native strictfp</p>\n<p>命名約定</p>\n<p>5.1 對所有標識符都通用的規則</p>\n<p>標識符只能使用ASCII字母和數字，因此每個有效的標識符名稱都能匹配正則表達式\\w+。</p>\n<p>在Google其它編程語言風格中使用的特殊前綴或後綴，如name</p>\n<p>_</p>\n<p>, mName, s</p>\n<p>_</p>\n<p>name和kName，在Java編程風格中都不再使用。</p>\n<p>5.2 標識符類型的規則</p>\n<p>5.2.1 包名</p>\n<p>包名全部小寫，連續的單詞只是簡單地連接起來，不使用下劃線。</p>\n<p>5.2.2 類名</p>\n<p>類名都以UpperCamelCase風格編寫。</p>\n<p>類名通常是名詞或名詞短語，接口名稱有時可能是形容詞或形容詞短語。現在還沒有特定的規則或行之有效的約定來命名註解類型。</p>\n<p>測試類的命名以它要測試的類的名稱開始，以Test結束。例如，HashTest或HashIntegrationTest。</p>\n<p>5.2.3 方法名</p>\n<p>方法名都以lowerCamelCase風格編寫。</p>\n<p>方法名通常是動詞或動詞短語。</p>\n<p>下劃線可能出現在JUnit測試方法名稱中用以分隔名稱的邏輯組件。一個典型的模式是：test</p>\n<p>&lt;</p>\n<p>MethodUnderTest</p>\n<p>&gt;</p>\n<p>_</p>\n<p>&lt;</p>\n<p>state</p>\n<p>&gt;</p>\n<p>，例如testPop</p>\n<p>_</p>\n<p>emptyStack。 並不存在唯一正確的方式來命名測試方法。</p>\n<p>5.2.4 常量名</p>\n<p>常量名命名模式為CONSTANT_CASE，全部字母大寫，用下劃線分隔單詞。那，到底什麽算是一個常量？</p>\n<p>每個常量都是一個靜態final字段，但不是所有靜態final字段都是常量。在決定一個字段是否是一個常量時， 考慮它是否真的感覺像是一個常量。例如，如果任何一個該實例的觀測狀態是可變的，則它幾乎肯定不會是一個常量。 只是永遠不打算改變對象一般是不夠的，它要真的一直不變才能將它示為常量。</p>\n<p>// Constants</p>\n<p>static final int NUMBER = 5;</p>\n<p>static final ImmutableList</p>\n<p>&lt;</p>\n<p>String</p>\n<p>&gt;</p>\n<p> NAMES = ImmutableList.of(“Ed”, “Ann”);</p>\n<p>static final Joiner COMMA_JOINER = Joiner.on(‘,’); // because Joiner is immutable</p>\n<p>static final SomeMutableType[] EMPTY_ARRAY = {};</p>\n<p>enum SomeEnum { ENUM_CONSTANT }</p>\n<p>// Not constants</p>\n<p>static String nonFinal = “non-final”;</p>\n<p>final String nonStatic = “non-static”;</p>\n<p>static final Set</p>\n<p>&lt;</p>\n<p>String</p>\n<p>&gt;</p>\n<p> mutableCollection = new HashSet</p>\n<p>&lt;</p>\n<p>String</p>\n<p>&gt;</p>\n<p>();</p>\n<p>static final ImmutableSet</p>\n<p>&lt;</p>\n<p>SomeMutableType</p>\n<p>&gt;</p>\n<p> mutableElements = ImmutableSet.of(mutable);</p>\n<p>static final Logger logger = Logger.getLogger(MyClass.getName());</p>\n<p>static final String[] nonEmptyArray = {“these”, “can”, “change”};</p>\n<p>這些名字通常是名詞或名詞短語。</p>\n<p>5.2.5 非常量字段名</p>\n<p>非常量字段名以lowerCamelCase風格編寫。</p>\n<p>這些名字通常是名詞或名詞短語。</p>\n<p>5.2.6 參數名</p>\n<p>參數名以lowerCamelCase風格編寫。</p>\n<p>參數應該避免用單個字符命名。</p>\n<p>5.2.7 局部變量名</p>\n<p>局部變量名以lowerCamelCase風格編寫，比起其它類型的名稱，局部變量名可以有更為寬松的縮寫。</p>\n<p>雖然縮寫更寬松，但還是要避免用單字符進行命名，除了臨時變量和循環變量。</p>\n<p>即使局部變量是final和不可改變的，也不應該把它示為常量，自然也不能用常量的規則去命名它。</p>\n<p>5.2.8 類型變量名</p>\n<p>類型變量可用以下兩種風格之一進行命名：</p>\n<p>單個的大寫字母，後面可以跟一個數字(如：E, T, X, T2)。</p>\n<p>以類命名方式(5.2.2節)，後面加個大寫的T(如：RequestT, FooBarT)。</p>\n<p>5.3 駝峰式命名法(CamelCase)</p>\n<p>駝峰式命名法分大駝峰式命名法(UpperCamelCase)和小駝峰式命名法(lowerCamelCase)。 有時，我們有不只一種合理的方式將一個英語詞組轉換成駝峰形式，如縮略語或不尋常的結構(例如”IPv6”或”iOS”)。Google指定了以下的轉換方案。</p>\n<p>名字從散文形式(prose form)開始:</p>\n<p>把短語轉換為純ASCII碼，並且移除任何單引號。例如：”Müller’s algorithm”將變成”Muellers algorithm”。</p>\n<p>把這個結果切分成單詞，在空格或其它標點符號(通常是連字符)處分割開。</p>\n<p>推薦：如果某個單詞已經有了常用的駝峰表示形式，按它的組成將它分割開(如”AdWords”將分割成”ad words”)。 需要註意的是”iOS”並不是一個真正的駝峰表示形式，因此該推薦對它並不適用。</p>\n<p>現在將所有字母都小寫(包括縮寫)，然後將單詞的第一個字母大寫：</p>\n<p>每個單詞的第一個字母都大寫，來得到大駝峰式命名。</p>\n<p>除了第一個單詞，每個單詞的第一個字母都大寫，來得到小駝峰式命名。</p>\n<p>最後將所有的單詞連接起來得到一個標識符。</p>\n<p>示例：</p>\n<p>Prose form Correct Incorrect ——————————————————————</p>\n<p>“XML HTTP request” XmlHttpRequest XMLHTTPRequest</p>\n<p>“new customer ID” newCustomerId newCustomerID</p>\n<p>“inner stopwatch” innerStopwatch innerStopWatch</p>\n<p>“supports IPv6 on iOS?” supportsIpv6OnIos supportsIPv6OnIOS</p>\n<p>“YouTube importer” YouTubeImporter</p>\n<p>YoutubeImporter*</p>\n<p>加星號處表示可以，但不推薦。</p>\n<p>Note：在英語中，某些帶有連字符的單詞形式不唯一。例如：”nonempty”和”non-empty”都是正確的，因此方法名checkNonempty和checkNonEmpty也都是正確的。</p>\n<p>編程實踐</p>\n<p>6.1 @Override：能用則用</p>\n<p>只要是合法的，就把@Override註解給用上。</p>\n<p>6.2 捕獲的異常：不能忽視</p>\n<p>除了下面的例子，對捕獲的異常不做響應是極少正確的。(典型的響應方式是打印日誌，或者如果它被認為是不可能的，則把它當作一個AssertionError重新拋出。)</p>\n<p>如果它確實是不需要在catch塊中做任何響應，需要做註釋加以說明(如下面的例子)。</p>\n<p>try {</p>\n<p>int i = Integer.parseInt(response);</p>\n<p>return handleNumericResponse(i);</p>\n<p>} catch (NumberFormatException ok) {</p>\n<p>// it’s not numeric; that’s fine, just continue</p>\n<p>}</p>\n<p>return handleTextResponse(response);</p>\n<p>例外：在測試中，如果一個捕獲的異常被命名為expected，則它可以被不加註釋地忽略。下面是一種非常常見的情形，用以確保所測試的方法會拋出一個期望中的異常， 因此在這裏就沒有必要加註釋。</p>\n<p>try {</p>\n<p>emptyStack.pop();</p>\n<p>fail();</p>\n<p>} catch (NoSuchElementException expected) {</p>\n<p>}</p>\n<p>6.3 靜態成員：使用類進行調用</p>\n<p>使用類名調用靜態的類成員，而不是具體某個對象或表達式。</p>\n<p>Foo aFoo = …;</p>\n<p>Foo.aStaticMethod(); // good</p>\n<p>aFoo.aStaticMethod(); // bad</p>\n<p>somethingThatYieldsAFoo().aStaticMethod(); // very bad</p>\n<p>6.4 Finalizers: 禁用</p>\n<p>極少會去重寫Object.finalize。</p>\n<p>Tip：不要使用finalize。如果你非要使用它，請先仔細閱讀和理解Effective Java 第7條款：“Avoid Finalizers”，然後不要使用它。</p>\n<p>Javadoc</p>\n<p>7.1 格式</p>\n<p>7.1.1 一般形式</p>\n<p>Javadoc塊的基本格式如下所示：</p>\n<p>/**</p>\n<p>*</p>\n<p> Multiple lines of Javadoc text are written here,</p>\n<p>*</p>\n<p> wrapped normally…</p>\n<p> */</p>\n<p>public int method(String p1) { … }</p>\n<p>或者是以下單行形式：</p>\n<p>/** An especially short bit of Javadoc. */</p>\n<p>基本格式總是OK的。當整個Javadoc塊能容納於一行時(且沒有Javadoc標記@XXX)，可以使用單行形式。</p>\n<p>7.1.2 段落</p>\n<p>空行(即，只包含最左側星號的行)會出現在段落之間和Javadoc標記(@XXX)之前(如果有的話)。 除了第一個段落，每個段落第一個單詞前都有標簽</p>\n<p>&lt;</p>\n<p>p</p>\n<p>&gt;</p>\n<p>，並且它和第一個單詞間沒有空格。</p>\n<p>7.1.3 Javadoc標記</p>\n<p>標準的Javadoc標記按以下順序出現：@param, @return, @throws, @deprecated, 前面這4種標記如果出現，描述都不能為空。 當描述無法在一行中容納，連續行需要至少再縮進4個空格。</p>\n<p>7.2 摘要片段</p>\n<p>每個類或成員的Javadoc以一個簡短的摘要片段開始。這個片段是非常重要的，在某些情況下，它是唯一出現的文本，比如在類和方法索引中。</p>\n<p>這只是一個小片段，可以是一個名詞短語或動詞短語，但不是一個完整的句子。它不會以A {@code Foo} is a…或This method returns…開頭, 它也不會是一個完整的祈使句，如Save the record…。然而，由於開頭大寫及被加了標點，它看起來就像是個完整的句子。</p>\n<p>Tip：一個常見的錯誤是把簡單的Javadoc寫成/</p>\n<p>**</p>\n<p> @return the customer ID */，這是不正確的。它應該寫成/</p>\n<p>**</p>\n<p> Returns the customer ID. */。</p>\n<p>7.3 哪裏需要使用Javadoc</p>\n<p>至少在每個public類及它的每個public和protected成員處使用Javadoc，以下是一些例外：</p>\n<p>7.3.1 例外：不言自明的方法</p>\n<p>對於簡單明顯的方法如getFoo，Javadoc是可選的(即，是可以不寫的)。這種情況下除了寫“Returns the foo”，確實也沒有什麽值得寫了。</p>\n<p>單元測試類中的測試方法可能是不言自明的最常見例子了，我們通常可以從這些方法的描述性命名中知道它是幹什麽的，因此不需要額外的文檔說明。</p>\n<p>Tip：如果有一些相關信息是需要讀者了解的，那麽以上的例外不應作為忽視這些信息的理由。例如，對於方法名getCanonicalName， 就不應該忽視文檔說明，因為讀者很可能不知道詞語canonical name指的是什麽。</p>\n<p>7.3.2 例外：重寫</p>\n<p>如果一個方法重寫了超類中的方法，那麽Javadoc並非必需的。</p>\n<p>7.3.3 可選的Javadoc</p>\n<p>對於包外不可見的類和方法，如有需要，也是要使用Javadoc的。如果一個註釋是用來定義一個類，方法，字段的整體目的或行為， 那麽這個註釋應該寫成Javadoc，這樣更統一更友好。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Android參考規範\"><a href=\"#Android參考規範\" class=\"headerlink\" title=\"Android參考規範\"></a>Android參考規範</h2><p><a href=\"https://google.github.io/styleguide/javaguide.html\" target=\"_blank\" rel=\"noopener\">https://google.github.io/styleguide/javaguide.html</a></p>\n<h3 id=\"基本的命名法\"><a href=\"#基本的命名法\" class=\"headerlink\" title=\"基本的命名法\"></a>基本的命名法</h3><p>Java編程比較常見的有下面三種命名方式</p>\n<p>1.駝峰(Camel)命名法:又稱小駝峰命名法，除首單詞外，其余所有單詞的第一個字母大寫。</p>\n<p>2.帕斯卡(pascal)命名法:又稱大駝峰命名法，所有單詞的第一個字母大寫</p>\n<p>3.下劃線命名法:單詞與單詞間用下劃線做間隔</p>\n<p>一般建議拿來做命名的單詞要比較精悍短小，這樣即使兩三個單詞一起拼裝成一個命名，也不至於顯得很冗長。當然有些單詞我們也可以直接寫成一些約定俗成的縮寫。諸如：msg(message)、init(initial)、img(image)等…..</p>\n<p>個人認為，這些縮寫可參照業界常見的縮寫命名，也可以根據當前項目中的風格，進行團隊成員間的約定。這樣相對比較靈活，也方便團隊成員之間相互理解。</p>\n<h3 id=\"包命名\"><a href=\"#包命名\" class=\"headerlink\" title=\"包命名\"></a>包命名</h3><p>采用反域名命名規則，全部使用小寫字母，一般為3層</p>\n<p>一級包名為com;</p>\n<p>二級包名為xx（可以是公司或則個人的隨便）;</p>\n<p>三級包名應用的英文名app_name;</p>\n<p>四級包名為模塊名或層級名;</p>\n<p>如：<a href=\"http://www.ziines.com\" target=\"_blank\" rel=\"noopener\">www.ziines.com</a></p>\n<p>正常-&gt;com.ziines.www</p>\n<p>參考-&gt;com.ziines.android或com.ziines.it</p>\n<p>如：framework.com.hk</p>\n<p>正常-&gt;hk.nmg.framework</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命名格式</th>\n<th style=\"text-align:left\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.activities(或com.xx.app_name.activity)</td>\n<td style=\"text-align:left\">存放app所有的Activity</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.service</td>\n<td style=\"text-align:left\">存放app所有的Service</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.receiver</td>\n<td style=\"text-align:left\">存放app所有的BroadcastReceiver</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.provider</td>\n<td style=\"text-align:left\">存放app所有的ContentProvider</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.fragment</td>\n<td style=\"text-align:left\">存放app所有的Fragment</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.dialog</td>\n<td style=\"text-align:left\">存放app所有的Dialog</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.base</td>\n<td style=\"text-align:left\">存放app一些共有的基礎模塊，諸如BaseActivity、BaseContentProvider、BaseService，BaseFragment等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.utils</td>\n<td style=\"text-align:left\">存放app的工具類,諸如格式化日期的DateFormatUtils，處理字符串的StringUtils等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.bean(或com.xx.app_name.unity)</td>\n<td style=\"text-align:left\">存放app自定義的實體類</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.db)</td>\n<td style=\"text-align:left\">存放app數據庫操作相關的類</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.view)</td>\n<td style=\"text-align:left\">存放app自定義的控件</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">com.xx.app_name.adapter)</td>\n<td style=\"text-align:left\">存放app所有的適配器類</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"類命名\"><a href=\"#類命名\" class=\"headerlink\" title=\"類命名\"></a>類命名</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">類</th>\n<th style=\"text-align:left\">命名格式</th>\n<th style=\"text-align:left\">示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Activity</td>\n<td style=\"text-align:left\">XXX功能+Activity</td>\n<td style=\"text-align:left\">如主界面HomeActivity,啟動頁LauncherActivity</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Service</td>\n<td style=\"text-align:left\">XXX功能+Service</td>\n<td style=\"text-align:left\">如消息推送的Service，PushService或PushMessageService</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">BroadcastReceiver</td>\n<td style=\"text-align:left\">XXX功能+Receiver</td>\n<td style=\"text-align:left\">如在線的消息廣播接受者，OnlineReceiver</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ContentProvider</td>\n<td style=\"text-align:left\">XXX功能+Provider</td>\n<td style=\"text-align:left\">如聯系人的內容提供者，ContactsProvider</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fragment</td>\n<td style=\"text-align:left\">XXX功能+Fragment</td>\n<td style=\"text-align:left\">如顯示聯系人的Fragment，ContactsFragment</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Dialog</td>\n<td style=\"text-align:left\">XXX功能+Dialog</td>\n<td style=\"text-align:left\">如普通的選擇提示對話框，ChoiceDialog</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Adapter</td>\n<td style=\"text-align:left\">XXX功能+XX类型控件Adapter</td>\n<td style=\"text-align:left\">如聯系人列表，ContactsListAdapter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">基础功能类</td>\n<td style=\"text-align:left\">Base+XX父类名</td>\n<td style=\"text-align:left\">如BaseActivity，BaseFragment</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">工具类</td>\n<td style=\"text-align:left\">XXX功能+Utils</td>\n<td style=\"text-align:left\">如處理字符串的工具類，StringUtils</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">管理类</td>\n<td style=\"text-align:left\">XXX功能+Manager</td>\n<td style=\"text-align:left\">如管理聯系人的類，ContactsManager</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"接口命名\"><a href=\"#接口命名\" class=\"headerlink\" title=\"接口命名\"></a>接口命名</h3><p>和類名基本一致。也可以在接口名前面再加一個大寫的I，表明這是一個接口Interface。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>動詞或動名詞，采用小駝峰命名法。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命名風格</th>\n<th style=\"text-align:left\">含義</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">initXX()</td>\n<td style=\"text-align:left\">初始化，如初始化所有控件initView()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">isXX()</td>\n<td style=\"text-align:left\">是否滿足某種要求，如是否為註冊用戶isRegister()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">processXX()</td>\n<td style=\"text-align:left\">對數據做某些處理，可以以process作為前綴</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">displayXX()</td>\n<td style=\"text-align:left\">顯示提示信息，如displayXXDialog，displayToast，displayXXPopupWindow</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">saveXX()</td>\n<td style=\"text-align:left\">保存XX數據</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">resetXX()</td>\n<td style=\"text-align:left\">重置XX數據</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">addXX()/insertXX()</td>\n<td style=\"text-align:left\">添加XX數據</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">deleteXX()/removeXX()</td>\n<td style=\"text-align:left\">刪除XX數據</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">updateXX()</td>\n<td style=\"text-align:left\">更新XX數據</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">searchXX()/findXX()/queryXX()</td>\n<td style=\"text-align:left\">查找XX數據</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">draw()</td>\n<td style=\"text-align:left\">控件裏面使用居多，例如繪制文本drawText</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"變量\"><a href=\"#變量\" class=\"headerlink\" title=\"變量\"></a>變量</h3><p>采采用小駝峰命名法。同樣比較簡單，但為了更好表明含義，我建議做一下的的區分</p>\n<p>成員變量命名前面加m（member，表示成員變量之意），如，控件的寬高 mWidth，mHeight</p>\n<p>靜態類變量前面加s（static，表示靜態變量之意），如，一個靜態的單例 sSingleInstance</p>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>同樣較為簡單，全部大寫,采用下劃線命名法.如：MIN_WIDTH,MAX_SIZE</p>\n<h3 id=\"布局資源文件-layout文件夾下\"><a href=\"#布局資源文件-layout文件夾下\" class=\"headerlink\" title=\"布局資源文件(layout文件夾下)\"></a>布局資源文件(layout文件夾下)</h3><p>全部小寫，采用下劃線命名法</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">布局類型</th>\n<th style=\"text-align:left\">命名風格</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Activity的xml布局</td>\n<td style=\"text-align:left\">activity_+XX功能，如主頁面activity_home</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Fragment的xml布局</td>\n<td style=\"text-align:left\">fragment_+XX功能，如聯繫人模塊fragment_contacts</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Dialog的xml布局</td>\n<td style=\"text-align:left\">dialog_+XX功能，如選擇日期dialog_select_date</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">抽取出來重用的xml布局（include）</td>\n<td style=\"text-align:left\">include_+XX功能，如底部tab欄include_bottom_tabs</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ListView或者RecyclerView的item xml布局</td>\n<td style=\"text-align:left\">XX功能+_list_item，如聯繫人的contact_info_list_item</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GridView的item xml布局</td>\n<td style=\"text-align:left\">XX功能+_grid_item，如相冊的album_grid_item</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"動畫資源文件-anim文件夾下\"><a href=\"#動畫資源文件-anim文件夾下\" class=\"headerlink\" title=\"動畫資源文件(anim文件夾下)\"></a>動畫資源文件(anim文件夾下)</h3><p>全部小寫，采用下劃線命名法，加前綴區分.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">動畫效果</th>\n<th style=\"text-align:left\">命名風格</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">淡入/淡出</td>\n<td style=\"text-align:left\">fade_in/fade_out</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从某個方向淡入/淡出</td>\n<td style=\"text-align:left\">fade_方向_in(out),右边淡入淡出fade_right_in(out)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从某個方向彈入/彈出</td>\n<td style=\"text-align:left\">push_方向_in(out),右边推入推出push_right_in(out)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从某個方向滑入/滑出</td>\n<td style=\"text-align:left\">slide_in(out)<em>from</em>方向,右边滑入滑出slide_in(out)_from_right</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"strings和colors資源文件\"><a href=\"#strings和colors資源文件\" class=\"headerlink\" title=\"strings和colors資源文件\"></a>strings和colors資源文件</h3><p>小駝峰命名法,命名風格大致如下：</p>\n<p>string命名格式：XX界面_XX功能_str,如 activity_home_welcome_str</p>\n<p>color命名格式：color_16進制顏色值，如紅色 color_ff0000</p>\n<p>像string通常建議把同一個界面的所有string都放到一起，方便查找。而color的命名則省去我們頭疼的想這個顏色怎麽命名。</p>\n<h3 id=\"selecor、drawable、layer-list資源文件\"><a href=\"#selecor、drawable、layer-list資源文件\" class=\"headerlink\" title=\"selecor、drawable、layer-list資源文件\"></a>selecor、drawable、layer-list資源文件</h3><p>小駝峰命名法。命名風格通常都是XX_selector、XX_drawable、XX_layer。</p>\n<p>下面舉兩個比較常用的栗子：</p>\n<p>按鈕按壓效果button_selector，正常狀態命名為button_normal(XX_normal)，按壓狀態命名為button_pressed(XX_pressed)</p>\n<p>選擇效果checkbox_selector,未選中狀態命名為checkbox_unchecked(XX_unchecked),選中狀態為checkbox_checked(XX_checked)</p>\n<h3 id=\"styles、dimens資源文件\"><a href=\"#styles、dimens資源文件\" class=\"headerlink\" title=\"styles、dimens資源文件\"></a>styles、dimens資源文件</h3><p>style采用大駝峰命名法，主題可以命名為XXTheme,控件的風格可以命名為XXStyle</p>\n<p>dimen采用小駝峰命名法，如所有Activity的titlebar的高度，activity_title_height_dimen</p>\n<h3 id=\"控件id命名\"><a href=\"#控件id命名\" class=\"headerlink\" title=\"控件id命名\"></a>控件id命名</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">控件</th>\n<th style=\"text-align:left\">java前綴縮寫</th>\n<th style=\"text-align:left\">xml</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">RelativeLayout</td>\n<td style=\"text-align:left\">rly</td>\n<td style=\"text-align:left\">rly</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinearLayout</td>\n<td style=\"text-align:left\">lly</td>\n<td style=\"text-align:left\">lly</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">FrameLayout</td>\n<td style=\"text-align:left\">fly</td>\n<td style=\"text-align:left\">fly</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TextView</td>\n<td style=\"text-align:left\">tv</td>\n<td style=\"text-align:left\">tv</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Button</td>\n<td style=\"text-align:left\">btn</td>\n<td style=\"text-align:left\">btn</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ImageButton</td>\n<td style=\"text-align:left\">imgBtn</td>\n<td style=\"text-align:left\">img_btn</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ImageView</td>\n<td style=\"text-align:left\">iv</td>\n<td style=\"text-align:left\">iv</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CheckBox</td>\n<td style=\"text-align:left\">chk</td>\n<td style=\"text-align:left\">chk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RadioButton</td>\n<td style=\"text-align:left\">rb</td>\n<td style=\"text-align:left\">rb</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">analogClock</td>\n<td style=\"text-align:left\">anaClk</td>\n<td style=\"text-align:left\">ana_clk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DigtalClock</td>\n<td style=\"text-align:left\">dgtClk</td>\n<td style=\"text-align:left\">dgt_clk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DatePicker</td>\n<td style=\"text-align:left\">dtPk</td>\n<td style=\"text-align:left\">dt_pk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">EditText</td>\n<td style=\"text-align:left\">edt</td>\n<td style=\"text-align:left\">edt</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TimePicker</td>\n<td style=\"text-align:left\">tmPk</td>\n<td style=\"text-align:left\">tm_pk</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">toggleButton</td>\n<td style=\"text-align:left\">tglBtn</td>\n<td style=\"text-align:left\">tgl_btn</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ProgressBar</td>\n<td style=\"text-align:left\">proBar / progressBar</td>\n<td style=\"text-align:left\">pro_bar / progress_bar</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SeekBar</td>\n<td style=\"text-align:left\">skBar / seekBar</td>\n<td style=\"text-align:left\">sk_bar / seek_bar</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">AutoCompleteTextView</td>\n<td style=\"text-align:left\">autoTv</td>\n<td style=\"text-align:left\">auto_tv</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZoomControl</td>\n<td style=\"text-align:left\">zmCtl</td>\n<td style=\"text-align:left\">zm_ctl</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">VideoView</td>\n<td style=\"text-align:left\">videoView</td>\n<td style=\"text-align:left\">video_view</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">WebView</td>\n<td style=\"text-align:left\">webView</td>\n<td style=\"text-align:left\">web_view</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Spinner</td>\n<td style=\"text-align:left\">spn</td>\n<td style=\"text-align:left\">spn</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Chronometer</td>\n<td style=\"text-align:left\">cmt</td>\n<td style=\"text-align:left\">cmt</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ScollView</td>\n<td style=\"text-align:left\">scollView</td>\n<td style=\"text-align:left\">scoll_view</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">TextSwitch</td>\n<td style=\"text-align:left\">txtSwitch</td>\n<td style=\"text-align:left\">txt_swt</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ImageSwitch</td>\n<td style=\"text-align:left\">imgSwt</td>\n<td style=\"text-align:left\">img_swt</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ListView</td>\n<td style=\"text-align:left\">lv</td>\n<td style=\"text-align:left\">lv</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">GridView</td>\n<td style=\"text-align:left\">gv</td>\n<td style=\"text-align:left\">gv</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ExpandableList</td>\n<td style=\"text-align:left\">epdLt</td>\n<td style=\"text-align:left\">epd_lt</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">MapView</td>\n<td style=\"text-align:left\">mapView</td>\n<td style=\"text-align:left\">map_view</td>\n</tr>\n</tbody>\n</table>\n<p>前言</p>\n<p>這份文檔是Google Java編程風格規範的完整定義。當且僅當一個Java源文件符合此文檔中的規則， 我們才認為它符合Google的Java編程風格。</p>\n<p>與其它的編程風格指南一樣，這裏所討論的不僅僅是編碼格式美不美觀的問題， 同時也討論一些約定及編碼標準。然而，這份文檔主要側重於我們所普遍遵循的規則， 對於那些不是明確強制要求的，我們盡量避免提供意見。</p>\n<p>1.1 術語說明</p>\n<p>在本文檔中，除非另有說明：</p>\n<p>術語class可表示一個普通類，枚舉類，接口或是annotation類型(@interface)</p>\n<p>術語comment只用來指代實現的註釋(implementation comments)，我們不使用“documentation comments”一詞，而是用Javadoc。</p>\n<p>其他的術語說明會偶爾在後面的文檔出現。</p>\n<p>1.2 指南說明</p>\n<p>本文檔中的示例代碼並不作為規範。也就是說，雖然示例代碼是遵循Google編程風格，但並不意味著這是展現這些代碼的唯一方式。 示例中的格式選擇不應該被強制定為規則。</p>\n<p>源文件基礎</p>\n<p>2.1 文件名</p>\n<p>源文件以其最頂層的類名來命名，大小寫敏感，文件擴展名為.java。</p>\n<p>2.2 文件編碼：UTF-8</p>\n<p>源文件編碼格式為UTF-8。</p>\n<p>2.3 特殊字符</p>\n<p>2.3.1 空白字符</p>\n<p>除了行結束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允許出現的空白字符，這意味著：</p>\n<p>所有其它字符串中的空白字符都要進行轉義。</p>\n<p>制表符不用於縮進。</p>\n<p>2.3.2 特殊轉義序列</p>\n<p>對於具有特殊轉義序列的任何字符(\\b, \\t, \\n, \\f, \\r, “, ‘及\\)，我們使用它的轉義序列，而不是相應的八進制(比如\\012)或Unicode(比如\\u000a)轉義。</p>\n<p>2.3.3 非ASCII字符</p>\n<p>對於剩余的非ASCII字符，是使用實際的Unicode字符(比如∞)，還是使用等價的Unicode轉義符(比如\\u221e)，取決於哪個能讓代碼更易於閱讀和理解。</p>\n<p>Tip: 在使用Unicode轉義符或是一些實際的Unicode字符時，建議做些註釋給出解釋，這有助於別人閱讀和理解。</p>\n<p>例如：</p>\n<p>String unitAbbrev = “μs”; | 贊，即使沒有註釋也非常清晰</p>\n<p>String unitAbbrev = “\\u03bcs”; // “μs” | 允許，但沒有理由要這樣做</p>\n<p>String unitAbbrev = “\\u03bcs”; // Greek letter mu, “s” | 允許，但這樣做顯得笨拙還容易出錯</p>\n<p>String unitAbbrev = “\\u03bcs”; | 很糟，讀者根本看不出這是什麽</p>\n<p>return ‘\\ufeff’ + content; // byte order mark | Good，對於非打印字符，使用轉義，並在必要時寫上註釋</p>\n<p>Tip: 永遠不要由於害怕某些程序可能無法正確處理非ASCII字符而讓你的代碼可讀性變差。當程序無法正確處理非ASCII字符時，它自然無法正確運行， 你就會去fix這些問題的了。(言下之意就是大膽去用非ASCII字符，如果真的有需要的話)</p>\n<p>源文件結構</p>\n<p>一個源文件包含(按順序地)：</p>\n<p>許可證或版權信息(如有需要)</p>\n<p>package語句</p>\n<p>import語句</p>\n<p>一個頂級類(只有一個)</p>\n<p>以上每個部分之間用一個空行隔開。</p>\n<p>3.1 許可證或版權信息</p>\n<p>如果一個文件包含許可證或版權信息，那麽它應當被放在文件最前面。</p>\n<p>3.2 package語句</p>\n<p>package語句不換行，列限制(4.4節)並不適用於package語句。(即package語句寫在一行裏)</p>\n<p>3.3 import語句</p>\n<p>3.3.1 import不要使用通配符</p>\n<p>即，不要出現類似這樣的import語句：import java.util.*;</p>\n<p>3.3.2 不要換行</p>\n<p>import語句不換行，列限制(4.4節)並不適用於import語句。(每個import語句獨立成行)</p>\n<p>3.3.3 順序和間距</p>\n<p>import語句可分為以下幾組，按照這個順序，每組由一個空行分隔：</p>\n<p>所有的靜態導入獨立成組</p>\n<p>com.google imports(僅當這個源文件是在com.google包下)</p>\n<p>第三方的包。每個頂級包為一組，字典序。例如：android, com, junit, org, sun</p>\n<p>java imports</p>\n<p>javax imports</p>\n<p>組內不空行，按字典序排列。</p>\n<p>3.4 類聲明</p>\n<p>3.4.1 只有一個頂級類聲明</p>\n<p>每個頂級類都在一個與它同名的源文件中(當然，還包含.java後綴)。</p>\n<p>例外：package-info.java，該文件中可沒有package-info類。</p>\n<p>3.4.2 類成員順序</p>\n<p>類的成員順序對易學性有很大的影響，但這也不存在唯一的通用法則。不同的類對成員的排序可能是不同的。 最重要的一點，每個類應該以某種邏輯去排序它的成員，維護者應該要能解釋這種排序邏輯。比如， 新的方法不能總是習慣性地添加到類的結尾，因為這樣就是按時間順序而非某種邏輯來排序的。</p>\n<p>3.4.2.1 重載：永不分離</p>\n<p>當一個類有多個構造函數，或是多個同名方法，這些函數/方法應該按順序出現在一起，中間不要放進其它函數/方法。</p>\n<p>格式</p>\n<p>術語說明：塊狀結構(block-like construct)指的是一個類，方法或構造函數的主體。需要註意的是，數組初始化中的初始值可被選擇性地視為塊狀結構(4.8.3.1節)。</p>\n<p>4.1 大括號</p>\n<p>4.1.1 使用大括號(即使是可選的)</p>\n<p>大括號與if, else, for, do, while語句一起使用，即使只有一條語句(或是空)，也應該把大括號寫上。</p>\n<p>4.1.2 非空塊：K </p>\n<p>&amp;</p>\n<p> R 風格</p>\n<p>對於非空塊和塊狀結構，大括號遵循Kernighan和Ritchie風格 (Egyptian brackets):</p>\n<p>左大括號前不換行</p>\n<p>左大括號後換行</p>\n<p>右大括號前換行</p>\n<p>如果右大括號是一個語句、函數體或類的終止，則右大括號後換行; 否則不換行。例如，如果右大括號後面是else或逗號，則不換行。</p>\n<p>示例：</p>\n<p>return new MyClass() {</p>\n<p>@Override public void method() {</p>\n<p>if (condition()) {</p>\n<p>try {</p>\n<p>something();</p>\n<p>} catch (ProblemException e) {</p>\n<p>recover();</p>\n<p>}</p>\n<p>}</p>\n<p>}</p>\n<p>};</p>\n<p>4.8.1節給出了enum類的一些例外。</p>\n<p>4.1.3 空塊：可以用簡潔版本</p>\n<p>一個空的塊狀結構裏什麽也不包含，大括號可以簡潔地寫成{}，不需要換行。例外：如果它是一個多塊語句的一部分(if/else 或 try/catch/finally) ，即使大括號內沒內容，右大括號也要換行。</p>\n<p>示例：</p>\n<p>void doNothing() {}</p>\n<p>4.2 塊縮進：2個空格</p>\n<p>每當開始一個新的塊，縮進增加2個空格，當塊結束時，縮進返回先前的縮進級別。縮進級別適用於代碼和註釋。(見4.1.2節中的代碼示例)</p>\n<p>4.3 一行一個語句</p>\n<p>每個語句後要換行。</p>\n<p>4.4 列限制：80或100</p>\n<p>一個項目可以選擇一行80個字符或100個字符的列限制，除了下述例外，任何一行如果超過這個字符數限制，必須自動換行。</p>\n<p>例外：</p>\n<p>不可能滿足列限制的行(例如，Javadoc中的一個長URL，或是一個長的JSNI方法參考)。</p>\n<p>package和import語句(見3.2節和3.3節)。</p>\n<p>註釋中那些可能被剪切並粘貼到shell中的命令行。</p>\n<p>4.5 自動換行</p>\n<p>術語說明：一般情況下，一行長代碼為了避免超出列限制(80或100個字符)而被分為多行，我們稱之為自動換行(line-wrapping)。</p>\n<p>我們並沒有全面，確定性的準則來決定在每一種情況下如何自動換行。很多時候，對於同一段代碼會有好幾種有效的自動換行方式。</p>\n<p>Tip: 提取方法或局部變量可以在不換行的情況下解決代碼過長的問題(是合理縮短命名長度吧)</p>\n<p>4.5.1 從哪裏斷開</p>\n<p>自動換行的基本準則是：更傾向於在更高的語法級別處斷開。</p>\n<p>如果在非賦值運算符處斷開，那麽在該符號前斷開(比如+，它將位於下一行)。註意：這一點與Google其它語言的編程風格不同(如C++和JavaScript)。 這條規則也適用於以下“類運算符”符號：點分隔符(.)，類型界限中的</p>\n<p>&amp;</p>\n<p>（</p>\n<p>&lt;</p>\n<p>T extends Foo </p>\n<p>&amp;</p>\n<p> Bar</p>\n<p>&gt;</p>\n<p>)，catch塊中的管道符號(catch (FooException | BarException e)</p>\n<p>如果在賦值運算符處斷開，通常的做法是在該符號後斷開(比如=，它與前面的內容留在同一行)。這條規則也適用於foreach語句中的分號。</p>\n<p>方法名或構造函數名與左括號留在同一行。</p>\n<p>逗號(,)與其前面的內容留在同一行。</p>\n<p>4.5.2 自動換行時縮進至少+4個空格</p>\n<p>自動換行時，第一行後的每一行至少比第一行多縮進4個空格(註意：制表符不用於縮進。見2.3.1節)。</p>\n<p>當存在連續自動換行時，縮進可能會多縮進不只4個空格(語法元素存在多級時)。一般而言，兩個連續行使用相同的縮進當且僅當它們開始於同級語法元素。</p>\n<p>第4.6.3水平對齊一節中指出，不鼓勵使用可變數目的空格來對齊前面行的符號。</p>\n<p>4.6 空白</p>\n<p>4.6.1 垂直空白</p>\n<p>以下情況需要使用一個空行：</p>\n<p>類內連續的成員之間：字段，構造函數，方法，嵌套類，靜態初始化塊，實例初始化塊。</p>\n<p>例外：兩個連續字段之間的空行是可選的，用於字段的空行主要用來對字段進行邏輯分組。</p>\n<p>在函數體內，語句的邏輯分組間使用空行。</p>\n<p>類內的第一個成員前或最後一個成員後的空行是可選的(既不鼓勵也不反對這樣做，視個人喜好而定)。</p>\n<p>要滿足本文檔中其他節的空行要求(比如3.3節：import語句)</p>\n<p>多個連續的空行是允許的，但沒有必要這樣做(我們也不鼓勵這樣做)。</p>\n<p>4.6.2 水平空白</p>\n<p>除了語言需求和其它規則，並且除了文字，註釋和Javadoc用到單個空格，單個ASCII空格也出現在以下幾個地方：</p>\n<p>分隔任何保留字與緊隨其後的左括號(()(如if, for catch等)。</p>\n<p>分隔任何保留字與其前面的右大括號(})(如else, catch)。</p>\n<p>在任何左大括號前({)，兩個例外：</p>\n<p>@SomeAnnotation({a, b})(不使用空格)。</p>\n<p>String</p>\n<p>[][]</p>\n<p> x = foo;(大括號間沒有空格，見下面的Note)。</p>\n<p>在任何二元或三元運算符的兩側。這也適用於以下“類運算符”符號：</p>\n<p>類型界限中的</p>\n<p>&amp;</p>\n<p>(</p>\n<p>&lt;</p>\n<p>T extends Foo </p>\n<p>&amp;</p>\n<p> Bar</p>\n<p>&gt;</p>\n<p>)。</p>\n<p>catch塊中的管道符號(catch (FooException | BarException e)。</p>\n<p>foreach語句中的分號。</p>\n<p>在, : ;及右括號())後</p>\n<p>如果在一條語句後做註釋，則雙斜杠(//)兩邊都要空格。這裏可以允許多個空格，但沒有必要。</p>\n<p>類型和變量之間：List list。</p>\n<p>數組初始化中，大括號內的空格是可選的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。</p>\n<p>Note：這個規則並不要求或禁止一行的開關或結尾需要額外的空格，只對內部空格做要求。</p>\n<p>4.6.3 水平對齊：不做要求</p>\n<p>術語說明：水平對齊指的是通過增加可變數量的空格來使某一行的字符與上一行的相應字符對齊。</p>\n<p>這是允許的(而且在不少地方可以看到這樣的代碼)，但Google編程風格對此不做要求。即使對於已經使用水平對齊的代碼，我們也不需要去保持這種風格。</p>\n<p>以下示例先展示未對齊的代碼，然後是對齊的代碼：</p>\n<p>private int x; // this is fine</p>\n<p>private Color color; // this too</p>\n<p>private int x; // permitted, but future edits</p>\n<p>private Color color; // may leave it unaligned</p>\n<p>Tip：對齊可增加代碼可讀性，但它為日後的維護帶來問題。考慮未來某個時候，我們需要修改一堆對齊的代碼中的一行。 這可能導致原本很漂亮的對齊代碼變得錯位。很可能它會提示你調整周圍代碼的空白來使這一堆代碼重新水平對齊(比如程序員想保持這種水平對齊的風格)， 這就會讓你做許多的無用功，增加了reviewer的工作並且可能導致更多的合並沖突。</p>\n<p>4.7 用小括號來限定組：推薦</p>\n<p>除非作者和reviewer都認為去掉小括號也不會使代碼被誤解，或是去掉小括號能讓代碼更易於閱讀，否則我們不應該去掉小括號。 我們沒有理由假設讀者能記住整個Java運算符優先級表。</p>\n<p>4.8 具體結構</p>\n<p>4.8.1 枚舉類</p>\n<p>枚舉常量間用逗號隔開，換行可選。</p>\n<p>沒有方法和文檔的枚舉類可寫成數組初始化的格式：</p>\n<p>private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }</p>\n<p>由於枚舉類也是一個類，因此所有適用於其它類的格式規則也適用於枚舉類。</p>\n<p>4.8.2 變量聲明</p>\n<p>4.8.2.1 每次只聲明一個變量</p>\n<p>不要使用組合聲明，比如int a, b;。</p>\n<p>4.8.2.2 需要時才聲明，並盡快進行初始化</p>\n<p>不要在一個代碼塊的開頭把局部變量一次性都聲明了(這是c語言的做法)，而是在第一次需要使用它時才聲明。 局部變量在聲明時最好就進行初始化，或者聲明後盡快進行初始化。</p>\n<p>4.8.3 數組</p>\n<p>4.8.3.1 數組初始化：可寫成塊狀結構</p>\n<p>數組初始化可以寫成塊狀結構，比如，下面的寫法都是OK的：</p>\n<p>new int[] {</p>\n<p>0, 1, 2, 3</p>\n<p>}</p>\n<p>new int[] {</p>\n<p>0,</p>\n<p>1,</p>\n<p>2,</p>\n<p>3</p>\n<p>}</p>\n<p>new int[] {</p>\n<p>0, 1,</p>\n<p>2, 3</p>\n<p>}</p>\n<p>new int[]{0, 1, 2, 3}</p>\n<p>4.8.3.2 非C風格的數組聲明</p>\n<p>中括號是類型的一部分：String[] args， 而非String args[]。</p>\n<p>4.8.4 switch語句</p>\n<p>術語說明：switch塊的大括號內是一個或多個語句組。每個語句組包含一個或多個switch標簽(case FOO:或default:)，後面跟著一條或多條語句。</p>\n<p>4.8.4.1 縮進</p>\n<p>與其它塊狀結構一致，switch塊中的內容縮進為2個空格。</p>\n<p>每個switch標簽後新起一行，再縮進2個空格，寫下一條或多條語句。</p>\n<p>4.8.4.2 Fall-through：註釋</p>\n<p>在一個switch塊內，每個語句組要麽通過break, continue, return或拋出異常來終止，要麽通過一條註釋來說明程序將繼續執行到下一個語句組， 任何能表達這個意思的註釋都是OK的(典型的是用// fall through)。這個特殊的註釋並不需要在最後一個語句組(一般是default)中出現。示例：</p>\n<p>switch (input) {</p>\n<p>case 1:</p>\n<p>case 2:</p>\n<p>prepareOneOrTwo();</p>\n<p>// fall through</p>\n<p>case 3:</p>\n<p>handleOneTwoOrThree();</p>\n<p>break;</p>\n<p>default:</p>\n<p>handleLargeNumber(input);</p>\n<p>}</p>\n<p>4.8.4.3 default的情況要寫出來</p>\n<p>每個switch語句都包含一個default語句組，即使它什麽代碼也不包含。</p>\n<p>4.8.5 註解(Annotations)</p>\n<p>註解緊跟在文檔塊後面，應用於類、方法和構造函數，一個註解獨占一行。這些換行不屬於自動換行(第4.5節，自動換行)，因此縮進級別不變。例如：</p>\n<p>@Override</p>\n<p>@Nullable</p>\n<p>public String getNameIfPresent() { … }</p>\n<p>例外：單個的註解可以和簽名的第一行出現在同一行。例如：</p>\n<p>@Override public int hashCode() { … }</p>\n<p>應用於字段的註解緊隨文檔塊出現，應用於字段的多個註解允許與字段出現在同一行。例如：</p>\n<p>@Partial @Mock DataLoader loader;</p>\n<p>參數和局部變量註解沒有特定規則。</p>\n<p>4.8.6 註釋</p>\n<p>4.8.6.1 塊註釋風格</p>\n<p>塊註釋與其周圍的代碼在同一縮進級別。它們可以是/* … </p>\n<p>*</p>\n<p>/風格，也可以是// …風格。對於多行的/</p>\n<p>*</p>\n<p> … </p>\n<p>*</p>\n<p>/註釋，後續行必須從</p>\n<p>*</p>\n<p>開始， 並且與前一行的*對齊。以下示例註釋都是OK的。</p>\n<p>/*</p>\n<p>*</p>\n<p> This is // And so /* Or you can</p>\n<p>*</p>\n<p> okay. // is this. * even do this. */</p>\n<p> */</p>\n<p>註釋不要封閉在由星號或其它字符繪制的框架裏。</p>\n<p>Tip：在寫多行註釋時，如果你希望在必要時能重新換行(即註釋像段落風格一樣)，那麽使用/* … */。</p>\n<p>4.8.7 Modifiers</p>\n<p>類和成員的modifiers如果存在，則按Java語言規範中推薦的順序出現。</p>\n<p>public protected private abstract static final transient volatile synchronized native strictfp</p>\n<p>命名約定</p>\n<p>5.1 對所有標識符都通用的規則</p>\n<p>標識符只能使用ASCII字母和數字，因此每個有效的標識符名稱都能匹配正則表達式\\w+。</p>\n<p>在Google其它編程語言風格中使用的特殊前綴或後綴，如name</p>\n<p>_</p>\n<p>, mName, s</p>\n<p>_</p>\n<p>name和kName，在Java編程風格中都不再使用。</p>\n<p>5.2 標識符類型的規則</p>\n<p>5.2.1 包名</p>\n<p>包名全部小寫，連續的單詞只是簡單地連接起來，不使用下劃線。</p>\n<p>5.2.2 類名</p>\n<p>類名都以UpperCamelCase風格編寫。</p>\n<p>類名通常是名詞或名詞短語，接口名稱有時可能是形容詞或形容詞短語。現在還沒有特定的規則或行之有效的約定來命名註解類型。</p>\n<p>測試類的命名以它要測試的類的名稱開始，以Test結束。例如，HashTest或HashIntegrationTest。</p>\n<p>5.2.3 方法名</p>\n<p>方法名都以lowerCamelCase風格編寫。</p>\n<p>方法名通常是動詞或動詞短語。</p>\n<p>下劃線可能出現在JUnit測試方法名稱中用以分隔名稱的邏輯組件。一個典型的模式是：test</p>\n<p>&lt;</p>\n<p>MethodUnderTest</p>\n<p>&gt;</p>\n<p>_</p>\n<p>&lt;</p>\n<p>state</p>\n<p>&gt;</p>\n<p>，例如testPop</p>\n<p>_</p>\n<p>emptyStack。 並不存在唯一正確的方式來命名測試方法。</p>\n<p>5.2.4 常量名</p>\n<p>常量名命名模式為CONSTANT_CASE，全部字母大寫，用下劃線分隔單詞。那，到底什麽算是一個常量？</p>\n<p>每個常量都是一個靜態final字段，但不是所有靜態final字段都是常量。在決定一個字段是否是一個常量時， 考慮它是否真的感覺像是一個常量。例如，如果任何一個該實例的觀測狀態是可變的，則它幾乎肯定不會是一個常量。 只是永遠不打算改變對象一般是不夠的，它要真的一直不變才能將它示為常量。</p>\n<p>// Constants</p>\n<p>static final int NUMBER = 5;</p>\n<p>static final ImmutableList</p>\n<p>&lt;</p>\n<p>String</p>\n<p>&gt;</p>\n<p> NAMES = ImmutableList.of(“Ed”, “Ann”);</p>\n<p>static final Joiner COMMA_JOINER = Joiner.on(‘,’); // because Joiner is immutable</p>\n<p>static final SomeMutableType[] EMPTY_ARRAY = {};</p>\n<p>enum SomeEnum { ENUM_CONSTANT }</p>\n<p>// Not constants</p>\n<p>static String nonFinal = “non-final”;</p>\n<p>final String nonStatic = “non-static”;</p>\n<p>static final Set</p>\n<p>&lt;</p>\n<p>String</p>\n<p>&gt;</p>\n<p> mutableCollection = new HashSet</p>\n<p>&lt;</p>\n<p>String</p>\n<p>&gt;</p>\n<p>();</p>\n<p>static final ImmutableSet</p>\n<p>&lt;</p>\n<p>SomeMutableType</p>\n<p>&gt;</p>\n<p> mutableElements = ImmutableSet.of(mutable);</p>\n<p>static final Logger logger = Logger.getLogger(MyClass.getName());</p>\n<p>static final String[] nonEmptyArray = {“these”, “can”, “change”};</p>\n<p>這些名字通常是名詞或名詞短語。</p>\n<p>5.2.5 非常量字段名</p>\n<p>非常量字段名以lowerCamelCase風格編寫。</p>\n<p>這些名字通常是名詞或名詞短語。</p>\n<p>5.2.6 參數名</p>\n<p>參數名以lowerCamelCase風格編寫。</p>\n<p>參數應該避免用單個字符命名。</p>\n<p>5.2.7 局部變量名</p>\n<p>局部變量名以lowerCamelCase風格編寫，比起其它類型的名稱，局部變量名可以有更為寬松的縮寫。</p>\n<p>雖然縮寫更寬松，但還是要避免用單字符進行命名，除了臨時變量和循環變量。</p>\n<p>即使局部變量是final和不可改變的，也不應該把它示為常量，自然也不能用常量的規則去命名它。</p>\n<p>5.2.8 類型變量名</p>\n<p>類型變量可用以下兩種風格之一進行命名：</p>\n<p>單個的大寫字母，後面可以跟一個數字(如：E, T, X, T2)。</p>\n<p>以類命名方式(5.2.2節)，後面加個大寫的T(如：RequestT, FooBarT)。</p>\n<p>5.3 駝峰式命名法(CamelCase)</p>\n<p>駝峰式命名法分大駝峰式命名法(UpperCamelCase)和小駝峰式命名法(lowerCamelCase)。 有時，我們有不只一種合理的方式將一個英語詞組轉換成駝峰形式，如縮略語或不尋常的結構(例如”IPv6”或”iOS”)。Google指定了以下的轉換方案。</p>\n<p>名字從散文形式(prose form)開始:</p>\n<p>把短語轉換為純ASCII碼，並且移除任何單引號。例如：”Müller’s algorithm”將變成”Muellers algorithm”。</p>\n<p>把這個結果切分成單詞，在空格或其它標點符號(通常是連字符)處分割開。</p>\n<p>推薦：如果某個單詞已經有了常用的駝峰表示形式，按它的組成將它分割開(如”AdWords”將分割成”ad words”)。 需要註意的是”iOS”並不是一個真正的駝峰表示形式，因此該推薦對它並不適用。</p>\n<p>現在將所有字母都小寫(包括縮寫)，然後將單詞的第一個字母大寫：</p>\n<p>每個單詞的第一個字母都大寫，來得到大駝峰式命名。</p>\n<p>除了第一個單詞，每個單詞的第一個字母都大寫，來得到小駝峰式命名。</p>\n<p>最後將所有的單詞連接起來得到一個標識符。</p>\n<p>示例：</p>\n<p>Prose form Correct Incorrect ——————————————————————</p>\n<p>“XML HTTP request” XmlHttpRequest XMLHTTPRequest</p>\n<p>“new customer ID” newCustomerId newCustomerID</p>\n<p>“inner stopwatch” innerStopwatch innerStopWatch</p>\n<p>“supports IPv6 on iOS?” supportsIpv6OnIos supportsIPv6OnIOS</p>\n<p>“YouTube importer” YouTubeImporter</p>\n<p>YoutubeImporter*</p>\n<p>加星號處表示可以，但不推薦。</p>\n<p>Note：在英語中，某些帶有連字符的單詞形式不唯一。例如：”nonempty”和”non-empty”都是正確的，因此方法名checkNonempty和checkNonEmpty也都是正確的。</p>\n<p>編程實踐</p>\n<p>6.1 @Override：能用則用</p>\n<p>只要是合法的，就把@Override註解給用上。</p>\n<p>6.2 捕獲的異常：不能忽視</p>\n<p>除了下面的例子，對捕獲的異常不做響應是極少正確的。(典型的響應方式是打印日誌，或者如果它被認為是不可能的，則把它當作一個AssertionError重新拋出。)</p>\n<p>如果它確實是不需要在catch塊中做任何響應，需要做註釋加以說明(如下面的例子)。</p>\n<p>try {</p>\n<p>int i = Integer.parseInt(response);</p>\n<p>return handleNumericResponse(i);</p>\n<p>} catch (NumberFormatException ok) {</p>\n<p>// it’s not numeric; that’s fine, just continue</p>\n<p>}</p>\n<p>return handleTextResponse(response);</p>\n<p>例外：在測試中，如果一個捕獲的異常被命名為expected，則它可以被不加註釋地忽略。下面是一種非常常見的情形，用以確保所測試的方法會拋出一個期望中的異常， 因此在這裏就沒有必要加註釋。</p>\n<p>try {</p>\n<p>emptyStack.pop();</p>\n<p>fail();</p>\n<p>} catch (NoSuchElementException expected) {</p>\n<p>}</p>\n<p>6.3 靜態成員：使用類進行調用</p>\n<p>使用類名調用靜態的類成員，而不是具體某個對象或表達式。</p>\n<p>Foo aFoo = …;</p>\n<p>Foo.aStaticMethod(); // good</p>\n<p>aFoo.aStaticMethod(); // bad</p>\n<p>somethingThatYieldsAFoo().aStaticMethod(); // very bad</p>\n<p>6.4 Finalizers: 禁用</p>\n<p>極少會去重寫Object.finalize。</p>\n<p>Tip：不要使用finalize。如果你非要使用它，請先仔細閱讀和理解Effective Java 第7條款：“Avoid Finalizers”，然後不要使用它。</p>\n<p>Javadoc</p>\n<p>7.1 格式</p>\n<p>7.1.1 一般形式</p>\n<p>Javadoc塊的基本格式如下所示：</p>\n<p>/**</p>\n<p>*</p>\n<p> Multiple lines of Javadoc text are written here,</p>\n<p>*</p>\n<p> wrapped normally…</p>\n<p> */</p>\n<p>public int method(String p1) { … }</p>\n<p>或者是以下單行形式：</p>\n<p>/** An especially short bit of Javadoc. */</p>\n<p>基本格式總是OK的。當整個Javadoc塊能容納於一行時(且沒有Javadoc標記@XXX)，可以使用單行形式。</p>\n<p>7.1.2 段落</p>\n<p>空行(即，只包含最左側星號的行)會出現在段落之間和Javadoc標記(@XXX)之前(如果有的話)。 除了第一個段落，每個段落第一個單詞前都有標簽</p>\n<p>&lt;</p>\n<p>p</p>\n<p>&gt;</p>\n<p>，並且它和第一個單詞間沒有空格。</p>\n<p>7.1.3 Javadoc標記</p>\n<p>標準的Javadoc標記按以下順序出現：@param, @return, @throws, @deprecated, 前面這4種標記如果出現，描述都不能為空。 當描述無法在一行中容納，連續行需要至少再縮進4個空格。</p>\n<p>7.2 摘要片段</p>\n<p>每個類或成員的Javadoc以一個簡短的摘要片段開始。這個片段是非常重要的，在某些情況下，它是唯一出現的文本，比如在類和方法索引中。</p>\n<p>這只是一個小片段，可以是一個名詞短語或動詞短語，但不是一個完整的句子。它不會以A {@code Foo} is a…或This method returns…開頭, 它也不會是一個完整的祈使句，如Save the record…。然而，由於開頭大寫及被加了標點，它看起來就像是個完整的句子。</p>\n<p>Tip：一個常見的錯誤是把簡單的Javadoc寫成/</p>\n<p>**</p>\n<p> @return the customer ID */，這是不正確的。它應該寫成/</p>\n<p>**</p>\n<p> Returns the customer ID. */。</p>\n<p>7.3 哪裏需要使用Javadoc</p>\n<p>至少在每個public類及它的每個public和protected成員處使用Javadoc，以下是一些例外：</p>\n<p>7.3.1 例外：不言自明的方法</p>\n<p>對於簡單明顯的方法如getFoo，Javadoc是可選的(即，是可以不寫的)。這種情況下除了寫“Returns the foo”，確實也沒有什麽值得寫了。</p>\n<p>單元測試類中的測試方法可能是不言自明的最常見例子了，我們通常可以從這些方法的描述性命名中知道它是幹什麽的，因此不需要額外的文檔說明。</p>\n<p>Tip：如果有一些相關信息是需要讀者了解的，那麽以上的例外不應作為忽視這些信息的理由。例如，對於方法名getCanonicalName， 就不應該忽視文檔說明，因為讀者很可能不知道詞語canonical name指的是什麽。</p>\n<p>7.3.2 例外：重寫</p>\n<p>如果一個方法重寫了超類中的方法，那麽Javadoc並非必需的。</p>\n<p>7.3.3 可選的Javadoc</p>\n<p>對於包外不可見的類和方法，如有需要，也是要使用Javadoc的。如果一個註釋是用來定義一個類，方法，字段的整體目的或行為， 那麽這個註釋應該寫成Javadoc，這樣更統一更友好。</p>\n"},{"title":"C++入门基础","date":"2018-10-02T01:09:09.000Z","_content":"# C++入门基础\n\n\n---\n\n\n##1.new 、 delete 、 malloc 、 free 关系\n\ndelete 会调用对象的析构函数 , 和 new 对应 free 只会释放内存， new 调用构造函数。 malloc 与 free 是C++/C 语言的标准库函数， new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free 。因此 C++ 语言需要一个能完成动态内存分配和初始化工作的运算符 new ，以及一个能完成清理与释放内存工作的运算符 delete 。注意 new/delete 不是库函数。\n\n总结：new和delete会自动调用对象的构造与析构函数而malloc与free不会；\n\n      new和delete式C++运算符，而malloc和free是C/C++标准库函数。\n\n---\n\n##2.delete 与 delete [] 区别\n\ndelete 只会调用一次析构函数，而 delete[] 会调用每一个成员的析构函数。在 More Effective  C++ 中有更为详细的解释：“当 delete 操作符用于数组时，它为每个数组元素调用析构函数，然后调用 operatordelete 来释放内存。” delete 与 New 配套， delete [] 与 new [] 配套\n```c++\n  MemTest*mTest1=newMemTest[10];\n\n  MemTest*mTest2=newMemTest;\n\n  int*pInt1=newint[10];\n\n  int*pInt2=newint;\n\n  delete[]pInt1;  //-1-\n\n  delete[]pInt2;  //-2-\n\n  delete[]mTest1;//-3-\n\n  delete[]mTest2;//-4-\n```\n  在 -4- 处报错。\n\n这就说明：对于内建简单数据类型， delete 和 delete[] 功能是相同的。对于自定义的复杂数据类型， delete和 delete[] 不能互用。 delete[] 删除一个数组， delete 删除一个指针简单来说，用 new 分配的内存用 delete 删除用 new[] 分配的内存用 delete[] 删除 delete[] 会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用 delete 时没用括号， delete 就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。\n\n总结： delete 只会调用一次析构函数，而 delete[] 会调用每一个成员的析构函数。\n\n\n---\n\n\n##3. C C++ JAVA 共同点，不同之处？\n\n\n\n---\n\n\n\n##4. 继承优缺点。\n\n类继承是在编译时刻静态定义的，且可直接使用，类继承可以较方便地改变父类的实现。但是类继承也有一些不足之处。首先，因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现。更糟的是，父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为。如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。\n\n（待补充）\n\n \n\n---\n\n\n\n##5.C++ 有哪些性质（面向对象特点）\n\n封装，继承和多态。\n\n在面向对象程序设计语言中，封装是利用可重用成分构造软件系统的特性，它不仅支持系统的可重用性，而且还有利于提高系统的可扩充性；消息传递可以实现发送一个通用的消息而调用不同的方法；封装是实现信息隐蔽的一种技术，其目的是使类的定义和实现分离。\n\n\n---\n\n\n##6. 子类析构时要调用父类的析构函数吗？\n\n析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候 , 派生类的信息已经全部销毁了定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数 JAVA 无析构函数深拷贝和浅拷贝\n\n\n---\n\n\n##7. 多态，虚函数，纯虚函数\n\n\n---\n\n\n##8. 求下面函数的返回值（微软）\n```c++\nint func(x) \n{ \n    int countx = 0; \n    while(x) \n    { \n          countx ++; \n          x = x&(x-1); \n     } \n    return countx; \n} \n```\n假定 x = 9999 。 答案： 8\n\n思路：将 x 转化为 2 进制，看含有的 1 的个数。\n\n\n---\n\n\n##9. 什么是 “ 引用 ” ？申明和使用 “ 引用 ” 要注意哪些问题？\n\n答：引用就是某个目标变量的 “ 别名 ”(alias) ，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。\n\n\n---\n\n\n##10. 将 “ 引用 ” 作为函数参数有哪些特点？\n\n（ 1 ）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。\n\n（ 2 ）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。\n\n（ 3 ）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用 \"\\* 指针变量名 \" 的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。\n\n\n---\n\n\n##11. 在什么时候需要使用 “ 常引用 ” ？ 　\n\n如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式： const 类型标识符 & 引用名 = 目标变量名；\n\n例 1\n```c++\nint a ;\nconst int &ra=a;\nra=1; // 错误 \na=1; // 正确\n```\n例 2\n\n```c++\nstring foo( );\nvoid bar(string & s);\n```\n那么下面的表达式将是非法的：\n\n```c++\nbar(foo( ));\nbar(\"hello world\");\n```\n原因在于 foo( ) 和 \"hello world\" 串都会产生一个临时对象，而在 C++ 中，这些临时对象都是 const 类型的。因此上面的表达式就是试图将一个 const 类型的对象转换为非 const 类型，这是非法的。引用型参数应该在能被定义为 const 的情况下，尽量定义为 const 。\n\n\n---\n\n\n##12. 将 “ 引用 ” 作为函数返回值类型的格式、好处和需要遵守的规则 ?\n\n格式：类型标识符 & 函数名（形参列表及类型说明） { // 函数体 }\n\n好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生 runtime error! 注意事项：\n\n（ 1 ）不能返回局部变量的引用。这条可以参照 Effective C++[1] 的 Item 31 。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了 \" 无所指 \" 的引用，程序会进入未知状态。\n\n（ 2 ）不能返回函数内部 new 分配的内存的引用。这条可以参照 Effective C++[1] 的 Item 31 。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部 new 分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由 new 分配）就无法释放，造成 memory leak 。\n\n（ 3 ）可以返回类成员的引用，但最好是 const 。这条原则可以参照 Effective C++[1] 的 Item 30 。主要原因是当对象的属性是与某种业务规则（ business rule ）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。\n\n（ 4 ）流操作符重载返回值申明为 “ 引用 ” 的作用：\n\n流操作符 << 和 >> ，这两个操作符常常希望被连续使用，例如： cout << \"hello\" << endl; 　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个 << 操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用 << 操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是 C++ 语言中引入引用这个概念的原因吧。 赋值操作符 = 。这个操作符象流操作符一样，是可以连续使用的，例如： x = j = 10; 或者 (x=10)=100; 赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。\n\n例 3\n\n```c++\n＃ i nclude <iostream.h>\nint &put(int n);\nint vals[10];\nint error=-1;\nvoid main()\n{\nput(0)=10; // 以 put(0) 函数值作为左值，等价于 vals[0]=10; \nput(9)=20; // 以 put(9) 函数值作为左值，等价于 vals[9]=20; \ncout<<vals[0]; \ncout<<vals[9];\n} \nint &put(int n)\n{\nif (n>=0 && n<=9 ) return vals[n]; \nelse { cout<<\"subscript error\"; return error; }\n}\n```\n（ 5 ）在另外的一些操作符中，却千万不能返回引用： +-*/ 四则运算符。它们不能返回引用， Effective C++[1] 的 Item23 详细的讨论了这个问题。主要原因是这四个操作符没有 side effect ，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个 new 分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第 2 、 3 两个方案都被否决了。静态对象的引用又因为 ((a+b) == (c+d)) 会永远为 true 而导致错误。所以可选的只剩下返回一个对象了。\n\n\n---\n\n\n##13.“ 引用 ” 与多态的关系？\n\n引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。例4\n\nClass A; Class B : Class A{...};  B b; A& ref = b;\n\n\n---\n\n\n##14.“ 引用 ” 与指针的区别是什么？\n\n指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。此外，就是上面提到的对函数传 ref 和pointer 的区别。\n\n\n---\n\n\n##15. 什么时候需要 “ 引用 ” ？\n\n流操作符 << 和 >> 、赋值操作符 = 的返回值、拷贝构造函数的参数、赋值操作符 = 的参数、其它情况都推荐使用引用。以上 2-8 参考： http://develop.csai.cn/c/NO0000021.htm\n\n\n---\n\n\n##16. 结构与联合有和区别？\n\n\n(1). 结构和联合都是由多个不同的数据类型成员组成 , 但在任何同一时刻 , 联合中只存放了一个被选中的成员（所有成员共用一块地址空间） , 而结构的所有成员都存在（不同成员的存放地址不同）。  \n (2). 对于联合的不同成员赋值 , 将会对其它成员重写 ,  原来成员的值就不存在了 , 而对于结构的不同成员赋值是互不影响的。\n\n\n---\n\n\n##17. 面关于 “ 联合 ” 的题目的输出？\n\na)\n```c++\n＃ i nclude <stdio.h>\nunion\n{\nint i;\nchar x[2];\n}a;\n\n\nvoid main()\n{\na.x[0] = 10; \na.x[1] = 1;\nprintf(\"%d\",a.i);\n}\n答案： 266 ( 低位低地址，高位高地址，内存占用情况是 Ox010A ）\n```\nb)\n```c++\nmain() \n     { \n          union{                   /* 定义一个联合 */ \n               int i; \n               struct{             /* 在联合中定义一个结构 */ \n                    char first; \n                    char second; \n               }half; \n          }number; \n          number.i=0x4241;         /* 联合成员赋值 */ \n          printf(\"%c%cn\", number.half.first, mumber.half.second); \n          number.half.first='a';   /* 联合中结构成员赋值 */ \n          number.half.second='b'; \n          printf(\"%xn\", number.i); \n          getch(); \n     } \n     ```\n答案： AB   (0x41 对应 'A', 是低位； Ox42 对应 'B', 是高位）\n\n       6261 (number.i 和 number.half 共用一块地址空间）\n\n18. 关联、聚合 (Aggregation) 以及组合(Composition) 的区别？\n\n涉及到 UML 中的一些概念：关联是表示两个类的一般性联系，比如 “ 学生 ” 和 “ 老师 ” 就是一种关联关系；聚合表示 has-a 的关系，是一种相对松散的关系，聚合类不需要对被聚合类负责，如下图所示，用空的菱形表示聚合关系：从实现的角度讲，聚合可以表示为 :\n\nclass A {...}  class B { A* a; .....}\n\n而组合表示 contains-a 的关系，关联性强于聚合：组合类与被组合类有相同的生命周期，组合类要对被组合类负责，采用实心的菱形表示组合关系：实现的形式是 :\n\nclass A{...} class B{ A a; ...}\n\n参考文章： http://www.cnitblog.com/Lily/archive/2006/02/23/6860.html\n\n          http://www.vckbase.com/document/viewdoc/?id=422\n\n19. 面向对象的三个基本特征，并简单叙述之？\n\n1. 封装：将客观事物抽象成类，每个类对自身的数据和方法实行 protection(private, protected,public)\n\n2. 继承：广义的继承有三种实现形式：实现继承（指使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后到子类实现）。前两种（类继承）和后一种（对象组合 => 接口继承以及纯虚函数）构成了功能复用的两种方式。\n\n3. 多态：是将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。\n\n20. 重载（ overload) 和重写 (overried ，有的书也叫做 “ 覆盖 ” ）的区别？\n\n常考的题目。从定义上来说：\n\n重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。\n\n重写：是指子类重新定义父类虚函数的方法。\n\n从实现原理上来说：\n\n重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数： function func(p:integer):integer; 和 function func(p:string):integer; 。 那么编译器做过修饰后的函数名称可能是这样的： int_func 、 str_func 。对于这两个函数的调用，在编译器间就已经确定了，是 静态 的。也就是说， 它们的地址在编译期就绑定了（早绑定）， 因此， 重载和多态无关 ！\n\n重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针， 动态的调用 属于子类的该函数，这样的函 数调用在编译期间是无法确定的 （调用的子类的虚函数的地址无法给出）。因此， 这样的函数地址是在运行期绑定的（晚绑定）。\n\n\n---\n\n\n##21. 多态的作用？\n\n主要是两个：\n\n1. 隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；\n\n2. 接口重用：为了类在继承和派生的时候 ，保证使用家族中任一类的实例的某一属性时的正确调用 。\n\n\n---\n\n\n##22.Ado 与 Ado.net 的相同与不同？\n\n除了“能够让应用程序处理存储于 DBMS 中的数据“这一基本相似点外，两者没有太多共同之处。但是 Ado使用 OLE DB 接口并基于微软的 COM 技术，而 ADO.NET 拥有自己的 ADO.NET 接口并且基于微软的 .NET 体系架构。众所周知 .NET 体系不同于 COM 体系， ADO.NET 接口也就完全不同于 ADO 和 OLE DB 接口，这也就是说 ADO.NET 和 ADO 是两种数据访问方式。 ADO.net 提供对 XML 的支持。\n\n\n---\n\n\n##23.New delete 与 malloc free 的联系与区别 ?\n\n答案：都是在堆 (heap) 上进行动态的内存操作。用 malloc 函数需要指定内存分配的字节数并且不能初始化对象， new 会自动调用对象的构造函数。 delete 会调用对象的 destructor ，而 free 不会调用对象的 destructor.\n\n\n---\n\n\n##24.#define DOUBLE(x) x+x ， i = 5*DOUBLE(5) ； i是多少？\n\n答案： i 为 30 。\n\n\n---\n\n\n##25. 有哪几种情况只能用 intialization list 而不能用assignment?\n\n答案：当类中含有 const 、 reference 成员变量；基类的构造函数都需要初始化表。\n\n\n---\n\n\n##26. C++ 是不是类型安全的？\n\n答案：不是。两个不同类型的指针之间可以强制转换（用 reinterpret cast) 。 C# 是类型安全的。\n\n\n---\n\n\n##27. main 函数执行以前，还会执行什么代码？\n\n答案：全局对象的构造函数会在 main 函数之前执行。\n\n\n---\n\n\n##28.  描述内存分配方式以及它们的区别 ?\n\n1 ） 从静态存储区域分配 。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如 全局变量， static 变量 。 \n2 ） 在栈上创建 。在执行函数时， 函数内局部变量的存储单元都可以在栈上创建 ，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。 \n3 ） 从堆上分配 ， 亦称动态内存分配 。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。\n\n\n---\n\n\n##29.struct 和 class 的区别\n\n答案： struct 的成员默认是公有的，而类的成员默认是私有的。 struct 和 class 在其他方面是功能相当的。从感情上讲，大多数的开发者感到类和结构有很大的差别。感觉上结构仅仅象一堆缺乏封装和功能的开放的内存位，而类就象活的并且可靠的社会成员，它有智能服务，有牢固的封装屏障和一个良好定义的接口。既然大多数人都这么认为，那么只有在你的类有很少的方法并且有公有数据（这种事情在良好设计的系统中是存在的 ! ）时，你也许应该使用 struct 关键字，否则，你应该使用 class 关键字。  \n\n\n---\n\n\n##30. 当一个类 A 中没有任何成员变量与成员函数 , 这时sizeof(A) 的值是多少？\n\n答案：如果不是零，请解释一下编译器为什么没有让它为零。（ Autodesk ）肯定不是零。举个反例，如果是零的话，声明一个 class A[10] 对象数组，而每一个对象占用的空间是零，这时就没办法区分 A[0],A[1] …了。\n\n\n---\n\n\n##31. 在 8086 汇编下，逻辑地址和物理地址是怎样转换的？（ Intel ）\n\n答案：通用寄存器给出的地址，是段内偏移地址，相应段寄存器地址 *10H+ 通用寄存器内地址，就得到了真正要访问的地址。\n\n\n---\n\n##32.  比较 C++ 中的 4 种类型转换方式？\n\n请参考： http://blog.csdn.net/wfwd/archive/2006/05/30/763785.aspx ，重点是 static_cast, dynamic_cast和 reinterpret_cast 的区别和应用。\n\ndynamic_casts 在帮助你浏览继承层次上是有限制的。它不能被用于缺乏虚函数的类型上，它被用于安全地沿着类的继承关系向下进行类型转换。如你想在没有继承关系的类型中进行转换，你可能想到 static_cast\n\n---\n\n##33. 分别写出 BOOL,int,float, 指针类型的变量 a与“零”的比较语句。\n\n答案： \nBOOL :    if ( !a ) or if(a)\nint :     if ( a == 0)\nfloat :   const EXPRESSION EXP = 0.000001\n          if ( a < EXP && a >-EXP)\npointer : if ( a != NULL) or if(a == NULL)\n\n ---\n\n##34. 请说出 const 与 #define 相比，有何优点？\n\n答案：\n\nConst 作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被 Const 修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。\n\n1 ） const 常量有数据类型，而宏常量没有数据类型 。编译器可以对前者进行类型 安全检查 。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。 \n      2 ） 有些集成化的调试工具可以对 const 常量进行调试 ，但是不能对宏常量进行调试。\n\n---\n\n##35. 简述数组与指针的区别？\n\n数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。 \n(1) 修改内容上的差别 \nchar a[] = “ hello ” ;\na[0] = ‘ X ’ ;\nchar *p = “ world ” ; // 注意 p 指向常量字符串 \np[0] = ‘ X ’ ; // 编译器不能发现该错误，运行时错误 \n(2) 用运算符 sizeof 可以计算出数组的容量（字节数）。 sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是 p 所指的内存容量 。 C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。 注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。 \nchar a[] = \"hello world\";\nchar *p = a;\ncout<< sizeof(a) << endl; // 12 字节 \ncout<< sizeof(p) << endl; // 4 字节 \n计算数组和指针的内存容量 \nvoid Func(char a[100])\n{\ncout<< sizeof(a) << endl; // 4 字节而不是 100 字节 \n}\n\n\n---\n\n\n##36. 类成员函数的重载、覆盖和隐藏区别？\n\n答案： a. 成员函数被重载的特征： \n（ 1 ）相同的范围（在同一个类中）； \n（ 2 ）函数名字相同； \n（ 3 ）参数不同； \n（ 4 ） virtual 关键字可有可无。 \nb. 覆盖是指派生类函数覆盖基类函数，特征是： \n（ 1 ）不同的范围（分别位于派生类与基类）； \n（ 2 ）函数名字相同； \n（ 3 ）参数相同； \n（ 4 ）基类函数必须有 virtual 关键字。 \n  c. “隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下： \n（ 1 ）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载混淆）。 \n（ 2 ）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）\n\n\n---\n\n\n##37. 求出两个数中的较大这\n\nThere are two int variables: a and b, don ’ t use “ if ” , “ ? : ” , “ switch ” or other judgement statements, find out the biggest one of the two numbers.\n\n答案： ( ( a + b ) + abs( a - b ) ) / 2\n\n\n---\n\n\n##38. 如何打印出当前源文件的文件名以及源文件的当前行号？\n\n答案： \ncout << __FILE__ ;\ncout<<__LINE__ ;\n__FILE__ 和 __LINE__ 是系统预定义宏，这种宏并不是在某个文件中定义的，而是由编译器定义的。\n\n\n---\n\n\n##39. main 主函数执行完毕后，是否可能会再执行一段代码，给出说明？\n\n答案：可以，可以用 _onexit 注册一个函数，它会在 main 之后执行 int fn1(void), fn2(void), fn3(void), fn4 (void);\n```c++\nvoid main( void )\n{\nString str(\"zhanglin\");\n_onexit( fn1 );\n_onexit( fn2 );\n_onexit( fn3 );\n_onexit( fn4 );\nprintf( \"This is executed first.n\" );\n}\nint fn1()\n{\nprintf( \"next.n\" );\nreturn 0;\n}\nint fn2()\n{\nprintf( \"executed \" );\nreturn 0;\n}\nint fn3()\n{\nprintf( \"is \" );\nreturn 0;\n}\nint fn4()\n{\nprintf( \"This \" );\nreturn 0;\n}\n```\nThe _onexit function is passed the address of a function (func) to be called when the program terminates normally. Successive calls to _onexit create a register of functions that are executed in LIFO (last-in-first-out) order. The functions passed to _onexit cannot take parameters.\n\n---\n\n##40. 如何判断一段程序是由 C 编译程序还是由 C++ 编译程序编译的？\n\n答案： \n#ifdef __cplusplus\ncout<<\"c++\";\n#else\ncout<<\"c\";\n#endif\n\n\n---\n\n\n##41. 文件中有一组整数，要求排序后输出到另一个文件中\n\n\n答案：\n```c++\n＃ i nclude<iostream>\n\n＃ i nclude<fstream>\n\nusing namespace std;\n\n\nvoid Order(vector<int>& data) //bubble sort\n{\nint count = data.size() ;\nint tag = false ; // 设置是否需要继续冒泡的标志位 \nfor ( int i = 0 ; i < count ; i++)\n{\nfor ( int j = 0 ; j < count - i - 1 ; j++)\n{\nif ( data[j] > data[j+1])\n{\ntag = true ;\nint temp = data[j] ;\ndata[j] = data[j+1] ;\ndata[j+1] = temp ;\n}\n}\nif ( !tag )\nbreak ;\n}\n}\n\n\nvoid main( void )\n{\nvector<int>data;\nifstream in(\"c:/data.txt\");\nif ( !in)\n{\ncout<<\"file error!\";\nexit(1);\n}\nint temp;\nwhile (!in.eof())\n{\nin>>temp;\ndata.push_back(temp);\n}\nin.close(); // 关闭输入文件流 \nOrder(data);\nofstream out(\"c:/result.txt\");\nif ( !out)\n{\ncout<<\"file error!\";\nexit(1);\n}\nfor ( i = 0 ; i < data.size() ; i++)\nout<<data[i]<<\" \";\nout.close(); // 关闭输出文件流 \n}\n```\n \n\n\n---\n\n\n##42. 链表题：一个链表的结点结构\n```c++\nstruct Node\n{\nint data ;\nNode *next ;\n};\ntypedef struct Node Node ;\n\n\n(1) 已知链表的头结点 head, 写一个函数把这个链表逆序 ( Intel)\n\nNode * ReverseList(Node *head) // 链表逆序 \n{\nif ( head == NULL || head->next == NULL )\nreturn head;\nNode *p1 = head ;\nNode *p2 = p1->next ;\nNode *p3 = p2->next ;\np1->next = NULL ;\nwhile ( p3 != NULL )\n{\np2->next = p1 ;\np1 = p2 ;\np2 = p3 ;\np3 = p3->next ;\n}\np2->next = p1 ;\nhead = p2 ;\nreturn head ;\n}\n(2) 已知两个链表 head1 和 head2 各自有序，请把它们合并成一个链表依然有序。 ( 保留所有结点，即便大小相同） \nNode * Merge(Node *head1 , Node *head2)\n{\nif ( head1 == NULL)\nreturn head2 ;\nif ( head2 == NULL)\nreturn head1 ;\nNode *head = NULL ;\nNode *p1 = NULL;\nNode *p2 = NULL;\nif ( head1->data < head2->data )\n{\nhead = head1 ;\np1 = head1->next;\np2 = head2 ;\n}\nelse\n{\nhead = head2 ;\np2 = head2->next ;\np1 = head1 ;\n}\nNode *pcurrent = head ;\nwhile ( p1 != NULL && p2 != NULL)\n{\nif ( p1->data <= p2->data )\n{\npcurrent->next = p1 ;\npcurrent = p1 ;\np1 = p1->next ;\n}\nelse\n{\npcurrent->next = p2 ;\npcurrent = p2 ;\np2 = p2->next ;\n}\n}\nif ( p1 != NULL )\npcurrent->next = p1 ;\nif ( p2 != NULL )\npcurrent->next = p2 ;\nreturn head ;\n}\n(3) 已知两个链表 head1 和 head2 各自有序，请把它们合并成一个链表依然有序，这次要求用递归方法进行。(Autodesk)\n答案： \nNode * MergeRecursive(Node *head1 , Node *head2)\n{\nif ( head1 == NULL )\nreturn head2 ;\nif ( head2 == NULL)\nreturn head1 ;\nNode *head = NULL ;\nif ( head1->data < head2->data )\n{\nhead = head1 ;\nhead->next = MergeRecursive(head1->next,head2);\n}\nelse\n{\nhead = head2 ;\nhead->next = MergeRecursive(head1,head2->next);\n}\nreturn head ;\n```\n \n\n----------\n\n##41. 分析一下这段程序的输出 (Autodesk)\nclass B\n{\npublic:\nB()\n{\ncout<<\"default constructor\"<<endl;\n}\n~B()\n{\ncout<<\"destructed\"<<endl;\n}\nB(int i):data(i)    //B(int) works as a converter ( int -> instance of  B)\n{\ncout<<\"constructed by parameter \" << data <<endl;\n}\nprivate:\nint data;\n};\n\n\nB Play( B b) \n{\nreturn b ;\n}\n\n(1)                                            results:\nint main(int argc, char* argv[])      constructed by parameter 5\n{                                     destructed  B(5) 形参析构 \nB t1 = Play(5); B t2 = Play(t1);   　 destructed  t1 形参析构 \nreturn 0; 　　　　　　　　　　　　　　 destructed  t2 　注意顺序！ \n}                                     destructed  t1\n\n(2)                                   results:\nint main(int argc, char* argv[])      constructed by parameter 5\n{                                     destructed  B(5) 形参析构 \nB t1 = Play(5); B t2 = Play(10);   　 constructed by parameter 10\nreturn 0; 　　　　　　　　　　　　　　 destructed  B(10) 形参析构 \n}                                     destructed  t2 　注意顺序！\n\n                                      destructed  t1\n```\n\n---\n\n\n##43. 写一个函数找出一个整数数组中，第二大的数 （microsoft ）\n\n答案： \n```c++\nconst int MINNUMBER = -32767 ;\nint find_sec_max( int data[] , int count)\n{\nint maxnumber = data[0] ;\nint sec_max = MINNUMBER ;\nfor ( int i = 1 ; i < count ; i++)\n{\nif ( data[i] > maxnumber )\n{\nsec_max = maxnumber ;\nmaxnumber = data[i] ;\n}\nelse\n{\nif ( data[i] > sec_max )\nsec_max = data[i] ;\n}\n}\nreturn sec_max ;\n}\n```\n##44. 写一个在一个字符串 (n) 中寻找一个子串 (m) 第一个位置的函数。\n\nKMP 算法效率最好，时间复杂度是Ｏ (n+m), 详见： http://www.zhanglihai.com/blog/c_335_kmp.html\n\n\n---\n\n\n##46. 多重继承的内存分配问题：\n\n比如有 class A : public class B, public class C {} 那么 A 的内存结构大致是怎么样的？ \n这个是 compiler-dependent 的 , 不同的实现其细节可能不同。如果不考虑有虚函数、虚继承的话就相当简单；否则的话，相当复杂。可以参考《深入探索 C++ 对象模型》，或者： \nhttp://blog.csdn.net/rainlight/archive/2006/03/03/614792.aspx\nhttp://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dnarvc/html/jangrayhood.asp\n\n\n---\n\n\n##47. 如何判断一个单链表是有环的？（注意不能用标志位，最多只能用两个额外指针）\n```c++\nstruct node { char val; node* next;}\nbool check(const node* head) {} //return false : 无环； true: 有环一种 O （ n ）的办法就是（搞两个指针，一个每次递增一步，一个每次递增两步，如果有环的话两者必然重合，反之亦然）： \nbool check(const node* head)\n{\n    if(head==NULL)  return false;\n    node *low=head, *fast=head->next;\n    while(fast!=NULL && fast->next!=NULL)\n    {\n        low=low->next;\n        fast=fast->next->next;\n        if(low==fast) return true;\n    }\n    return false;\n}\n\n \n```\n\n---\n\n\n##48. 指针找错题\n\n分析这些面试题，本身包含很强的趣味性 ; 而作为一名研发人员，通过对这些面试题的深入剖析则可进一步增强自身的内功。 \n　　 2. 找错题 试题 1 ： \n以下是引用片段： \nvoid test1()  // 数组越界 \n　　 {\n　　 char string[10];\n　　 char* str1 = \"0123456789\";\n　　 strcpy( string, str1 );\n　　 }\n　　试题 2 ：　 \n以下是引用片段： \n　 void test2()\n　　 {\n　　 char string[10], str1[10]; \n　　 int i;\n　　 for(i=0; i<10; i++)\n　　 {\n　　 str1= 'a';\n　　 }\n　　 strcpy( string, str1 );\n　　 }\n　　试题 3 ：　　 \n以下是引用片段： \nvoid test3(char* str1)\n　　 {\n　　 char string[10];\n　　 if( strlen( str1 ) <= 10 )\n　　 {\n　　 strcpy( string, str1 );\n　　 }\n　　 }\n　　解答： \n　　试题 1 字符串 str1 需要 11 个字节才能存放下 ( 包括末尾的 ’/0’) ，而 string 只有 10 个字节的空间， strcpy会导致数组越界 ; 对试题 2 ，如果面试者指出字符数组 str1 不能在数组内结束可以给 3 分 ; 如果面试者指出strcpy(string,str1) 调用使得从 str1 内存起复制到 string 内存起所复制的字节数具有不确定性可以给 7 分，在此基础上指出库函数 strcpy 工作方式的给 10 分 ;\n对试题 3 ， if(strlen(str1) <= 10) 应改为 if(strlen(str1) <10) ，因为 strlen 的结果未统计 ’/0’ 所占用的 1 个字节。剖析：考查对基本功的掌握 \n　　 (1) 字符串以 ’/0’ 结尾 ;\n　　 (2) 对数组越界把握的敏感度 ;\n　　 (3) 库函数 strcpy 的工作方式，\n\n\n---\n\n\n##49. 如果编写一个标准 strcpy 函数\n\n总分值为 10 ，下面给出几个不同得分的答案： 2 分 以下是引用片段： \nvoid strcpy( char *strDest, char *strSrc )\n　　 {\n　　 while( (*strDest++ = * strSrc++) != ‘/0’ );\n　　 }\n　　 4 分　以下是引用片段： \n　 void strcpy( char *strDest, const char *strSrc )\n　　 // 将源字符串加 const ，表明其为输入参数，加 2 分 \n　　 {\n　　 while( (*strDest++ = * strSrc++) != ‘/0’ );\n　　 }\n　　 7 分 以下是引用片段： \nvoid strcpy(char *strDest, const char *strSrc)\n　　 {\n　　 // 对源地址和目的地址加非 0 断言，加 3 分 \n　　 assert( (strDest != NULL) &&(strSrc != NULL) );\n　　 while( (*strDest++ = * strSrc++) != ‘/0’ );\n　　 }\n　　 10 分 以下是引用片段： \n// 为了实现链式操作，将目的地址返回，加 3 分 !\n　　 char * strcpy( char *strDest, const char *strSrc )\n　　 {\n　　 assert( (strDest != NULL) &&(strSrc != NULL) ); \n　　 char *address = strDest;\n　　 while( (*strDest++ = * strSrc++) != ‘/0’ );\n　　 return address;\n　　 }\n　　从 2 分到 10 分的几个答案我们可以清楚的看到，小小的 strcpy 竟然暗藏着这么多玄机，真不是盖的 ! 需要多么扎实的基本功才能写一个完美的 strcpy 啊 !\n　　 (4) 对 strlen 的掌握，它没有包括字符串末尾的 '/0' 。 \n　　读者看了不同分值的 strcpy 版本，应该也可以写出一个 10 分的 strlen 函数了，完美的版本为： int strlen( const char *str ) // 输入参数 const 　以下是引用片段： \n　 {\n　　 assert( strt != NULL ); // 断言字符串地址非 0\n　　 int len=0; // 注，一定要初始化。 \n　　 while( (*str++) != '/0' )\n　　 {\n　　 len++;\n　　 }\n　　 return len;\n　　 }\n　　试题 4 ：以下是引用片段： \nvoid GetMemory( char *p )\n　　 {\n　　 p = (char *) malloc( 100 );\n　　 }\n　　 void Test( void )\n　　 {\n　　 char *str = NULL;\n　　 GetMemory( str );\n　　 strcpy( str, \"hello world\" );\n　　 printf( str );\n　　 } \n　　试题 5 ：　 \n以下是引用片段： \nchar *GetMemory( void )\n　　 {\n　　 char p[] = \"hello world\";\n　　 return p;\n　　 }\n　　 void Test( void )\n　　 {\n　　 char *str = NULL;\n　　 str = GetMemory();\n　　 printf( str );\n　　 }\n　　试题 6 ：以下是引用片段： \nvoid GetMemory( char **p, int num )\n　　 {\n　　 *p = (char *) malloc( num );\n　　 }\n　　 void Test( void )\n　　 {\n　　 char *str = NULL;\n　　 GetMemory( &str, 100 );\n　　 strcpy( str, \"hello\" );\n　　 printf( str );\n　　 }\n　　试题 7 ：以下是引用片段： \n　 void Test( void )\n　　 {\n　　 char *str = (char *) malloc( 100 );\n　　 strcpy( str, \"hello\" );\n　　 free( str );\n　　 ... // 省略的其它语句 \n　　 }\n　　解答：试题 4 传入中 GetMemory( char *p ) 函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的值，执行完 \n　　 char *str = NULL; \n　　 GetMemory( str );\n　　后的 str 仍然为 NULL; 试题 5 中 \n　　 char p[] = \"hello world\";\n　　 return p;\n　　的 p[] 数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。 \n　　试题 6 的 GetMemory 避免了试题 4 的问题，传入 GetMemory 的参数为字符串指针的指针，但是在GetMemory 中执行申请内存及赋值语句 tiffanybracelets\n　　 *p = (char *) malloc( num );\n　　后未判断内存是否申请成功，应加上： \n　　 if ( *p == NULL )\n　　 {\n　　 ...// 进行申请内存失败处理 \n\n　　 }\n　　试题 7 存在与试题 6 同样的问题，在执行 \n　　 char *str = (char *) malloc(100);\n　　后未进行内存是否申请成功的判断 ; 另外，在 free(str) 后未置 str 为空，导致可能变成一个 “ 野 ” 指针，应加上： \n　　 str = NULL;\n　　试题 6 的 Test 函数中也未对 malloc 的内存进行释放。 \n　　剖析： \n　　试题 4 ～ 7 考查面试者对内存操作的理解程度，基本功扎实的面试者一般都能正确的回答其中 50~60 的错误。但是要完全解答正确，却也绝非易事。\n\n软件开发网 www.mscto.com\n　　对内存操作的考查主要集中在： \n　　 (1) 指针的理解 ;\n　　 (2) 变量的生存期及作用范围 ;\n　　 (3) 良好的动态内存申请和释放习惯。 \n　　再看看下面的一段程序有什么错误：　　 \n以下是引用片段： \nswap( int* p1,int* p2 )\n　　 {\n　　 int *p;\n　　 *p = *p1;\n　　 *p1 = *p2;\n　　 *p2 = *p;\n　　 }\n　　在 swap 函数中， p 是一个 “ 野 ” 指针，有可能指向系统区，导致程序运行的崩溃。在 VC++ 中 DEBUG 运行时提示错误 “Access Violation” 。该程序应该改为 \n以下是引用片段： \nswap( int* p1,int* p2 )\n　　 {\n　　 int p;\n　　 p = *p1;\n　　 *p1 = *p2;\n　　 *p2 = p;\n　　 }\n\n\n---\n\n\n##50.String 的具体实现\n\n \n\n已知 String 类定义如下： \n\nclass String\n{\npublic:\nString(const char *str = NULL); // 通用构造函数 \nString(const String &another); // 拷贝构造函数 \n~ String(); // 析构函数 \nString & operater =(const String &rhs); // 赋值函数 \nprivate:\nchar *m_data; // 用于保存字符串 \n};\n\n尝试写出类的成员函数实现。 \n\n答案： \nString::String(const char *str)\n{\nif ( str == NULL ) //strlen 在参数为 NULL 时会抛异常才会有这步判断 \n{\nm_data = new char[1] ;\nm_data[0] = '/0' ;\n}\nelse\n{\nm_data = new char[strlen(str) + 1];\nstrcpy(m_data,str);\n}\n\n} \n\nString::String(const String &another)\n\n\n  {\nm_data = new char[strlen(another.m_data) + 1];\nstrcpy(m_data,other.m_data);\n}\n\nString& String::operator =(const String &rhs)\n{\nif ( this == &rhs)\nreturn *this ;\ndelete []m_data; // 删除原来的数据，新开一块内存 \nm_data = new char[strlen(rhs.m_data) + 1];\nstrcpy(m_data,rhs.m_data);\nreturn *this ;\n}\n\n\nString::~String()\n{\ndelete []m_data ;\n}\n\n\n---\n\n\n##51.h 头文件中的 ifndef/define/endif 的作用？\n\n答：防止该头文件被重复引用。\n\n\n---\n\n\n##52. ＃ i nclude<file.h> 与 ＃ i nclude \"file.h\" 的区别？\n\n答：前者是从 Standard Library 的路径寻找和引用 file.h ，而后者是从当前工作路径搜寻并引用 file.h 。 \n\n\n \n\n53. 在 C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C” ？\n\nC++ 语言支持函数重载， C 语言不支持函数重载。 C++ 提供了 C 连接交换指定符号 extern “C”\n\n解决名字匹配问题。\n\n\n首先，作为 extern 是 C/C++ 语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。 \n\n通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字 extern 声明。例如，如果模块B 欲引用该模块 A 中定义的全局变量和函数时只需包含模块 A 的头文件即可。这样，模块 B 中调用模块 A 中的函数时，在编译阶段，模块 B 虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块 A 编译生成的目标代码中找到此函数 \n\nextern \"C\" 是连接申明 (linkage declaration), 被 extern \"C\" 修饰的变量和函数是按照 C 语言方式编译和连接的 ,来看看 C++ 中对类似 C 的函数是怎样编译的： \n\n\n作为一种面向对象的语言， C++ 支持函数重载，而过程式语言 C 则不支持。函数被 C++ 编译后在符号库中的名字与 C 语言的不同。例如，假设某个函数的原型为： \n\nvoid foo( int x, int y );\n　　 \n\n该函数被 C 编译器编译后在符号库中的名字为 _foo ，而 C++ 编译器则会产生像 _foo_int_int 之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为 “mangled name” ）。 \n\n_foo_int_int 这样的名字包含了函数名、函数参数数量及类型信息， C++ 就是靠这种机制来实现函数重载的。例如，在 C++ 中，函数 void foo( int x, int y ) 与 void foo( int x, float y ) 编译生成的符号是不相同的，后者为_foo_int_float 。 \n\n同样地， C++ 中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以 \".\" 来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。 \n\n未加 extern \"C\" 声明时的连接方式 \n\n假设在 C++ 中，模块 A 的头文件如下： \n\n// 模块 A 头文件　 moduleA.h\n#ifndef MODULE_A_H\n#define MODULE_A_H\nint foo( int x, int y );\n#endif 　　 \n\n在模块 B 中引用该函数： \n\n// 模块 B 实现文件　 moduleB.cpp\n＃ i nclude \"moduleA.h\"\nfoo(2,3);\n\n加 extern \"C\" 声明后的编译和连接方式 \n\n加 extern \"C\" 声明后，模块 A 的头文件变为： \n\n// 模块 A 头文件　 moduleA.h\n#ifndef MODULE_A_H\n#define MODULE_A_H\nextern \"C\" int foo( int x, int y );\n#endif 　　 \n\n在模块 B 的实现文件中仍然调用 foo( 2,3 ) ，其结果是： \n（ 1 ）模块 A 编译生成 foo 的目标代码时，没有对其名字进行特殊处理，采用了 C 语言的方式； \n\n（ 2 ）连接器在为模块 B 的目标代码寻找 foo(2,3) 调用时，寻找的是未经修改的符号名 _foo 。 \n\n如果在模块 A 中函数声明了 foo 为 extern \"C\" 类型，而模块 B 中包含的是 extern int foo( int x, int y ) ，则模块 B找不到模块 A 中的函数；反之亦然。 \n\n所以，可以用一句话概括 extern “C” 这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）：实现 C++ 与 C 及其它语言的混合编程。　　 \n\n明白了 C++ 中 extern \"C\" 的设立动机，我们下面来具体分析 extern \"C\" 通常的使用技巧： \n\nextern \"C\" 的惯用法 \n\n（ 1 ）在 C++ 中引用 C 语言中的函数和变量，在包含 C 语言头文件（假设为 cExample.h ）时，需进行下列处理： \n\n\nextern \"C\"\n{\n＃ i nclude \"cExample.h\"\n}\n\n而在 C 语言的头文件中，对其外部函数只能指定为 extern 类型， C 语言中不支持 extern \"C\" 声明，在 .c 文件中包含了 extern \"C\" 时会出现编译语法错误。 \n\nC++ 引用 C 函数例子工程中包含的三个文件的源代码如下： \n\n/* c 语言头文件： cExample.h */\n#ifndef C_EXAMPLE_H\n#define C_EXAMPLE_H\nextern int add(int x,int y);\n#endif\n\n\n/* c 语言实现文件： cExample.c */\n＃ i nclude \"cExample.h\"\nint add( int x, int y )\n{\nreturn x + y;\n}\n\n\n// c++ 实现文件，调用 add ： cppFile.cpp\nextern \"C\"\n{\n＃ i nclude \"cExample.h\"\n}\nint main(int argc, char* argv[])\n{\nadd(2,3);\nreturn 0;\n}\n\n如果 C++ 调用一个 C 语言编写的 .DLL 时，当包括 .DLL 的头文件或声明接口函数时，应加 extern \"C\" { 　 } 。 \n\n（ 2 ）在 C 中引用 C++ 语言中的函数和变量时， C++ 的头文件需添加 extern \"C\" ，但是在 C 语言中不能直接引用声明了 extern \"C\" 的该头文件，应该仅将 C 文件中将 C++ 中定义的 extern \"C\" 函数声明为 extern 类型。 \n\nC 引用 C++ 函数例子工程中包含的三个文件的源代码如下： \n\n//C++ 头文件 cppExample.h\n#ifndef CPP_EXAMPLE_H\n#define CPP_EXAMPLE_H\nextern \"C\" int add( int x, int y );\n#endif\n\n\n//C++ 实现文件 cppExample.cpp\n＃ i nclude \"cppExample.h\"\nint add( int x, int y )\n{\nreturn x + y;\n}\n\n\n/* C 实现文件 cFile.c\n/* 这样会编译出错：＃ i nclude \"cExample.h\" */\n\nint main( int argc, char* argv[] )\n{\nadd( 2, 3 );\nreturn 0;\n}\n\n15 题目的解答请参考《 C++ 中 extern “C” 含义深层探索》注解：\n\n几道 c 笔试题 ( 含参考答案 )\n\n1. \nWhat is displayed when f() is called given the code:\nclass Number {\npublic:\nstring type; \n\nNumber(): type( “ void ” ) { }\nexplicit Number(short) : type( “ short ” ) { } \nNumber(int) : type( “ int ” ) { }\n};\nvoid Show(const Number& n) { cout << n.type; }\nvoid f()\n{\nshort s = 42;\nShow(s); \n}\na) void\nb) short\nc) int\nd) None of the above\n\n2. Which is the correct output for the following code\ndouble dArray[2] = {4, 8}, *p, *q;\np = &dArray[0];\nq = p + 1;\ncout << q – p << endl; \ncout << (int)q - (int)p << endl;\na) 1 and 8\nb) 8 and 4\nc) 4 and 8\nd) 8 and 1\n\n\n第一个选 C ； \n虽然传入的是 short 类型，但是 short 类型的构造函数被生命被 explicit ，也就是只能显示类型转换，不能使用隐式类型转换。 \n第二个选 A ； \n第一个是指针加减，按照的是指向地址类型的加减，只跟类型位置有关， q 和 p 指向的数据类型以实际数据类型来算差一个位置，因此是 1 。而第二个加减是实际指针值得加减，在内存中一个 double 类型占据 8 个字节，因此是 8\n\n \n\n54.Sony 笔试题\n\n\n　　 1 ．完成下列程序 \n　　 * \n　　 *.*. \n　　 *..*..*.. \n　　 *...*...*...*... \n　　 *....*....*....*....*.... \n　　 *.....*.....*.....*.....*.....*..... \n　　 *......*......*......*......*......*......*...... \n　　 *.......*.......*.......*.......*.......*.......*.......*....... \n　　 #include \n　　 #define N 8 \n　　 int main() \n　　 { \n　　 int i; \n　　 int j; \n　　 int k; \n　　 --------------------------------------------------------- \n　　 | | \n　　 | | \n　　 | | \n　　 --------------------------------------------------------- \n　　 return 0; \n　　 } \n　　 2 ．完成程序，实现对数组的降序排序 \n　　 #include \n　　 void sort( ); \n　　 int main() \n　　 { \n　　 int array[]={45 ， 56 ， 76 ， 234 ， 1 ， 34 ， 23 ， 2 ， 3} ； // 数字任 // 意给出 \n　　 sort( ); \n　　 return 0; \n　　 } \n　　 void sort( ) \n　　 { \n　　 ____________________________________ \n　　 | | \n　　 | | \n　　 |-----------------------------------------------------| \n　　 } \n　　 3 ．费波那其数列， 1 ， 1 ， 2 ， 3 ， 5 ……编写程序求第十项。可以用递归，也可以用其 \n他方法，但要说明你选择的理由。 \n　　 #include \n　　 int Pheponatch(int); \n　　 int main() \n　　 { \n　　 printf(\"The 10th is %d\",Pheponatch(10)); \n　　 return 0; \n　　 } \n　　 int Pheponatch(int N) \n　　 { \n　　 -------------------------------- \n　　 | | \n　　 | | \n　　 -------------------------------- \n　　 } \n　　 4 ．下列程序运行时会崩溃，请找出错误并改正，并且说明原因。 \n　　 #include \n　　 #include \n　　 typedef struct{ \n　　 TNode* left; \n　　 TNode* right; \n　　 int value; \n　　 } TNode; \n　　 TNode* root=NULL; \n　　 void append(int N); \n　　 int main() \n　　 { \n　　 append(63); \n　　 append(45); \n　　 append(32); \n　　 append(77); \n　　 append(96); \n　　 append(21); \n　　 append(17); // Again, 数字任意给出 \n　　 } \n　　 void append(int N) \n　　 { \n　　 TNode* NewNode=(TNode *)malloc(sizeof(TNode)); \n　　 NewNode->value=N; \n\n\n　　 if(root==NULL) \n　　 { \n　　 root=NewNode; \n　　 return; \n　　 } \n　　 else \n　　 { \n　　 TNode* temp; \n　　 temp=root; \n\n　　 while((N>=temp.value && temp.left!=NULL) || (N !=NULL \n　　 )) \n　　 { \n　　 while(N>=temp.value && temp.left!=NULL) \n　　 temp=temp.left; \n　　 while(N 　　 temp=temp.right; \n　　 } \n　　 if(N>=temp.value) \n　　 temp.left=NewNode; \n　　 else \n　　 temp.right=NewNode; \n　　 return; \n　　 } \n　　 } \n\n※ 来源 : ·哈工大紫丁香 http://bbs.hit.edu.cn · [FROM:219.217.233.47] \n\n\n──────────────────────────────────────── \nmengfd (Icebreaker) 于 (Sun Oct 23 14:59:59 2005) 说道 :\n\n55 请你分别画出 OSI 的七层网络结构图和 TCP/IP 的五层结构图。\n\n应用层：为应用程序提供服务\n\n表示层：处理在两个通信系统中交换信息的表示方式\n\n会话层：负责维护两个结点间会话连接的建立、管理和终止，以及数据交换\n\n传输层：向用户提供可靠的端到端服务。 UDP TCP 协议。\n\n网络层：通过路由选择算法为分组通过通信子网选择最适当的路径，以及实现拥塞控制、网络互联等功能。数据传输单元是分组。 IP 地址，路由器， IP 协议。\n\n数据链路层：在物理层提供的服务基础上，数据链路层在通信的实体间建立数据链路连接，传输一帧为单位的数据包（，并采用差错控制与流量控制方法，使有差错的物理线路变成无差错的数据链路。）\n\n物理层：传输比特流。传输单元是比特。调制解调器。\n\n \n\n\n\n\n\n \n\nTCP/IP详解学习笔记(1)-基本概念\n\n \n\n56 请你详细地解释一下 IP 协议的定义，在哪个层上面？主要有什么作用？ TCP 与 UDP 呢 ？\n\n网络层。\n\n57. 请问交换机和路由器各自的实现原理是什么？分别在哪个层次上面实现的？\n\n交换机：数据链路层。路由器：网络层。\n\n58. 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的 ？\n\n \n\n59.8086 是多少位的系统？在数据总线上是怎么实现的？ \n\n\n\n8086 微处理器共有 4 个 16 位的段寄存器，在寻址内存单元时，用它们直接或间接地存放段地址。\n\n　　代码段寄存器 CS ：存放当前执行的程序的段地址。\n\n　　数据段寄存器 DS ：存放当前执行的程序所用操作数的段地址。\n\n　　堆栈段寄存器 SS ：存放当前执行的程序所用堆栈的段地址。\n\n　　附加段寄存器 ES ：存放当前执行程序中一个辅助数据段的段地址。\n\n由 cs:ip 构成指令地址， ss:sp 构成堆栈的栈顶地址指针。 DS 和 ES 用作数据段和附加段的段地址（段起始地址或段值）\n\n \n\n8086 ／ 8088 微处理器的存储器管理\n\n   1. 地址线（码）与寻址范围： N 条地址线      寻址范围 =2N\n\n   2.8086 有 20 地址线      寻址范围为 1MB  由 00000H ～ FFFFFH\n\n   3. 8086 微处理器是一个 16 位结构，用户可用的寄存器均为 16 位：寻址 64KB\n\n   4. 8086 ／ 8088 采用分段的方法对存储器进行管理。具体做法是：把 1MB 的存储器空间分成若干段，每段容量为 64KB ，每段存储器的起始地址必须是一个能被 16 整除的地址码，即在 20 位的二进制地址码中最低 4 位必须是 “0” 。每个段首地址的高 16 位二进制代码就是该段的段号 ( 称段基地址 ) 或简称段地址，段号保存在段寄存器中。我们可对段寄存器设置不同的值来使微处理器的存储器访问指向不同的段。\n\n   5. 段内的某个存储单元相对于该段段首地址的差值，称为段内偏移地址 ( 也叫偏移量 ) 用 16 位二进制代码表示。\n\n   6. 物理地址是由 8086 ／ 8088 芯片地址引线送出的 20 位地址码，它用来参加存储器的地址译码，最终读／写所访问的一个特定的存储单元。\n\n   7. 逻辑地址由某段的段地址和段内偏移地址 ( 也叫偏移量 ) 两部分所组成。写成：\n\n     段地址：偏移地址 ( 例如， 1234H ： 0088H) 。\n\n   8. 在硬件上起作用的是物理地址，物理地址＝段基地址 ×10H 十偏移地址\n\n\n\n联想笔试题 \n　　 1 ．设计函数 int atoi(char *s) 。 \n　　 2 ． int i=(j=4,k=8,l=16,m=32); printf( “ %d ” , i); 输出是多少？ \n\n\n60. 解释局部变量、全局变量和静态变量的含义。\n\n\n　　 4 ．解释堆和栈的区别。\n\n61. 论述含参数的宏与函数的优缺点。 \n\n\n普天 C++ 笔试题 \n　　 1 ．实现双向链表删除一个节点 P ，在节点 P 后插入一个节点，写出这两个函数。 \n　　 2 ．写一个函数，将其中的 /t 都转换成 4 个空格。\n\n \n\n61.Windows 程序的入口是哪里？写出 Windows 消息机制的流程。 \n\n\n4 ．如何定义和实现一个类的成员函数为回调函数？\n\n \n\n62.C++ 里面是不是所有的动作都是 main() 引起的？如果不是，请举例。 \n　　\n\n6 ． C++ 里面如何声明 const void f(void) 函数为 C 程序中的库函数？ \n　　 7 ．下列哪两个是等同的 \n　　 int b; \n　　 A const int* a = &b; \n　　 B const* int a = &b; \n　　 C const int* const a = &b; \n　　 D int const* const a = &b; \n　　 8 ．内联函数在编译时是否做参数类型检查？ \n　　 void g(base & b){ \n　　 b.play; \n　　 } \n　　 void main(){ \n　　 son s; \n　　 g(s); \n　　 return; \n　　 } \n\n\n\n\n※ 来源 : ·哈工大紫丁香 http://bbs.hit.edu.cn · [FROM:219.217.233.47] \n\n\n──────────────────────────────────────── \nmengfd (Icebreaker) 于 (Sun Oct 23 15:00:14 2005) 说道 : \n\n大唐电信 \n　　 DTT 笔试题 \n　　考试时间一小时，第一部分是填空和选择： \n　　 1 ．数列 6 ， 10 ， 18 ， 32 ，“？”，问“？”是几？ \n　　 2 ．某人出 70 买进一个 x ， 80 卖出， 90 买回， 100 卖出，这桩买卖怎么样？ \n　　 3 ．月球绕地球一圈，至少要多少时间？ \n　　 4 ． 7 个人用 7 小时挖了 7 米 的沟，以同样的速度在 50 小时挖 50 米 的沟要多少人？ \n　　 5 ．鱼头长 9 ，鱼尾等于鱼头加半个鱼身，鱼身等于鱼头加鱼尾，问鱼全长多少？ \n　　 6 ．一个小姐买了一块手表，回家发现手表比她家的表慢了两分钟，晚上看新闻的时候 \n又发现她家的表比新闻里的时间慢了两分钟，则 。 \n　　 A 手表和新闻里的时间一样 \n　　 B 手表比新闻里的时间慢 \n　　 C 手表比新闻里的时间快 \n　　 7 ．王先生看到一则招聘启事，发现两个公司除了以下条件不同外，其他条件都相同 \n\n　　 A 半年年薪 50 万，每半年涨 5 万 \n　　 B 一年年薪 100 万，每一年涨 20 万 \n　　王先生想去一家待遇比较优厚的公司，他会去哪家？ \n　　 10 ．问哪个袋子里有金子？ \n　　 A 袋子上的标签是这样写的： B 袋子上的话是对的，金子在 A 袋子。 \n　　 B 袋子上的标签是这样写的： A 袋子上的话是错的，金子在 A 袋子里。 \n　　 11 ． 3 个人住酒店 30 块钱，经理找回 5 块钱，服务生从中藏了 2 块钱，找给每人 1 块钱， \n3 ×（ 101 ） +2=29 ，问这是怎么回事？ \n　　 12 ．三篇写作，均为书信形式。 \n　　（ 1 ）一片中文的祝贺信，祝贺某男当了某公司 xx \n　　（ 2 ）两篇英文的，一是说有事不能应邀，派别人去；另一篇是讨债的， 7 天不给钱就 \n走人（主要考 business letter 格式）。 \n　　大唐面试试题 \n　　 1 ．什么是中断？中断发生时 CPU 做什么工作？ \n　　 2 ． CPU 在上电后，进入操作系统的 main() 之前必须做什么工作？ \n　　 3 ．简述 ISO OSI 的物理层 Layer1 ，链路层 Layer2 ，网络层 Layer3 的任务。 \n　　 4 ．有线电话和无线电话有何区别？无线电话特别需要注意的是什么？ \n　　\n\n63. 软件开发五个主要 step 是什么？\n\n\n　　 6 ．你在开发软件的时候，这 5 个 step 分别占用的时间百分比是多少？ \n　　 7 ． makefile 文件的作用是什么？ \n　　 8 ． UNIX 显示文件夹中，文件名的命令是什么？能使文件内容显示在屏幕的命令是什么 \n？ \n　　 9 ．（选做）手机用户在从一个基站漫游到另一个基站的过程中，都会发生什么 ? \n\n※ 来源 : ·哈工大紫丁香 http://bbs.hit.edu.cn · [FROM:219.217.233.47] \n\n\n──────────────────────────────────────── \nmengfd (Icebreaker) 于 (Sun Oct 23 15:01:22 2005) 说道 : \n\n网通笔试题 \n　　选择题（每题 5 分，只有一个正确答案） \n　　 1 ．中国 1 号信令协议属于 的协议。 \n　　 A ccs B cas C ip D atm \n　　 2 ． isdnpri 协议全称是 。 \n　　 A 综合业务模拟网基速协议 \n　　 B 综合业务模拟网模拟协议 \n　　 C 综合业务数字网基率协议 \n　　 D 综合业务数字网基次协议 \n　　 3 ．路由协议中， 协议是用距离作为向量的。 \n　　 A ospf B bgp C is-is D rip \n　　 4 ．中国智能网中， ssp 与 scp 间最上层的 ss7 协议是 。 \n　　 A incs B is41b C is41c D inap \n　　 5 ． dtmf 全称是 。 \n　　 A 双音多频 B 多音双频 C 多音三频 D 三音多频 \n　　 6 ．计算机的基本组成部分中，不包含下面设备的是 。 \n　　 A cpu B 输入设备 C 存储器 D 接口 \n　　 7 ．脉冲编码调制的简称是 。 \n　　 A pcm B pam C (delta)M D atm \n　　 8 ．普通电话线接口专业称呼是 。 \n　　 A rj11 B rj45 C rs232 D bnc \n　　 9 ．现有的公共数据网都采用 。 \n　　 A 电路交换技术 B 报文交换技术 \n　　 C 语音插空 D 分组交换 \n　　 10 ． ss7 协议中的制止市忙消息简写为 。 \n　　 A stb B slb C sub D spb \n　　简答题（每题 10 分） \n　　 1 ．简述普通电话与 IP 电话的区别。 \n　　 2 ．简述随路信令与公路信令的根本区别。 \n　　 3 ．说明掩码的主要作用。 \n　　 4 ． ss7 协议中，有三大要素决定其具体定位，哪三大要素？ \n　　 5 ．描述 ss7 的基本通话过程。 \n　　 6 ．简述通信网的组成结构。 \n　　 7 ．面向连接与面向非连接各有何利弊？ \n　　 8 ．写出爱尔兰的基本计算公式。 \n　　 9 ．数据网主要有哪些设备？ \n　　 10 ．中国一号协议是如何在被叫号码中插入主叫号码的？ \n\n\n东信笔试题目 \n　　笔试： 30 分钟。 \n　　 1 ．压控振荡器的英文缩写。 \n　　 2 ．动态随机存储器的英文缩写。 \n　　 3 ．选择电阻时要考虑什么？ \n　　 4 ．单片机上电后没有运转，首先要检查什么？ \n　　 5 ．计算机的基本组成部分及其各自的作用。 \n　　 6 ．怎样用 D 触发器、与或非门组成二分频电路？\n\n \n\n64.static 有什么用途？（请至少说明两种）\n\n答 、 1. 限制变量的作用域 ( 文件级的 ) 。\n\n  2. 设置变量的存储域 ( 全局数据区 ) 。\n\n \n\n \n\n65. 引用与指针有什么区别？\n\n答 、 1) 引用必须被初始化，指针不必。\n\n2) 引用初始化以后不能被改变，指针可以改变所指的对象。\n\n3) 不存在指向空值的引用，但是存在指向空值的指针。\n\n66. 描述实时系统的基本特性\n\n答 、在特定时间内完成特定的任务，实时性与可靠性。\n\n \n\n \n\n67. 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？\n\n答 、全局变量储存在静态数据区，局部变量在堆栈中。\n\n \n\n \n\n68. 什么是平衡二叉树？\n\n答 、左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于 1 。\n\n \n\n \n\n69. 堆栈溢出一般是由什么原因导致的？\n\n答 、 1. 没有回收垃圾资源\n\n         2. 层次太深的递归调用      \n\n \n\n \n\n70. 什么函数不能声明为虚函数？\n\n答 、 constructor\n\n       Deconstructor 可以声明为虚函数。\n\n       系统为一个空类创建的成员函数有那些。\n\n \n\n71. 冒泡排序算法的时间复杂度是什么？\n\n答 、 O(n^2)\n\n \n\n \n\n72. 写出 float x 与“零值”比较的 if 语句。\n\n答 、 if(x>0.000001&&x<-0.000001)\n\n \n\n \n\n73.Internet 采用哪种网络协议？该协议的主要层次结构？\n\n \n\n答 、 tcp/ip 应用层 / 传输层 / 网络层 / 数据链路层 / 物理层\n\n \n\n \n\n74.Internet 物理地址和 IP 地址转换采用什么协议？\n\n答 、 ARP (Address Resolution Protocol) （地址解析协议）\n\n \n\n \n\n75.IP 地址的编码分为哪俩部分？\n\n答 、 IP 地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与之后才能区分哪些是网络位哪些是主机位。\n\n \n\n76. 用户输入 M,N 值，从 1 至 N 开始顺序循环数数，每数到 M 输出该数值，直至全部输出。写出 C 程序。\n\n答 、循环链表，用取余操作做\n\n \n\n \n\n77. 不能做 switch() 的参数类型是：\n\n答 、 switch 的参数不能为实型。\n\n华为\n\n78. 局部变量能否和全局变量重名？\n\n答、能，局部会屏蔽全局。要用全局变量，需要使用 \"::\"\n\n局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内\n\n \n\n \n\n79. 如何引用一个已经定义过的全局变量？\n\n答 、可以用引用头文件的方式，也可以用 extern 关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用 extern 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错\n\n \n\n \n\n80. 全局变量可不可以定义在可被多个 .C 文件包含的头文件中？为什么？\n\n答 、可以，在不同的 C 文件中以 static 形式来声明同名全局变量。\n\n可以在不同的 C 文件中声明同名的全局变量，前提是其中只能有一个 C 文件中对此变量赋初值，此时连接不会出错\n\n \n\n \n\n81. 语句 for( ； 1 ； ) 有什么问题？它是什么意思？\n\n答 、和 while(1) 相同。\n\n \n\n \n\n82.do …… while 和 while …… do 有什么区别？\n\n答 、前一个循环一遍再判断，后一个判断以后再循环\n\n \n\n \n\n83. 请写出下列代码的输出内容\n\n#i nclude\n\nmain()\n\n{\n\nint a,b,c,d;\n\na=10;\n\nb=a++;\n\nc=++a;\n\nd=10*a++;\n\nprintf(\"b ， c ， d ： %d ， %d ， %d\" ， b ， c ， d ） ;\n\nreturn 0;\n\n}\n\n答 、 10 ， 12 ， 120\n\n84.statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数\n\nstatic 全局变量与普通的全局变量有什么区别？ static 局部变量和普通局部变量有什么区别？ static 函数与普通函数有什么区别？\n\n答 、全局变量 ( 外部变量 ) 的说明之前再冠以 static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。\n\n从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。\n\nstatic 函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数 (static) ，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件\n\nstatic 全局变量与普通的全局变量有什么区别： static 全局变量只初使化一次，防止在其他文件单元中被引用 ;\n\nstatic 局部变量和普通局部变量有什么区别： static 局部变量只被初始化一次，下一次依据上一次结果值；\n\nstatic 函数与普通函数有什么区别： static 函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝\n\n程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。\n\n85. 设有以下说明和定义：\n\ntypedef union {long i; int k[5]; char c;} DATE;\n\nstruct data { int cat; DATE cow; double dog;} too;\n\nDATE max;\n\n则语句 printf(\"%d\",sizeof(struct date)+sizeof(max)); 的执行结果是？\n\n答 、结果是： ___52____ 。 DATE 是一个 union, 变量公用空间 . 里面最大的变量类型是 int[5], 占用 20 个字节. 所以它的大小是 20\n\ndata 是一个 struct, 每个变量分开占用空间 . 依次为 int4 + DATE20 + double8 = 32.\n\n所以结果是 20 + 32 = 52.\n\n当然 ... 在某些 16 位编辑器下 , int 可能是 2 字节 , 那么结果是 int2 + DATE10 + double8 = 20\n\n86.-1,2,7,28,,126 请问 28 和 126 中间那个数是什么？为什么？\n\n答 、应该是 4^3-1=63\n\n规律是 n^3-1( 当 n 为偶数 0 ， 2 ， 4)\n\nn^3+1( 当 n 为奇数 1 ， 3 ， 5)\n\n \n\n87. 用两个栈实现一个队列的功能？要求给出算法和思路！\n\n答 、设 2 个栈为 A,B, 一开始均为空 .\n\n入队 :\n\n将新元素 push 入栈 A;\n\n出队 :\n\n(1) 判断栈 B 是否为空；\n\n(2) 如果不为空，则将栈 A 中所有元素依次 pop 出并 push 到栈 B ；\n\n(3) 将栈 B 的栈顶元素 pop 出；\n\n这样实现的队列入队和出队的平摊复杂度都还是 O(1), 比上面的几种方法要好。\n\n \n\n88. 在 c 语言库函数中将一个字符转换成整型的函数是atool() 吗，这个函数的原型是什么？\n\n答 、函数名 : atol\n\n功 能 : 把字符串转换成长整型数\n\n用 法 : long atol(const char *nptr);\n\n程序例 :\n\n＃ include\n\n＃ include\n\nint main(void)\n\n{\n\n    long l;\n\n    char *str = \"98765432\";\n\n    l = atol(lstr);\n\n    printf(\"string = %s integer = %ld/n\", str, l);\n\n    return(0);\n\n}\n\n \n\n \n\n89. 对于一个频繁使用的短小函数 , 在 C 语言中应用什么实现 , 在 C++ 中应用什么实现 ?\n\n答 、 c 用宏定义， c++ 用 inline\n\n \n\n90. 用预处理指令 #define 声明一个常数，用以表明 1年中有多少秒（忽略闰年问题）\n\n \n\n#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL\n\n我在这想看到几件事情：\n\n1). #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）\n\n2). 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。\n\n3). 意识到这个表达式将使一个 16 位机的整型数溢出 - 因此要用到长整型符号 L, 告诉编译器这个常数是的长整型数。\n\n4). 如果你在你的表达式中用到 UL （表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。\n\n \n\n91. 写一个“标准”宏 MIN ，这个宏输入两个参数并返回较小的一个。\n\n \n\n#define MIN(A,B) ((A) <= (B) (A) : (B))\n\n这个测试是为下面的目的而设的：\n\n1). 标识 #define 在宏中应用的基本知识。这是很重要的，因为直到嵌入 (inline) 操作符变为标准 C 的一部分，宏是方便产生嵌入代码的唯一方法，\n\n对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。\n\n2). 三重条件操作符的知识。这个操作符存在 C 语言中的原因是它使得编译器能产生比 if-then-else 更优化的代码，了解这个用法是很重要的。\n\n3). 懂得在宏中小心地把参数用括号括起来\n\n4). 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？\n\nleast = MIN(*p++, b);\n\n \n\n92. 预处理器标识 #error 的目的是什么？\n\n \n\n如果你不知道答案，请看参考文献 1 。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读 C 语言课本的附录去找出象这种\n\n问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。\n\n \n\n死循环（ Infinite loops ）\n\n \n\n93. 嵌入式系统中经常要用到无限循环，你怎么样用 C编写死循环呢？\n\n \n\n这个问题用几个解决方案。我首选的方案是：\n\nwhile(1)\n\n{\n\n}\n\n一些程序员更喜欢如下方案：\n\nfor(;;)\n\n{\n\n}\n\n这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的\n\n基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。\n\n第三个方案是用 goto\n\nLoop :\n\n...\n\ngoto Loop;\n\n应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN 程序员。\n\n \n\n数据声明（ Data declarations ）\n\n \n\n94. 用变量 a 给出下面的定义\n\na) 一个整型数（ An integer ）\n\nb) 一个指向整型数的指针（ A pointer to an integer ）\n\nc) 一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an integer ）\n\nd) 一个有 10 个整型数的数组（ An array of 10 integers ）\n\ne) 一个有 10 个指针的数组，该指针是指向一个整型数的（ An array of 10 pointers to integers ）\n\nf) 一个指向有 10 个整型数数组的指针（ A pointer to an array of 10 integers ）\n\ng) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（ A pointer to a function that takes an integer as an argument and returns an integer ）\n\nh) 一个有 10 个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer\n\nargument and return an integer ）\n\n \n\n答案是：\n\na) int a; // An integer\n\nb) int *a; // A pointer to an integer\n\nc) int **a; // A pointer to a pointer to an integer\n\nd) int a[10]; // An array of 10 integers\n\ne) int *a[10]; // An array of 10 pointers to integers\n\nf) int (*a)[10]; // A pointer to an array of 10 integers\n\ng) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer\n\nh) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer\n\n \n\n人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。\n\n但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道\n\n所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？\n\n \n\nStatic\n\n \n\n95. 关键字 static 的作用是什么？\n\n \n\n这个简单的问题很少有人能回答完全。在 C 语言中，关键字 static 有三个明显的作用：\n\n1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。\n\n2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。\n\n3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。\n\n大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数\n\n据和代码范围的好处和重要性。\n\n \n\nConst\n\n \n\n96. 关键字 const 是什么含意？\n\n我只要一听到被面试者说：“ const 意味着常数”，我就知道我正在和一个业余者打交道。去年 Dan Saks 已经在他的文章里完全概括了 const 的所有用法，因此 ESP( 译者： Embedded Systems Programming) 的每一位读者应该非常熟悉 const 能做什么和不能做什么 . 如果你从没有读到那篇文章，只要能说出 const 意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下 Saks 的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？\n\n \n\nconst int a;\n\nint const a;\n\nconst int *a;\n\nint * const a;\n\nint const * a const;\n\n \n\n前两个的作用是一样， a 是一个常整型数。第三个意味着 a 是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思 a 是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着 a 是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const ，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字 const 呢？我也如下的几下理由：\n\n1). 关键字 const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用 const 的程序员很少会留下的垃圾让别人来清理的。）\n\n2). 通过给优化器一些附加的信息，使用关键字 const 也许能产生更紧凑的代码。\n\n3). 合理地使用关键字 const 可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少 bug 的出现。\n\n \n\nVolatile\n\n \n\n97. 关键字 volatile 有什么含意 并给出三个不同的例子。\n\n \n\n一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是 volatile 变量的几个例子：\n\n1). 并行设备的硬件寄存器（如：状态寄存器）\n\n2). 一个中断服务子程序中会访问到的非自动变量 (Non-automatic variables)\n\n3). 多线程应用中被几个任务共享的变量\n\n回答不出这个问题的人是不会被雇佣的。我认为这是区分 C 程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、 RTOS 等等打交道，所用这些都要求 volatile 变量。不懂得 volatile 内容将会带来灾难。\n\n假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得 volatile 完全的重要性。\n\n1). 一个参数既可以是 const 还可以是 volatile 吗？解释为什么。\n\n2). 一个指针可以是 volatile 吗？解释为什么。\n\n3). 下面的函数有什么错误：\n\nint square(volatile int *ptr)\n\n{\n\nreturn *ptr * *ptr;\n\n}\n\n下面是答案：\n\n1). 是的。一个例子是只读的状态寄存器。它是 volatile 因为它可能被意想不到地改变。它是 const 因为程序不应该试图去修改它。\n\n2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个 buffer 的指针时。\n\n3). 这段代码的有个恶作剧。这段代码的目的是用来返指针 *ptr 指向值的平方，但是，由于 *ptr 指向一个 volatile型参数，编译器将产生类似下面的代码：\n\nint square(volatile int *ptr)\n\n{\n\nint a,b;\n\na = *ptr;\n\nb = *ptr;\n\nreturn a * b;\n\n}\n\n由于 *ptr 的值可能被意想不到地该变，因此 a 和 b 可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：\n\nlong square(volatile int *ptr)\n\n{\n\nint a;\n\na = *ptr;\n\nreturn a * a;\n\n}\n\n \n\n位操作（ Bit manipulation ）\n\n \n\n \n\n98. 下面的代码输出是什么，为什么？\n\n \n\nvoid foo(void)\n\n{\n\nunsigned int a = 6;\n\nint b = -20;\n\n(a+b > 6) puts(\"> 6\") : puts(\"<= 6\");\n\n}\n\n \n\n \n\n这个问题测试你是否懂得 C 语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是“ >6 ”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此 -20 变成了一个非常大的正整数，所以该表达式计算出的结果大于 6 。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。\n\n \n\n \n\n99.C 语言同意一些令人震惊的结构 , 下面的结构是合法的吗，如果是它做些什么？\n\nint a = 5, b = 7, c;\n\nc = a+++b;\n\n \n\n这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：\n\nc = a++ + b;\n\n因此 , 这段代码持行后 a = 6, b = 7, c = 12 。\n\n如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是 : 这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题\n\n \n\n \n\n \n\n \n\n今天早上的面试题 9 道，比较难，\n\n100. 线形表 a 、 b 为两个有序升序的线形表，编写一程序，使两个有序线形表合并成一个有序升序线形表 h；\n\n \n\n \n\n答案在 请化大学 严锐敏《数据结构第二版》第二章例题，数据结构当中，这个叫做：两路归并排序\n\nLinklist *unio(Linklist *p,Linklist *q){\n\nlinklist *R,*pa,*qa,*ra;\n\npa=p;\n\nqa=q;\n\nR=ra=p;\n\nwhile(pa->next!=NULL&&qa->next!=NULL){\n\nif(pa->data>qa->data){\n\nra->next=qa;\n\nqa=qa->next;\n\n}\n\nelse{\n\nra->next=pa;\n\npa=pa->next;\n\n}\n\n}\n\nif(pa->next!=NULL)\n\nra->next=pa;\n\nif(qa->next!=NULL)\n\nra->next==qa;\n\nreturn R;\n\n}\n\n101. 用递归算法判断数组 a[N] 是否为一个递增数组。\n\n递归的方法，记录当前最大的，并且判断当前的是否比这个还大，大则继续，否则返回 false 结束：\n\nbool fun( int a[], int n )\n\n{\n\nif( n= =1 )\n\nreturn true;\n\nif( n= =2 )\n\nreturn a[n-1] >= a[n-2];\n\nreturn fun( a,n-1) && ( a[n-1] >= a[n-2] );\n\n}\n\n102. 编写算法，从 10 亿个浮点数当中，选出其中最大的 10000 个。\n\n用外部排序，在《数据结构》书上有《计算方法导论》在找到第 n 大的数的算法上加工\n\n103. 编写一 unix 程序，防止僵尸进程的出现 .\n\n同学的 4 道面试题，应聘的职位是搜索引擎工程师，后两道超级难，（希望大家多给一些算发）\n\n1. 给两个数组和他们的大小，还有一动态开辟的内存，求交集，把交集放到动态内存 dongtai ，并且返回交集个数\n\nlong jiaoji(long* a[],long b[],long* alength,long blength,long* dongtai[])\n\n2. 单连表的建立，把 'a'--'z'26 个字母插入到连表中，并且倒叙，还要打印！\n\n方法 1 ：\n\ntypedef struct val\n\n{   int date_1;\n\n    struct val *next;\n\n}*p;\n\n \n\nvoid main(void)\n\n{   char c;\n\n    \n\n    for(c=122;c>=97;c--)\n\n       { p.date=c;\n\n          p=p->next;\n\n        }\n\n \n\n    p.next=NULL;\n\n}\n\n}\n\n方法 2 ：\n\nnode *p = NULL;\n\nnode *q = NULL;\n\n \n\nnode *head = (node*)malloc(sizeof(node));\n\nhead->data = ' ';head->next=NULL;\n\n \n\nnode *first = (node*)malloc(sizeof(node));\n\nfirst->data = 'a';first->next=NULL;head->next = first;\n\np = first;\n\n \n\nint longth = 'z' - 'b';\n\nint i=0;\n\nwhile ( i<=longth )\n\n{\n\nnode *temp = (node*)malloc(sizeof(node));\n\ntemp->data = 'b'+i;temp->next=NULL;q=temp;\n\n \n\nhead->next = temp; temp->next=p;p=q;\n\ni++;\n\n}\n\n \n\nprint(head);\n\n \n\n104. 可怕的题目终于来了\n\n象搜索的输入信息是一个字符串，统计 300 万输入信息中的最热门的前十条，我们每次输入的一个字符串为不超过 255byte, 内存使用只有 1G ,\n\n请描述思想，写出算发（ c 语言），空间和时间复杂度，\n\n7. 国内的一些帖吧，如 baidu, 有几十万个主题，假设每一个主题都有上亿的跟帖子，怎么样设计这个系统速度最好，请描述思想，写出算发（ c 语言），空间和时间复杂度，\n\n \n\n \n\n#include   string.h\n\nmain(void)\n\n{   char   *src=\"hello,world\";\n\n    char   *dest=NULL;\n\n    dest=(char    *)malloc(strlen(src));\n\n    int   len=strlen(str);\n\n    char   *d=dest;\n\n    char   *s=src[len];\n\n    while(len--!=0)\n\n      d++=s--;\n\n    printf(\"%s\",dest);\n\n}\n\n找出错误！！\n\n#include   \"string.h\"\n\n#include \"stdio.h\"\n\n#include \"malloc.h\"\n\nmain(void)\n\n{  \n\nchar   *src=\"hello,world\";\n\n    char   *dest=NULL;\n\n    dest=(char   *)malloc(sizeof(char)*(strlen(src)+1));\n\n    int   len=strlen(src);\n\n    char   *d=dest;\n\n    char   *s=src+len-1;\n\n    while(len--!=0)\n\n      *d++=*s--;\n\n*d='/0';\n\n    printf(\"%s\",dest);\n\n}\n\n105. 判断字符串是否为回文\n\nbool IsSymmetry(const char * p)\n\n     {\n\n         assert(p!=NULL);\n\n         const char * q=p;      \n\n         int len=0;\n\n         while (*q++!='/0' )\n\n         {\n\n              len++;\n\n         }       \n\n         bool bSign=true ;\n\n         q=p+len-1;\n\n         if (0<len)\n\n         {\n\n              for (int i=0;i<len/2;i++)\n\n              {\n\n                   if (*p++!=*q--){ bSign=false ;break ;};\n\n              }\n\n         }\n\n         if (bSign==true )\n\n         {\n\n              printf(\"Yes!/n\" );\n\n         }\n\n         else\n\n         {\n\n              printf(\"No!/n\" );\n\n         }\n\n         return bSign;\n\n     }\n\n107.ASDL 使用的是什么协议？并进行简单描述？\n\n \n\n108.Static 作用是什么\n\n首先 static 的最主要功能是隐藏，其次因为 static 变量存放在静态存储区，所以它具备持久性和默认值 0 。\n\n109. 什么是预编译 , 何时需要预编译 ?\n\n预编译又称为预处理 , 是做些代码文本的替换工作。处理 # 开头的指令 , 比如拷贝 #include 包含的文件代码，#define 宏定义的替换 , 条件编译等，就是为编译做的预备工作的阶段，主要处理 # 开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。\n\n \n\nc 编译系统在对程序进行通常的编译之前，先进行预处理。 c 提供的预处理功能主要有以下三种： 1 ）宏定义　2 ）文件包含　 3 ）条件编译\n\n \n\n１、总是使用不经常改动的大型代码体。 \n２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。\n\n \n\n110. 进程和线程的区别\n\n什么是进程（ Process ）：普通的解释就是，进程是程序的一次执行，而什么是线程（ Thread ），线程可以理解为进程中的执行的一段程序片段。在一个多任务环境中下面的概念可以帮助我们理解两者间的差别： \n\n进程间是独立的，这表现在内存空间，上下文环境；线程运行在进程空间内。 一般来讲（不使用特殊技术）进程是无法突破进程边界存取其他进程内的存储空间；而线程由于处于进程空间内，所以同一进程所产生的线程共享同一内存空间。 同一进程中的两段代码不能够同时执行，除非引入线程。线程是属于进程的，当进程退出时该进程所产生的线程都会被强制退出并清除。线程占用的资源要少于进程所占用的资源。 进程和线程都可以有优先级。在线程系统中进程也是一个线程。可以将进程理解为一个程序的第一个线程。\n\n \n\n线程是指进程内的一个执行单元 , 也是进程内的可调度实体 . 与进程的区别 :\n(1) 地址空间 : 进程内的一个执行单元 ; 进程至少有一个线程 ; 它们共享进程的地址空间 ; 而进程有自己独立的地址空间 ;\n(2) 进程是资源分配和拥有的单位 , 同一个进程内的线程共享进程的资源 \n(3) 线程是处理器调度的基本单位 , 但进程不是 .\n(4) 二者均可并发执行 .\n\n111. 插入排序和\n\n插入排序基本思想：（假定从大到小排序）依次从后面拿一个数和前面已经排好序的数进行比较，比较的过程是从已经排好序的数中最后一个数开始比较，如果比这个数，继续往前面比较，直到找到比它大的数，然后就放在它的后面，如果一直没有找到，肯定这个数已经比较到了第一个数，那就放到第一个数的前面。那么一般情况下，对于采用插入排序法去排序的一组数，可以先选 取第一个数做为已经排好序的一组数。然后把第二个放到正确位置。\n\n \n\n选择排序 (Selection Sort) 是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素 ,存放到排序序列的起始位置 , 然后 , 再从剩余未排序元素中继续寻找最小元素 , 然后放到排序序列末尾。以此类推, 直到所有元素均排序完毕。\n\n112. 运算符优先级问题\n\n能正确表示 a 和 b 同时为正或同时为负的逻辑表达式是 (D ) 。\n\nsssA 、 (a>=0||b>=0) ＆＆ (a<0||b<0) \nB 、 (a>=0 ＆＆ b>=0)&&(a<0& ＆ b<0) \nC 、 (a+b>0) ＆＆ (a+b<=0) \nD 、 a*b>0\n\n \n\n以下关于运算符优先顺序的描述中正确的是 (C) 。 \nA 、关系运算符 < 算术运算符 < 赋值运算符 < 逻辑与运算符 \nB 、逻辑与运算符 < 关系运算符 < 算术运算符 < 赋值运算符 \nC 、赋值运算符 < 逻辑与运算符 < 关系运算符 < 算术运算符 \nD 、算术运算符 < 关系运算符 < 赋值运算符 < 逻辑与运算符\n\n \n\n113. 字符串倒序\n\n \n\n写一个函数将 \"tom is cat\" 倒序打印出来，即 \"cat is tom\"\n\n//a.ch\n\n#define SPACE ' '\n#define ENDL '/0'\n\nchar* str = \"Tom is cat\"; // 字符串 \nchar* p1 = str+strlen(str)-1;\nchar* p2 = p1; // 开始时， p1,p2 都指向字符串结尾处 \nchar t=0; // 临时变量，用来保存被临时替换为 ENDL 的字符\n\nwhile(str!=p1--)\n{\n  if(SPACE!=*p1){\n     for(p2=p1+1;SPACE!=*p1; p1--, t=*p2, *p2=ENDL);\n\n     // p1+1 指向单词的第一个字母 ,p2 指向单词的结尾 , 此时输出这个单词 \n                printf(\"%s \",p1+1);\n                *p2=t;\n                p2=p1;\n         }\n}\n\nOutput:\ncat is Tom\n\n----------------------------------------------------------------------\n1) 写一个递归函数将内存中的字符串翻转 \"abc\"->\"cba\"\n2) 写一个函数将 \"tom is cat\" 将内存中的字符串翻转，即 \"cat is tomm\" \n\n#include <stdio.h>\n#define SPACE ' '\n#define ENDL '/0'\nchar* s = \"The quick brown fox jumps over the lazy dog\";\n\nvoid str_reverse(char* p1,char* p2){\n      if(p1==p2)return;\n    *p1 = (*p1)+(*p2);\n    *p2 = (*p1)-(*p2);\n    *p1 = (*p1)-(*p2);\n      if(p1==p2-1)return;\n      else str_reverse(++p1,--p2);\n}\n\nvoid str_word_reverse(char* str){\n      char *q1=str, *q2=str, *t;\n\n      while(*q1==SPACE)q1++;\n      if(*q1==ENDL)return; //!\n      else q2=q1+1;\n\n      while( (*q2!=SPACE) && (*q2!=ENDL) )q2++;\n    \n     t=q2--; \n    str_reverse(q1,q2);\n\n      if(*t==ENDL)return;\n      else str_word_reverse(t);\n}\n\nint\nmain(int a ,char** b)\n{\n    printf(\"%s/n\",s);\n    str_reverse(s,s+strlen(s)-1);\n    printf(\"%s/n\",s);\n    str_word_reverse(s);\n    printf(\"%s/n\",s);\n           return 0;\n}\n\nOutput:\n\nThe quick brown fox jumps over the lazy dog\ngod yzal eht revo spmuj xof nworb kciuq ehT\ndog lazy the over jumps fox brown quick The\n\n----------------------------------------------------------------------\n今天同学又问一道题 , 和上面有些类似，但是要求更严格了一些： \n写一个递归函数将内存中的字符串翻转 \"abc\"->\"cba\", 并且函数原型已确定： void reverse(char* p)\n\n其实，要求越多，思路越确定，我的解如下： \n\n#include <stdio.h>\n#include <string.h>\nchar* s = \"0123456789\";\n#define ENDL '/0'\nvoid reverse(char* p){\n       // 这是这种方法的关键，使用 static 为的是能用 str_reverse 的思路，但是不好 \n       static char* x=0;\n       if(x==0)x=p;\n       char* q = x+strlen(p)-1; \n       if(p==q)return;\n       *q=(*p)^(*q);\n       *p=(*p)^(*q);\n       *q =(*p)^(*q);\n       if(q==p+1)return;\n       reverse(++p);\n}\n\n// 这种方法就直观多了，但是当字符串很长的时候就很低效 \nvoid reverse2(char* p){\n       if(*(p+1)==ENDL)return;\n       for(char* o=p+strlen(p)-1,char t=*o;o!=p;o--)\n          *o=*(o-1);\n       *p=t;\n       reverse2(p+1);\n}\n\nint main(int c,char** argv){\n       reverse2(s);\n       printf(\"%s/n\",s);\n       return 0;\n}\n\n \n\n114. 交换两个数的宏定义\n\n \n\n交换两个参数值的 宏定义 为： . #define SWAP (a,b) (a)=(a)+(b);(b)=(a)-(b);(a)=(a)-(b);\n\n \n\n115.Itearator 各指针的区别\n\n \n\n游标和指针\n\n我说过游标是指针，但不仅仅是指针。游标和指针很像，功能很像指针，但是实际上，游标是通过重载一元的 ”*”和 ”->” 来从容器中间接地返回一个值。将这些值存储在容器中并不是一个好主意，因为每当一个新值添加到容器中或者有一个值从容器中删除，这些值就会失效。在某种程度上，游标可以看作是句柄（ handle ）。通常情况下游标（ iterator ）的类型可以有所变化，这样容器也会有几种不同方式的转变：\n\n\niterator—— 对于除了 vector 以外的其他任何容器，你可以通过这种游标在一次操作中在容器中朝向前的方向走一步。这意味着对于这种游标你只能使用 “++” 操作符。而不能使用 “--” 或 “+=” 操作符。而对于 vector 这一种容器，你可以使用 “+=” 、 “—” 、 “++” 、 “-=” 中的任何一种操作符和 “<” 、 “<=” 、 “>” 、 “>=” 、 “==” 、 “!=” 等比较运算符。\n\n \n\n116. C++ 中的 class 和 struct 的区别\n\n从语法上，在 C++ 中（只讨论 C++ 中）。 class 和 struct 做类型定义时只有两点区别： \n（一）默认继承权限。如果不明确指定，来自 class 的继承按照 private 继承处理，来自 struct 的继承按照 public继承处理； \n（二）成员的默认访问权限。 class 的成员默认是 private 权限， struct 默认是 public 权限。 \n除了这两点， class 和 struct 基本就是一个东西。语法上没有任何其它区别。\n\n不能因为学过 C 就总觉得连 C++ 中 struct 和 class 都区别很大，下面列举的说明可能比较无聊，因为 struct 和class 本来就是基本一样的东西，无需多说。但这些说明可能有助于澄清一些常见的关于 struct 和 class 的错误认识： \n（ 1 ）都可以有成员函数；包括各类构造函数，析构函数，重载的运算符，友元类，友元结构，友元函数，虚函数，纯虚函数，静态函数； \n（ 2 ）都可以有一大堆 public/private/protected 修饰符在里边； \n（ 3 ）虽然这种风格不再被提倡，但语法上二者都可以使用大括号的方式初始化：\n\nA a = {1, 2, 3}; 不管 A 是个 struct 还是个 class ，前提是这个类 / 结构足够简单，比如所有的成员都是 public的，所有的成员都是简单类型，没有显式声明的构造函数。 \n（ 4 ）都可以进行复杂的继承甚至多重继承，一个 struct 可以继承自一个 class ，反之亦可；一个 struct 可以同时继承 5 个 class 和 5 个 struct ，虽然这样做不太好。 \n（ 5 ）如果说 class 的设计需要注意 OO 的原则和风格，那么没任何理由说设计 struct 就不需要注意。 \n（ 6 ）再次说明，以上所有说法都是指在 C++ 语言中，至于在 C 里的情况， C 里是根本没有 “class” ，而 C 的struct 从根本上也只是个包装数据的语法机制。 \n---------------------------------------------------------------\n\n最后，作为语言的两个关键字，除去定义类型时有上述区别之外，另外还有一点点： “class” 这个关键字还用于定义模板参数，就像 “typename” 。但关键字 “struct” 不用于定义模板参数。\n\n \n\n关于使用大括号初始化\n\n　　 class 和 struct 如果定义了构造函数的话，都不能用大括号进行初始化\n\n　　如果没有定义构造函数， struct 可以用大括号初始化。\n\n　　如果没有定义构造函数，且所有成员变量全是 public 的话，可以用大括号初始化。\n\n　　关于默认访问权限\n\n　　 class 中默认的成员访问权限是 private 的，而 struct 中则是 public 的。\n\n　　关于继承方式\n\n　　 class 继承默认是 private 继承，而 struct 继承默认是 public 继承。\n\n　　关于模版\n\n \n\n　　在模版中，类型参数前面可以使用 class 或 typename ，如果使用 struct ，则含义不同， struct 后面跟的是“non-type template parameter” ，而 class 或 typename 后面跟的是类型参数。\n\n \n\nclass 中有个默认的 this 指针， struct 没有 \n不同点：构造函数，析构函数  this  指针\n\n \n\n117. 有关重载函数\n\n \n\n返回值类型不同构不成重载 \n参数参数顺序不同能构成重载\n\nc++ 函数同名不同返回值不算重载！函数重载是忽略返回值类型的。 \n\n--------------------------------------------- \n成员函数被重载的特征有： \n1) 相同的范围（在同一个类中）； \n2) 函数名字相同； \n3) 参数不同； \n4) virtual 关键字可有可无。\n\n5) 成员函数中 有无 const ( 函数后面 ) 也可判断是否重载\n\n \n\n118. 数据库与 T-SQL 语言 \n   \n\n关系数据库是表的集合，它是由一个或多个关系模式定义。 SQL 语言中的数据定义功能包括对数据库、基本表、视图、索引的定义。\n\n \n\n119. 关系模型的基本概念 \n\n\n  关系数据库以关系模型为基础，它有以下三部分组成： \n    ● 数据结构 —— 模型所操作的对象、类型的集合 \n    ● 完整性规则 —— 保证数据有效、正确的约束条件 \n    ● 数据操作 —— 对模型对象所允许执行的操作方式 \n    关系（ Relation ）是一个由行和列组成的二维表格，表中的每一行是一条记录（ Record ），每一列是记录的一个字段（ Field ）。表中的每一条记录必须是互斥的，字段的值必须具有原子性。 \n\n\n120.SQL 语言概述\n\n\n    SQL （结构化查询语言）是关系数据库语言的一种国际标准，它是一种非过程化的语言。通过编写 SQL ，我们可以实现对关系数据库的全部操作。 \n    ● 数据定义语言（ DDL ） —— 建立和管理数据库对象 \n    ● 数据操纵语言（ DML ） —— 用来查询与更新数据 \n    ● 数据控制语言（ DCL ） —— 控制数据的安全性\n\n \n\n起来是一个很简单的问题，每一个使用过 RDBMS 的人都会有一个概念。\n\n事务处理系统的典型特点是具备 ACID 特征。 ACID 指的是 Atomic （原子的）、 Consistent （一致的）、Isolated （隔离的）以及 Durable （持续的），它们代表着事务处理应该具备的四个特征：\n\n原子性：组成事务处理的语句形成了一个逻辑单元，不能只执行其中的一部分\n\n一致性：在事务处理执行之前和之后，数据是一致的。\n\n隔离性：一个事务处理对另一个事务处理没有影响。\n\n持续性：当事务处理成功执行到结束的时候，其效果在数据库中被永久纪录下来。\n\n \n\n121.C 语言中结构化程序设计的三种基本控制结构\n\n \n\n顺序结构 \n选择结构 \n循环结构\n\n \n\n122.CVS 是什么\n\n \n\ncvs （ Concurrent Version System ） 是一个版本控制系统。使用它，可以记录下你的源文件的历史。 \n\n例如，修改软件时可能会不知不觉混进一些 bug ，而且可能过了很久你才会察觉到它们的存在。有了 cvs ，你可以很容易地恢复旧版本，并从中看出到底是哪个修改导致了这个 bug 。有时这是很有用的。 \n\nCVS 服务器端对每个文件维护着一个修订号 , 每次对文件的更新，都会使得文件的修订号加 1 。在客户端中也对每个文件维护着一个修订号 ,CVS 通过这两个修订号的关系，来进行 Update,Commit 和发现冲突等操作操作\n\n \n\n123. 三种基本的数据模型\n\n \n\n按照数据结构类型的不同，将数据模型划分为层次模型、网状模型和关系模型。","source":"_posts/C++/CPP入门基础.md","raw":"---\ntitle: C++入门基础\ndate: 2018-10-02 09:09:09\ncategories: cpp\n---\n# C++入门基础\n\n\n---\n\n\n##1.new 、 delete 、 malloc 、 free 关系\n\ndelete 会调用对象的析构函数 , 和 new 对应 free 只会释放内存， new 调用构造函数。 malloc 与 free 是C++/C 语言的标准库函数， new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free 。因此 C++ 语言需要一个能完成动态内存分配和初始化工作的运算符 new ，以及一个能完成清理与释放内存工作的运算符 delete 。注意 new/delete 不是库函数。\n\n总结：new和delete会自动调用对象的构造与析构函数而malloc与free不会；\n\n      new和delete式C++运算符，而malloc和free是C/C++标准库函数。\n\n---\n\n##2.delete 与 delete [] 区别\n\ndelete 只会调用一次析构函数，而 delete[] 会调用每一个成员的析构函数。在 More Effective  C++ 中有更为详细的解释：“当 delete 操作符用于数组时，它为每个数组元素调用析构函数，然后调用 operatordelete 来释放内存。” delete 与 New 配套， delete [] 与 new [] 配套\n```c++\n  MemTest*mTest1=newMemTest[10];\n\n  MemTest*mTest2=newMemTest;\n\n  int*pInt1=newint[10];\n\n  int*pInt2=newint;\n\n  delete[]pInt1;  //-1-\n\n  delete[]pInt2;  //-2-\n\n  delete[]mTest1;//-3-\n\n  delete[]mTest2;//-4-\n```\n  在 -4- 处报错。\n\n这就说明：对于内建简单数据类型， delete 和 delete[] 功能是相同的。对于自定义的复杂数据类型， delete和 delete[] 不能互用。 delete[] 删除一个数组， delete 删除一个指针简单来说，用 new 分配的内存用 delete 删除用 new[] 分配的内存用 delete[] 删除 delete[] 会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用 delete 时没用括号， delete 就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。\n\n总结： delete 只会调用一次析构函数，而 delete[] 会调用每一个成员的析构函数。\n\n\n---\n\n\n##3. C C++ JAVA 共同点，不同之处？\n\n\n\n---\n\n\n\n##4. 继承优缺点。\n\n类继承是在编译时刻静态定义的，且可直接使用，类继承可以较方便地改变父类的实现。但是类继承也有一些不足之处。首先，因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现。更糟的是，父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为。如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。\n\n（待补充）\n\n \n\n---\n\n\n\n##5.C++ 有哪些性质（面向对象特点）\n\n封装，继承和多态。\n\n在面向对象程序设计语言中，封装是利用可重用成分构造软件系统的特性，它不仅支持系统的可重用性，而且还有利于提高系统的可扩充性；消息传递可以实现发送一个通用的消息而调用不同的方法；封装是实现信息隐蔽的一种技术，其目的是使类的定义和实现分离。\n\n\n---\n\n\n##6. 子类析构时要调用父类的析构函数吗？\n\n析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候 , 派生类的信息已经全部销毁了定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数 JAVA 无析构函数深拷贝和浅拷贝\n\n\n---\n\n\n##7. 多态，虚函数，纯虚函数\n\n\n---\n\n\n##8. 求下面函数的返回值（微软）\n```c++\nint func(x) \n{ \n    int countx = 0; \n    while(x) \n    { \n          countx ++; \n          x = x&(x-1); \n     } \n    return countx; \n} \n```\n假定 x = 9999 。 答案： 8\n\n思路：将 x 转化为 2 进制，看含有的 1 的个数。\n\n\n---\n\n\n##9. 什么是 “ 引用 ” ？申明和使用 “ 引用 ” 要注意哪些问题？\n\n答：引用就是某个目标变量的 “ 别名 ”(alias) ，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。\n\n\n---\n\n\n##10. 将 “ 引用 ” 作为函数参数有哪些特点？\n\n（ 1 ）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。\n\n（ 2 ）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。\n\n（ 3 ）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用 \"\\* 指针变量名 \" 的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。\n\n\n---\n\n\n##11. 在什么时候需要使用 “ 常引用 ” ？ 　\n\n如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式： const 类型标识符 & 引用名 = 目标变量名；\n\n例 1\n```c++\nint a ;\nconst int &ra=a;\nra=1; // 错误 \na=1; // 正确\n```\n例 2\n\n```c++\nstring foo( );\nvoid bar(string & s);\n```\n那么下面的表达式将是非法的：\n\n```c++\nbar(foo( ));\nbar(\"hello world\");\n```\n原因在于 foo( ) 和 \"hello world\" 串都会产生一个临时对象，而在 C++ 中，这些临时对象都是 const 类型的。因此上面的表达式就是试图将一个 const 类型的对象转换为非 const 类型，这是非法的。引用型参数应该在能被定义为 const 的情况下，尽量定义为 const 。\n\n\n---\n\n\n##12. 将 “ 引用 ” 作为函数返回值类型的格式、好处和需要遵守的规则 ?\n\n格式：类型标识符 & 函数名（形参列表及类型说明） { // 函数体 }\n\n好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生 runtime error! 注意事项：\n\n（ 1 ）不能返回局部变量的引用。这条可以参照 Effective C++[1] 的 Item 31 。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了 \" 无所指 \" 的引用，程序会进入未知状态。\n\n（ 2 ）不能返回函数内部 new 分配的内存的引用。这条可以参照 Effective C++[1] 的 Item 31 。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部 new 分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由 new 分配）就无法释放，造成 memory leak 。\n\n（ 3 ）可以返回类成员的引用，但最好是 const 。这条原则可以参照 Effective C++[1] 的 Item 30 。主要原因是当对象的属性是与某种业务规则（ business rule ）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。\n\n（ 4 ）流操作符重载返回值申明为 “ 引用 ” 的作用：\n\n流操作符 << 和 >> ，这两个操作符常常希望被连续使用，例如： cout << \"hello\" << endl; 　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个 << 操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用 << 操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是 C++ 语言中引入引用这个概念的原因吧。 赋值操作符 = 。这个操作符象流操作符一样，是可以连续使用的，例如： x = j = 10; 或者 (x=10)=100; 赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。\n\n例 3\n\n```c++\n＃ i nclude <iostream.h>\nint &put(int n);\nint vals[10];\nint error=-1;\nvoid main()\n{\nput(0)=10; // 以 put(0) 函数值作为左值，等价于 vals[0]=10; \nput(9)=20; // 以 put(9) 函数值作为左值，等价于 vals[9]=20; \ncout<<vals[0]; \ncout<<vals[9];\n} \nint &put(int n)\n{\nif (n>=0 && n<=9 ) return vals[n]; \nelse { cout<<\"subscript error\"; return error; }\n}\n```\n（ 5 ）在另外的一些操作符中，却千万不能返回引用： +-*/ 四则运算符。它们不能返回引用， Effective C++[1] 的 Item23 详细的讨论了这个问题。主要原因是这四个操作符没有 side effect ，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个 new 分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第 2 、 3 两个方案都被否决了。静态对象的引用又因为 ((a+b) == (c+d)) 会永远为 true 而导致错误。所以可选的只剩下返回一个对象了。\n\n\n---\n\n\n##13.“ 引用 ” 与多态的关系？\n\n引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。例4\n\nClass A; Class B : Class A{...};  B b; A& ref = b;\n\n\n---\n\n\n##14.“ 引用 ” 与指针的区别是什么？\n\n指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。此外，就是上面提到的对函数传 ref 和pointer 的区别。\n\n\n---\n\n\n##15. 什么时候需要 “ 引用 ” ？\n\n流操作符 << 和 >> 、赋值操作符 = 的返回值、拷贝构造函数的参数、赋值操作符 = 的参数、其它情况都推荐使用引用。以上 2-8 参考： http://develop.csai.cn/c/NO0000021.htm\n\n\n---\n\n\n##16. 结构与联合有和区别？\n\n\n(1). 结构和联合都是由多个不同的数据类型成员组成 , 但在任何同一时刻 , 联合中只存放了一个被选中的成员（所有成员共用一块地址空间） , 而结构的所有成员都存在（不同成员的存放地址不同）。  \n (2). 对于联合的不同成员赋值 , 将会对其它成员重写 ,  原来成员的值就不存在了 , 而对于结构的不同成员赋值是互不影响的。\n\n\n---\n\n\n##17. 面关于 “ 联合 ” 的题目的输出？\n\na)\n```c++\n＃ i nclude <stdio.h>\nunion\n{\nint i;\nchar x[2];\n}a;\n\n\nvoid main()\n{\na.x[0] = 10; \na.x[1] = 1;\nprintf(\"%d\",a.i);\n}\n答案： 266 ( 低位低地址，高位高地址，内存占用情况是 Ox010A ）\n```\nb)\n```c++\nmain() \n     { \n          union{                   /* 定义一个联合 */ \n               int i; \n               struct{             /* 在联合中定义一个结构 */ \n                    char first; \n                    char second; \n               }half; \n          }number; \n          number.i=0x4241;         /* 联合成员赋值 */ \n          printf(\"%c%cn\", number.half.first, mumber.half.second); \n          number.half.first='a';   /* 联合中结构成员赋值 */ \n          number.half.second='b'; \n          printf(\"%xn\", number.i); \n          getch(); \n     } \n     ```\n答案： AB   (0x41 对应 'A', 是低位； Ox42 对应 'B', 是高位）\n\n       6261 (number.i 和 number.half 共用一块地址空间）\n\n18. 关联、聚合 (Aggregation) 以及组合(Composition) 的区别？\n\n涉及到 UML 中的一些概念：关联是表示两个类的一般性联系，比如 “ 学生 ” 和 “ 老师 ” 就是一种关联关系；聚合表示 has-a 的关系，是一种相对松散的关系，聚合类不需要对被聚合类负责，如下图所示，用空的菱形表示聚合关系：从实现的角度讲，聚合可以表示为 :\n\nclass A {...}  class B { A* a; .....}\n\n而组合表示 contains-a 的关系，关联性强于聚合：组合类与被组合类有相同的生命周期，组合类要对被组合类负责，采用实心的菱形表示组合关系：实现的形式是 :\n\nclass A{...} class B{ A a; ...}\n\n参考文章： http://www.cnitblog.com/Lily/archive/2006/02/23/6860.html\n\n          http://www.vckbase.com/document/viewdoc/?id=422\n\n19. 面向对象的三个基本特征，并简单叙述之？\n\n1. 封装：将客观事物抽象成类，每个类对自身的数据和方法实行 protection(private, protected,public)\n\n2. 继承：广义的继承有三种实现形式：实现继承（指使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后到子类实现）。前两种（类继承）和后一种（对象组合 => 接口继承以及纯虚函数）构成了功能复用的两种方式。\n\n3. 多态：是将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。\n\n20. 重载（ overload) 和重写 (overried ，有的书也叫做 “ 覆盖 ” ）的区别？\n\n常考的题目。从定义上来说：\n\n重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。\n\n重写：是指子类重新定义父类虚函数的方法。\n\n从实现原理上来说：\n\n重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数： function func(p:integer):integer; 和 function func(p:string):integer; 。 那么编译器做过修饰后的函数名称可能是这样的： int_func 、 str_func 。对于这两个函数的调用，在编译器间就已经确定了，是 静态 的。也就是说， 它们的地址在编译期就绑定了（早绑定）， 因此， 重载和多态无关 ！\n\n重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针， 动态的调用 属于子类的该函数，这样的函 数调用在编译期间是无法确定的 （调用的子类的虚函数的地址无法给出）。因此， 这样的函数地址是在运行期绑定的（晚绑定）。\n\n\n---\n\n\n##21. 多态的作用？\n\n主要是两个：\n\n1. 隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；\n\n2. 接口重用：为了类在继承和派生的时候 ，保证使用家族中任一类的实例的某一属性时的正确调用 。\n\n\n---\n\n\n##22.Ado 与 Ado.net 的相同与不同？\n\n除了“能够让应用程序处理存储于 DBMS 中的数据“这一基本相似点外，两者没有太多共同之处。但是 Ado使用 OLE DB 接口并基于微软的 COM 技术，而 ADO.NET 拥有自己的 ADO.NET 接口并且基于微软的 .NET 体系架构。众所周知 .NET 体系不同于 COM 体系， ADO.NET 接口也就完全不同于 ADO 和 OLE DB 接口，这也就是说 ADO.NET 和 ADO 是两种数据访问方式。 ADO.net 提供对 XML 的支持。\n\n\n---\n\n\n##23.New delete 与 malloc free 的联系与区别 ?\n\n答案：都是在堆 (heap) 上进行动态的内存操作。用 malloc 函数需要指定内存分配的字节数并且不能初始化对象， new 会自动调用对象的构造函数。 delete 会调用对象的 destructor ，而 free 不会调用对象的 destructor.\n\n\n---\n\n\n##24.#define DOUBLE(x) x+x ， i = 5*DOUBLE(5) ； i是多少？\n\n答案： i 为 30 。\n\n\n---\n\n\n##25. 有哪几种情况只能用 intialization list 而不能用assignment?\n\n答案：当类中含有 const 、 reference 成员变量；基类的构造函数都需要初始化表。\n\n\n---\n\n\n##26. C++ 是不是类型安全的？\n\n答案：不是。两个不同类型的指针之间可以强制转换（用 reinterpret cast) 。 C# 是类型安全的。\n\n\n---\n\n\n##27. main 函数执行以前，还会执行什么代码？\n\n答案：全局对象的构造函数会在 main 函数之前执行。\n\n\n---\n\n\n##28.  描述内存分配方式以及它们的区别 ?\n\n1 ） 从静态存储区域分配 。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如 全局变量， static 变量 。 \n2 ） 在栈上创建 。在执行函数时， 函数内局部变量的存储单元都可以在栈上创建 ，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。 \n3 ） 从堆上分配 ， 亦称动态内存分配 。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。\n\n\n---\n\n\n##29.struct 和 class 的区别\n\n答案： struct 的成员默认是公有的，而类的成员默认是私有的。 struct 和 class 在其他方面是功能相当的。从感情上讲，大多数的开发者感到类和结构有很大的差别。感觉上结构仅仅象一堆缺乏封装和功能的开放的内存位，而类就象活的并且可靠的社会成员，它有智能服务，有牢固的封装屏障和一个良好定义的接口。既然大多数人都这么认为，那么只有在你的类有很少的方法并且有公有数据（这种事情在良好设计的系统中是存在的 ! ）时，你也许应该使用 struct 关键字，否则，你应该使用 class 关键字。  \n\n\n---\n\n\n##30. 当一个类 A 中没有任何成员变量与成员函数 , 这时sizeof(A) 的值是多少？\n\n答案：如果不是零，请解释一下编译器为什么没有让它为零。（ Autodesk ）肯定不是零。举个反例，如果是零的话，声明一个 class A[10] 对象数组，而每一个对象占用的空间是零，这时就没办法区分 A[0],A[1] …了。\n\n\n---\n\n\n##31. 在 8086 汇编下，逻辑地址和物理地址是怎样转换的？（ Intel ）\n\n答案：通用寄存器给出的地址，是段内偏移地址，相应段寄存器地址 *10H+ 通用寄存器内地址，就得到了真正要访问的地址。\n\n\n---\n\n##32.  比较 C++ 中的 4 种类型转换方式？\n\n请参考： http://blog.csdn.net/wfwd/archive/2006/05/30/763785.aspx ，重点是 static_cast, dynamic_cast和 reinterpret_cast 的区别和应用。\n\ndynamic_casts 在帮助你浏览继承层次上是有限制的。它不能被用于缺乏虚函数的类型上，它被用于安全地沿着类的继承关系向下进行类型转换。如你想在没有继承关系的类型中进行转换，你可能想到 static_cast\n\n---\n\n##33. 分别写出 BOOL,int,float, 指针类型的变量 a与“零”的比较语句。\n\n答案： \nBOOL :    if ( !a ) or if(a)\nint :     if ( a == 0)\nfloat :   const EXPRESSION EXP = 0.000001\n          if ( a < EXP && a >-EXP)\npointer : if ( a != NULL) or if(a == NULL)\n\n ---\n\n##34. 请说出 const 与 #define 相比，有何优点？\n\n答案：\n\nConst 作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被 Const 修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。\n\n1 ） const 常量有数据类型，而宏常量没有数据类型 。编译器可以对前者进行类型 安全检查 。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。 \n      2 ） 有些集成化的调试工具可以对 const 常量进行调试 ，但是不能对宏常量进行调试。\n\n---\n\n##35. 简述数组与指针的区别？\n\n数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。 \n(1) 修改内容上的差别 \nchar a[] = “ hello ” ;\na[0] = ‘ X ’ ;\nchar *p = “ world ” ; // 注意 p 指向常量字符串 \np[0] = ‘ X ’ ; // 编译器不能发现该错误，运行时错误 \n(2) 用运算符 sizeof 可以计算出数组的容量（字节数）。 sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是 p 所指的内存容量 。 C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。 注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。 \nchar a[] = \"hello world\";\nchar *p = a;\ncout<< sizeof(a) << endl; // 12 字节 \ncout<< sizeof(p) << endl; // 4 字节 \n计算数组和指针的内存容量 \nvoid Func(char a[100])\n{\ncout<< sizeof(a) << endl; // 4 字节而不是 100 字节 \n}\n\n\n---\n\n\n##36. 类成员函数的重载、覆盖和隐藏区别？\n\n答案： a. 成员函数被重载的特征： \n（ 1 ）相同的范围（在同一个类中）； \n（ 2 ）函数名字相同； \n（ 3 ）参数不同； \n（ 4 ） virtual 关键字可有可无。 \nb. 覆盖是指派生类函数覆盖基类函数，特征是： \n（ 1 ）不同的范围（分别位于派生类与基类）； \n（ 2 ）函数名字相同； \n（ 3 ）参数相同； \n（ 4 ）基类函数必须有 virtual 关键字。 \n  c. “隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下： \n（ 1 ）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载混淆）。 \n（ 2 ）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）\n\n\n---\n\n\n##37. 求出两个数中的较大这\n\nThere are two int variables: a and b, don ’ t use “ if ” , “ ? : ” , “ switch ” or other judgement statements, find out the biggest one of the two numbers.\n\n答案： ( ( a + b ) + abs( a - b ) ) / 2\n\n\n---\n\n\n##38. 如何打印出当前源文件的文件名以及源文件的当前行号？\n\n答案： \ncout << __FILE__ ;\ncout<<__LINE__ ;\n__FILE__ 和 __LINE__ 是系统预定义宏，这种宏并不是在某个文件中定义的，而是由编译器定义的。\n\n\n---\n\n\n##39. main 主函数执行完毕后，是否可能会再执行一段代码，给出说明？\n\n答案：可以，可以用 _onexit 注册一个函数，它会在 main 之后执行 int fn1(void), fn2(void), fn3(void), fn4 (void);\n```c++\nvoid main( void )\n{\nString str(\"zhanglin\");\n_onexit( fn1 );\n_onexit( fn2 );\n_onexit( fn3 );\n_onexit( fn4 );\nprintf( \"This is executed first.n\" );\n}\nint fn1()\n{\nprintf( \"next.n\" );\nreturn 0;\n}\nint fn2()\n{\nprintf( \"executed \" );\nreturn 0;\n}\nint fn3()\n{\nprintf( \"is \" );\nreturn 0;\n}\nint fn4()\n{\nprintf( \"This \" );\nreturn 0;\n}\n```\nThe _onexit function is passed the address of a function (func) to be called when the program terminates normally. Successive calls to _onexit create a register of functions that are executed in LIFO (last-in-first-out) order. The functions passed to _onexit cannot take parameters.\n\n---\n\n##40. 如何判断一段程序是由 C 编译程序还是由 C++ 编译程序编译的？\n\n答案： \n#ifdef __cplusplus\ncout<<\"c++\";\n#else\ncout<<\"c\";\n#endif\n\n\n---\n\n\n##41. 文件中有一组整数，要求排序后输出到另一个文件中\n\n\n答案：\n```c++\n＃ i nclude<iostream>\n\n＃ i nclude<fstream>\n\nusing namespace std;\n\n\nvoid Order(vector<int>& data) //bubble sort\n{\nint count = data.size() ;\nint tag = false ; // 设置是否需要继续冒泡的标志位 \nfor ( int i = 0 ; i < count ; i++)\n{\nfor ( int j = 0 ; j < count - i - 1 ; j++)\n{\nif ( data[j] > data[j+1])\n{\ntag = true ;\nint temp = data[j] ;\ndata[j] = data[j+1] ;\ndata[j+1] = temp ;\n}\n}\nif ( !tag )\nbreak ;\n}\n}\n\n\nvoid main( void )\n{\nvector<int>data;\nifstream in(\"c:/data.txt\");\nif ( !in)\n{\ncout<<\"file error!\";\nexit(1);\n}\nint temp;\nwhile (!in.eof())\n{\nin>>temp;\ndata.push_back(temp);\n}\nin.close(); // 关闭输入文件流 \nOrder(data);\nofstream out(\"c:/result.txt\");\nif ( !out)\n{\ncout<<\"file error!\";\nexit(1);\n}\nfor ( i = 0 ; i < data.size() ; i++)\nout<<data[i]<<\" \";\nout.close(); // 关闭输出文件流 \n}\n```\n \n\n\n---\n\n\n##42. 链表题：一个链表的结点结构\n```c++\nstruct Node\n{\nint data ;\nNode *next ;\n};\ntypedef struct Node Node ;\n\n\n(1) 已知链表的头结点 head, 写一个函数把这个链表逆序 ( Intel)\n\nNode * ReverseList(Node *head) // 链表逆序 \n{\nif ( head == NULL || head->next == NULL )\nreturn head;\nNode *p1 = head ;\nNode *p2 = p1->next ;\nNode *p3 = p2->next ;\np1->next = NULL ;\nwhile ( p3 != NULL )\n{\np2->next = p1 ;\np1 = p2 ;\np2 = p3 ;\np3 = p3->next ;\n}\np2->next = p1 ;\nhead = p2 ;\nreturn head ;\n}\n(2) 已知两个链表 head1 和 head2 各自有序，请把它们合并成一个链表依然有序。 ( 保留所有结点，即便大小相同） \nNode * Merge(Node *head1 , Node *head2)\n{\nif ( head1 == NULL)\nreturn head2 ;\nif ( head2 == NULL)\nreturn head1 ;\nNode *head = NULL ;\nNode *p1 = NULL;\nNode *p2 = NULL;\nif ( head1->data < head2->data )\n{\nhead = head1 ;\np1 = head1->next;\np2 = head2 ;\n}\nelse\n{\nhead = head2 ;\np2 = head2->next ;\np1 = head1 ;\n}\nNode *pcurrent = head ;\nwhile ( p1 != NULL && p2 != NULL)\n{\nif ( p1->data <= p2->data )\n{\npcurrent->next = p1 ;\npcurrent = p1 ;\np1 = p1->next ;\n}\nelse\n{\npcurrent->next = p2 ;\npcurrent = p2 ;\np2 = p2->next ;\n}\n}\nif ( p1 != NULL )\npcurrent->next = p1 ;\nif ( p2 != NULL )\npcurrent->next = p2 ;\nreturn head ;\n}\n(3) 已知两个链表 head1 和 head2 各自有序，请把它们合并成一个链表依然有序，这次要求用递归方法进行。(Autodesk)\n答案： \nNode * MergeRecursive(Node *head1 , Node *head2)\n{\nif ( head1 == NULL )\nreturn head2 ;\nif ( head2 == NULL)\nreturn head1 ;\nNode *head = NULL ;\nif ( head1->data < head2->data )\n{\nhead = head1 ;\nhead->next = MergeRecursive(head1->next,head2);\n}\nelse\n{\nhead = head2 ;\nhead->next = MergeRecursive(head1,head2->next);\n}\nreturn head ;\n```\n \n\n----------\n\n##41. 分析一下这段程序的输出 (Autodesk)\nclass B\n{\npublic:\nB()\n{\ncout<<\"default constructor\"<<endl;\n}\n~B()\n{\ncout<<\"destructed\"<<endl;\n}\nB(int i):data(i)    //B(int) works as a converter ( int -> instance of  B)\n{\ncout<<\"constructed by parameter \" << data <<endl;\n}\nprivate:\nint data;\n};\n\n\nB Play( B b) \n{\nreturn b ;\n}\n\n(1)                                            results:\nint main(int argc, char* argv[])      constructed by parameter 5\n{                                     destructed  B(5) 形参析构 \nB t1 = Play(5); B t2 = Play(t1);   　 destructed  t1 形参析构 \nreturn 0; 　　　　　　　　　　　　　　 destructed  t2 　注意顺序！ \n}                                     destructed  t1\n\n(2)                                   results:\nint main(int argc, char* argv[])      constructed by parameter 5\n{                                     destructed  B(5) 形参析构 \nB t1 = Play(5); B t2 = Play(10);   　 constructed by parameter 10\nreturn 0; 　　　　　　　　　　　　　　 destructed  B(10) 形参析构 \n}                                     destructed  t2 　注意顺序！\n\n                                      destructed  t1\n```\n\n---\n\n\n##43. 写一个函数找出一个整数数组中，第二大的数 （microsoft ）\n\n答案： \n```c++\nconst int MINNUMBER = -32767 ;\nint find_sec_max( int data[] , int count)\n{\nint maxnumber = data[0] ;\nint sec_max = MINNUMBER ;\nfor ( int i = 1 ; i < count ; i++)\n{\nif ( data[i] > maxnumber )\n{\nsec_max = maxnumber ;\nmaxnumber = data[i] ;\n}\nelse\n{\nif ( data[i] > sec_max )\nsec_max = data[i] ;\n}\n}\nreturn sec_max ;\n}\n```\n##44. 写一个在一个字符串 (n) 中寻找一个子串 (m) 第一个位置的函数。\n\nKMP 算法效率最好，时间复杂度是Ｏ (n+m), 详见： http://www.zhanglihai.com/blog/c_335_kmp.html\n\n\n---\n\n\n##46. 多重继承的内存分配问题：\n\n比如有 class A : public class B, public class C {} 那么 A 的内存结构大致是怎么样的？ \n这个是 compiler-dependent 的 , 不同的实现其细节可能不同。如果不考虑有虚函数、虚继承的话就相当简单；否则的话，相当复杂。可以参考《深入探索 C++ 对象模型》，或者： \nhttp://blog.csdn.net/rainlight/archive/2006/03/03/614792.aspx\nhttp://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dnarvc/html/jangrayhood.asp\n\n\n---\n\n\n##47. 如何判断一个单链表是有环的？（注意不能用标志位，最多只能用两个额外指针）\n```c++\nstruct node { char val; node* next;}\nbool check(const node* head) {} //return false : 无环； true: 有环一种 O （ n ）的办法就是（搞两个指针，一个每次递增一步，一个每次递增两步，如果有环的话两者必然重合，反之亦然）： \nbool check(const node* head)\n{\n    if(head==NULL)  return false;\n    node *low=head, *fast=head->next;\n    while(fast!=NULL && fast->next!=NULL)\n    {\n        low=low->next;\n        fast=fast->next->next;\n        if(low==fast) return true;\n    }\n    return false;\n}\n\n \n```\n\n---\n\n\n##48. 指针找错题\n\n分析这些面试题，本身包含很强的趣味性 ; 而作为一名研发人员，通过对这些面试题的深入剖析则可进一步增强自身的内功。 \n　　 2. 找错题 试题 1 ： \n以下是引用片段： \nvoid test1()  // 数组越界 \n　　 {\n　　 char string[10];\n　　 char* str1 = \"0123456789\";\n　　 strcpy( string, str1 );\n　　 }\n　　试题 2 ：　 \n以下是引用片段： \n　 void test2()\n　　 {\n　　 char string[10], str1[10]; \n　　 int i;\n　　 for(i=0; i<10; i++)\n　　 {\n　　 str1= 'a';\n　　 }\n　　 strcpy( string, str1 );\n　　 }\n　　试题 3 ：　　 \n以下是引用片段： \nvoid test3(char* str1)\n　　 {\n　　 char string[10];\n　　 if( strlen( str1 ) <= 10 )\n　　 {\n　　 strcpy( string, str1 );\n　　 }\n　　 }\n　　解答： \n　　试题 1 字符串 str1 需要 11 个字节才能存放下 ( 包括末尾的 ’/0’) ，而 string 只有 10 个字节的空间， strcpy会导致数组越界 ; 对试题 2 ，如果面试者指出字符数组 str1 不能在数组内结束可以给 3 分 ; 如果面试者指出strcpy(string,str1) 调用使得从 str1 内存起复制到 string 内存起所复制的字节数具有不确定性可以给 7 分，在此基础上指出库函数 strcpy 工作方式的给 10 分 ;\n对试题 3 ， if(strlen(str1) <= 10) 应改为 if(strlen(str1) <10) ，因为 strlen 的结果未统计 ’/0’ 所占用的 1 个字节。剖析：考查对基本功的掌握 \n　　 (1) 字符串以 ’/0’ 结尾 ;\n　　 (2) 对数组越界把握的敏感度 ;\n　　 (3) 库函数 strcpy 的工作方式，\n\n\n---\n\n\n##49. 如果编写一个标准 strcpy 函数\n\n总分值为 10 ，下面给出几个不同得分的答案： 2 分 以下是引用片段： \nvoid strcpy( char *strDest, char *strSrc )\n　　 {\n　　 while( (*strDest++ = * strSrc++) != ‘/0’ );\n　　 }\n　　 4 分　以下是引用片段： \n　 void strcpy( char *strDest, const char *strSrc )\n　　 // 将源字符串加 const ，表明其为输入参数，加 2 分 \n　　 {\n　　 while( (*strDest++ = * strSrc++) != ‘/0’ );\n　　 }\n　　 7 分 以下是引用片段： \nvoid strcpy(char *strDest, const char *strSrc)\n　　 {\n　　 // 对源地址和目的地址加非 0 断言，加 3 分 \n　　 assert( (strDest != NULL) &&(strSrc != NULL) );\n　　 while( (*strDest++ = * strSrc++) != ‘/0’ );\n　　 }\n　　 10 分 以下是引用片段： \n// 为了实现链式操作，将目的地址返回，加 3 分 !\n　　 char * strcpy( char *strDest, const char *strSrc )\n　　 {\n　　 assert( (strDest != NULL) &&(strSrc != NULL) ); \n　　 char *address = strDest;\n　　 while( (*strDest++ = * strSrc++) != ‘/0’ );\n　　 return address;\n　　 }\n　　从 2 分到 10 分的几个答案我们可以清楚的看到，小小的 strcpy 竟然暗藏着这么多玄机，真不是盖的 ! 需要多么扎实的基本功才能写一个完美的 strcpy 啊 !\n　　 (4) 对 strlen 的掌握，它没有包括字符串末尾的 '/0' 。 \n　　读者看了不同分值的 strcpy 版本，应该也可以写出一个 10 分的 strlen 函数了，完美的版本为： int strlen( const char *str ) // 输入参数 const 　以下是引用片段： \n　 {\n　　 assert( strt != NULL ); // 断言字符串地址非 0\n　　 int len=0; // 注，一定要初始化。 \n　　 while( (*str++) != '/0' )\n　　 {\n　　 len++;\n　　 }\n　　 return len;\n　　 }\n　　试题 4 ：以下是引用片段： \nvoid GetMemory( char *p )\n　　 {\n　　 p = (char *) malloc( 100 );\n　　 }\n　　 void Test( void )\n　　 {\n　　 char *str = NULL;\n　　 GetMemory( str );\n　　 strcpy( str, \"hello world\" );\n　　 printf( str );\n　　 } \n　　试题 5 ：　 \n以下是引用片段： \nchar *GetMemory( void )\n　　 {\n　　 char p[] = \"hello world\";\n　　 return p;\n　　 }\n　　 void Test( void )\n　　 {\n　　 char *str = NULL;\n　　 str = GetMemory();\n　　 printf( str );\n　　 }\n　　试题 6 ：以下是引用片段： \nvoid GetMemory( char **p, int num )\n　　 {\n　　 *p = (char *) malloc( num );\n　　 }\n　　 void Test( void )\n　　 {\n　　 char *str = NULL;\n　　 GetMemory( &str, 100 );\n　　 strcpy( str, \"hello\" );\n　　 printf( str );\n　　 }\n　　试题 7 ：以下是引用片段： \n　 void Test( void )\n　　 {\n　　 char *str = (char *) malloc( 100 );\n　　 strcpy( str, \"hello\" );\n　　 free( str );\n　　 ... // 省略的其它语句 \n　　 }\n　　解答：试题 4 传入中 GetMemory( char *p ) 函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的值，执行完 \n　　 char *str = NULL; \n　　 GetMemory( str );\n　　后的 str 仍然为 NULL; 试题 5 中 \n　　 char p[] = \"hello world\";\n　　 return p;\n　　的 p[] 数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。 \n　　试题 6 的 GetMemory 避免了试题 4 的问题，传入 GetMemory 的参数为字符串指针的指针，但是在GetMemory 中执行申请内存及赋值语句 tiffanybracelets\n　　 *p = (char *) malloc( num );\n　　后未判断内存是否申请成功，应加上： \n　　 if ( *p == NULL )\n　　 {\n　　 ...// 进行申请内存失败处理 \n\n　　 }\n　　试题 7 存在与试题 6 同样的问题，在执行 \n　　 char *str = (char *) malloc(100);\n　　后未进行内存是否申请成功的判断 ; 另外，在 free(str) 后未置 str 为空，导致可能变成一个 “ 野 ” 指针，应加上： \n　　 str = NULL;\n　　试题 6 的 Test 函数中也未对 malloc 的内存进行释放。 \n　　剖析： \n　　试题 4 ～ 7 考查面试者对内存操作的理解程度，基本功扎实的面试者一般都能正确的回答其中 50~60 的错误。但是要完全解答正确，却也绝非易事。\n\n软件开发网 www.mscto.com\n　　对内存操作的考查主要集中在： \n　　 (1) 指针的理解 ;\n　　 (2) 变量的生存期及作用范围 ;\n　　 (3) 良好的动态内存申请和释放习惯。 \n　　再看看下面的一段程序有什么错误：　　 \n以下是引用片段： \nswap( int* p1,int* p2 )\n　　 {\n　　 int *p;\n　　 *p = *p1;\n　　 *p1 = *p2;\n　　 *p2 = *p;\n　　 }\n　　在 swap 函数中， p 是一个 “ 野 ” 指针，有可能指向系统区，导致程序运行的崩溃。在 VC++ 中 DEBUG 运行时提示错误 “Access Violation” 。该程序应该改为 \n以下是引用片段： \nswap( int* p1,int* p2 )\n　　 {\n　　 int p;\n　　 p = *p1;\n　　 *p1 = *p2;\n　　 *p2 = p;\n　　 }\n\n\n---\n\n\n##50.String 的具体实现\n\n \n\n已知 String 类定义如下： \n\nclass String\n{\npublic:\nString(const char *str = NULL); // 通用构造函数 \nString(const String &another); // 拷贝构造函数 \n~ String(); // 析构函数 \nString & operater =(const String &rhs); // 赋值函数 \nprivate:\nchar *m_data; // 用于保存字符串 \n};\n\n尝试写出类的成员函数实现。 \n\n答案： \nString::String(const char *str)\n{\nif ( str == NULL ) //strlen 在参数为 NULL 时会抛异常才会有这步判断 \n{\nm_data = new char[1] ;\nm_data[0] = '/0' ;\n}\nelse\n{\nm_data = new char[strlen(str) + 1];\nstrcpy(m_data,str);\n}\n\n} \n\nString::String(const String &another)\n\n\n  {\nm_data = new char[strlen(another.m_data) + 1];\nstrcpy(m_data,other.m_data);\n}\n\nString& String::operator =(const String &rhs)\n{\nif ( this == &rhs)\nreturn *this ;\ndelete []m_data; // 删除原来的数据，新开一块内存 \nm_data = new char[strlen(rhs.m_data) + 1];\nstrcpy(m_data,rhs.m_data);\nreturn *this ;\n}\n\n\nString::~String()\n{\ndelete []m_data ;\n}\n\n\n---\n\n\n##51.h 头文件中的 ifndef/define/endif 的作用？\n\n答：防止该头文件被重复引用。\n\n\n---\n\n\n##52. ＃ i nclude<file.h> 与 ＃ i nclude \"file.h\" 的区别？\n\n答：前者是从 Standard Library 的路径寻找和引用 file.h ，而后者是从当前工作路径搜寻并引用 file.h 。 \n\n\n \n\n53. 在 C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C” ？\n\nC++ 语言支持函数重载， C 语言不支持函数重载。 C++ 提供了 C 连接交换指定符号 extern “C”\n\n解决名字匹配问题。\n\n\n首先，作为 extern 是 C/C++ 语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。 \n\n通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字 extern 声明。例如，如果模块B 欲引用该模块 A 中定义的全局变量和函数时只需包含模块 A 的头文件即可。这样，模块 B 中调用模块 A 中的函数时，在编译阶段，模块 B 虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块 A 编译生成的目标代码中找到此函数 \n\nextern \"C\" 是连接申明 (linkage declaration), 被 extern \"C\" 修饰的变量和函数是按照 C 语言方式编译和连接的 ,来看看 C++ 中对类似 C 的函数是怎样编译的： \n\n\n作为一种面向对象的语言， C++ 支持函数重载，而过程式语言 C 则不支持。函数被 C++ 编译后在符号库中的名字与 C 语言的不同。例如，假设某个函数的原型为： \n\nvoid foo( int x, int y );\n　　 \n\n该函数被 C 编译器编译后在符号库中的名字为 _foo ，而 C++ 编译器则会产生像 _foo_int_int 之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为 “mangled name” ）。 \n\n_foo_int_int 这样的名字包含了函数名、函数参数数量及类型信息， C++ 就是靠这种机制来实现函数重载的。例如，在 C++ 中，函数 void foo( int x, int y ) 与 void foo( int x, float y ) 编译生成的符号是不相同的，后者为_foo_int_float 。 \n\n同样地， C++ 中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以 \".\" 来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。 \n\n未加 extern \"C\" 声明时的连接方式 \n\n假设在 C++ 中，模块 A 的头文件如下： \n\n// 模块 A 头文件　 moduleA.h\n#ifndef MODULE_A_H\n#define MODULE_A_H\nint foo( int x, int y );\n#endif 　　 \n\n在模块 B 中引用该函数： \n\n// 模块 B 实现文件　 moduleB.cpp\n＃ i nclude \"moduleA.h\"\nfoo(2,3);\n\n加 extern \"C\" 声明后的编译和连接方式 \n\n加 extern \"C\" 声明后，模块 A 的头文件变为： \n\n// 模块 A 头文件　 moduleA.h\n#ifndef MODULE_A_H\n#define MODULE_A_H\nextern \"C\" int foo( int x, int y );\n#endif 　　 \n\n在模块 B 的实现文件中仍然调用 foo( 2,3 ) ，其结果是： \n（ 1 ）模块 A 编译生成 foo 的目标代码时，没有对其名字进行特殊处理，采用了 C 语言的方式； \n\n（ 2 ）连接器在为模块 B 的目标代码寻找 foo(2,3) 调用时，寻找的是未经修改的符号名 _foo 。 \n\n如果在模块 A 中函数声明了 foo 为 extern \"C\" 类型，而模块 B 中包含的是 extern int foo( int x, int y ) ，则模块 B找不到模块 A 中的函数；反之亦然。 \n\n所以，可以用一句话概括 extern “C” 这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）：实现 C++ 与 C 及其它语言的混合编程。　　 \n\n明白了 C++ 中 extern \"C\" 的设立动机，我们下面来具体分析 extern \"C\" 通常的使用技巧： \n\nextern \"C\" 的惯用法 \n\n（ 1 ）在 C++ 中引用 C 语言中的函数和变量，在包含 C 语言头文件（假设为 cExample.h ）时，需进行下列处理： \n\n\nextern \"C\"\n{\n＃ i nclude \"cExample.h\"\n}\n\n而在 C 语言的头文件中，对其外部函数只能指定为 extern 类型， C 语言中不支持 extern \"C\" 声明，在 .c 文件中包含了 extern \"C\" 时会出现编译语法错误。 \n\nC++ 引用 C 函数例子工程中包含的三个文件的源代码如下： \n\n/* c 语言头文件： cExample.h */\n#ifndef C_EXAMPLE_H\n#define C_EXAMPLE_H\nextern int add(int x,int y);\n#endif\n\n\n/* c 语言实现文件： cExample.c */\n＃ i nclude \"cExample.h\"\nint add( int x, int y )\n{\nreturn x + y;\n}\n\n\n// c++ 实现文件，调用 add ： cppFile.cpp\nextern \"C\"\n{\n＃ i nclude \"cExample.h\"\n}\nint main(int argc, char* argv[])\n{\nadd(2,3);\nreturn 0;\n}\n\n如果 C++ 调用一个 C 语言编写的 .DLL 时，当包括 .DLL 的头文件或声明接口函数时，应加 extern \"C\" { 　 } 。 \n\n（ 2 ）在 C 中引用 C++ 语言中的函数和变量时， C++ 的头文件需添加 extern \"C\" ，但是在 C 语言中不能直接引用声明了 extern \"C\" 的该头文件，应该仅将 C 文件中将 C++ 中定义的 extern \"C\" 函数声明为 extern 类型。 \n\nC 引用 C++ 函数例子工程中包含的三个文件的源代码如下： \n\n//C++ 头文件 cppExample.h\n#ifndef CPP_EXAMPLE_H\n#define CPP_EXAMPLE_H\nextern \"C\" int add( int x, int y );\n#endif\n\n\n//C++ 实现文件 cppExample.cpp\n＃ i nclude \"cppExample.h\"\nint add( int x, int y )\n{\nreturn x + y;\n}\n\n\n/* C 实现文件 cFile.c\n/* 这样会编译出错：＃ i nclude \"cExample.h\" */\n\nint main( int argc, char* argv[] )\n{\nadd( 2, 3 );\nreturn 0;\n}\n\n15 题目的解答请参考《 C++ 中 extern “C” 含义深层探索》注解：\n\n几道 c 笔试题 ( 含参考答案 )\n\n1. \nWhat is displayed when f() is called given the code:\nclass Number {\npublic:\nstring type; \n\nNumber(): type( “ void ” ) { }\nexplicit Number(short) : type( “ short ” ) { } \nNumber(int) : type( “ int ” ) { }\n};\nvoid Show(const Number& n) { cout << n.type; }\nvoid f()\n{\nshort s = 42;\nShow(s); \n}\na) void\nb) short\nc) int\nd) None of the above\n\n2. Which is the correct output for the following code\ndouble dArray[2] = {4, 8}, *p, *q;\np = &dArray[0];\nq = p + 1;\ncout << q – p << endl; \ncout << (int)q - (int)p << endl;\na) 1 and 8\nb) 8 and 4\nc) 4 and 8\nd) 8 and 1\n\n\n第一个选 C ； \n虽然传入的是 short 类型，但是 short 类型的构造函数被生命被 explicit ，也就是只能显示类型转换，不能使用隐式类型转换。 \n第二个选 A ； \n第一个是指针加减，按照的是指向地址类型的加减，只跟类型位置有关， q 和 p 指向的数据类型以实际数据类型来算差一个位置，因此是 1 。而第二个加减是实际指针值得加减，在内存中一个 double 类型占据 8 个字节，因此是 8\n\n \n\n54.Sony 笔试题\n\n\n　　 1 ．完成下列程序 \n　　 * \n　　 *.*. \n　　 *..*..*.. \n　　 *...*...*...*... \n　　 *....*....*....*....*.... \n　　 *.....*.....*.....*.....*.....*..... \n　　 *......*......*......*......*......*......*...... \n　　 *.......*.......*.......*.......*.......*.......*.......*....... \n　　 #include \n　　 #define N 8 \n　　 int main() \n　　 { \n　　 int i; \n　　 int j; \n　　 int k; \n　　 --------------------------------------------------------- \n　　 | | \n　　 | | \n　　 | | \n　　 --------------------------------------------------------- \n　　 return 0; \n　　 } \n　　 2 ．完成程序，实现对数组的降序排序 \n　　 #include \n　　 void sort( ); \n　　 int main() \n　　 { \n　　 int array[]={45 ， 56 ， 76 ， 234 ， 1 ， 34 ， 23 ， 2 ， 3} ； // 数字任 // 意给出 \n　　 sort( ); \n　　 return 0; \n　　 } \n　　 void sort( ) \n　　 { \n　　 ____________________________________ \n　　 | | \n　　 | | \n　　 |-----------------------------------------------------| \n　　 } \n　　 3 ．费波那其数列， 1 ， 1 ， 2 ， 3 ， 5 ……编写程序求第十项。可以用递归，也可以用其 \n他方法，但要说明你选择的理由。 \n　　 #include \n　　 int Pheponatch(int); \n　　 int main() \n　　 { \n　　 printf(\"The 10th is %d\",Pheponatch(10)); \n　　 return 0; \n　　 } \n　　 int Pheponatch(int N) \n　　 { \n　　 -------------------------------- \n　　 | | \n　　 | | \n　　 -------------------------------- \n　　 } \n　　 4 ．下列程序运行时会崩溃，请找出错误并改正，并且说明原因。 \n　　 #include \n　　 #include \n　　 typedef struct{ \n　　 TNode* left; \n　　 TNode* right; \n　　 int value; \n　　 } TNode; \n　　 TNode* root=NULL; \n　　 void append(int N); \n　　 int main() \n　　 { \n　　 append(63); \n　　 append(45); \n　　 append(32); \n　　 append(77); \n　　 append(96); \n　　 append(21); \n　　 append(17); // Again, 数字任意给出 \n　　 } \n　　 void append(int N) \n　　 { \n　　 TNode* NewNode=(TNode *)malloc(sizeof(TNode)); \n　　 NewNode->value=N; \n\n\n　　 if(root==NULL) \n　　 { \n　　 root=NewNode; \n　　 return; \n　　 } \n　　 else \n　　 { \n　　 TNode* temp; \n　　 temp=root; \n\n　　 while((N>=temp.value && temp.left!=NULL) || (N !=NULL \n　　 )) \n　　 { \n　　 while(N>=temp.value && temp.left!=NULL) \n　　 temp=temp.left; \n　　 while(N 　　 temp=temp.right; \n　　 } \n　　 if(N>=temp.value) \n　　 temp.left=NewNode; \n　　 else \n　　 temp.right=NewNode; \n　　 return; \n　　 } \n　　 } \n\n※ 来源 : ·哈工大紫丁香 http://bbs.hit.edu.cn · [FROM:219.217.233.47] \n\n\n──────────────────────────────────────── \nmengfd (Icebreaker) 于 (Sun Oct 23 14:59:59 2005) 说道 :\n\n55 请你分别画出 OSI 的七层网络结构图和 TCP/IP 的五层结构图。\n\n应用层：为应用程序提供服务\n\n表示层：处理在两个通信系统中交换信息的表示方式\n\n会话层：负责维护两个结点间会话连接的建立、管理和终止，以及数据交换\n\n传输层：向用户提供可靠的端到端服务。 UDP TCP 协议。\n\n网络层：通过路由选择算法为分组通过通信子网选择最适当的路径，以及实现拥塞控制、网络互联等功能。数据传输单元是分组。 IP 地址，路由器， IP 协议。\n\n数据链路层：在物理层提供的服务基础上，数据链路层在通信的实体间建立数据链路连接，传输一帧为单位的数据包（，并采用差错控制与流量控制方法，使有差错的物理线路变成无差错的数据链路。）\n\n物理层：传输比特流。传输单元是比特。调制解调器。\n\n \n\n\n\n\n\n \n\nTCP/IP详解学习笔记(1)-基本概念\n\n \n\n56 请你详细地解释一下 IP 协议的定义，在哪个层上面？主要有什么作用？ TCP 与 UDP 呢 ？\n\n网络层。\n\n57. 请问交换机和路由器各自的实现原理是什么？分别在哪个层次上面实现的？\n\n交换机：数据链路层。路由器：网络层。\n\n58. 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的 ？\n\n \n\n59.8086 是多少位的系统？在数据总线上是怎么实现的？ \n\n\n\n8086 微处理器共有 4 个 16 位的段寄存器，在寻址内存单元时，用它们直接或间接地存放段地址。\n\n　　代码段寄存器 CS ：存放当前执行的程序的段地址。\n\n　　数据段寄存器 DS ：存放当前执行的程序所用操作数的段地址。\n\n　　堆栈段寄存器 SS ：存放当前执行的程序所用堆栈的段地址。\n\n　　附加段寄存器 ES ：存放当前执行程序中一个辅助数据段的段地址。\n\n由 cs:ip 构成指令地址， ss:sp 构成堆栈的栈顶地址指针。 DS 和 ES 用作数据段和附加段的段地址（段起始地址或段值）\n\n \n\n8086 ／ 8088 微处理器的存储器管理\n\n   1. 地址线（码）与寻址范围： N 条地址线      寻址范围 =2N\n\n   2.8086 有 20 地址线      寻址范围为 1MB  由 00000H ～ FFFFFH\n\n   3. 8086 微处理器是一个 16 位结构，用户可用的寄存器均为 16 位：寻址 64KB\n\n   4. 8086 ／ 8088 采用分段的方法对存储器进行管理。具体做法是：把 1MB 的存储器空间分成若干段，每段容量为 64KB ，每段存储器的起始地址必须是一个能被 16 整除的地址码，即在 20 位的二进制地址码中最低 4 位必须是 “0” 。每个段首地址的高 16 位二进制代码就是该段的段号 ( 称段基地址 ) 或简称段地址，段号保存在段寄存器中。我们可对段寄存器设置不同的值来使微处理器的存储器访问指向不同的段。\n\n   5. 段内的某个存储单元相对于该段段首地址的差值，称为段内偏移地址 ( 也叫偏移量 ) 用 16 位二进制代码表示。\n\n   6. 物理地址是由 8086 ／ 8088 芯片地址引线送出的 20 位地址码，它用来参加存储器的地址译码，最终读／写所访问的一个特定的存储单元。\n\n   7. 逻辑地址由某段的段地址和段内偏移地址 ( 也叫偏移量 ) 两部分所组成。写成：\n\n     段地址：偏移地址 ( 例如， 1234H ： 0088H) 。\n\n   8. 在硬件上起作用的是物理地址，物理地址＝段基地址 ×10H 十偏移地址\n\n\n\n联想笔试题 \n　　 1 ．设计函数 int atoi(char *s) 。 \n　　 2 ． int i=(j=4,k=8,l=16,m=32); printf( “ %d ” , i); 输出是多少？ \n\n\n60. 解释局部变量、全局变量和静态变量的含义。\n\n\n　　 4 ．解释堆和栈的区别。\n\n61. 论述含参数的宏与函数的优缺点。 \n\n\n普天 C++ 笔试题 \n　　 1 ．实现双向链表删除一个节点 P ，在节点 P 后插入一个节点，写出这两个函数。 \n　　 2 ．写一个函数，将其中的 /t 都转换成 4 个空格。\n\n \n\n61.Windows 程序的入口是哪里？写出 Windows 消息机制的流程。 \n\n\n4 ．如何定义和实现一个类的成员函数为回调函数？\n\n \n\n62.C++ 里面是不是所有的动作都是 main() 引起的？如果不是，请举例。 \n　　\n\n6 ． C++ 里面如何声明 const void f(void) 函数为 C 程序中的库函数？ \n　　 7 ．下列哪两个是等同的 \n　　 int b; \n　　 A const int* a = &b; \n　　 B const* int a = &b; \n　　 C const int* const a = &b; \n　　 D int const* const a = &b; \n　　 8 ．内联函数在编译时是否做参数类型检查？ \n　　 void g(base & b){ \n　　 b.play; \n　　 } \n　　 void main(){ \n　　 son s; \n　　 g(s); \n　　 return; \n　　 } \n\n\n\n\n※ 来源 : ·哈工大紫丁香 http://bbs.hit.edu.cn · [FROM:219.217.233.47] \n\n\n──────────────────────────────────────── \nmengfd (Icebreaker) 于 (Sun Oct 23 15:00:14 2005) 说道 : \n\n大唐电信 \n　　 DTT 笔试题 \n　　考试时间一小时，第一部分是填空和选择： \n　　 1 ．数列 6 ， 10 ， 18 ， 32 ，“？”，问“？”是几？ \n　　 2 ．某人出 70 买进一个 x ， 80 卖出， 90 买回， 100 卖出，这桩买卖怎么样？ \n　　 3 ．月球绕地球一圈，至少要多少时间？ \n　　 4 ． 7 个人用 7 小时挖了 7 米 的沟，以同样的速度在 50 小时挖 50 米 的沟要多少人？ \n　　 5 ．鱼头长 9 ，鱼尾等于鱼头加半个鱼身，鱼身等于鱼头加鱼尾，问鱼全长多少？ \n　　 6 ．一个小姐买了一块手表，回家发现手表比她家的表慢了两分钟，晚上看新闻的时候 \n又发现她家的表比新闻里的时间慢了两分钟，则 。 \n　　 A 手表和新闻里的时间一样 \n　　 B 手表比新闻里的时间慢 \n　　 C 手表比新闻里的时间快 \n　　 7 ．王先生看到一则招聘启事，发现两个公司除了以下条件不同外，其他条件都相同 \n\n　　 A 半年年薪 50 万，每半年涨 5 万 \n　　 B 一年年薪 100 万，每一年涨 20 万 \n　　王先生想去一家待遇比较优厚的公司，他会去哪家？ \n　　 10 ．问哪个袋子里有金子？ \n　　 A 袋子上的标签是这样写的： B 袋子上的话是对的，金子在 A 袋子。 \n　　 B 袋子上的标签是这样写的： A 袋子上的话是错的，金子在 A 袋子里。 \n　　 11 ． 3 个人住酒店 30 块钱，经理找回 5 块钱，服务生从中藏了 2 块钱，找给每人 1 块钱， \n3 ×（ 101 ） +2=29 ，问这是怎么回事？ \n　　 12 ．三篇写作，均为书信形式。 \n　　（ 1 ）一片中文的祝贺信，祝贺某男当了某公司 xx \n　　（ 2 ）两篇英文的，一是说有事不能应邀，派别人去；另一篇是讨债的， 7 天不给钱就 \n走人（主要考 business letter 格式）。 \n　　大唐面试试题 \n　　 1 ．什么是中断？中断发生时 CPU 做什么工作？ \n　　 2 ． CPU 在上电后，进入操作系统的 main() 之前必须做什么工作？ \n　　 3 ．简述 ISO OSI 的物理层 Layer1 ，链路层 Layer2 ，网络层 Layer3 的任务。 \n　　 4 ．有线电话和无线电话有何区别？无线电话特别需要注意的是什么？ \n　　\n\n63. 软件开发五个主要 step 是什么？\n\n\n　　 6 ．你在开发软件的时候，这 5 个 step 分别占用的时间百分比是多少？ \n　　 7 ． makefile 文件的作用是什么？ \n　　 8 ． UNIX 显示文件夹中，文件名的命令是什么？能使文件内容显示在屏幕的命令是什么 \n？ \n　　 9 ．（选做）手机用户在从一个基站漫游到另一个基站的过程中，都会发生什么 ? \n\n※ 来源 : ·哈工大紫丁香 http://bbs.hit.edu.cn · [FROM:219.217.233.47] \n\n\n──────────────────────────────────────── \nmengfd (Icebreaker) 于 (Sun Oct 23 15:01:22 2005) 说道 : \n\n网通笔试题 \n　　选择题（每题 5 分，只有一个正确答案） \n　　 1 ．中国 1 号信令协议属于 的协议。 \n　　 A ccs B cas C ip D atm \n　　 2 ． isdnpri 协议全称是 。 \n　　 A 综合业务模拟网基速协议 \n　　 B 综合业务模拟网模拟协议 \n　　 C 综合业务数字网基率协议 \n　　 D 综合业务数字网基次协议 \n　　 3 ．路由协议中， 协议是用距离作为向量的。 \n　　 A ospf B bgp C is-is D rip \n　　 4 ．中国智能网中， ssp 与 scp 间最上层的 ss7 协议是 。 \n　　 A incs B is41b C is41c D inap \n　　 5 ． dtmf 全称是 。 \n　　 A 双音多频 B 多音双频 C 多音三频 D 三音多频 \n　　 6 ．计算机的基本组成部分中，不包含下面设备的是 。 \n　　 A cpu B 输入设备 C 存储器 D 接口 \n　　 7 ．脉冲编码调制的简称是 。 \n　　 A pcm B pam C (delta)M D atm \n　　 8 ．普通电话线接口专业称呼是 。 \n　　 A rj11 B rj45 C rs232 D bnc \n　　 9 ．现有的公共数据网都采用 。 \n　　 A 电路交换技术 B 报文交换技术 \n　　 C 语音插空 D 分组交换 \n　　 10 ． ss7 协议中的制止市忙消息简写为 。 \n　　 A stb B slb C sub D spb \n　　简答题（每题 10 分） \n　　 1 ．简述普通电话与 IP 电话的区别。 \n　　 2 ．简述随路信令与公路信令的根本区别。 \n　　 3 ．说明掩码的主要作用。 \n　　 4 ． ss7 协议中，有三大要素决定其具体定位，哪三大要素？ \n　　 5 ．描述 ss7 的基本通话过程。 \n　　 6 ．简述通信网的组成结构。 \n　　 7 ．面向连接与面向非连接各有何利弊？ \n　　 8 ．写出爱尔兰的基本计算公式。 \n　　 9 ．数据网主要有哪些设备？ \n　　 10 ．中国一号协议是如何在被叫号码中插入主叫号码的？ \n\n\n东信笔试题目 \n　　笔试： 30 分钟。 \n　　 1 ．压控振荡器的英文缩写。 \n　　 2 ．动态随机存储器的英文缩写。 \n　　 3 ．选择电阻时要考虑什么？ \n　　 4 ．单片机上电后没有运转，首先要检查什么？ \n　　 5 ．计算机的基本组成部分及其各自的作用。 \n　　 6 ．怎样用 D 触发器、与或非门组成二分频电路？\n\n \n\n64.static 有什么用途？（请至少说明两种）\n\n答 、 1. 限制变量的作用域 ( 文件级的 ) 。\n\n  2. 设置变量的存储域 ( 全局数据区 ) 。\n\n \n\n \n\n65. 引用与指针有什么区别？\n\n答 、 1) 引用必须被初始化，指针不必。\n\n2) 引用初始化以后不能被改变，指针可以改变所指的对象。\n\n3) 不存在指向空值的引用，但是存在指向空值的指针。\n\n66. 描述实时系统的基本特性\n\n答 、在特定时间内完成特定的任务，实时性与可靠性。\n\n \n\n \n\n67. 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？\n\n答 、全局变量储存在静态数据区，局部变量在堆栈中。\n\n \n\n \n\n68. 什么是平衡二叉树？\n\n答 、左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于 1 。\n\n \n\n \n\n69. 堆栈溢出一般是由什么原因导致的？\n\n答 、 1. 没有回收垃圾资源\n\n         2. 层次太深的递归调用      \n\n \n\n \n\n70. 什么函数不能声明为虚函数？\n\n答 、 constructor\n\n       Deconstructor 可以声明为虚函数。\n\n       系统为一个空类创建的成员函数有那些。\n\n \n\n71. 冒泡排序算法的时间复杂度是什么？\n\n答 、 O(n^2)\n\n \n\n \n\n72. 写出 float x 与“零值”比较的 if 语句。\n\n答 、 if(x>0.000001&&x<-0.000001)\n\n \n\n \n\n73.Internet 采用哪种网络协议？该协议的主要层次结构？\n\n \n\n答 、 tcp/ip 应用层 / 传输层 / 网络层 / 数据链路层 / 物理层\n\n \n\n \n\n74.Internet 物理地址和 IP 地址转换采用什么协议？\n\n答 、 ARP (Address Resolution Protocol) （地址解析协议）\n\n \n\n \n\n75.IP 地址的编码分为哪俩部分？\n\n答 、 IP 地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与之后才能区分哪些是网络位哪些是主机位。\n\n \n\n76. 用户输入 M,N 值，从 1 至 N 开始顺序循环数数，每数到 M 输出该数值，直至全部输出。写出 C 程序。\n\n答 、循环链表，用取余操作做\n\n \n\n \n\n77. 不能做 switch() 的参数类型是：\n\n答 、 switch 的参数不能为实型。\n\n华为\n\n78. 局部变量能否和全局变量重名？\n\n答、能，局部会屏蔽全局。要用全局变量，需要使用 \"::\"\n\n局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内\n\n \n\n \n\n79. 如何引用一个已经定义过的全局变量？\n\n答 、可以用引用头文件的方式，也可以用 extern 关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用 extern 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错\n\n \n\n \n\n80. 全局变量可不可以定义在可被多个 .C 文件包含的头文件中？为什么？\n\n答 、可以，在不同的 C 文件中以 static 形式来声明同名全局变量。\n\n可以在不同的 C 文件中声明同名的全局变量，前提是其中只能有一个 C 文件中对此变量赋初值，此时连接不会出错\n\n \n\n \n\n81. 语句 for( ； 1 ； ) 有什么问题？它是什么意思？\n\n答 、和 while(1) 相同。\n\n \n\n \n\n82.do …… while 和 while …… do 有什么区别？\n\n答 、前一个循环一遍再判断，后一个判断以后再循环\n\n \n\n \n\n83. 请写出下列代码的输出内容\n\n#i nclude\n\nmain()\n\n{\n\nint a,b,c,d;\n\na=10;\n\nb=a++;\n\nc=++a;\n\nd=10*a++;\n\nprintf(\"b ， c ， d ： %d ， %d ， %d\" ， b ， c ， d ） ;\n\nreturn 0;\n\n}\n\n答 、 10 ， 12 ， 120\n\n84.statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数\n\nstatic 全局变量与普通的全局变量有什么区别？ static 局部变量和普通局部变量有什么区别？ static 函数与普通函数有什么区别？\n\n答 、全局变量 ( 外部变量 ) 的说明之前再冠以 static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。\n\n从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。\n\nstatic 函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数 (static) ，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件\n\nstatic 全局变量与普通的全局变量有什么区别： static 全局变量只初使化一次，防止在其他文件单元中被引用 ;\n\nstatic 局部变量和普通局部变量有什么区别： static 局部变量只被初始化一次，下一次依据上一次结果值；\n\nstatic 函数与普通函数有什么区别： static 函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝\n\n程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。\n\n85. 设有以下说明和定义：\n\ntypedef union {long i; int k[5]; char c;} DATE;\n\nstruct data { int cat; DATE cow; double dog;} too;\n\nDATE max;\n\n则语句 printf(\"%d\",sizeof(struct date)+sizeof(max)); 的执行结果是？\n\n答 、结果是： ___52____ 。 DATE 是一个 union, 变量公用空间 . 里面最大的变量类型是 int[5], 占用 20 个字节. 所以它的大小是 20\n\ndata 是一个 struct, 每个变量分开占用空间 . 依次为 int4 + DATE20 + double8 = 32.\n\n所以结果是 20 + 32 = 52.\n\n当然 ... 在某些 16 位编辑器下 , int 可能是 2 字节 , 那么结果是 int2 + DATE10 + double8 = 20\n\n86.-1,2,7,28,,126 请问 28 和 126 中间那个数是什么？为什么？\n\n答 、应该是 4^3-1=63\n\n规律是 n^3-1( 当 n 为偶数 0 ， 2 ， 4)\n\nn^3+1( 当 n 为奇数 1 ， 3 ， 5)\n\n \n\n87. 用两个栈实现一个队列的功能？要求给出算法和思路！\n\n答 、设 2 个栈为 A,B, 一开始均为空 .\n\n入队 :\n\n将新元素 push 入栈 A;\n\n出队 :\n\n(1) 判断栈 B 是否为空；\n\n(2) 如果不为空，则将栈 A 中所有元素依次 pop 出并 push 到栈 B ；\n\n(3) 将栈 B 的栈顶元素 pop 出；\n\n这样实现的队列入队和出队的平摊复杂度都还是 O(1), 比上面的几种方法要好。\n\n \n\n88. 在 c 语言库函数中将一个字符转换成整型的函数是atool() 吗，这个函数的原型是什么？\n\n答 、函数名 : atol\n\n功 能 : 把字符串转换成长整型数\n\n用 法 : long atol(const char *nptr);\n\n程序例 :\n\n＃ include\n\n＃ include\n\nint main(void)\n\n{\n\n    long l;\n\n    char *str = \"98765432\";\n\n    l = atol(lstr);\n\n    printf(\"string = %s integer = %ld/n\", str, l);\n\n    return(0);\n\n}\n\n \n\n \n\n89. 对于一个频繁使用的短小函数 , 在 C 语言中应用什么实现 , 在 C++ 中应用什么实现 ?\n\n答 、 c 用宏定义， c++ 用 inline\n\n \n\n90. 用预处理指令 #define 声明一个常数，用以表明 1年中有多少秒（忽略闰年问题）\n\n \n\n#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL\n\n我在这想看到几件事情：\n\n1). #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）\n\n2). 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。\n\n3). 意识到这个表达式将使一个 16 位机的整型数溢出 - 因此要用到长整型符号 L, 告诉编译器这个常数是的长整型数。\n\n4). 如果你在你的表达式中用到 UL （表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。\n\n \n\n91. 写一个“标准”宏 MIN ，这个宏输入两个参数并返回较小的一个。\n\n \n\n#define MIN(A,B) ((A) <= (B) (A) : (B))\n\n这个测试是为下面的目的而设的：\n\n1). 标识 #define 在宏中应用的基本知识。这是很重要的，因为直到嵌入 (inline) 操作符变为标准 C 的一部分，宏是方便产生嵌入代码的唯一方法，\n\n对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。\n\n2). 三重条件操作符的知识。这个操作符存在 C 语言中的原因是它使得编译器能产生比 if-then-else 更优化的代码，了解这个用法是很重要的。\n\n3). 懂得在宏中小心地把参数用括号括起来\n\n4). 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？\n\nleast = MIN(*p++, b);\n\n \n\n92. 预处理器标识 #error 的目的是什么？\n\n \n\n如果你不知道答案，请看参考文献 1 。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读 C 语言课本的附录去找出象这种\n\n问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。\n\n \n\n死循环（ Infinite loops ）\n\n \n\n93. 嵌入式系统中经常要用到无限循环，你怎么样用 C编写死循环呢？\n\n \n\n这个问题用几个解决方案。我首选的方案是：\n\nwhile(1)\n\n{\n\n}\n\n一些程序员更喜欢如下方案：\n\nfor(;;)\n\n{\n\n}\n\n这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的\n\n基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。\n\n第三个方案是用 goto\n\nLoop :\n\n...\n\ngoto Loop;\n\n应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN 程序员。\n\n \n\n数据声明（ Data declarations ）\n\n \n\n94. 用变量 a 给出下面的定义\n\na) 一个整型数（ An integer ）\n\nb) 一个指向整型数的指针（ A pointer to an integer ）\n\nc) 一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an integer ）\n\nd) 一个有 10 个整型数的数组（ An array of 10 integers ）\n\ne) 一个有 10 个指针的数组，该指针是指向一个整型数的（ An array of 10 pointers to integers ）\n\nf) 一个指向有 10 个整型数数组的指针（ A pointer to an array of 10 integers ）\n\ng) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（ A pointer to a function that takes an integer as an argument and returns an integer ）\n\nh) 一个有 10 个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer\n\nargument and return an integer ）\n\n \n\n答案是：\n\na) int a; // An integer\n\nb) int *a; // A pointer to an integer\n\nc) int **a; // A pointer to a pointer to an integer\n\nd) int a[10]; // An array of 10 integers\n\ne) int *a[10]; // An array of 10 pointers to integers\n\nf) int (*a)[10]; // A pointer to an array of 10 integers\n\ng) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer\n\nh) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer\n\n \n\n人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。\n\n但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道\n\n所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？\n\n \n\nStatic\n\n \n\n95. 关键字 static 的作用是什么？\n\n \n\n这个简单的问题很少有人能回答完全。在 C 语言中，关键字 static 有三个明显的作用：\n\n1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。\n\n2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。\n\n3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。\n\n大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数\n\n据和代码范围的好处和重要性。\n\n \n\nConst\n\n \n\n96. 关键字 const 是什么含意？\n\n我只要一听到被面试者说：“ const 意味着常数”，我就知道我正在和一个业余者打交道。去年 Dan Saks 已经在他的文章里完全概括了 const 的所有用法，因此 ESP( 译者： Embedded Systems Programming) 的每一位读者应该非常熟悉 const 能做什么和不能做什么 . 如果你从没有读到那篇文章，只要能说出 const 意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下 Saks 的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？\n\n \n\nconst int a;\n\nint const a;\n\nconst int *a;\n\nint * const a;\n\nint const * a const;\n\n \n\n前两个的作用是一样， a 是一个常整型数。第三个意味着 a 是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思 a 是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着 a 是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const ，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字 const 呢？我也如下的几下理由：\n\n1). 关键字 const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用 const 的程序员很少会留下的垃圾让别人来清理的。）\n\n2). 通过给优化器一些附加的信息，使用关键字 const 也许能产生更紧凑的代码。\n\n3). 合理地使用关键字 const 可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少 bug 的出现。\n\n \n\nVolatile\n\n \n\n97. 关键字 volatile 有什么含意 并给出三个不同的例子。\n\n \n\n一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是 volatile 变量的几个例子：\n\n1). 并行设备的硬件寄存器（如：状态寄存器）\n\n2). 一个中断服务子程序中会访问到的非自动变量 (Non-automatic variables)\n\n3). 多线程应用中被几个任务共享的变量\n\n回答不出这个问题的人是不会被雇佣的。我认为这是区分 C 程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、 RTOS 等等打交道，所用这些都要求 volatile 变量。不懂得 volatile 内容将会带来灾难。\n\n假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得 volatile 完全的重要性。\n\n1). 一个参数既可以是 const 还可以是 volatile 吗？解释为什么。\n\n2). 一个指针可以是 volatile 吗？解释为什么。\n\n3). 下面的函数有什么错误：\n\nint square(volatile int *ptr)\n\n{\n\nreturn *ptr * *ptr;\n\n}\n\n下面是答案：\n\n1). 是的。一个例子是只读的状态寄存器。它是 volatile 因为它可能被意想不到地改变。它是 const 因为程序不应该试图去修改它。\n\n2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个 buffer 的指针时。\n\n3). 这段代码的有个恶作剧。这段代码的目的是用来返指针 *ptr 指向值的平方，但是，由于 *ptr 指向一个 volatile型参数，编译器将产生类似下面的代码：\n\nint square(volatile int *ptr)\n\n{\n\nint a,b;\n\na = *ptr;\n\nb = *ptr;\n\nreturn a * b;\n\n}\n\n由于 *ptr 的值可能被意想不到地该变，因此 a 和 b 可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：\n\nlong square(volatile int *ptr)\n\n{\n\nint a;\n\na = *ptr;\n\nreturn a * a;\n\n}\n\n \n\n位操作（ Bit manipulation ）\n\n \n\n \n\n98. 下面的代码输出是什么，为什么？\n\n \n\nvoid foo(void)\n\n{\n\nunsigned int a = 6;\n\nint b = -20;\n\n(a+b > 6) puts(\"> 6\") : puts(\"<= 6\");\n\n}\n\n \n\n \n\n这个问题测试你是否懂得 C 语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是“ >6 ”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此 -20 变成了一个非常大的正整数，所以该表达式计算出的结果大于 6 。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。\n\n \n\n \n\n99.C 语言同意一些令人震惊的结构 , 下面的结构是合法的吗，如果是它做些什么？\n\nint a = 5, b = 7, c;\n\nc = a+++b;\n\n \n\n这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：\n\nc = a++ + b;\n\n因此 , 这段代码持行后 a = 6, b = 7, c = 12 。\n\n如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是 : 这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题\n\n \n\n \n\n \n\n \n\n今天早上的面试题 9 道，比较难，\n\n100. 线形表 a 、 b 为两个有序升序的线形表，编写一程序，使两个有序线形表合并成一个有序升序线形表 h；\n\n \n\n \n\n答案在 请化大学 严锐敏《数据结构第二版》第二章例题，数据结构当中，这个叫做：两路归并排序\n\nLinklist *unio(Linklist *p,Linklist *q){\n\nlinklist *R,*pa,*qa,*ra;\n\npa=p;\n\nqa=q;\n\nR=ra=p;\n\nwhile(pa->next!=NULL&&qa->next!=NULL){\n\nif(pa->data>qa->data){\n\nra->next=qa;\n\nqa=qa->next;\n\n}\n\nelse{\n\nra->next=pa;\n\npa=pa->next;\n\n}\n\n}\n\nif(pa->next!=NULL)\n\nra->next=pa;\n\nif(qa->next!=NULL)\n\nra->next==qa;\n\nreturn R;\n\n}\n\n101. 用递归算法判断数组 a[N] 是否为一个递增数组。\n\n递归的方法，记录当前最大的，并且判断当前的是否比这个还大，大则继续，否则返回 false 结束：\n\nbool fun( int a[], int n )\n\n{\n\nif( n= =1 )\n\nreturn true;\n\nif( n= =2 )\n\nreturn a[n-1] >= a[n-2];\n\nreturn fun( a,n-1) && ( a[n-1] >= a[n-2] );\n\n}\n\n102. 编写算法，从 10 亿个浮点数当中，选出其中最大的 10000 个。\n\n用外部排序，在《数据结构》书上有《计算方法导论》在找到第 n 大的数的算法上加工\n\n103. 编写一 unix 程序，防止僵尸进程的出现 .\n\n同学的 4 道面试题，应聘的职位是搜索引擎工程师，后两道超级难，（希望大家多给一些算发）\n\n1. 给两个数组和他们的大小，还有一动态开辟的内存，求交集，把交集放到动态内存 dongtai ，并且返回交集个数\n\nlong jiaoji(long* a[],long b[],long* alength,long blength,long* dongtai[])\n\n2. 单连表的建立，把 'a'--'z'26 个字母插入到连表中，并且倒叙，还要打印！\n\n方法 1 ：\n\ntypedef struct val\n\n{   int date_1;\n\n    struct val *next;\n\n}*p;\n\n \n\nvoid main(void)\n\n{   char c;\n\n    \n\n    for(c=122;c>=97;c--)\n\n       { p.date=c;\n\n          p=p->next;\n\n        }\n\n \n\n    p.next=NULL;\n\n}\n\n}\n\n方法 2 ：\n\nnode *p = NULL;\n\nnode *q = NULL;\n\n \n\nnode *head = (node*)malloc(sizeof(node));\n\nhead->data = ' ';head->next=NULL;\n\n \n\nnode *first = (node*)malloc(sizeof(node));\n\nfirst->data = 'a';first->next=NULL;head->next = first;\n\np = first;\n\n \n\nint longth = 'z' - 'b';\n\nint i=0;\n\nwhile ( i<=longth )\n\n{\n\nnode *temp = (node*)malloc(sizeof(node));\n\ntemp->data = 'b'+i;temp->next=NULL;q=temp;\n\n \n\nhead->next = temp; temp->next=p;p=q;\n\ni++;\n\n}\n\n \n\nprint(head);\n\n \n\n104. 可怕的题目终于来了\n\n象搜索的输入信息是一个字符串，统计 300 万输入信息中的最热门的前十条，我们每次输入的一个字符串为不超过 255byte, 内存使用只有 1G ,\n\n请描述思想，写出算发（ c 语言），空间和时间复杂度，\n\n7. 国内的一些帖吧，如 baidu, 有几十万个主题，假设每一个主题都有上亿的跟帖子，怎么样设计这个系统速度最好，请描述思想，写出算发（ c 语言），空间和时间复杂度，\n\n \n\n \n\n#include   string.h\n\nmain(void)\n\n{   char   *src=\"hello,world\";\n\n    char   *dest=NULL;\n\n    dest=(char    *)malloc(strlen(src));\n\n    int   len=strlen(str);\n\n    char   *d=dest;\n\n    char   *s=src[len];\n\n    while(len--!=0)\n\n      d++=s--;\n\n    printf(\"%s\",dest);\n\n}\n\n找出错误！！\n\n#include   \"string.h\"\n\n#include \"stdio.h\"\n\n#include \"malloc.h\"\n\nmain(void)\n\n{  \n\nchar   *src=\"hello,world\";\n\n    char   *dest=NULL;\n\n    dest=(char   *)malloc(sizeof(char)*(strlen(src)+1));\n\n    int   len=strlen(src);\n\n    char   *d=dest;\n\n    char   *s=src+len-1;\n\n    while(len--!=0)\n\n      *d++=*s--;\n\n*d='/0';\n\n    printf(\"%s\",dest);\n\n}\n\n105. 判断字符串是否为回文\n\nbool IsSymmetry(const char * p)\n\n     {\n\n         assert(p!=NULL);\n\n         const char * q=p;      \n\n         int len=0;\n\n         while (*q++!='/0' )\n\n         {\n\n              len++;\n\n         }       \n\n         bool bSign=true ;\n\n         q=p+len-1;\n\n         if (0<len)\n\n         {\n\n              for (int i=0;i<len/2;i++)\n\n              {\n\n                   if (*p++!=*q--){ bSign=false ;break ;};\n\n              }\n\n         }\n\n         if (bSign==true )\n\n         {\n\n              printf(\"Yes!/n\" );\n\n         }\n\n         else\n\n         {\n\n              printf(\"No!/n\" );\n\n         }\n\n         return bSign;\n\n     }\n\n107.ASDL 使用的是什么协议？并进行简单描述？\n\n \n\n108.Static 作用是什么\n\n首先 static 的最主要功能是隐藏，其次因为 static 变量存放在静态存储区，所以它具备持久性和默认值 0 。\n\n109. 什么是预编译 , 何时需要预编译 ?\n\n预编译又称为预处理 , 是做些代码文本的替换工作。处理 # 开头的指令 , 比如拷贝 #include 包含的文件代码，#define 宏定义的替换 , 条件编译等，就是为编译做的预备工作的阶段，主要处理 # 开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。\n\n \n\nc 编译系统在对程序进行通常的编译之前，先进行预处理。 c 提供的预处理功能主要有以下三种： 1 ）宏定义　2 ）文件包含　 3 ）条件编译\n\n \n\n１、总是使用不经常改动的大型代码体。 \n２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。\n\n \n\n110. 进程和线程的区别\n\n什么是进程（ Process ）：普通的解释就是，进程是程序的一次执行，而什么是线程（ Thread ），线程可以理解为进程中的执行的一段程序片段。在一个多任务环境中下面的概念可以帮助我们理解两者间的差别： \n\n进程间是独立的，这表现在内存空间，上下文环境；线程运行在进程空间内。 一般来讲（不使用特殊技术）进程是无法突破进程边界存取其他进程内的存储空间；而线程由于处于进程空间内，所以同一进程所产生的线程共享同一内存空间。 同一进程中的两段代码不能够同时执行，除非引入线程。线程是属于进程的，当进程退出时该进程所产生的线程都会被强制退出并清除。线程占用的资源要少于进程所占用的资源。 进程和线程都可以有优先级。在线程系统中进程也是一个线程。可以将进程理解为一个程序的第一个线程。\n\n \n\n线程是指进程内的一个执行单元 , 也是进程内的可调度实体 . 与进程的区别 :\n(1) 地址空间 : 进程内的一个执行单元 ; 进程至少有一个线程 ; 它们共享进程的地址空间 ; 而进程有自己独立的地址空间 ;\n(2) 进程是资源分配和拥有的单位 , 同一个进程内的线程共享进程的资源 \n(3) 线程是处理器调度的基本单位 , 但进程不是 .\n(4) 二者均可并发执行 .\n\n111. 插入排序和\n\n插入排序基本思想：（假定从大到小排序）依次从后面拿一个数和前面已经排好序的数进行比较，比较的过程是从已经排好序的数中最后一个数开始比较，如果比这个数，继续往前面比较，直到找到比它大的数，然后就放在它的后面，如果一直没有找到，肯定这个数已经比较到了第一个数，那就放到第一个数的前面。那么一般情况下，对于采用插入排序法去排序的一组数，可以先选 取第一个数做为已经排好序的一组数。然后把第二个放到正确位置。\n\n \n\n选择排序 (Selection Sort) 是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素 ,存放到排序序列的起始位置 , 然后 , 再从剩余未排序元素中继续寻找最小元素 , 然后放到排序序列末尾。以此类推, 直到所有元素均排序完毕。\n\n112. 运算符优先级问题\n\n能正确表示 a 和 b 同时为正或同时为负的逻辑表达式是 (D ) 。\n\nsssA 、 (a>=0||b>=0) ＆＆ (a<0||b<0) \nB 、 (a>=0 ＆＆ b>=0)&&(a<0& ＆ b<0) \nC 、 (a+b>0) ＆＆ (a+b<=0) \nD 、 a*b>0\n\n \n\n以下关于运算符优先顺序的描述中正确的是 (C) 。 \nA 、关系运算符 < 算术运算符 < 赋值运算符 < 逻辑与运算符 \nB 、逻辑与运算符 < 关系运算符 < 算术运算符 < 赋值运算符 \nC 、赋值运算符 < 逻辑与运算符 < 关系运算符 < 算术运算符 \nD 、算术运算符 < 关系运算符 < 赋值运算符 < 逻辑与运算符\n\n \n\n113. 字符串倒序\n\n \n\n写一个函数将 \"tom is cat\" 倒序打印出来，即 \"cat is tom\"\n\n//a.ch\n\n#define SPACE ' '\n#define ENDL '/0'\n\nchar* str = \"Tom is cat\"; // 字符串 \nchar* p1 = str+strlen(str)-1;\nchar* p2 = p1; // 开始时， p1,p2 都指向字符串结尾处 \nchar t=0; // 临时变量，用来保存被临时替换为 ENDL 的字符\n\nwhile(str!=p1--)\n{\n  if(SPACE!=*p1){\n     for(p2=p1+1;SPACE!=*p1; p1--, t=*p2, *p2=ENDL);\n\n     // p1+1 指向单词的第一个字母 ,p2 指向单词的结尾 , 此时输出这个单词 \n                printf(\"%s \",p1+1);\n                *p2=t;\n                p2=p1;\n         }\n}\n\nOutput:\ncat is Tom\n\n----------------------------------------------------------------------\n1) 写一个递归函数将内存中的字符串翻转 \"abc\"->\"cba\"\n2) 写一个函数将 \"tom is cat\" 将内存中的字符串翻转，即 \"cat is tomm\" \n\n#include <stdio.h>\n#define SPACE ' '\n#define ENDL '/0'\nchar* s = \"The quick brown fox jumps over the lazy dog\";\n\nvoid str_reverse(char* p1,char* p2){\n      if(p1==p2)return;\n    *p1 = (*p1)+(*p2);\n    *p2 = (*p1)-(*p2);\n    *p1 = (*p1)-(*p2);\n      if(p1==p2-1)return;\n      else str_reverse(++p1,--p2);\n}\n\nvoid str_word_reverse(char* str){\n      char *q1=str, *q2=str, *t;\n\n      while(*q1==SPACE)q1++;\n      if(*q1==ENDL)return; //!\n      else q2=q1+1;\n\n      while( (*q2!=SPACE) && (*q2!=ENDL) )q2++;\n    \n     t=q2--; \n    str_reverse(q1,q2);\n\n      if(*t==ENDL)return;\n      else str_word_reverse(t);\n}\n\nint\nmain(int a ,char** b)\n{\n    printf(\"%s/n\",s);\n    str_reverse(s,s+strlen(s)-1);\n    printf(\"%s/n\",s);\n    str_word_reverse(s);\n    printf(\"%s/n\",s);\n           return 0;\n}\n\nOutput:\n\nThe quick brown fox jumps over the lazy dog\ngod yzal eht revo spmuj xof nworb kciuq ehT\ndog lazy the over jumps fox brown quick The\n\n----------------------------------------------------------------------\n今天同学又问一道题 , 和上面有些类似，但是要求更严格了一些： \n写一个递归函数将内存中的字符串翻转 \"abc\"->\"cba\", 并且函数原型已确定： void reverse(char* p)\n\n其实，要求越多，思路越确定，我的解如下： \n\n#include <stdio.h>\n#include <string.h>\nchar* s = \"0123456789\";\n#define ENDL '/0'\nvoid reverse(char* p){\n       // 这是这种方法的关键，使用 static 为的是能用 str_reverse 的思路，但是不好 \n       static char* x=0;\n       if(x==0)x=p;\n       char* q = x+strlen(p)-1; \n       if(p==q)return;\n       *q=(*p)^(*q);\n       *p=(*p)^(*q);\n       *q =(*p)^(*q);\n       if(q==p+1)return;\n       reverse(++p);\n}\n\n// 这种方法就直观多了，但是当字符串很长的时候就很低效 \nvoid reverse2(char* p){\n       if(*(p+1)==ENDL)return;\n       for(char* o=p+strlen(p)-1,char t=*o;o!=p;o--)\n          *o=*(o-1);\n       *p=t;\n       reverse2(p+1);\n}\n\nint main(int c,char** argv){\n       reverse2(s);\n       printf(\"%s/n\",s);\n       return 0;\n}\n\n \n\n114. 交换两个数的宏定义\n\n \n\n交换两个参数值的 宏定义 为： . #define SWAP (a,b) (a)=(a)+(b);(b)=(a)-(b);(a)=(a)-(b);\n\n \n\n115.Itearator 各指针的区别\n\n \n\n游标和指针\n\n我说过游标是指针，但不仅仅是指针。游标和指针很像，功能很像指针，但是实际上，游标是通过重载一元的 ”*”和 ”->” 来从容器中间接地返回一个值。将这些值存储在容器中并不是一个好主意，因为每当一个新值添加到容器中或者有一个值从容器中删除，这些值就会失效。在某种程度上，游标可以看作是句柄（ handle ）。通常情况下游标（ iterator ）的类型可以有所变化，这样容器也会有几种不同方式的转变：\n\n\niterator—— 对于除了 vector 以外的其他任何容器，你可以通过这种游标在一次操作中在容器中朝向前的方向走一步。这意味着对于这种游标你只能使用 “++” 操作符。而不能使用 “--” 或 “+=” 操作符。而对于 vector 这一种容器，你可以使用 “+=” 、 “—” 、 “++” 、 “-=” 中的任何一种操作符和 “<” 、 “<=” 、 “>” 、 “>=” 、 “==” 、 “!=” 等比较运算符。\n\n \n\n116. C++ 中的 class 和 struct 的区别\n\n从语法上，在 C++ 中（只讨论 C++ 中）。 class 和 struct 做类型定义时只有两点区别： \n（一）默认继承权限。如果不明确指定，来自 class 的继承按照 private 继承处理，来自 struct 的继承按照 public继承处理； \n（二）成员的默认访问权限。 class 的成员默认是 private 权限， struct 默认是 public 权限。 \n除了这两点， class 和 struct 基本就是一个东西。语法上没有任何其它区别。\n\n不能因为学过 C 就总觉得连 C++ 中 struct 和 class 都区别很大，下面列举的说明可能比较无聊，因为 struct 和class 本来就是基本一样的东西，无需多说。但这些说明可能有助于澄清一些常见的关于 struct 和 class 的错误认识： \n（ 1 ）都可以有成员函数；包括各类构造函数，析构函数，重载的运算符，友元类，友元结构，友元函数，虚函数，纯虚函数，静态函数； \n（ 2 ）都可以有一大堆 public/private/protected 修饰符在里边； \n（ 3 ）虽然这种风格不再被提倡，但语法上二者都可以使用大括号的方式初始化：\n\nA a = {1, 2, 3}; 不管 A 是个 struct 还是个 class ，前提是这个类 / 结构足够简单，比如所有的成员都是 public的，所有的成员都是简单类型，没有显式声明的构造函数。 \n（ 4 ）都可以进行复杂的继承甚至多重继承，一个 struct 可以继承自一个 class ，反之亦可；一个 struct 可以同时继承 5 个 class 和 5 个 struct ，虽然这样做不太好。 \n（ 5 ）如果说 class 的设计需要注意 OO 的原则和风格，那么没任何理由说设计 struct 就不需要注意。 \n（ 6 ）再次说明，以上所有说法都是指在 C++ 语言中，至于在 C 里的情况， C 里是根本没有 “class” ，而 C 的struct 从根本上也只是个包装数据的语法机制。 \n---------------------------------------------------------------\n\n最后，作为语言的两个关键字，除去定义类型时有上述区别之外，另外还有一点点： “class” 这个关键字还用于定义模板参数，就像 “typename” 。但关键字 “struct” 不用于定义模板参数。\n\n \n\n关于使用大括号初始化\n\n　　 class 和 struct 如果定义了构造函数的话，都不能用大括号进行初始化\n\n　　如果没有定义构造函数， struct 可以用大括号初始化。\n\n　　如果没有定义构造函数，且所有成员变量全是 public 的话，可以用大括号初始化。\n\n　　关于默认访问权限\n\n　　 class 中默认的成员访问权限是 private 的，而 struct 中则是 public 的。\n\n　　关于继承方式\n\n　　 class 继承默认是 private 继承，而 struct 继承默认是 public 继承。\n\n　　关于模版\n\n \n\n　　在模版中，类型参数前面可以使用 class 或 typename ，如果使用 struct ，则含义不同， struct 后面跟的是“non-type template parameter” ，而 class 或 typename 后面跟的是类型参数。\n\n \n\nclass 中有个默认的 this 指针， struct 没有 \n不同点：构造函数，析构函数  this  指针\n\n \n\n117. 有关重载函数\n\n \n\n返回值类型不同构不成重载 \n参数参数顺序不同能构成重载\n\nc++ 函数同名不同返回值不算重载！函数重载是忽略返回值类型的。 \n\n--------------------------------------------- \n成员函数被重载的特征有： \n1) 相同的范围（在同一个类中）； \n2) 函数名字相同； \n3) 参数不同； \n4) virtual 关键字可有可无。\n\n5) 成员函数中 有无 const ( 函数后面 ) 也可判断是否重载\n\n \n\n118. 数据库与 T-SQL 语言 \n   \n\n关系数据库是表的集合，它是由一个或多个关系模式定义。 SQL 语言中的数据定义功能包括对数据库、基本表、视图、索引的定义。\n\n \n\n119. 关系模型的基本概念 \n\n\n  关系数据库以关系模型为基础，它有以下三部分组成： \n    ● 数据结构 —— 模型所操作的对象、类型的集合 \n    ● 完整性规则 —— 保证数据有效、正确的约束条件 \n    ● 数据操作 —— 对模型对象所允许执行的操作方式 \n    关系（ Relation ）是一个由行和列组成的二维表格，表中的每一行是一条记录（ Record ），每一列是记录的一个字段（ Field ）。表中的每一条记录必须是互斥的，字段的值必须具有原子性。 \n\n\n120.SQL 语言概述\n\n\n    SQL （结构化查询语言）是关系数据库语言的一种国际标准，它是一种非过程化的语言。通过编写 SQL ，我们可以实现对关系数据库的全部操作。 \n    ● 数据定义语言（ DDL ） —— 建立和管理数据库对象 \n    ● 数据操纵语言（ DML ） —— 用来查询与更新数据 \n    ● 数据控制语言（ DCL ） —— 控制数据的安全性\n\n \n\n起来是一个很简单的问题，每一个使用过 RDBMS 的人都会有一个概念。\n\n事务处理系统的典型特点是具备 ACID 特征。 ACID 指的是 Atomic （原子的）、 Consistent （一致的）、Isolated （隔离的）以及 Durable （持续的），它们代表着事务处理应该具备的四个特征：\n\n原子性：组成事务处理的语句形成了一个逻辑单元，不能只执行其中的一部分\n\n一致性：在事务处理执行之前和之后，数据是一致的。\n\n隔离性：一个事务处理对另一个事务处理没有影响。\n\n持续性：当事务处理成功执行到结束的时候，其效果在数据库中被永久纪录下来。\n\n \n\n121.C 语言中结构化程序设计的三种基本控制结构\n\n \n\n顺序结构 \n选择结构 \n循环结构\n\n \n\n122.CVS 是什么\n\n \n\ncvs （ Concurrent Version System ） 是一个版本控制系统。使用它，可以记录下你的源文件的历史。 \n\n例如，修改软件时可能会不知不觉混进一些 bug ，而且可能过了很久你才会察觉到它们的存在。有了 cvs ，你可以很容易地恢复旧版本，并从中看出到底是哪个修改导致了这个 bug 。有时这是很有用的。 \n\nCVS 服务器端对每个文件维护着一个修订号 , 每次对文件的更新，都会使得文件的修订号加 1 。在客户端中也对每个文件维护着一个修订号 ,CVS 通过这两个修订号的关系，来进行 Update,Commit 和发现冲突等操作操作\n\n \n\n123. 三种基本的数据模型\n\n \n\n按照数据结构类型的不同，将数据模型划分为层次模型、网状模型和关系模型。","slug":"C++/CPP入门基础","published":1,"updated":"2018-10-02T05:05:14.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmren4ox0061ntnbfoblm73x","content":"<h1 id=\"C-入门基础\"><a href=\"#C-入门基础\" class=\"headerlink\" title=\"C++入门基础\"></a>C++入门基础</h1><hr>\n<p>##1.new 、 delete 、 malloc 、 free 关系</p>\n<p>delete 会调用对象的析构函数 , 和 new 对应 free 只会释放内存， new 调用构造函数。 malloc 与 free 是C++/C 语言的标准库函数， new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free 。因此 C++ 语言需要一个能完成动态内存分配和初始化工作的运算符 new ，以及一个能完成清理与释放内存工作的运算符 delete 。注意 new/delete 不是库函数。</p>\n<p>总结：new和delete会自动调用对象的构造与析构函数而malloc与free不会；</p>\n<pre><code>  new和delete式C++运算符，而malloc和free是C/C++标准库函数。\n</code></pre><hr>\n<p>##2.delete 与 delete [] 区别</p>\n<p>delete 只会调用一次析构函数，而 delete[] 会调用每一个成员的析构函数。在 More Effective  C++ 中有更为详细的解释：“当 delete 操作符用于数组时，它为每个数组元素调用析构函数，然后调用 operatordelete 来释放内存。” delete 与 New 配套， delete [] 与 new [] 配套</p>\n<pre><code class=\"c++\">  MemTest*mTest1=newMemTest[10];\n\n  MemTest*mTest2=newMemTest;\n\n  int*pInt1=newint[10];\n\n  int*pInt2=newint;\n\n  delete[]pInt1;  //-1-\n\n  delete[]pInt2;  //-2-\n\n  delete[]mTest1;//-3-\n\n  delete[]mTest2;//-4-\n</code></pre>\n<p>  在 -4- 处报错。</p>\n<p>这就说明：对于内建简单数据类型， delete 和 delete[] 功能是相同的。对于自定义的复杂数据类型， delete和 delete[] 不能互用。 delete[] 删除一个数组， delete 删除一个指针简单来说，用 new 分配的内存用 delete 删除用 new[] 分配的内存用 delete[] 删除 delete[] 会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用 delete 时没用括号， delete 就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。</p>\n<p>总结： delete 只会调用一次析构函数，而 delete[] 会调用每一个成员的析构函数。</p>\n<hr>\n<p>##3. C C++ JAVA 共同点，不同之处？</p>\n<hr>\n<p>##4. 继承优缺点。</p>\n<p>类继承是在编译时刻静态定义的，且可直接使用，类继承可以较方便地改变父类的实现。但是类继承也有一些不足之处。首先，因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现。更糟的是，父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为。如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</p>\n<p>（待补充）</p>\n<hr>\n<p>##5.C++ 有哪些性质（面向对象特点）</p>\n<p>封装，继承和多态。</p>\n<p>在面向对象程序设计语言中，封装是利用可重用成分构造软件系统的特性，它不仅支持系统的可重用性，而且还有利于提高系统的可扩充性；消息传递可以实现发送一个通用的消息而调用不同的方法；封装是实现信息隐蔽的一种技术，其目的是使类的定义和实现分离。</p>\n<hr>\n<p>##6. 子类析构时要调用父类的析构函数吗？</p>\n<p>析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候 , 派生类的信息已经全部销毁了定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数 JAVA 无析构函数深拷贝和浅拷贝</p>\n<hr>\n<p>##7. 多态，虚函数，纯虚函数</p>\n<hr>\n<p>##8. 求下面函数的返回值（微软）</p>\n<pre><code class=\"c++\">int func(x) \n{ \n    int countx = 0; \n    while(x) \n    { \n          countx ++; \n          x = x&amp;(x-1); \n     } \n    return countx; \n} \n</code></pre>\n<p>假定 x = 9999 。 答案： 8</p>\n<p>思路：将 x 转化为 2 进制，看含有的 1 的个数。</p>\n<hr>\n<p>##9. 什么是 “ 引用 ” ？申明和使用 “ 引用 ” 要注意哪些问题？</p>\n<p>答：引用就是某个目标变量的 “ 别名 ”(alias) ，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。</p>\n<hr>\n<p>##10. 将 “ 引用 ” 作为函数参数有哪些特点？</p>\n<p>（ 1 ）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</p>\n<p>（ 2 ）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</p>\n<p>（ 3 ）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用 “* 指针变量名 “ 的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p>\n<hr>\n<p>##11. 在什么时候需要使用 “ 常引用 ” ？ 　</p>\n<p>如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式： const 类型标识符 &amp; 引用名 = 目标变量名；</p>\n<p>例 1</p>\n<pre><code class=\"c++\">int a ;\nconst int &amp;ra=a;\nra=1; // 错误 \na=1; // 正确\n</code></pre>\n<p>例 2</p>\n<pre><code class=\"c++\">string foo( );\nvoid bar(string &amp; s);\n</code></pre>\n<p>那么下面的表达式将是非法的：</p>\n<pre><code class=\"c++\">bar(foo( ));\nbar(&quot;hello world&quot;);\n</code></pre>\n<p>原因在于 foo( ) 和 “hello world” 串都会产生一个临时对象，而在 C++ 中，这些临时对象都是 const 类型的。因此上面的表达式就是试图将一个 const 类型的对象转换为非 const 类型，这是非法的。引用型参数应该在能被定义为 const 的情况下，尽量定义为 const 。</p>\n<hr>\n<p>##12. 将 “ 引用 ” 作为函数返回值类型的格式、好处和需要遵守的规则 ?</p>\n<p>格式：类型标识符 &amp; 函数名（形参列表及类型说明） { // 函数体 }</p>\n<p>好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生 runtime error! 注意事项：</p>\n<p>（ 1 ）不能返回局部变量的引用。这条可以参照 Effective C++[1] 的 Item 31 。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了 “ 无所指 “ 的引用，程序会进入未知状态。</p>\n<p>（ 2 ）不能返回函数内部 new 分配的内存的引用。这条可以参照 Effective C++[1] 的 Item 31 。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部 new 分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由 new 分配）就无法释放，造成 memory leak 。</p>\n<p>（ 3 ）可以返回类成员的引用，但最好是 const 。这条原则可以参照 Effective C++[1] 的 Item 30 。主要原因是当对象的属性是与某种业务规则（ business rule ）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。</p>\n<p>（ 4 ）流操作符重载返回值申明为 “ 引用 ” 的作用：</p>\n<p>流操作符 &lt;&lt; 和 &gt;&gt; ，这两个操作符常常希望被连续使用，例如： cout &lt;&lt; “hello” &lt;&lt; endl; 　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个 &lt;&lt; 操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用 &lt;&lt; 操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是 C++ 语言中引入引用这个概念的原因吧。 赋值操作符 = 。这个操作符象流操作符一样，是可以连续使用的，例如： x = j = 10; 或者 (x=10)=100; 赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。</p>\n<p>例 3</p>\n<pre><code class=\"c++\">＃ i nclude &lt;iostream.h&gt;\nint &amp;put(int n);\nint vals[10];\nint error=-1;\nvoid main()\n{\nput(0)=10; // 以 put(0) 函数值作为左值，等价于 vals[0]=10; \nput(9)=20; // 以 put(9) 函数值作为左值，等价于 vals[9]=20; \ncout&lt;&lt;vals[0]; \ncout&lt;&lt;vals[9];\n} \nint &amp;put(int n)\n{\nif (n&gt;=0 &amp;&amp; n&lt;=9 ) return vals[n]; \nelse { cout&lt;&lt;&quot;subscript error&quot;; return error; }\n}\n</code></pre>\n<p>（ 5 ）在另外的一些操作符中，却千万不能返回引用： +-*/ 四则运算符。它们不能返回引用， Effective C++[1] 的 Item23 详细的讨论了这个问题。主要原因是这四个操作符没有 side effect ，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个 new 分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第 2 、 3 两个方案都被否决了。静态对象的引用又因为 ((a+b) == (c+d)) 会永远为 true 而导致错误。所以可选的只剩下返回一个对象了。</p>\n<hr>\n<p>##13.“ 引用 ” 与多态的关系？</p>\n<p>引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。例4</p>\n<p>Class A; Class B : Class A{…};  B b; A&amp; ref = b;</p>\n<hr>\n<p>##14.“ 引用 ” 与指针的区别是什么？</p>\n<p>指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。此外，就是上面提到的对函数传 ref 和pointer 的区别。</p>\n<hr>\n<p>##15. 什么时候需要 “ 引用 ” ？</p>\n<p>流操作符 &lt;&lt; 和 &gt;&gt; 、赋值操作符 = 的返回值、拷贝构造函数的参数、赋值操作符 = 的参数、其它情况都推荐使用引用。以上 2-8 参考： <a href=\"http://develop.csai.cn/c/NO0000021.htm\" target=\"_blank\" rel=\"noopener\">http://develop.csai.cn/c/NO0000021.htm</a></p>\n<hr>\n<p>##16. 结构与联合有和区别？</p>\n<p>(1). 结构和联合都是由多个不同的数据类型成员组成 , 但在任何同一时刻 , 联合中只存放了一个被选中的成员（所有成员共用一块地址空间） , 而结构的所有成员都存在（不同成员的存放地址不同）。<br> (2). 对于联合的不同成员赋值 , 将会对其它成员重写 ,  原来成员的值就不存在了 , 而对于结构的不同成员赋值是互不影响的。</p>\n<hr>\n<p>##17. 面关于 “ 联合 ” 的题目的输出？</p>\n<p>a)</p>\n<pre><code class=\"c++\">＃ i nclude &lt;stdio.h&gt;\nunion\n{\nint i;\nchar x[2];\n}a;\n\n\nvoid main()\n{\na.x[0] = 10; \na.x[1] = 1;\nprintf(&quot;%d&quot;,a.i);\n}\n答案： 266 ( 低位低地址，高位高地址，内存占用情况是 Ox010A ）\n</code></pre>\n<p>b)</p>\n<pre><code class=\"c++\">main() \n     { \n          union{                   /* 定义一个联合 */ \n               int i; \n               struct{             /* 在联合中定义一个结构 */ \n                    char first; \n                    char second; \n               }half; \n          }number; \n          number.i=0x4241;         /* 联合成员赋值 */ \n          printf(&quot;%c%cn&quot;, number.half.first, mumber.half.second); \n          number.half.first=&#39;a&#39;;   /* 联合中结构成员赋值 */ \n          number.half.second=&#39;b&#39;; \n          printf(&quot;%xn&quot;, number.i); \n          getch(); \n     } \n</code></pre>\n<p>答案： AB   (0x41 对应 ‘A’, 是低位； Ox42 对应 ‘B’, 是高位）</p>\n<pre><code>   6261 (number.i 和 number.half 共用一块地址空间）\n</code></pre><ol start=\"18\">\n<li>关联、聚合 (Aggregation) 以及组合(Composition) 的区别？</li>\n</ol>\n<p>涉及到 UML 中的一些概念：关联是表示两个类的一般性联系，比如 “ 学生 ” 和 “ 老师 ” 就是一种关联关系；聚合表示 has-a 的关系，是一种相对松散的关系，聚合类不需要对被聚合类负责，如下图所示，用空的菱形表示聚合关系：从实现的角度讲，聚合可以表示为 :</p>\n<p>class A {…}  class B { A* a; …..}</p>\n<p>而组合表示 contains-a 的关系，关联性强于聚合：组合类与被组合类有相同的生命周期，组合类要对被组合类负责，采用实心的菱形表示组合关系：实现的形式是 :</p>\n<p>class A{…} class B{ A a; …}</p>\n<p>参考文章： <a href=\"http://www.cnitblog.com/Lily/archive/2006/02/23/6860.html\" target=\"_blank\" rel=\"noopener\">http://www.cnitblog.com/Lily/archive/2006/02/23/6860.html</a></p>\n<pre><code>      http://www.vckbase.com/document/viewdoc/?id=422\n</code></pre><ol start=\"19\">\n<li><p>面向对象的三个基本特征，并简单叙述之？</p>\n</li>\n<li><p>封装：将客观事物抽象成类，每个类对自身的数据和方法实行 protection(private, protected,public)</p>\n</li>\n<li><p>继承：广义的继承有三种实现形式：实现继承（指使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后到子类实现）。前两种（类继承）和后一种（对象组合 =&gt; 接口继承以及纯虚函数）构成了功能复用的两种方式。</p>\n</li>\n<li><p>多态：是将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。</p>\n</li>\n<li><p>重载（ overload) 和重写 (overried ，有的书也叫做 “ 覆盖 ” ）的区别？</p>\n</li>\n</ol>\n<p>常考的题目。从定义上来说：</p>\n<p>重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。</p>\n<p>重写：是指子类重新定义父类虚函数的方法。</p>\n<p>从实现原理上来说：</p>\n<p>重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数： function func(p:integer):integer; 和 function func(p:string):integer; 。 那么编译器做过修饰后的函数名称可能是这样的： int_func 、 str_func 。对于这两个函数的调用，在编译器间就已经确定了，是 静态 的。也就是说， 它们的地址在编译期就绑定了（早绑定）， 因此， 重载和多态无关 ！</p>\n<p>重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针， 动态的调用 属于子类的该函数，这样的函 数调用在编译期间是无法确定的 （调用的子类的虚函数的地址无法给出）。因此， 这样的函数地址是在运行期绑定的（晚绑定）。</p>\n<hr>\n<p>##21. 多态的作用？</p>\n<p>主要是两个：</p>\n<ol>\n<li><p>隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；</p>\n</li>\n<li><p>接口重用：为了类在继承和派生的时候 ，保证使用家族中任一类的实例的某一属性时的正确调用 。</p>\n</li>\n</ol>\n<hr>\n<p>##22.Ado 与 Ado.net 的相同与不同？</p>\n<p>除了“能够让应用程序处理存储于 DBMS 中的数据“这一基本相似点外，两者没有太多共同之处。但是 Ado使用 OLE DB 接口并基于微软的 COM 技术，而 ADO.NET 拥有自己的 ADO.NET 接口并且基于微软的 .NET 体系架构。众所周知 .NET 体系不同于 COM 体系， ADO.NET 接口也就完全不同于 ADO 和 OLE DB 接口，这也就是说 ADO.NET 和 ADO 是两种数据访问方式。 ADO.net 提供对 XML 的支持。</p>\n<hr>\n<p>##23.New delete 与 malloc free 的联系与区别 ?</p>\n<p>答案：都是在堆 (heap) 上进行动态的内存操作。用 malloc 函数需要指定内存分配的字节数并且不能初始化对象， new 会自动调用对象的构造函数。 delete 会调用对象的 destructor ，而 free 不会调用对象的 destructor.</p>\n<hr>\n<p>##24.#define DOUBLE(x) x+x ， i = 5*DOUBLE(5) ； i是多少？</p>\n<p>答案： i 为 30 。</p>\n<hr>\n<p>##25. 有哪几种情况只能用 intialization list 而不能用assignment?</p>\n<p>答案：当类中含有 const 、 reference 成员变量；基类的构造函数都需要初始化表。</p>\n<hr>\n<p>##26. C++ 是不是类型安全的？</p>\n<p>答案：不是。两个不同类型的指针之间可以强制转换（用 reinterpret cast) 。 C# 是类型安全的。</p>\n<hr>\n<p>##27. main 函数执行以前，还会执行什么代码？</p>\n<p>答案：全局对象的构造函数会在 main 函数之前执行。</p>\n<hr>\n<p>##28.  描述内存分配方式以及它们的区别 ?</p>\n<p>1 ） 从静态存储区域分配 。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如 全局变量， static 变量 。<br>2 ） 在栈上创建 。在执行函数时， 函数内局部变量的存储单元都可以在栈上创建 ，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。<br>3 ） 从堆上分配 ， 亦称动态内存分配 。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。</p>\n<hr>\n<p>##29.struct 和 class 的区别</p>\n<p>答案： struct 的成员默认是公有的，而类的成员默认是私有的。 struct 和 class 在其他方面是功能相当的。从感情上讲，大多数的开发者感到类和结构有很大的差别。感觉上结构仅仅象一堆缺乏封装和功能的开放的内存位，而类就象活的并且可靠的社会成员，它有智能服务，有牢固的封装屏障和一个良好定义的接口。既然大多数人都这么认为，那么只有在你的类有很少的方法并且有公有数据（这种事情在良好设计的系统中是存在的 ! ）时，你也许应该使用 struct 关键字，否则，你应该使用 class 关键字。  </p>\n<hr>\n<p>##30. 当一个类 A 中没有任何成员变量与成员函数 , 这时sizeof(A) 的值是多少？</p>\n<p>答案：如果不是零，请解释一下编译器为什么没有让它为零。（ Autodesk ）肯定不是零。举个反例，如果是零的话，声明一个 class A[10] 对象数组，而每一个对象占用的空间是零，这时就没办法区分 A[0],A[1] …了。</p>\n<hr>\n<p>##31. 在 8086 汇编下，逻辑地址和物理地址是怎样转换的？（ Intel ）</p>\n<p>答案：通用寄存器给出的地址，是段内偏移地址，相应段寄存器地址 *10H+ 通用寄存器内地址，就得到了真正要访问的地址。</p>\n<hr>\n<p>##32.  比较 C++ 中的 4 种类型转换方式？</p>\n<p>请参考： <a href=\"http://blog.csdn.net/wfwd/archive/2006/05/30/763785.aspx\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/wfwd/archive/2006/05/30/763785.aspx</a> ，重点是 static_cast, dynamic_cast和 reinterpret_cast 的区别和应用。</p>\n<p>dynamic_casts 在帮助你浏览继承层次上是有限制的。它不能被用于缺乏虚函数的类型上，它被用于安全地沿着类的继承关系向下进行类型转换。如你想在没有继承关系的类型中进行转换，你可能想到 static_cast</p>\n<hr>\n<p>##33. 分别写出 BOOL,int,float, 指针类型的变量 a与“零”的比较语句。</p>\n<p>答案：<br>BOOL :    if ( !a ) or if(a)<br>int :     if ( a == 0)<br>float :   const EXPRESSION EXP = 0.000001<br>          if ( a &lt; EXP &amp;&amp; a &gt;-EXP)<br>pointer : if ( a != NULL) or if(a == NULL)</p>\n<hr>\n<p>##34. 请说出 const 与 #define 相比，有何优点？</p>\n<p>答案：</p>\n<p>Const 作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被 Const 修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。</p>\n<p>1 ） const 常量有数据类型，而宏常量没有数据类型 。编译器可以对前者进行类型 安全检查 。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。<br>      2 ） 有些集成化的调试工具可以对 const 常量进行调试 ，但是不能对宏常量进行调试。</p>\n<hr>\n<p>##35. 简述数组与指针的区别？</p>\n<p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。<br>(1) 修改内容上的差别<br>char a[] = “ hello ” ;<br>a[0] = ‘ X ’ ;<br>char <em>p = “ world ” ; // 注意 p 指向常量字符串<br>p[0] = ‘ X ’ ; // 编译器不能发现该错误，运行时错误<br>(2) 用运算符 sizeof 可以计算出数组的容量（字节数）。 sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是 p 所指的内存容量 。 C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。 注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。<br>char a[] = “hello world”;<br>char </em>p = a;<br>cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节<br>cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节<br>计算数组和指针的内存容量<br>void Func(char a[100])<br>{<br>cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是 100 字节<br>}</p>\n<hr>\n<p>##36. 类成员函数的重载、覆盖和隐藏区别？</p>\n<p>答案： a. 成员函数被重载的特征：<br>（ 1 ）相同的范围（在同一个类中）；<br>（ 2 ）函数名字相同；<br>（ 3 ）参数不同；<br>（ 4 ） virtual 关键字可有可无。<br>b. 覆盖是指派生类函数覆盖基类函数，特征是：<br>（ 1 ）不同的范围（分别位于派生类与基类）；<br>（ 2 ）函数名字相同；<br>（ 3 ）参数相同；<br>（ 4 ）基类函数必须有 virtual 关键字。<br>  c. “隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：<br>（ 1 ）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载混淆）。<br>（ 2 ）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）</p>\n<hr>\n<p>##37. 求出两个数中的较大这</p>\n<p>There are two int variables: a and b, don ’ t use “ if ” , “ ? : ” , “ switch ” or other judgement statements, find out the biggest one of the two numbers.</p>\n<p>答案： ( ( a + b ) + abs( a - b ) ) / 2</p>\n<hr>\n<p>##38. 如何打印出当前源文件的文件名以及源文件的当前行号？</p>\n<p>答案：<br>cout &lt;&lt; <strong>FILE</strong> ;<br>cout&lt;&lt;<strong>LINE</strong> ;<br><strong>FILE</strong> 和 <strong>LINE</strong> 是系统预定义宏，这种宏并不是在某个文件中定义的，而是由编译器定义的。</p>\n<hr>\n<p>##39. main 主函数执行完毕后，是否可能会再执行一段代码，给出说明？</p>\n<p>答案：可以，可以用 _onexit 注册一个函数，它会在 main 之后执行 int fn1(void), fn2(void), fn3(void), fn4 (void);</p>\n<pre><code class=\"c++\">void main( void )\n{\nString str(&quot;zhanglin&quot;);\n_onexit( fn1 );\n_onexit( fn2 );\n_onexit( fn3 );\n_onexit( fn4 );\nprintf( &quot;This is executed first.n&quot; );\n}\nint fn1()\n{\nprintf( &quot;next.n&quot; );\nreturn 0;\n}\nint fn2()\n{\nprintf( &quot;executed &quot; );\nreturn 0;\n}\nint fn3()\n{\nprintf( &quot;is &quot; );\nreturn 0;\n}\nint fn4()\n{\nprintf( &quot;This &quot; );\nreturn 0;\n}\n</code></pre>\n<p>The _onexit function is passed the address of a function (func) to be called when the program terminates normally. Successive calls to _onexit create a register of functions that are executed in LIFO (last-in-first-out) order. The functions passed to _onexit cannot take parameters.</p>\n<hr>\n<p>##40. 如何判断一段程序是由 C 编译程序还是由 C++ 编译程序编译的？</p>\n<p>答案： </p>\n<p>#ifdef __cplusplus<br>cout&lt;&lt;”c++”;</p>\n<p>#else<br>cout&lt;&lt;”c”;</p>\n<p>#endif</p>\n<hr>\n<p>##41. 文件中有一组整数，要求排序后输出到另一个文件中</p>\n<p>答案：</p>\n<pre><code class=\"c++\">＃ i nclude&lt;iostream&gt;\n\n＃ i nclude&lt;fstream&gt;\n\nusing namespace std;\n\n\nvoid Order(vector&lt;int&gt;&amp; data) //bubble sort\n{\nint count = data.size() ;\nint tag = false ; // 设置是否需要继续冒泡的标志位 \nfor ( int i = 0 ; i &lt; count ; i++)\n{\nfor ( int j = 0 ; j &lt; count - i - 1 ; j++)\n{\nif ( data[j] &gt; data[j+1])\n{\ntag = true ;\nint temp = data[j] ;\ndata[j] = data[j+1] ;\ndata[j+1] = temp ;\n}\n}\nif ( !tag )\nbreak ;\n}\n}\n\n\nvoid main( void )\n{\nvector&lt;int&gt;data;\nifstream in(&quot;c:/data.txt&quot;);\nif ( !in)\n{\ncout&lt;&lt;&quot;file error!&quot;;\nexit(1);\n}\nint temp;\nwhile (!in.eof())\n{\nin&gt;&gt;temp;\ndata.push_back(temp);\n}\nin.close(); // 关闭输入文件流 \nOrder(data);\nofstream out(&quot;c:/result.txt&quot;);\nif ( !out)\n{\ncout&lt;&lt;&quot;file error!&quot;;\nexit(1);\n}\nfor ( i = 0 ; i &lt; data.size() ; i++)\nout&lt;&lt;data[i]&lt;&lt;&quot; &quot;;\nout.close(); // 关闭输出文件流 \n}\n</code></pre>\n<hr>\n<p>##42. 链表题：一个链表的结点结构</p>\n<pre><code class=\"c++\">struct Node\n{\nint data ;\nNode *next ;\n};\ntypedef struct Node Node ;\n\n\n(1) 已知链表的头结点 head, 写一个函数把这个链表逆序 ( Intel)\n\nNode * ReverseList(Node *head) // 链表逆序 \n{\nif ( head == NULL || head-&gt;next == NULL )\nreturn head;\nNode *p1 = head ;\nNode *p2 = p1-&gt;next ;\nNode *p3 = p2-&gt;next ;\np1-&gt;next = NULL ;\nwhile ( p3 != NULL )\n{\np2-&gt;next = p1 ;\np1 = p2 ;\np2 = p3 ;\np3 = p3-&gt;next ;\n}\np2-&gt;next = p1 ;\nhead = p2 ;\nreturn head ;\n}\n(2) 已知两个链表 head1 和 head2 各自有序，请把它们合并成一个链表依然有序。 ( 保留所有结点，即便大小相同） \nNode * Merge(Node *head1 , Node *head2)\n{\nif ( head1 == NULL)\nreturn head2 ;\nif ( head2 == NULL)\nreturn head1 ;\nNode *head = NULL ;\nNode *p1 = NULL;\nNode *p2 = NULL;\nif ( head1-&gt;data &lt; head2-&gt;data )\n{\nhead = head1 ;\np1 = head1-&gt;next;\np2 = head2 ;\n}\nelse\n{\nhead = head2 ;\np2 = head2-&gt;next ;\np1 = head1 ;\n}\nNode *pcurrent = head ;\nwhile ( p1 != NULL &amp;&amp; p2 != NULL)\n{\nif ( p1-&gt;data &lt;= p2-&gt;data )\n{\npcurrent-&gt;next = p1 ;\npcurrent = p1 ;\np1 = p1-&gt;next ;\n}\nelse\n{\npcurrent-&gt;next = p2 ;\npcurrent = p2 ;\np2 = p2-&gt;next ;\n}\n}\nif ( p1 != NULL )\npcurrent-&gt;next = p1 ;\nif ( p2 != NULL )\npcurrent-&gt;next = p2 ;\nreturn head ;\n}\n(3) 已知两个链表 head1 和 head2 各自有序，请把它们合并成一个链表依然有序，这次要求用递归方法进行。(Autodesk)\n答案： \nNode * MergeRecursive(Node *head1 , Node *head2)\n{\nif ( head1 == NULL )\nreturn head2 ;\nif ( head2 == NULL)\nreturn head1 ;\nNode *head = NULL ;\nif ( head1-&gt;data &lt; head2-&gt;data )\n{\nhead = head1 ;\nhead-&gt;next = MergeRecursive(head1-&gt;next,head2);\n}\nelse\n{\nhead = head2 ;\nhead-&gt;next = MergeRecursive(head1,head2-&gt;next);\n}\nreturn head ;\n</code></pre>\n<hr>\n<p>##41. 分析一下这段程序的输出 (Autodesk)<br>class B<br>{<br>public:<br>B()<br>{<br>cout&lt;&lt;”default constructor”&lt;&lt;endl;<br>}<br>~B()<br>{<br>cout&lt;&lt;”destructed”&lt;&lt;endl;<br>}<br>B(int i):data(i)    //B(int) works as a converter ( int -&gt; instance of  B)<br>{<br>cout&lt;&lt;”constructed by parameter “ &lt;&lt; data &lt;&lt;endl;<br>}<br>private:<br>int data;<br>};</p>\n<p>B Play( B b)<br>{<br>return b ;<br>}</p>\n<p>(1)                                            results:<br>int main(int argc, char* argv[])      constructed by parameter 5<br>{                                     destructed  B(5) 形参析构<br>B t1 = Play(5); B t2 = Play(t1);   　 destructed  t1 形参析构<br>return 0; 　　　　　　　　　　　　　　 destructed  t2 　注意顺序！<br>}                                     destructed  t1</p>\n<p>(2)                                   results:<br>int main(int argc, char* argv[])      constructed by parameter 5<br>{                                     destructed  B(5) 形参析构<br>B t1 = Play(5); B t2 = Play(10);   　 constructed by parameter 10<br>return 0; 　　　　　　　　　　　　　　 destructed  B(10) 形参析构<br>}                                     destructed  t2 　注意顺序！</p>\n<pre><code>                                  destructed  t1\n</code></pre><pre><code>\n---\n\n\n##43. 写一个函数找出一个整数数组中，第二大的数 （microsoft ）\n\n答案： \n```c++\nconst int MINNUMBER = -32767 ;\nint find_sec_max( int data[] , int count)\n{\nint maxnumber = data[0] ;\nint sec_max = MINNUMBER ;\nfor ( int i = 1 ; i &lt; count ; i++)\n{\nif ( data[i] &gt; maxnumber )\n{\nsec_max = maxnumber ;\nmaxnumber = data[i] ;\n}\nelse\n{\nif ( data[i] &gt; sec_max )\nsec_max = data[i] ;\n}\n}\nreturn sec_max ;\n}\n</code></pre><p>##44. 写一个在一个字符串 (n) 中寻找一个子串 (m) 第一个位置的函数。</p>\n<p>KMP 算法效率最好，时间复杂度是Ｏ (n+m), 详见： <a href=\"http://www.zhanglihai.com/blog/c_335_kmp.html\" target=\"_blank\" rel=\"noopener\">http://www.zhanglihai.com/blog/c_335_kmp.html</a></p>\n<hr>\n<p>##46. 多重继承的内存分配问题：</p>\n<p>比如有 class A : public class B, public class C {} 那么 A 的内存结构大致是怎么样的？<br>这个是 compiler-dependent 的 , 不同的实现其细节可能不同。如果不考虑有虚函数、虚继承的话就相当简单；否则的话，相当复杂。可以参考《深入探索 C++ 对象模型》，或者：<br><a href=\"http://blog.csdn.net/rainlight/archive/2006/03/03/614792.aspx\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/rainlight/archive/2006/03/03/614792.aspx</a><br><a href=\"http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dnarvc/html/jangrayhood.asp\" target=\"_blank\" rel=\"noopener\">http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dnarvc/html/jangrayhood.asp</a></p>\n<hr>\n<p>##47. 如何判断一个单链表是有环的？（注意不能用标志位，最多只能用两个额外指针）</p>\n<pre><code class=\"c++\">struct node { char val; node* next;}\nbool check(const node* head) {} //return false : 无环； true: 有环一种 O （ n ）的办法就是（搞两个指针，一个每次递增一步，一个每次递增两步，如果有环的话两者必然重合，反之亦然）： \nbool check(const node* head)\n{\n    if(head==NULL)  return false;\n    node *low=head, *fast=head-&gt;next;\n    while(fast!=NULL &amp;&amp; fast-&gt;next!=NULL)\n    {\n        low=low-&gt;next;\n        fast=fast-&gt;next-&gt;next;\n        if(low==fast) return true;\n    }\n    return false;\n}\n\n\n</code></pre>\n<hr>\n<p>##48. 指针找错题</p>\n<p>分析这些面试题，本身包含很强的趣味性 ; 而作为一名研发人员，通过对这些面试题的深入剖析则可进一步增强自身的内功。<br>　　 2. 找错题 试题 1 ：<br>以下是引用片段：<br>void test1()  // 数组越界<br>　　 {<br>　　 char string[10];<br>　　 char<em> str1 = “0123456789”;<br>　　 strcpy( string, str1 );<br>　　 }<br>　　试题 2 ：　<br>以下是引用片段：<br>　 void test2()<br>　　 {<br>　　 char string[10], str1[10];<br>　　 int i;<br>　　 for(i=0; i&lt;10; i++)<br>　　 {<br>　　 str1= ‘a’;<br>　　 }<br>　　 strcpy( string, str1 );<br>　　 }<br>　　试题 3 ：　　<br>以下是引用片段：<br>void test3(char</em> str1)<br>　　 {<br>　　 char string[10];<br>　　 if( strlen( str1 ) &lt;= 10 )<br>　　 {<br>　　 strcpy( string, str1 );<br>　　 }<br>　　 }<br>　　解答：<br>　　试题 1 字符串 str1 需要 11 个字节才能存放下 ( 包括末尾的 ’/0’) ，而 string 只有 10 个字节的空间， strcpy会导致数组越界 ; 对试题 2 ，如果面试者指出字符数组 str1 不能在数组内结束可以给 3 分 ; 如果面试者指出strcpy(string,str1) 调用使得从 str1 内存起复制到 string 内存起所复制的字节数具有不确定性可以给 7 分，在此基础上指出库函数 strcpy 工作方式的给 10 分 ;<br>对试题 3 ， if(strlen(str1) &lt;= 10) 应改为 if(strlen(str1) &lt;10) ，因为 strlen 的结果未统计 ’/0’ 所占用的 1 个字节。剖析：考查对基本功的掌握<br>　　 (1) 字符串以 ’/0’ 结尾 ;<br>　　 (2) 对数组越界把握的敏感度 ;<br>　　 (3) 库函数 strcpy 的工作方式，</p>\n<hr>\n<p>##49. 如果编写一个标准 strcpy 函数</p>\n<p>总分值为 10 ，下面给出几个不同得分的答案： 2 分 以下是引用片段：<br>void strcpy( char <em>strDest, char </em>strSrc )<br>　　 {<br>　　 while( (<em>strDest++ = </em> strSrc++) != ‘/0’ );<br>　　 }<br>　　 4 分　以下是引用片段：<br>　 void strcpy( char <em>strDest, const char </em>strSrc )<br>　　 // 将源字符串加 const ，表明其为输入参数，加 2 分<br>　　 {<br>　　 while( (<em>strDest++ = </em> strSrc++) != ‘/0’ );<br>　　 }<br>　　 7 分 以下是引用片段：<br>void strcpy(char <em>strDest, const char </em>strSrc)<br>　　 {<br>　　 // 对源地址和目的地址加非 0 断言，加 3 分<br>　　 assert( (strDest != NULL) &amp;&amp;(strSrc != NULL) );<br>　　 while( (<em>strDest++ = </em> strSrc++) != ‘/0’ );<br>　　 }<br>　　 10 分 以下是引用片段：<br>// 为了实现链式操作，将目的地址返回，加 3 分 !<br>　　 char <em> strcpy( char </em>strDest, const char <em>strSrc )<br>　　 {<br>　　 assert( (strDest != NULL) &amp;&amp;(strSrc != NULL) );<br>　　 char </em>address = strDest;<br>　　 while( (<em>strDest++ = </em> strSrc++) != ‘/0’ );<br>　　 return address;<br>　　 }<br>　　从 2 分到 10 分的几个答案我们可以清楚的看到，小小的 strcpy 竟然暗藏着这么多玄机，真不是盖的 ! 需要多么扎实的基本功才能写一个完美的 strcpy 啊 !<br>　　 (4) 对 strlen 的掌握，它没有包括字符串末尾的 ‘/0’ 。<br>　　读者看了不同分值的 strcpy 版本，应该也可以写出一个 10 分的 strlen 函数了，完美的版本为： int strlen( const char <em>str ) // 输入参数 const 　以下是引用片段：<br>　 {<br>　　 assert( strt != NULL ); // 断言字符串地址非 0<br>　　 int len=0; // 注，一定要初始化。<br>　　 while( (</em>str++) != ‘/0’ )<br>　　 {<br>　　 len++;<br>　　 }<br>　　 return len;<br>　　 }<br>　　试题 4 ：以下是引用片段：<br>void GetMemory( char <em>p )<br>　　 {<br>　　 p = (char </em>) malloc( 100 );<br>　　 }<br>　　 void Test( void )<br>　　 {<br>　　 char <em>str = NULL;<br>　　 GetMemory( str );<br>　　 strcpy( str, “hello world” );<br>　　 printf( str );<br>　　 }<br>　　试题 5 ：　<br>以下是引用片段：<br>char </em>GetMemory( void )<br>　　 {<br>　　 char p[] = “hello world”;<br>　　 return p;<br>　　 }<br>　　 void Test( void )<br>　　 {<br>　　 char <em>str = NULL;<br>　　 str = GetMemory();<br>　　 printf( str );<br>　　 }<br>　　试题 6 ：以下是引用片段：<br>void GetMemory( char **p, int num )<br>　　 {\n　　 </em>p = (char <em>) malloc( num );<br>　　 }<br>　　 void Test( void )<br>　　 {<br>　　 char </em>str = NULL;<br>　　 GetMemory( &amp;str, 100 );<br>　　 strcpy( str, “hello” );<br>　　 printf( str );<br>　　 }<br>　　试题 7 ：以下是引用片段：<br>　 void Test( void )<br>　　 {<br>　　 char <em>str = (char </em>) malloc( 100 );<br>　　 strcpy( str, “hello” );<br>　　 free( str );<br>　　 … // 省略的其它语句<br>　　 }<br>　　解答：试题 4 传入中 GetMemory( char <em>p ) 函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的值，执行完<br>　　 char </em>str = NULL;<br>　　 GetMemory( str );<br>　　后的 str 仍然为 NULL; 试题 5 中<br>　　 char p[] = “hello world”;<br>　　 return p;<br>　　的 p[] 数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。<br>　　试题 6 的 GetMemory 避免了试题 4 的问题，传入 GetMemory 的参数为字符串指针的指针，但是在GetMemory 中执行申请内存及赋值语句 tiffanybracelets<br>　　 <em>p = (char </em>) malloc( num );<br>　　后未判断内存是否申请成功，应加上：<br>　　 if ( *p == NULL )<br>　　 {<br>　　 …// 进行申请内存失败处理 </p>\n<p>　　 }<br>　　试题 7 存在与试题 6 同样的问题，在执行<br>　　 char <em>str = (char </em>) malloc(100);<br>　　后未进行内存是否申请成功的判断 ; 另外，在 free(str) 后未置 str 为空，导致可能变成一个 “ 野 ” 指针，应加上：<br>　　 str = NULL;<br>　　试题 6 的 Test 函数中也未对 malloc 的内存进行释放。<br>　　剖析：<br>　　试题 4 ～ 7 考查面试者对内存操作的理解程度，基本功扎实的面试者一般都能正确的回答其中 50~60 的错误。但是要完全解答正确，却也绝非易事。</p>\n<p>软件开发网 <a href=\"http://www.mscto.com\" target=\"_blank\" rel=\"noopener\">www.mscto.com</a><br>　　对内存操作的考查主要集中在：<br>　　 (1) 指针的理解 ;<br>　　 (2) 变量的生存期及作用范围 ;<br>　　 (3) 良好的动态内存申请和释放习惯。<br>　　再看看下面的一段程序有什么错误：　　<br>以下是引用片段：<br>swap( int<em> p1,int</em> p2 )<br>　　 {<br>　　 int <em>p;\n　　 </em>p = <em>p1;\n　　 </em>p1 = <em>p2;\n　　 </em>p2 = <em>p;<br>　　 }<br>　　在 swap 函数中， p 是一个 “ 野 ” 指针，有可能指向系统区，导致程序运行的崩溃。在 VC++ 中 DEBUG 运行时提示错误 “Access Violation” 。该程序应该改为<br>以下是引用片段：<br>swap( int</em> p1,int<em> p2 )<br>　　 {<br>　　 int p;<br>　　 p = </em>p1;<br>　　 <em>p1 = </em>p2;<br>　　 *p2 = p;<br>　　 }</p>\n<hr>\n<p>##50.String 的具体实现</p>\n<p>已知 String 类定义如下： </p>\n<p>class String<br>{<br>public:<br>String(const char <em>str = NULL); // 通用构造函数<br>String(const String &amp;another); // 拷贝构造函数<br>~ String(); // 析构函数<br>String &amp; operater =(const String &amp;rhs); // 赋值函数<br>private:<br>char </em>m_data; // 用于保存字符串<br>};</p>\n<p>尝试写出类的成员函数实现。 </p>\n<p>答案：<br>String::String(const char *str)<br>{<br>if ( str == NULL ) //strlen 在参数为 NULL 时会抛异常才会有这步判断<br>{<br>m_data = new char[1] ;<br>m_data[0] = ‘/0’ ;<br>}<br>else<br>{<br>m_data = new char[strlen(str) + 1];<br>strcpy(m_data,str);<br>}</p>\n<p>} </p>\n<p>String::String(const String &amp;another)</p>\n<p>  {<br>m_data = new char[strlen(another.m_data) + 1];<br>strcpy(m_data,other.m_data);<br>}</p>\n<p>String&amp; String::operator =(const String &amp;rhs)<br>{<br>if ( this == &amp;rhs)<br>return <em>this ;<br>delete []m_data; // 删除原来的数据，新开一块内存<br>m_data = new char[strlen(rhs.m_data) + 1];<br>strcpy(m_data,rhs.m_data);<br>return </em>this ;<br>}</p>\n<p>String::~String()<br>{<br>delete []m_data ;<br>}</p>\n<hr>\n<p>##51.h 头文件中的 ifndef/define/endif 的作用？</p>\n<p>答：防止该头文件被重复引用。</p>\n<hr>\n<p>##52. ＃ i nclude&lt;file.h&gt; 与 ＃ i nclude “file.h” 的区别？</p>\n<p>答：前者是从 Standard Library 的路径寻找和引用 file.h ，而后者是从当前工作路径搜寻并引用 file.h 。 </p>\n<ol start=\"53\">\n<li>在 C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C” ？</li>\n</ol>\n<p>C++ 语言支持函数重载， C 语言不支持函数重载。 C++ 提供了 C 连接交换指定符号 extern “C”</p>\n<p>解决名字匹配问题。</p>\n<p>首先，作为 extern 是 C/C++ 语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。 </p>\n<p>通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字 extern 声明。例如，如果模块B 欲引用该模块 A 中定义的全局变量和函数时只需包含模块 A 的头文件即可。这样，模块 B 中调用模块 A 中的函数时，在编译阶段，模块 B 虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块 A 编译生成的目标代码中找到此函数 </p>\n<p>extern “C” 是连接申明 (linkage declaration), 被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和连接的 ,来看看 C++ 中对类似 C 的函数是怎样编译的： </p>\n<p>作为一种面向对象的语言， C++ 支持函数重载，而过程式语言 C 则不支持。函数被 C++ 编译后在符号库中的名字与 C 语言的不同。例如，假设某个函数的原型为： </p>\n<p>void foo( int x, int y );\n　　 </p>\n<p>该函数被 C 编译器编译后在符号库中的名字为 _foo ，而 C++ 编译器则会产生像 _foo_int_int 之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为 “mangled name” ）。 </p>\n<p>_foo_int_int 这样的名字包含了函数名、函数参数数量及类型信息， C++ 就是靠这种机制来实现函数重载的。例如，在 C++ 中，函数 void foo( int x, int y ) 与 void foo( int x, float y ) 编译生成的符号是不相同的，后者为_foo_int_float 。 </p>\n<p>同样地， C++ 中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以 “.” 来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。 </p>\n<p>未加 extern “C” 声明时的连接方式 </p>\n<p>假设在 C++ 中，模块 A 的头文件如下： </p>\n<p>// 模块 A 头文件　 moduleA.h</p>\n<p>#ifndef MODULE_A_H</p>\n<p>#define MODULE_A_H<br>int foo( int x, int y );</p>\n<p>#endif 　　 </p>\n<p>在模块 B 中引用该函数： </p>\n<p>// 模块 B 实现文件　 moduleB.cpp<br>＃ i nclude “moduleA.h”<br>foo(2,3);</p>\n<p>加 extern “C” 声明后的编译和连接方式 </p>\n<p>加 extern “C” 声明后，模块 A 的头文件变为： </p>\n<p>// 模块 A 头文件　 moduleA.h</p>\n<p>#ifndef MODULE_A_H</p>\n<p>#define MODULE_A_H<br>extern “C” int foo( int x, int y );</p>\n<p>#endif 　　 </p>\n<p>在模块 B 的实现文件中仍然调用 foo( 2,3 ) ，其结果是：<br>（ 1 ）模块 A 编译生成 foo 的目标代码时，没有对其名字进行特殊处理，采用了 C 语言的方式； </p>\n<p>（ 2 ）连接器在为模块 B 的目标代码寻找 foo(2,3) 调用时，寻找的是未经修改的符号名 _foo 。 </p>\n<p>如果在模块 A 中函数声明了 foo 为 extern “C” 类型，而模块 B 中包含的是 extern int foo( int x, int y ) ，则模块 B找不到模块 A 中的函数；反之亦然。 </p>\n<p>所以，可以用一句话概括 extern “C” 这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）：实现 C++ 与 C 及其它语言的混合编程。　　 </p>\n<p>明白了 C++ 中 extern “C” 的设立动机，我们下面来具体分析 extern “C” 通常的使用技巧： </p>\n<p>extern “C” 的惯用法 </p>\n<p>（ 1 ）在 C++ 中引用 C 语言中的函数和变量，在包含 C 语言头文件（假设为 cExample.h ）时，需进行下列处理： </p>\n<p>extern “C”<br>{<br>＃ i nclude “cExample.h”<br>}</p>\n<p>而在 C 语言的头文件中，对其外部函数只能指定为 extern 类型， C 语言中不支持 extern “C” 声明，在 .c 文件中包含了 extern “C” 时会出现编译语法错误。 </p>\n<p>C++ 引用 C 函数例子工程中包含的三个文件的源代码如下： </p>\n<p>/<em> c 语言头文件： cExample.h </em>/</p>\n<p>#ifndef C_EXAMPLE_H</p>\n<p>#define C_EXAMPLE_H<br>extern int add(int x,int y);</p>\n<p>#endif</p>\n<p>/<em> c 语言实现文件： cExample.c </em>/<br>＃ i nclude “cExample.h”<br>int add( int x, int y )<br>{<br>return x + y;<br>}</p>\n<p>// c++ 实现文件，调用 add ： cppFile.cpp<br>extern “C”<br>{<br>＃ i nclude “cExample.h”<br>}<br>int main(int argc, char* argv[])<br>{<br>add(2,3);<br>return 0;<br>}</p>\n<p>如果 C++ 调用一个 C 语言编写的 .DLL 时，当包括 .DLL 的头文件或声明接口函数时，应加 extern “C” { 　 } 。 </p>\n<p>（ 2 ）在 C 中引用 C++ 语言中的函数和变量时， C++ 的头文件需添加 extern “C” ，但是在 C 语言中不能直接引用声明了 extern “C” 的该头文件，应该仅将 C 文件中将 C++ 中定义的 extern “C” 函数声明为 extern 类型。 </p>\n<p>C 引用 C++ 函数例子工程中包含的三个文件的源代码如下： </p>\n<p>//C++ 头文件 cppExample.h</p>\n<p>#ifndef CPP_EXAMPLE_H</p>\n<p>#define CPP_EXAMPLE_H<br>extern “C” int add( int x, int y );</p>\n<p>#endif</p>\n<p>//C++ 实现文件 cppExample.cpp<br>＃ i nclude “cppExample.h”<br>int add( int x, int y )<br>{<br>return x + y;<br>}</p>\n<p>/<em> C 实现文件 cFile.c<br>/</em> 这样会编译出错：＃ i nclude “cExample.h” */</p>\n<p>int main( int argc, char* argv[] )<br>{<br>add( 2, 3 );<br>return 0;<br>}</p>\n<p>15 题目的解答请参考《 C++ 中 extern “C” 含义深层探索》注解：</p>\n<p>几道 c 笔试题 ( 含参考答案 )</p>\n<ol>\n<li>What is displayed when f() is called given the code:<br>class Number {<br>public:<br>string type; </li>\n</ol>\n<p>Number(): type( “ void ” ) { }<br>explicit Number(short) : type( “ short ” ) { }<br>Number(int) : type( “ int ” ) { }<br>};<br>void Show(const Number&amp; n) { cout &lt;&lt; n.type; }<br>void f()<br>{<br>short s = 42;<br>Show(s);<br>}<br>a) void<br>b) short<br>c) int<br>d) None of the above</p>\n<ol start=\"2\">\n<li>Which is the correct output for the following code<br>double dArray[2] = {4, 8}, <em>p, </em>q;<br>p = &amp;dArray[0];<br>q = p + 1;<br>cout &lt;&lt; q – p &lt;&lt; endl;<br>cout &lt;&lt; (int)q - (int)p &lt;&lt; endl;<br>a) 1 and 8<br>b) 8 and 4<br>c) 4 and 8<br>d) 8 and 1</li>\n</ol>\n<p>第一个选 C ；<br>虽然传入的是 short 类型，但是 short 类型的构造函数被生命被 explicit ，也就是只能显示类型转换，不能使用隐式类型转换。<br>第二个选 A ；<br>第一个是指针加减，按照的是指向地址类型的加减，只跟类型位置有关， q 和 p 指向的数据类型以实际数据类型来算差一个位置，因此是 1 。而第二个加减是实际指针值得加减，在内存中一个 double 类型占据 8 个字节，因此是 8</p>\n<p>54.Sony 笔试题</p>\n<p>　　 1 ．完成下列程序<br>　　 <em> \n　　 </em>.<em>. \n　　 </em>..<em>..</em>..<br>　　 <em>…</em>…<em>…</em>…<br>　　 <em>….</em>….<em>….</em>….<em>…. \n　　 </em>…..<em>…..</em>…..<em>…..</em>…..<em>….. \n　　 </em>……<em>……</em>……<em>……</em>……<em>……</em>……<br>　　 <em>…….</em>…….<em>…….</em>…….<em>…….</em>…….<em>…….</em>…….<br>　　 #include<br>　　 #define N 8<br>　　 int main()<br>　　 {<br>　　 int i;<br>　　 int j;<br>　　 int k;<br>　　 ———————————————————<br>　　 | |<br>　　 | |<br>　　 | |<br>　　 ———————————————————<br>　　 return 0;<br>　　 }<br>　　 2 ．完成程序，实现对数组的降序排序<br>　　 #include<br>　　 void sort( );<br>　　 int main()<br>　　 {<br>　　 int array[]={45 ， 56 ， 76 ， 234 ， 1 ， 34 ， 23 ， 2 ， 3} ； // 数字任 // 意给出<br>　　 sort( );<br>　　 return 0;<br>　　 }<br>　　 void sort( )<br>　　 {<br>　　 <strong><strong><strong><strong><strong><strong><strong><strong>____</strong></strong></strong></strong></strong></strong></strong></strong><br>　　 | |<br>　　 | |<br>　　 |—————————————————–|<br>　　 }<br>　　 3 ．费波那其数列， 1 ， 1 ， 2 ， 3 ， 5 ……编写程序求第十项。可以用递归，也可以用其<br>他方法，但要说明你选择的理由。<br>　　 #include<br>　　 int Pheponatch(int);<br>　　 int main()<br>　　 {<br>　　 printf(“The 10th is %d”,Pheponatch(10));<br>　　 return 0;<br>　　 }<br>　　 int Pheponatch(int N)<br>　　 {<br>　　 ——————————–<br>　　 | |<br>　　 | |<br>　　 ——————————–<br>　　 }<br>　　 4 ．下列程序运行时会崩溃，请找出错误并改正，并且说明原因。<br>　　 #include<br>　　 #include<br>　　 typedef struct{<br>　　 TNode<em> left;<br>　　 TNode</em> right;<br>　　 int value;<br>　　 } TNode;<br>　　 TNode<em> root=NULL;<br>　　 void append(int N);<br>　　 int main()<br>　　 {<br>　　 append(63);<br>　　 append(45);<br>　　 append(32);<br>　　 append(77);<br>　　 append(96);<br>　　 append(21);<br>　　 append(17); // Again, 数字任意给出<br>　　 }<br>　　 void append(int N)<br>　　 {<br>　　 TNode</em> NewNode=(TNode *)malloc(sizeof(TNode));<br>　　 NewNode-&gt;value=N; </p>\n<p>　　 if(root==NULL)<br>　　 {<br>　　 root=NewNode;<br>　　 return;<br>　　 }<br>　　 else<br>　　 {<br>　　 TNode* temp;<br>　　 temp=root; </p>\n<p>　　 while((N&gt;=temp.value &amp;&amp; temp.left!=NULL) || (N !=NULL<br>　　 ))<br>　　 {<br>　　 while(N&gt;=temp.value &amp;&amp; temp.left!=NULL)<br>　　 temp=temp.left;<br>　　 while(N 　　 temp=temp.right;<br>　　 }<br>　　 if(N&gt;=temp.value)<br>　　 temp.left=NewNode;<br>　　 else<br>　　 temp.right=NewNode;<br>　　 return;<br>　　 }<br>　　 } </p>\n<p>※ 来源 : ·哈工大紫丁香 <a href=\"http://bbs.hit.edu.cn\" target=\"_blank\" rel=\"noopener\">http://bbs.hit.edu.cn</a> · [FROM:219.217.233.47] </p>\n<p>────────────────────────────────────────<br>mengfd (Icebreaker) 于 (Sun Oct 23 14:59:59 2005) 说道 :</p>\n<p>55 请你分别画出 OSI 的七层网络结构图和 TCP/IP 的五层结构图。</p>\n<p>应用层：为应用程序提供服务</p>\n<p>表示层：处理在两个通信系统中交换信息的表示方式</p>\n<p>会话层：负责维护两个结点间会话连接的建立、管理和终止，以及数据交换</p>\n<p>传输层：向用户提供可靠的端到端服务。 UDP TCP 协议。</p>\n<p>网络层：通过路由选择算法为分组通过通信子网选择最适当的路径，以及实现拥塞控制、网络互联等功能。数据传输单元是分组。 IP 地址，路由器， IP 协议。</p>\n<p>数据链路层：在物理层提供的服务基础上，数据链路层在通信的实体间建立数据链路连接，传输一帧为单位的数据包（，并采用差错控制与流量控制方法，使有差错的物理线路变成无差错的数据链路。）</p>\n<p>物理层：传输比特流。传输单元是比特。调制解调器。</p>\n<p>TCP/IP详解学习笔记(1)-基本概念</p>\n<p>56 请你详细地解释一下 IP 协议的定义，在哪个层上面？主要有什么作用？ TCP 与 UDP 呢 ？</p>\n<p>网络层。</p>\n<ol start=\"57\">\n<li>请问交换机和路由器各自的实现原理是什么？分别在哪个层次上面实现的？</li>\n</ol>\n<p>交换机：数据链路层。路由器：网络层。</p>\n<ol start=\"58\">\n<li>全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的 ？</li>\n</ol>\n<p>59.8086 是多少位的系统？在数据总线上是怎么实现的？ </p>\n<p>8086 微处理器共有 4 个 16 位的段寄存器，在寻址内存单元时，用它们直接或间接地存放段地址。</p>\n<p>　　代码段寄存器 CS ：存放当前执行的程序的段地址。</p>\n<p>　　数据段寄存器 DS ：存放当前执行的程序所用操作数的段地址。</p>\n<p>　　堆栈段寄存器 SS ：存放当前执行的程序所用堆栈的段地址。</p>\n<p>　　附加段寄存器 ES ：存放当前执行程序中一个辅助数据段的段地址。</p>\n<p>由 cs:ip 构成指令地址， ss:sp 构成堆栈的栈顶地址指针。 DS 和 ES 用作数据段和附加段的段地址（段起始地址或段值）</p>\n<p>8086 ／ 8088 微处理器的存储器管理</p>\n<ol>\n<li><p>地址线（码）与寻址范围： N 条地址线      寻址范围 =2N</p>\n<p>2.8086 有 20 地址线      寻址范围为 1MB  由 00000H ～ FFFFFH</p>\n</li>\n<li><p>8086 微处理器是一个 16 位结构，用户可用的寄存器均为 16 位：寻址 64KB</p>\n</li>\n<li><p>8086 ／ 8088 采用分段的方法对存储器进行管理。具体做法是：把 1MB 的存储器空间分成若干段，每段容量为 64KB ，每段存储器的起始地址必须是一个能被 16 整除的地址码，即在 20 位的二进制地址码中最低 4 位必须是 “0” 。每个段首地址的高 16 位二进制代码就是该段的段号 ( 称段基地址 ) 或简称段地址，段号保存在段寄存器中。我们可对段寄存器设置不同的值来使微处理器的存储器访问指向不同的段。</p>\n</li>\n<li><p>段内的某个存储单元相对于该段段首地址的差值，称为段内偏移地址 ( 也叫偏移量 ) 用 16 位二进制代码表示。</p>\n</li>\n<li><p>物理地址是由 8086 ／ 8088 芯片地址引线送出的 20 位地址码，它用来参加存储器的地址译码，最终读／写所访问的一个特定的存储单元。</p>\n</li>\n<li><p>逻辑地址由某段的段地址和段内偏移地址 ( 也叫偏移量 ) 两部分所组成。写成：</p>\n<p>段地址：偏移地址 ( 例如， 1234H ： 0088H) 。</p>\n</li>\n<li><p>在硬件上起作用的是物理地址，物理地址＝段基地址 ×10H 十偏移地址</p>\n</li>\n</ol>\n<p>联想笔试题<br>　　 1 ．设计函数 int atoi(char *s) 。<br>　　 2 ． int i=(j=4,k=8,l=16,m=32); printf( “ %d ” , i); 输出是多少？ </p>\n<ol start=\"60\">\n<li>解释局部变量、全局变量和静态变量的含义。</li>\n</ol>\n<p>　　 4 ．解释堆和栈的区别。</p>\n<ol start=\"61\">\n<li>论述含参数的宏与函数的优缺点。 </li>\n</ol>\n<p>普天 C++ 笔试题<br>　　 1 ．实现双向链表删除一个节点 P ，在节点 P 后插入一个节点，写出这两个函数。<br>　　 2 ．写一个函数，将其中的 /t 都转换成 4 个空格。</p>\n<p>61.Windows 程序的入口是哪里？写出 Windows 消息机制的流程。 </p>\n<p>4 ．如何定义和实现一个类的成员函数为回调函数？</p>\n<p>62.C++ 里面是不是所有的动作都是 main() 引起的？如果不是，请举例。 \n　　</p>\n<p>6 ． C++ 里面如何声明 const void f(void) 函数为 C 程序中的库函数？<br>　　 7 ．下列哪两个是等同的<br>　　 int b;<br>　　 A const int<em> a = &b;<br>　　 B const</em> int a = &b;<br>　　 C const int<em> const a = &b;<br>　　 D int const</em> const a = &b;<br>　　 8 ．内联函数在编译时是否做参数类型检查？<br>　　 void g(base &amp; b){<br>　　 b.play;<br>　　 }<br>　　 void main(){<br>　　 son s;<br>　　 g(s);<br>　　 return;<br>　　 } </p>\n<p>※ 来源 : ·哈工大紫丁香 <a href=\"http://bbs.hit.edu.cn\" target=\"_blank\" rel=\"noopener\">http://bbs.hit.edu.cn</a> · [FROM:219.217.233.47] </p>\n<p>────────────────────────────────────────<br>mengfd (Icebreaker) 于 (Sun Oct 23 15:00:14 2005) 说道 : </p>\n<p>大唐电信<br>　　 DTT 笔试题<br>　　考试时间一小时，第一部分是填空和选择：<br>　　 1 ．数列 6 ， 10 ， 18 ， 32 ，“？”，问“？”是几？<br>　　 2 ．某人出 70 买进一个 x ， 80 卖出， 90 买回， 100 卖出，这桩买卖怎么样？<br>　　 3 ．月球绕地球一圈，至少要多少时间？<br>　　 4 ． 7 个人用 7 小时挖了 7 米 的沟，以同样的速度在 50 小时挖 50 米 的沟要多少人？<br>　　 5 ．鱼头长 9 ，鱼尾等于鱼头加半个鱼身，鱼身等于鱼头加鱼尾，问鱼全长多少？<br>　　 6 ．一个小姐买了一块手表，回家发现手表比她家的表慢了两分钟，晚上看新闻的时候<br>又发现她家的表比新闻里的时间慢了两分钟，则 。<br>　　 A 手表和新闻里的时间一样<br>　　 B 手表比新闻里的时间慢<br>　　 C 手表比新闻里的时间快<br>　　 7 ．王先生看到一则招聘启事，发现两个公司除了以下条件不同外，其他条件都相同 </p>\n<p>　　 A 半年年薪 50 万，每半年涨 5 万<br>　　 B 一年年薪 100 万，每一年涨 20 万<br>　　王先生想去一家待遇比较优厚的公司，他会去哪家？<br>　　 10 ．问哪个袋子里有金子？<br>　　 A 袋子上的标签是这样写的： B 袋子上的话是对的，金子在 A 袋子。<br>　　 B 袋子上的标签是这样写的： A 袋子上的话是错的，金子在 A 袋子里。<br>　　 11 ． 3 个人住酒店 30 块钱，经理找回 5 块钱，服务生从中藏了 2 块钱，找给每人 1 块钱，<br>3 ×（ 101 ） +2=29 ，问这是怎么回事？<br>　　 12 ．三篇写作，均为书信形式。<br>　　（ 1 ）一片中文的祝贺信，祝贺某男当了某公司 xx<br>　　（ 2 ）两篇英文的，一是说有事不能应邀，派别人去；另一篇是讨债的， 7 天不给钱就<br>走人（主要考 business letter 格式）。<br>　　大唐面试试题<br>　　 1 ．什么是中断？中断发生时 CPU 做什么工作？<br>　　 2 ． CPU 在上电后，进入操作系统的 main() 之前必须做什么工作？<br>　　 3 ．简述 ISO OSI 的物理层 Layer1 ，链路层 Layer2 ，网络层 Layer3 的任务。<br>　　 4 ．有线电话和无线电话有何区别？无线电话特别需要注意的是什么？ \n　　</p>\n<ol start=\"63\">\n<li>软件开发五个主要 step 是什么？</li>\n</ol>\n<p>　　 6 ．你在开发软件的时候，这 5 个 step 分别占用的时间百分比是多少？<br>　　 7 ． makefile 文件的作用是什么？<br>　　 8 ． UNIX 显示文件夹中，文件名的命令是什么？能使文件内容显示在屏幕的命令是什么<br>？<br>　　 9 ．（选做）手机用户在从一个基站漫游到另一个基站的过程中，都会发生什么 ? </p>\n<p>※ 来源 : ·哈工大紫丁香 <a href=\"http://bbs.hit.edu.cn\" target=\"_blank\" rel=\"noopener\">http://bbs.hit.edu.cn</a> · [FROM:219.217.233.47] </p>\n<p>────────────────────────────────────────<br>mengfd (Icebreaker) 于 (Sun Oct 23 15:01:22 2005) 说道 : </p>\n<p>网通笔试题<br>　　选择题（每题 5 分，只有一个正确答案）<br>　　 1 ．中国 1 号信令协议属于 的协议。<br>　　 A ccs B cas C ip D atm<br>　　 2 ． isdnpri 协议全称是 。<br>　　 A 综合业务模拟网基速协议<br>　　 B 综合业务模拟网模拟协议<br>　　 C 综合业务数字网基率协议<br>　　 D 综合业务数字网基次协议<br>　　 3 ．路由协议中， 协议是用距离作为向量的。<br>　　 A ospf B bgp C is-is D rip<br>　　 4 ．中国智能网中， ssp 与 scp 间最上层的 ss7 协议是 。<br>　　 A incs B is41b C is41c D inap<br>　　 5 ． dtmf 全称是 。<br>　　 A 双音多频 B 多音双频 C 多音三频 D 三音多频<br>　　 6 ．计算机的基本组成部分中，不包含下面设备的是 。<br>　　 A cpu B 输入设备 C 存储器 D 接口<br>　　 7 ．脉冲编码调制的简称是 。<br>　　 A pcm B pam C (delta)M D atm<br>　　 8 ．普通电话线接口专业称呼是 。<br>　　 A rj11 B rj45 C rs232 D bnc<br>　　 9 ．现有的公共数据网都采用 。<br>　　 A 电路交换技术 B 报文交换技术<br>　　 C 语音插空 D 分组交换<br>　　 10 ． ss7 协议中的制止市忙消息简写为 。<br>　　 A stb B slb C sub D spb<br>　　简答题（每题 10 分）<br>　　 1 ．简述普通电话与 IP 电话的区别。<br>　　 2 ．简述随路信令与公路信令的根本区别。<br>　　 3 ．说明掩码的主要作用。<br>　　 4 ． ss7 协议中，有三大要素决定其具体定位，哪三大要素？<br>　　 5 ．描述 ss7 的基本通话过程。<br>　　 6 ．简述通信网的组成结构。<br>　　 7 ．面向连接与面向非连接各有何利弊？<br>　　 8 ．写出爱尔兰的基本计算公式。<br>　　 9 ．数据网主要有哪些设备？<br>　　 10 ．中国一号协议是如何在被叫号码中插入主叫号码的？ </p>\n<p>东信笔试题目<br>　　笔试： 30 分钟。<br>　　 1 ．压控振荡器的英文缩写。<br>　　 2 ．动态随机存储器的英文缩写。<br>　　 3 ．选择电阻时要考虑什么？<br>　　 4 ．单片机上电后没有运转，首先要检查什么？<br>　　 5 ．计算机的基本组成部分及其各自的作用。<br>　　 6 ．怎样用 D 触发器、与或非门组成二分频电路？</p>\n<p>64.static 有什么用途？（请至少说明两种）</p>\n<p>答 、 1. 限制变量的作用域 ( 文件级的 ) 。</p>\n<ol start=\"2\">\n<li>设置变量的存储域 ( 全局数据区 ) 。</li>\n</ol>\n<ol start=\"65\">\n<li>引用与指针有什么区别？</li>\n</ol>\n<p>答 、 1) 引用必须被初始化，指针不必。</p>\n<p>2) 引用初始化以后不能被改变，指针可以改变所指的对象。</p>\n<p>3) 不存在指向空值的引用，但是存在指向空值的指针。</p>\n<ol start=\"66\">\n<li>描述实时系统的基本特性</li>\n</ol>\n<p>答 、在特定时间内完成特定的任务，实时性与可靠性。</p>\n<ol start=\"67\">\n<li>全局变量和局部变量在内存中是否有区别？如果有，是什么区别？</li>\n</ol>\n<p>答 、全局变量储存在静态数据区，局部变量在堆栈中。</p>\n<ol start=\"68\">\n<li>什么是平衡二叉树？</li>\n</ol>\n<p>答 、左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于 1 。</p>\n<ol start=\"69\">\n<li>堆栈溢出一般是由什么原因导致的？</li>\n</ol>\n<p>答 、 1. 没有回收垃圾资源</p>\n<pre><code>     2. 层次太深的递归调用      \n</code></pre><ol start=\"70\">\n<li>什么函数不能声明为虚函数？</li>\n</ol>\n<p>答 、 constructor</p>\n<pre><code>   Deconstructor 可以声明为虚函数。\n\n   系统为一个空类创建的成员函数有那些。\n</code></pre><ol start=\"71\">\n<li>冒泡排序算法的时间复杂度是什么？</li>\n</ol>\n<p>答 、 O(n^2)</p>\n<ol start=\"72\">\n<li>写出 float x 与“零值”比较的 if 语句。</li>\n</ol>\n<p>答 、 if(x&gt;0.000001&amp;&amp;x&lt;-0.000001)</p>\n<p>73.Internet 采用哪种网络协议？该协议的主要层次结构？</p>\n<p>答 、 tcp/ip 应用层 / 传输层 / 网络层 / 数据链路层 / 物理层</p>\n<p>74.Internet 物理地址和 IP 地址转换采用什么协议？</p>\n<p>答 、 ARP (Address Resolution Protocol) （地址解析协议）</p>\n<p>75.IP 地址的编码分为哪俩部分？</p>\n<p>答 、 IP 地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与之后才能区分哪些是网络位哪些是主机位。</p>\n<ol start=\"76\">\n<li>用户输入 M,N 值，从 1 至 N 开始顺序循环数数，每数到 M 输出该数值，直至全部输出。写出 C 程序。</li>\n</ol>\n<p>答 、循环链表，用取余操作做</p>\n<ol start=\"77\">\n<li>不能做 switch() 的参数类型是：</li>\n</ol>\n<p>答 、 switch 的参数不能为实型。</p>\n<p>华为</p>\n<ol start=\"78\">\n<li>局部变量能否和全局变量重名？</li>\n</ol>\n<p>答、能，局部会屏蔽全局。要用全局变量，需要使用 “::”</p>\n<p>局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内</p>\n<ol start=\"79\">\n<li>如何引用一个已经定义过的全局变量？</li>\n</ol>\n<p>答 、可以用引用头文件的方式，也可以用 extern 关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用 extern 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错</p>\n<ol start=\"80\">\n<li>全局变量可不可以定义在可被多个 .C 文件包含的头文件中？为什么？</li>\n</ol>\n<p>答 、可以，在不同的 C 文件中以 static 形式来声明同名全局变量。</p>\n<p>可以在不同的 C 文件中声明同名的全局变量，前提是其中只能有一个 C 文件中对此变量赋初值，此时连接不会出错</p>\n<ol start=\"81\">\n<li>语句 for( ； 1 ； ) 有什么问题？它是什么意思？</li>\n</ol>\n<p>答 、和 while(1) 相同。</p>\n<p>82.do …… while 和 while …… do 有什么区别？</p>\n<p>答 、前一个循环一遍再判断，后一个判断以后再循环</p>\n<ol start=\"83\">\n<li>请写出下列代码的输出内容</li>\n</ol>\n<p>#i nclude</p>\n<p>main()</p>\n<p>{</p>\n<p>int a,b,c,d;</p>\n<p>a=10;</p>\n<p>b=a++;</p>\n<p>c=++a;</p>\n<p>d=10*a++;</p>\n<p>printf(“b ， c ， d ： %d ， %d ， %d” ， b ， c ， d ） ;</p>\n<p>return 0;</p>\n<p>}</p>\n<p>答 、 10 ， 12 ， 120</p>\n<p>84.statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数</p>\n<p>static 全局变量与普通的全局变量有什么区别？ static 局部变量和普通局部变量有什么区别？ static 函数与普通函数有什么区别？</p>\n<p>答 、全局变量 ( 外部变量 ) 的说明之前再冠以 static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。</p>\n<p>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。</p>\n<p>static 函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数 (static) ，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件</p>\n<p>static 全局变量与普通的全局变量有什么区别： static 全局变量只初使化一次，防止在其他文件单元中被引用 ;</p>\n<p>static 局部变量和普通局部变量有什么区别： static 局部变量只被初始化一次，下一次依据上一次结果值；</p>\n<p>static 函数与普通函数有什么区别： static 函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</p>\n<p>程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。</p>\n<ol start=\"85\">\n<li>设有以下说明和定义：</li>\n</ol>\n<p>typedef union {long i; int k[5]; char c;} DATE;</p>\n<p>struct data { int cat; DATE cow; double dog;} too;</p>\n<p>DATE max;</p>\n<p>则语句 printf(“%d”,sizeof(struct date)+sizeof(max)); 的执行结果是？</p>\n<p>答 、结果是： <strong>_52__</strong> 。 DATE 是一个 union, 变量公用空间 . 里面最大的变量类型是 int[5], 占用 20 个字节. 所以它的大小是 20</p>\n<p>data 是一个 struct, 每个变量分开占用空间 . 依次为 int4 + DATE20 + double8 = 32.</p>\n<p>所以结果是 20 + 32 = 52.</p>\n<p>当然 … 在某些 16 位编辑器下 , int 可能是 2 字节 , 那么结果是 int2 + DATE10 + double8 = 20</p>\n<p>86.-1,2,7,28,,126 请问 28 和 126 中间那个数是什么？为什么？</p>\n<p>答 、应该是 4^3-1=63</p>\n<p>规律是 n^3-1( 当 n 为偶数 0 ， 2 ， 4)</p>\n<p>n^3+1( 当 n 为奇数 1 ， 3 ， 5)</p>\n<ol start=\"87\">\n<li>用两个栈实现一个队列的功能？要求给出算法和思路！</li>\n</ol>\n<p>答 、设 2 个栈为 A,B, 一开始均为空 .</p>\n<p>入队 :</p>\n<p>将新元素 push 入栈 A;</p>\n<p>出队 :</p>\n<p>(1) 判断栈 B 是否为空；</p>\n<p>(2) 如果不为空，则将栈 A 中所有元素依次 pop 出并 push 到栈 B ；</p>\n<p>(3) 将栈 B 的栈顶元素 pop 出；</p>\n<p>这样实现的队列入队和出队的平摊复杂度都还是 O(1), 比上面的几种方法要好。</p>\n<ol start=\"88\">\n<li>在 c 语言库函数中将一个字符转换成整型的函数是atool() 吗，这个函数的原型是什么？</li>\n</ol>\n<p>答 、函数名 : atol</p>\n<p>功 能 : 把字符串转换成长整型数</p>\n<p>用 法 : long atol(const char *nptr);</p>\n<p>程序例 :</p>\n<p>＃ include</p>\n<p>＃ include</p>\n<p>int main(void)</p>\n<p>{</p>\n<pre><code>long l;\n\nchar *str = &quot;98765432&quot;;\n\nl = atol(lstr);\n\nprintf(&quot;string = %s integer = %ld/n&quot;, str, l);\n\nreturn(0);\n</code></pre><p>}</p>\n<ol start=\"89\">\n<li>对于一个频繁使用的短小函数 , 在 C 语言中应用什么实现 , 在 C++ 中应用什么实现 ?</li>\n</ol>\n<p>答 、 c 用宏定义， c++ 用 inline</p>\n<ol start=\"90\">\n<li>用预处理指令 #define 声明一个常数，用以表明 1年中有多少秒（忽略闰年问题）</li>\n</ol>\n<p>#define SECONDS_PER_YEAR (60 <em> 60 </em> 24 * 365)UL</p>\n<p>我在这想看到几件事情：</p>\n<p>1). #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）</p>\n<p>2). 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。</p>\n<p>3). 意识到这个表达式将使一个 16 位机的整型数溢出 - 因此要用到长整型符号 L, 告诉编译器这个常数是的长整型数。</p>\n<p>4). 如果你在你的表达式中用到 UL （表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。</p>\n<ol start=\"91\">\n<li>写一个“标准”宏 MIN ，这个宏输入两个参数并返回较小的一个。</li>\n</ol>\n<p>#define MIN(A,B) ((A) &lt;= (B) (A) : (B))</p>\n<p>这个测试是为下面的目的而设的：</p>\n<p>1). 标识 #define 在宏中应用的基本知识。这是很重要的，因为直到嵌入 (inline) 操作符变为标准 C 的一部分，宏是方便产生嵌入代码的唯一方法，</p>\n<p>对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。</p>\n<p>2). 三重条件操作符的知识。这个操作符存在 C 语言中的原因是它使得编译器能产生比 if-then-else 更优化的代码，了解这个用法是很重要的。</p>\n<p>3). 懂得在宏中小心地把参数用括号括起来</p>\n<p>4). 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？</p>\n<p>least = MIN(*p++, b);</p>\n<ol start=\"92\">\n<li>预处理器标识 #error 的目的是什么？</li>\n</ol>\n<p>如果你不知道答案，请看参考文献 1 。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读 C 语言课本的附录去找出象这种</p>\n<p>问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。</p>\n<p>死循环（ Infinite loops ）</p>\n<ol start=\"93\">\n<li>嵌入式系统中经常要用到无限循环，你怎么样用 C编写死循环呢？</li>\n</ol>\n<p>这个问题用几个解决方案。我首选的方案是：</p>\n<p>while(1)</p>\n<p>{</p>\n<p>}</p>\n<p>一些程序员更喜欢如下方案：</p>\n<p>for(;;)</p>\n<p>{</p>\n<p>}</p>\n<p>这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的</p>\n<p>基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。</p>\n<p>第三个方案是用 goto</p>\n<p>Loop :</p>\n<p>…</p>\n<p>goto Loop;</p>\n<p>应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN 程序员。</p>\n<p>数据声明（ Data declarations ）</p>\n<ol start=\"94\">\n<li>用变量 a 给出下面的定义</li>\n</ol>\n<p>a) 一个整型数（ An integer ）</p>\n<p>b) 一个指向整型数的指针（ A pointer to an integer ）</p>\n<p>c) 一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an integer ）</p>\n<p>d) 一个有 10 个整型数的数组（ An array of 10 integers ）</p>\n<p>e) 一个有 10 个指针的数组，该指针是指向一个整型数的（ An array of 10 pointers to integers ）</p>\n<p>f) 一个指向有 10 个整型数数组的指针（ A pointer to an array of 10 integers ）</p>\n<p>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（ A pointer to a function that takes an integer as an argument and returns an integer ）</p>\n<p>h) 一个有 10 个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer</p>\n<p>argument and return an integer ）</p>\n<p>答案是：</p>\n<p>a) int a; // An integer</p>\n<p>b) int *a; // A pointer to an integer</p>\n<p>c) int **a; // A pointer to a pointer to an integer</p>\n<p>d) int a[10]; // An array of 10 integers</p>\n<p>e) int *a[10]; // An array of 10 pointers to integers</p>\n<p>f) int (*a)[10]; // A pointer to an array of 10 integers</p>\n<p>g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer</p>\n<p>h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer</p>\n<p>人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。</p>\n<p>但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道</p>\n<p>所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？</p>\n<p>Static</p>\n<ol start=\"95\">\n<li>关键字 static 的作用是什么？</li>\n</ol>\n<p>这个简单的问题很少有人能回答完全。在 C 语言中，关键字 static 有三个明显的作用：</p>\n<p>1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。</p>\n<p>2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。</p>\n<p>3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。</p>\n<p>大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数</p>\n<p>据和代码范围的好处和重要性。</p>\n<p>Const</p>\n<ol start=\"96\">\n<li>关键字 const 是什么含意？</li>\n</ol>\n<p>我只要一听到被面试者说：“ const 意味着常数”，我就知道我正在和一个业余者打交道。去年 Dan Saks 已经在他的文章里完全概括了 const 的所有用法，因此 ESP( 译者： Embedded Systems Programming) 的每一位读者应该非常熟悉 const 能做什么和不能做什么 . 如果你从没有读到那篇文章，只要能说出 const 意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下 Saks 的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？</p>\n<p>const int a;</p>\n<p>int const a;</p>\n<p>const int *a;</p>\n<p>int * const a;</p>\n<p>int const * a const;</p>\n<p>前两个的作用是一样， a 是一个常整型数。第三个意味着 a 是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思 a 是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着 a 是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const ，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字 const 呢？我也如下的几下理由：</p>\n<p>1). 关键字 const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用 const 的程序员很少会留下的垃圾让别人来清理的。）</p>\n<p>2). 通过给优化器一些附加的信息，使用关键字 const 也许能产生更紧凑的代码。</p>\n<p>3). 合理地使用关键字 const 可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少 bug 的出现。</p>\n<p>Volatile</p>\n<ol start=\"97\">\n<li>关键字 volatile 有什么含意 并给出三个不同的例子。</li>\n</ol>\n<p>一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是 volatile 变量的几个例子：</p>\n<p>1). 并行设备的硬件寄存器（如：状态寄存器）</p>\n<p>2). 一个中断服务子程序中会访问到的非自动变量 (Non-automatic variables)</p>\n<p>3). 多线程应用中被几个任务共享的变量</p>\n<p>回答不出这个问题的人是不会被雇佣的。我认为这是区分 C 程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、 RTOS 等等打交道，所用这些都要求 volatile 变量。不懂得 volatile 内容将会带来灾难。</p>\n<p>假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得 volatile 完全的重要性。</p>\n<p>1). 一个参数既可以是 const 还可以是 volatile 吗？解释为什么。</p>\n<p>2). 一个指针可以是 volatile 吗？解释为什么。</p>\n<p>3). 下面的函数有什么错误：</p>\n<p>int square(volatile int *ptr)</p>\n<p>{</p>\n<p>return <em>ptr </em> *ptr;</p>\n<p>}</p>\n<p>下面是答案：</p>\n<p>1). 是的。一个例子是只读的状态寄存器。它是 volatile 因为它可能被意想不到地改变。它是 const 因为程序不应该试图去修改它。</p>\n<p>2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个 buffer 的指针时。</p>\n<p>3). 这段代码的有个恶作剧。这段代码的目的是用来返指针 <em>ptr 指向值的平方，但是，由于 </em>ptr 指向一个 volatile型参数，编译器将产生类似下面的代码：</p>\n<p>int square(volatile int *ptr)</p>\n<p>{</p>\n<p>int a,b;</p>\n<p>a = *ptr;</p>\n<p>b = *ptr;</p>\n<p>return a * b;</p>\n<p>}</p>\n<p>由于 *ptr 的值可能被意想不到地该变，因此 a 和 b 可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：</p>\n<p>long square(volatile int *ptr)</p>\n<p>{</p>\n<p>int a;</p>\n<p>a = *ptr;</p>\n<p>return a * a;</p>\n<p>}</p>\n<p>位操作（ Bit manipulation ）</p>\n<ol start=\"98\">\n<li>下面的代码输出是什么，为什么？</li>\n</ol>\n<p>void foo(void)</p>\n<p>{</p>\n<p>unsigned int a = 6;</p>\n<p>int b = -20;</p>\n<p>(a+b &gt; 6) puts(“&gt; 6”) : puts(“&lt;= 6”);</p>\n<p>}</p>\n<p>这个问题测试你是否懂得 C 语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是“ &gt;6 ”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此 -20 变成了一个非常大的正整数，所以该表达式计算出的结果大于 6 。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。</p>\n<p>99.C 语言同意一些令人震惊的结构 , 下面的结构是合法的吗，如果是它做些什么？</p>\n<p>int a = 5, b = 7, c;</p>\n<p>c = a+++b;</p>\n<p>这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：</p>\n<p>c = a++ + b;</p>\n<p>因此 , 这段代码持行后 a = 6, b = 7, c = 12 。</p>\n<p>如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是 : 这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题</p>\n<p>今天早上的面试题 9 道，比较难，</p>\n<ol start=\"100\">\n<li>线形表 a 、 b 为两个有序升序的线形表，编写一程序，使两个有序线形表合并成一个有序升序线形表 h；</li>\n</ol>\n<p>答案在 请化大学 严锐敏《数据结构第二版》第二章例题，数据结构当中，这个叫做：两路归并排序</p>\n<p>Linklist <em>unio(Linklist </em>p,Linklist *q){</p>\n<p>linklist <em>R,</em>pa,<em>qa,</em>ra;</p>\n<p>pa=p;</p>\n<p>qa=q;</p>\n<p>R=ra=p;</p>\n<p>while(pa-&gt;next!=NULL&amp;&amp;qa-&gt;next!=NULL){</p>\n<p>if(pa-&gt;data&gt;qa-&gt;data){</p>\n<p>ra-&gt;next=qa;</p>\n<p>qa=qa-&gt;next;</p>\n<p>}</p>\n<p>else{</p>\n<p>ra-&gt;next=pa;</p>\n<p>pa=pa-&gt;next;</p>\n<p>}</p>\n<p>}</p>\n<p>if(pa-&gt;next!=NULL)</p>\n<p>ra-&gt;next=pa;</p>\n<p>if(qa-&gt;next!=NULL)</p>\n<p>ra-&gt;next==qa;</p>\n<p>return R;</p>\n<p>}</p>\n<ol start=\"101\">\n<li>用递归算法判断数组 a[N] 是否为一个递增数组。</li>\n</ol>\n<p>递归的方法，记录当前最大的，并且判断当前的是否比这个还大，大则继续，否则返回 false 结束：</p>\n<p>bool fun( int a[], int n )</p>\n<p>{</p>\n<p>if( n= =1 )</p>\n<p>return true;</p>\n<p>if( n= =2 )</p>\n<p>return a[n-1] &gt;= a[n-2];</p>\n<p>return fun( a,n-1) &amp;&amp; ( a[n-1] &gt;= a[n-2] );</p>\n<p>}</p>\n<ol start=\"102\">\n<li>编写算法，从 10 亿个浮点数当中，选出其中最大的 10000 个。</li>\n</ol>\n<p>用外部排序，在《数据结构》书上有《计算方法导论》在找到第 n 大的数的算法上加工</p>\n<ol start=\"103\">\n<li>编写一 unix 程序，防止僵尸进程的出现 .</li>\n</ol>\n<p>同学的 4 道面试题，应聘的职位是搜索引擎工程师，后两道超级难，（希望大家多给一些算发）</p>\n<ol>\n<li>给两个数组和他们的大小，还有一动态开辟的内存，求交集，把交集放到动态内存 dongtai ，并且返回交集个数</li>\n</ol>\n<p>long jiaoji(long<em> a[],long b[],long</em> alength,long blength,long* dongtai[])</p>\n<ol start=\"2\">\n<li>单连表的建立，把 ‘a’–’z’26 个字母插入到连表中，并且倒叙，还要打印！</li>\n</ol>\n<p>方法 1 ：</p>\n<p>typedef struct val</p>\n<p>{   int date_1;</p>\n<pre><code>struct val *next;\n</code></pre><p>}*p;</p>\n<p>void main(void)</p>\n<p>{   char c;</p>\n<pre><code>for(c=122;c&gt;=97;c--)\n\n   { p.date=c;\n\n      p=p-&gt;next;\n\n    }\n\n\n\np.next=NULL;\n</code></pre><p>}</p>\n<p>}</p>\n<p>方法 2 ：</p>\n<p>node *p = NULL;</p>\n<p>node *q = NULL;</p>\n<p>node <em>head = (node</em>)malloc(sizeof(node));</p>\n<p>head-&gt;data = ‘ ‘;head-&gt;next=NULL;</p>\n<p>node <em>first = (node</em>)malloc(sizeof(node));</p>\n<p>first-&gt;data = ‘a’;first-&gt;next=NULL;head-&gt;next = first;</p>\n<p>p = first;</p>\n<p>int longth = ‘z’ - ‘b’;</p>\n<p>int i=0;</p>\n<p>while ( i&lt;=longth )</p>\n<p>{</p>\n<p>node <em>temp = (node</em>)malloc(sizeof(node));</p>\n<p>temp-&gt;data = ‘b’+i;temp-&gt;next=NULL;q=temp;</p>\n<p>head-&gt;next = temp; temp-&gt;next=p;p=q;</p>\n<p>i++;</p>\n<p>}</p>\n<p>print(head);</p>\n<ol start=\"104\">\n<li>可怕的题目终于来了</li>\n</ol>\n<p>象搜索的输入信息是一个字符串，统计 300 万输入信息中的最热门的前十条，我们每次输入的一个字符串为不超过 255byte, 内存使用只有 1G ,</p>\n<p>请描述思想，写出算发（ c 语言），空间和时间复杂度，</p>\n<ol start=\"7\">\n<li>国内的一些帖吧，如 baidu, 有几十万个主题，假设每一个主题都有上亿的跟帖子，怎么样设计这个系统速度最好，请描述思想，写出算发（ c 语言），空间和时间复杂度，</li>\n</ol>\n<p>#include   string.h</p>\n<p>main(void)</p>\n<p>{   char   *src=”hello,world”;</p>\n<pre><code>char   *dest=NULL;\n\ndest=(char    *)malloc(strlen(src));\n\nint   len=strlen(str);\n\nchar   *d=dest;\n\nchar   *s=src[len];\n\nwhile(len--!=0)\n\n  d++=s--;\n\nprintf(&quot;%s&quot;,dest);\n</code></pre><p>}</p>\n<p>找出错误！！</p>\n<p>#include   “string.h”</p>\n<p>#include “stdio.h”</p>\n<p>#include “malloc.h”</p>\n<p>main(void)</p>\n<p>{  </p>\n<p>char   *src=”hello,world”;</p>\n<pre><code>char   *dest=NULL;\n\ndest=(char   *)malloc(sizeof(char)*(strlen(src)+1));\n\nint   len=strlen(src);\n\nchar   *d=dest;\n\nchar   *s=src+len-1;\n\nwhile(len--!=0)\n\n  *d++=*s--;\n</code></pre><p>*d=’/0’;</p>\n<pre><code>printf(&quot;%s&quot;,dest);\n</code></pre><p>}</p>\n<ol start=\"105\">\n<li>判断字符串是否为回文</li>\n</ol>\n<p>bool IsSymmetry(const char * p)</p>\n<pre><code> {\n\n     assert(p!=NULL);\n\n     const char * q=p;      \n\n     int len=0;\n\n     while (*q++!=&#39;/0&#39; )\n\n     {\n\n          len++;\n\n     }       \n\n     bool bSign=true ;\n\n     q=p+len-1;\n\n     if (0&lt;len)\n\n     {\n\n          for (int i=0;i&lt;len/2;i++)\n\n          {\n\n               if (*p++!=*q--){ bSign=false ;break ;};\n\n          }\n\n     }\n\n     if (bSign==true )\n\n     {\n\n          printf(&quot;Yes!/n&quot; );\n\n     }\n\n     else\n\n     {\n\n          printf(&quot;No!/n&quot; );\n\n     }\n\n     return bSign;\n\n }\n</code></pre><p>107.ASDL 使用的是什么协议？并进行简单描述？</p>\n<p>108.Static 作用是什么</p>\n<p>首先 static 的最主要功能是隐藏，其次因为 static 变量存放在静态存储区，所以它具备持久性和默认值 0 。</p>\n<ol start=\"109\">\n<li>什么是预编译 , 何时需要预编译 ?</li>\n</ol>\n<p>预编译又称为预处理 , 是做些代码文本的替换工作。处理 # 开头的指令 , 比如拷贝 #include 包含的文件代码，#define 宏定义的替换 , 条件编译等，就是为编译做的预备工作的阶段，主要处理 # 开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。</p>\n<p>c 编译系统在对程序进行通常的编译之前，先进行预处理。 c 提供的预处理功能主要有以下三种： 1 ）宏定义　2 ）文件包含　 3 ）条件编译</p>\n<p>１、总是使用不经常改动的大型代码体。<br>２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。</p>\n<ol start=\"110\">\n<li>进程和线程的区别</li>\n</ol>\n<p>什么是进程（ Process ）：普通的解释就是，进程是程序的一次执行，而什么是线程（ Thread ），线程可以理解为进程中的执行的一段程序片段。在一个多任务环境中下面的概念可以帮助我们理解两者间的差别： </p>\n<p>进程间是独立的，这表现在内存空间，上下文环境；线程运行在进程空间内。 一般来讲（不使用特殊技术）进程是无法突破进程边界存取其他进程内的存储空间；而线程由于处于进程空间内，所以同一进程所产生的线程共享同一内存空间。 同一进程中的两段代码不能够同时执行，除非引入线程。线程是属于进程的，当进程退出时该进程所产生的线程都会被强制退出并清除。线程占用的资源要少于进程所占用的资源。 进程和线程都可以有优先级。在线程系统中进程也是一个线程。可以将进程理解为一个程序的第一个线程。</p>\n<p>线程是指进程内的一个执行单元 , 也是进程内的可调度实体 . 与进程的区别 :<br>(1) 地址空间 : 进程内的一个执行单元 ; 进程至少有一个线程 ; 它们共享进程的地址空间 ; 而进程有自己独立的地址空间 ;<br>(2) 进程是资源分配和拥有的单位 , 同一个进程内的线程共享进程的资源<br>(3) 线程是处理器调度的基本单位 , 但进程不是 .<br>(4) 二者均可并发执行 .</p>\n<ol start=\"111\">\n<li>插入排序和</li>\n</ol>\n<p>插入排序基本思想：（假定从大到小排序）依次从后面拿一个数和前面已经排好序的数进行比较，比较的过程是从已经排好序的数中最后一个数开始比较，如果比这个数，继续往前面比较，直到找到比它大的数，然后就放在它的后面，如果一直没有找到，肯定这个数已经比较到了第一个数，那就放到第一个数的前面。那么一般情况下，对于采用插入排序法去排序的一组数，可以先选 取第一个数做为已经排好序的一组数。然后把第二个放到正确位置。</p>\n<p>选择排序 (Selection Sort) 是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素 ,存放到排序序列的起始位置 , 然后 , 再从剩余未排序元素中继续寻找最小元素 , 然后放到排序序列末尾。以此类推, 直到所有元素均排序完毕。</p>\n<ol start=\"112\">\n<li>运算符优先级问题</li>\n</ol>\n<p>能正确表示 a 和 b 同时为正或同时为负的逻辑表达式是 (D ) 。</p>\n<p>sssA 、 (a&gt;=0||b&gt;=0) ＆＆ (a&lt;0||b&lt;0)<br>B 、 (a&gt;=0 ＆＆ b&gt;=0)&amp;&amp;(a&lt;0&amp; ＆ b&lt;0)<br>C 、 (a+b&gt;0) ＆＆ (a+b&lt;=0)<br>D 、 a*b&gt;0</p>\n<p>以下关于运算符优先顺序的描述中正确的是 (C) 。<br>A 、关系运算符 &lt; 算术运算符 &lt; 赋值运算符 &lt; 逻辑与运算符<br>B 、逻辑与运算符 &lt; 关系运算符 &lt; 算术运算符 &lt; 赋值运算符<br>C 、赋值运算符 &lt; 逻辑与运算符 &lt; 关系运算符 &lt; 算术运算符<br>D 、算术运算符 &lt; 关系运算符 &lt; 赋值运算符 &lt; 逻辑与运算符</p>\n<ol start=\"113\">\n<li>字符串倒序</li>\n</ol>\n<p>写一个函数将 “tom is cat” 倒序打印出来，即 “cat is tom”</p>\n<p>//a.ch</p>\n<p>#define SPACE ‘ ‘</p>\n<p>#define ENDL ‘/0’</p>\n<p>char<em> str = “Tom is cat”; // 字符串<br>char</em> p1 = str+strlen(str)-1;<br>char* p2 = p1; // 开始时， p1,p2 都指向字符串结尾处<br>char t=0; // 临时变量，用来保存被临时替换为 ENDL 的字符</p>\n<p>while(str!=p1–)<br>{<br>  if(SPACE!=<em>p1){<br>     for(p2=p1+1;SPACE!=</em>p1; p1–, t=<em>p2, </em>p2=ENDL);</p>\n<pre><code> // p1+1 指向单词的第一个字母 ,p2 指向单词的结尾 , 此时输出这个单词 \n            printf(&quot;%s &quot;,p1+1);\n            *p2=t;\n            p2=p1;\n     }\n</code></pre><p>}</p>\n<p>Output:<br>cat is Tom</p>\n<hr>\n<p>1) 写一个递归函数将内存中的字符串翻转 “abc”-&gt;”cba”<br>2) 写一个函数将 “tom is cat” 将内存中的字符串翻转，即 “cat is tomm” </p>\n<p>#include &lt;stdio.h&gt;</p>\n<p>#define SPACE ‘ ‘</p>\n<p>#define ENDL ‘/0’<br>char* s = “The quick brown fox jumps over the lazy dog”;</p>\n<p>void str_reverse(char<em> p1,char</em> p2){<br>      if(p1==p2)return;<br>    <em>p1 = (</em>p1)+(<em>p2);\n    </em>p2 = (<em>p1)-(</em>p2);<br>    <em>p1 = (</em>p1)-(*p2);<br>      if(p1==p2-1)return;<br>      else str_reverse(++p1,–p2);<br>}</p>\n<p>void str_word_reverse(char<em> str){<br>      char </em>q1=str, <em>q2=str, </em>t;</p>\n<pre><code>  while(*q1==SPACE)q1++;\n  if(*q1==ENDL)return; //!\n  else q2=q1+1;\n\n  while( (*q2!=SPACE) &amp;&amp; (*q2!=ENDL) )q2++;\n\n t=q2--; \nstr_reverse(q1,q2);\n\n  if(*t==ENDL)return;\n  else str_word_reverse(t);\n</code></pre><p>}</p>\n<p>int<br>main(int a ,char** b)<br>{<br>    printf(“%s/n”,s);<br>    str_reverse(s,s+strlen(s)-1);<br>    printf(“%s/n”,s);<br>    str_word_reverse(s);<br>    printf(“%s/n”,s);<br>           return 0;<br>}</p>\n<p>Output:</p>\n<p>The quick brown fox jumps over the lazy dog<br>god yzal eht revo spmuj xof nworb kciuq ehT<br>dog lazy the over jumps fox brown quick The</p>\n<hr>\n<p>今天同学又问一道题 , 和上面有些类似，但是要求更严格了一些：<br>写一个递归函数将内存中的字符串翻转 “abc”-&gt;”cba”, 并且函数原型已确定： void reverse(char* p)</p>\n<p>其实，要求越多，思路越确定，我的解如下： </p>\n<p>#include &lt;stdio.h&gt;</p>\n<p>#include &lt;string.h&gt;<br>char* s = “0123456789”;</p>\n<p>#define ENDL ‘/0’<br>void reverse(char<em> p){<br>       // 这是这种方法的关键，使用 static 为的是能用 str_reverse 的思路，但是不好<br>       static char</em> x=0;<br>       if(x==0)x=p;<br>       char<em> q = x+strlen(p)-1;<br>       if(p==q)return;\n       </em>q=(<em>p)^(</em>q);<br>       <em>p=(</em>p)^(<em>q);\n       </em>q =(<em>p)^(</em>q);<br>       if(q==p+1)return;<br>       reverse(++p);<br>}</p>\n<p>// 这种方法就直观多了，但是当字符串很长的时候就很低效<br>void reverse2(char<em> p){<br>       if(</em>(p+1)==ENDL)return;<br>       for(char<em> o=p+strlen(p)-1,char t=</em>o;o!=p;o–)<br>          <em>o=</em>(o-1);<br>       *p=t;<br>       reverse2(p+1);<br>}</p>\n<p>int main(int c,char** argv){<br>       reverse2(s);<br>       printf(“%s/n”,s);<br>       return 0;<br>}</p>\n<ol start=\"114\">\n<li>交换两个数的宏定义</li>\n</ol>\n<p>交换两个参数值的 宏定义 为： . #define SWAP (a,b) (a)=(a)+(b);(b)=(a)-(b);(a)=(a)-(b);</p>\n<p>115.Itearator 各指针的区别</p>\n<p>游标和指针</p>\n<p>我说过游标是指针，但不仅仅是指针。游标和指针很像，功能很像指针，但是实际上，游标是通过重载一元的 ”*”和 ”-&gt;” 来从容器中间接地返回一个值。将这些值存储在容器中并不是一个好主意，因为每当一个新值添加到容器中或者有一个值从容器中删除，这些值就会失效。在某种程度上，游标可以看作是句柄（ handle ）。通常情况下游标（ iterator ）的类型可以有所变化，这样容器也会有几种不同方式的转变：</p>\n<p>iterator—— 对于除了 vector 以外的其他任何容器，你可以通过这种游标在一次操作中在容器中朝向前的方向走一步。这意味着对于这种游标你只能使用 “++” 操作符。而不能使用 “–” 或 “+=” 操作符。而对于 vector 这一种容器，你可以使用 “+=” 、 “—” 、 “++” 、 “-=” 中的任何一种操作符和 “&lt;” 、 “&lt;=” 、 “&gt;” 、 “&gt;=” 、 “==” 、 “!=” 等比较运算符。</p>\n<ol start=\"116\">\n<li>C++ 中的 class 和 struct 的区别</li>\n</ol>\n<p>从语法上，在 C++ 中（只讨论 C++ 中）。 class 和 struct 做类型定义时只有两点区别：<br>（一）默认继承权限。如果不明确指定，来自 class 的继承按照 private 继承处理，来自 struct 的继承按照 public继承处理；<br>（二）成员的默认访问权限。 class 的成员默认是 private 权限， struct 默认是 public 权限。<br>除了这两点， class 和 struct 基本就是一个东西。语法上没有任何其它区别。</p>\n<p>不能因为学过 C 就总觉得连 C++ 中 struct 和 class 都区别很大，下面列举的说明可能比较无聊，因为 struct 和class 本来就是基本一样的东西，无需多说。但这些说明可能有助于澄清一些常见的关于 struct 和 class 的错误认识：<br>（ 1 ）都可以有成员函数；包括各类构造函数，析构函数，重载的运算符，友元类，友元结构，友元函数，虚函数，纯虚函数，静态函数；<br>（ 2 ）都可以有一大堆 public/private/protected 修饰符在里边；<br>（ 3 ）虽然这种风格不再被提倡，但语法上二者都可以使用大括号的方式初始化：</p>\n<p>A a = {1, 2, 3}; 不管 A 是个 struct 还是个 class ，前提是这个类 / 结构足够简单，比如所有的成员都是 public的，所有的成员都是简单类型，没有显式声明的构造函数。<br>（ 4 ）都可以进行复杂的继承甚至多重继承，一个 struct 可以继承自一个 class ，反之亦可；一个 struct 可以同时继承 5 个 class 和 5 个 struct ，虽然这样做不太好。<br>（ 5 ）如果说 class 的设计需要注意 OO 的原则和风格，那么没任何理由说设计 struct 就不需要注意。 </p>\n<h2 id=\"（-6-）再次说明，以上所有说法都是指在-C-语言中，至于在-C-里的情况，-C-里是根本没有-“class”-，而-C-的struct-从根本上也只是个包装数据的语法机制。\"><a href=\"#（-6-）再次说明，以上所有说法都是指在-C-语言中，至于在-C-里的情况，-C-里是根本没有-“class”-，而-C-的struct-从根本上也只是个包装数据的语法机制。\" class=\"headerlink\" title=\"（ 6 ）再次说明，以上所有说法都是指在 C++ 语言中，至于在 C 里的情况， C 里是根本没有 “class” ，而 C 的struct 从根本上也只是个包装数据的语法机制。 \"></a>（ 6 ）再次说明，以上所有说法都是指在 C++ 语言中，至于在 C 里的情况， C 里是根本没有 “class” ，而 C 的struct 从根本上也只是个包装数据的语法机制。 </h2><p>最后，作为语言的两个关键字，除去定义类型时有上述区别之外，另外还有一点点： “class” 这个关键字还用于定义模板参数，就像 “typename” 。但关键字 “struct” 不用于定义模板参数。</p>\n<p>关于使用大括号初始化</p>\n<p>　　 class 和 struct 如果定义了构造函数的话，都不能用大括号进行初始化</p>\n<p>　　如果没有定义构造函数， struct 可以用大括号初始化。</p>\n<p>　　如果没有定义构造函数，且所有成员变量全是 public 的话，可以用大括号初始化。</p>\n<p>　　关于默认访问权限</p>\n<p>　　 class 中默认的成员访问权限是 private 的，而 struct 中则是 public 的。</p>\n<p>　　关于继承方式</p>\n<p>　　 class 继承默认是 private 继承，而 struct 继承默认是 public 继承。</p>\n<p>　　关于模版</p>\n<p>　　在模版中，类型参数前面可以使用 class 或 typename ，如果使用 struct ，则含义不同， struct 后面跟的是“non-type template parameter” ，而 class 或 typename 后面跟的是类型参数。</p>\n<p>class 中有个默认的 this 指针， struct 没有<br>不同点：构造函数，析构函数  this  指针</p>\n<ol start=\"117\">\n<li>有关重载函数</li>\n</ol>\n<p>返回值类型不同构不成重载<br>参数参数顺序不同能构成重载</p>\n<p>c++ 函数同名不同返回值不算重载！函数重载是忽略返回值类型的。 </p>\n<hr>\n<p>成员函数被重载的特征有：<br>1) 相同的范围（在同一个类中）；<br>2) 函数名字相同；<br>3) 参数不同；<br>4) virtual 关键字可有可无。</p>\n<p>5) 成员函数中 有无 const ( 函数后面 ) 也可判断是否重载</p>\n<ol start=\"118\">\n<li>数据库与 T-SQL 语言 </li>\n</ol>\n<p>关系数据库是表的集合，它是由一个或多个关系模式定义。 SQL 语言中的数据定义功能包括对数据库、基本表、视图、索引的定义。</p>\n<ol start=\"119\">\n<li>关系模型的基本概念 </li>\n</ol>\n<p>  关系数据库以关系模型为基础，它有以下三部分组成：<br>    ● 数据结构 —— 模型所操作的对象、类型的集合<br>    ● 完整性规则 —— 保证数据有效、正确的约束条件<br>    ● 数据操作 —— 对模型对象所允许执行的操作方式<br>    关系（ Relation ）是一个由行和列组成的二维表格，表中的每一行是一条记录（ Record ），每一列是记录的一个字段（ Field ）。表中的每一条记录必须是互斥的，字段的值必须具有原子性。 </p>\n<p>120.SQL 语言概述</p>\n<pre><code>SQL （结构化查询语言）是关系数据库语言的一种国际标准，它是一种非过程化的语言。通过编写 SQL ，我们可以实现对关系数据库的全部操作。 \n● 数据定义语言（ DDL ） —— 建立和管理数据库对象 \n● 数据操纵语言（ DML ） —— 用来查询与更新数据 \n● 数据控制语言（ DCL ） —— 控制数据的安全性\n</code></pre><p>起来是一个很简单的问题，每一个使用过 RDBMS 的人都会有一个概念。</p>\n<p>事务处理系统的典型特点是具备 ACID 特征。 ACID 指的是 Atomic （原子的）、 Consistent （一致的）、Isolated （隔离的）以及 Durable （持续的），它们代表着事务处理应该具备的四个特征：</p>\n<p>原子性：组成事务处理的语句形成了一个逻辑单元，不能只执行其中的一部分</p>\n<p>一致性：在事务处理执行之前和之后，数据是一致的。</p>\n<p>隔离性：一个事务处理对另一个事务处理没有影响。</p>\n<p>持续性：当事务处理成功执行到结束的时候，其效果在数据库中被永久纪录下来。</p>\n<p>121.C 语言中结构化程序设计的三种基本控制结构</p>\n<p>顺序结构<br>选择结构<br>循环结构</p>\n<p>122.CVS 是什么</p>\n<p>cvs （ Concurrent Version System ） 是一个版本控制系统。使用它，可以记录下你的源文件的历史。 </p>\n<p>例如，修改软件时可能会不知不觉混进一些 bug ，而且可能过了很久你才会察觉到它们的存在。有了 cvs ，你可以很容易地恢复旧版本，并从中看出到底是哪个修改导致了这个 bug 。有时这是很有用的。 </p>\n<p>CVS 服务器端对每个文件维护着一个修订号 , 每次对文件的更新，都会使得文件的修订号加 1 。在客户端中也对每个文件维护着一个修订号 ,CVS 通过这两个修订号的关系，来进行 Update,Commit 和发现冲突等操作操作</p>\n<ol start=\"123\">\n<li>三种基本的数据模型</li>\n</ol>\n<p>按照数据结构类型的不同，将数据模型划分为层次模型、网状模型和关系模型。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C-入门基础\"><a href=\"#C-入门基础\" class=\"headerlink\" title=\"C++入门基础\"></a>C++入门基础</h1><hr>\n<p>##1.new 、 delete 、 malloc 、 free 关系</p>\n<p>delete 会调用对象的析构函数 , 和 new 对应 free 只会释放内存， new 调用构造函数。 malloc 与 free 是C++/C 语言的标准库函数， new/delete 是 C++ 的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free 。因此 C++ 语言需要一个能完成动态内存分配和初始化工作的运算符 new ，以及一个能完成清理与释放内存工作的运算符 delete 。注意 new/delete 不是库函数。</p>\n<p>总结：new和delete会自动调用对象的构造与析构函数而malloc与free不会；</p>\n<pre><code>  new和delete式C++运算符，而malloc和free是C/C++标准库函数。\n</code></pre><hr>\n<p>##2.delete 与 delete [] 区别</p>\n<p>delete 只会调用一次析构函数，而 delete[] 会调用每一个成员的析构函数。在 More Effective  C++ 中有更为详细的解释：“当 delete 操作符用于数组时，它为每个数组元素调用析构函数，然后调用 operatordelete 来释放内存。” delete 与 New 配套， delete [] 与 new [] 配套</p>\n<pre><code class=\"c++\">  MemTest*mTest1=newMemTest[10];\n\n  MemTest*mTest2=newMemTest;\n\n  int*pInt1=newint[10];\n\n  int*pInt2=newint;\n\n  delete[]pInt1;  //-1-\n\n  delete[]pInt2;  //-2-\n\n  delete[]mTest1;//-3-\n\n  delete[]mTest2;//-4-\n</code></pre>\n<p>  在 -4- 处报错。</p>\n<p>这就说明：对于内建简单数据类型， delete 和 delete[] 功能是相同的。对于自定义的复杂数据类型， delete和 delete[] 不能互用。 delete[] 删除一个数组， delete 删除一个指针简单来说，用 new 分配的内存用 delete 删除用 new[] 分配的内存用 delete[] 删除 delete[] 会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用 delete 时没用括号， delete 就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。</p>\n<p>总结： delete 只会调用一次析构函数，而 delete[] 会调用每一个成员的析构函数。</p>\n<hr>\n<p>##3. C C++ JAVA 共同点，不同之处？</p>\n<hr>\n<p>##4. 继承优缺点。</p>\n<p>类继承是在编译时刻静态定义的，且可直接使用，类继承可以较方便地改变父类的实现。但是类继承也有一些不足之处。首先，因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现。更糟的是，父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为。如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</p>\n<p>（待补充）</p>\n<hr>\n<p>##5.C++ 有哪些性质（面向对象特点）</p>\n<p>封装，继承和多态。</p>\n<p>在面向对象程序设计语言中，封装是利用可重用成分构造软件系统的特性，它不仅支持系统的可重用性，而且还有利于提高系统的可扩充性；消息传递可以实现发送一个通用的消息而调用不同的方法；封装是实现信息隐蔽的一种技术，其目的是使类的定义和实现分离。</p>\n<hr>\n<p>##6. 子类析构时要调用父类的析构函数吗？</p>\n<p>析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候 , 派生类的信息已经全部销毁了定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数 JAVA 无析构函数深拷贝和浅拷贝</p>\n<hr>\n<p>##7. 多态，虚函数，纯虚函数</p>\n<hr>\n<p>##8. 求下面函数的返回值（微软）</p>\n<pre><code class=\"c++\">int func(x) \n{ \n    int countx = 0; \n    while(x) \n    { \n          countx ++; \n          x = x&amp;(x-1); \n     } \n    return countx; \n} \n</code></pre>\n<p>假定 x = 9999 。 答案： 8</p>\n<p>思路：将 x 转化为 2 进制，看含有的 1 的个数。</p>\n<hr>\n<p>##9. 什么是 “ 引用 ” ？申明和使用 “ 引用 ” 要注意哪些问题？</p>\n<p>答：引用就是某个目标变量的 “ 别名 ”(alias) ，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。</p>\n<hr>\n<p>##10. 将 “ 引用 ” 作为函数参数有哪些特点？</p>\n<p>（ 1 ）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</p>\n<p>（ 2 ）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</p>\n<p>（ 3 ）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用 “* 指针变量名 “ 的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p>\n<hr>\n<p>##11. 在什么时候需要使用 “ 常引用 ” ？ 　</p>\n<p>如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式： const 类型标识符 &amp; 引用名 = 目标变量名；</p>\n<p>例 1</p>\n<pre><code class=\"c++\">int a ;\nconst int &amp;ra=a;\nra=1; // 错误 \na=1; // 正确\n</code></pre>\n<p>例 2</p>\n<pre><code class=\"c++\">string foo( );\nvoid bar(string &amp; s);\n</code></pre>\n<p>那么下面的表达式将是非法的：</p>\n<pre><code class=\"c++\">bar(foo( ));\nbar(&quot;hello world&quot;);\n</code></pre>\n<p>原因在于 foo( ) 和 “hello world” 串都会产生一个临时对象，而在 C++ 中，这些临时对象都是 const 类型的。因此上面的表达式就是试图将一个 const 类型的对象转换为非 const 类型，这是非法的。引用型参数应该在能被定义为 const 的情况下，尽量定义为 const 。</p>\n<hr>\n<p>##12. 将 “ 引用 ” 作为函数返回值类型的格式、好处和需要遵守的规则 ?</p>\n<p>格式：类型标识符 &amp; 函数名（形参列表及类型说明） { // 函数体 }</p>\n<p>好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生 runtime error! 注意事项：</p>\n<p>（ 1 ）不能返回局部变量的引用。这条可以参照 Effective C++[1] 的 Item 31 。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了 “ 无所指 “ 的引用，程序会进入未知状态。</p>\n<p>（ 2 ）不能返回函数内部 new 分配的内存的引用。这条可以参照 Effective C++[1] 的 Item 31 。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部 new 分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由 new 分配）就无法释放，造成 memory leak 。</p>\n<p>（ 3 ）可以返回类成员的引用，但最好是 const 。这条原则可以参照 Effective C++[1] 的 Item 30 。主要原因是当对象的属性是与某种业务规则（ business rule ）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。</p>\n<p>（ 4 ）流操作符重载返回值申明为 “ 引用 ” 的作用：</p>\n<p>流操作符 &lt;&lt; 和 &gt;&gt; ，这两个操作符常常希望被连续使用，例如： cout &lt;&lt; “hello” &lt;&lt; endl; 　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个 &lt;&lt; 操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用 &lt;&lt; 操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是 C++ 语言中引入引用这个概念的原因吧。 赋值操作符 = 。这个操作符象流操作符一样，是可以连续使用的，例如： x = j = 10; 或者 (x=10)=100; 赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。</p>\n<p>例 3</p>\n<pre><code class=\"c++\">＃ i nclude &lt;iostream.h&gt;\nint &amp;put(int n);\nint vals[10];\nint error=-1;\nvoid main()\n{\nput(0)=10; // 以 put(0) 函数值作为左值，等价于 vals[0]=10; \nput(9)=20; // 以 put(9) 函数值作为左值，等价于 vals[9]=20; \ncout&lt;&lt;vals[0]; \ncout&lt;&lt;vals[9];\n} \nint &amp;put(int n)\n{\nif (n&gt;=0 &amp;&amp; n&lt;=9 ) return vals[n]; \nelse { cout&lt;&lt;&quot;subscript error&quot;; return error; }\n}\n</code></pre>\n<p>（ 5 ）在另外的一些操作符中，却千万不能返回引用： +-*/ 四则运算符。它们不能返回引用， Effective C++[1] 的 Item23 详细的讨论了这个问题。主要原因是这四个操作符没有 side effect ，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个 new 分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第 2 、 3 两个方案都被否决了。静态对象的引用又因为 ((a+b) == (c+d)) 会永远为 true 而导致错误。所以可选的只剩下返回一个对象了。</p>\n<hr>\n<p>##13.“ 引用 ” 与多态的关系？</p>\n<p>引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。例4</p>\n<p>Class A; Class B : Class A{…};  B b; A&amp; ref = b;</p>\n<hr>\n<p>##14.“ 引用 ” 与指针的区别是什么？</p>\n<p>指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。此外，就是上面提到的对函数传 ref 和pointer 的区别。</p>\n<hr>\n<p>##15. 什么时候需要 “ 引用 ” ？</p>\n<p>流操作符 &lt;&lt; 和 &gt;&gt; 、赋值操作符 = 的返回值、拷贝构造函数的参数、赋值操作符 = 的参数、其它情况都推荐使用引用。以上 2-8 参考： <a href=\"http://develop.csai.cn/c/NO0000021.htm\" target=\"_blank\" rel=\"noopener\">http://develop.csai.cn/c/NO0000021.htm</a></p>\n<hr>\n<p>##16. 结构与联合有和区别？</p>\n<p>(1). 结构和联合都是由多个不同的数据类型成员组成 , 但在任何同一时刻 , 联合中只存放了一个被选中的成员（所有成员共用一块地址空间） , 而结构的所有成员都存在（不同成员的存放地址不同）。<br> (2). 对于联合的不同成员赋值 , 将会对其它成员重写 ,  原来成员的值就不存在了 , 而对于结构的不同成员赋值是互不影响的。</p>\n<hr>\n<p>##17. 面关于 “ 联合 ” 的题目的输出？</p>\n<p>a)</p>\n<pre><code class=\"c++\">＃ i nclude &lt;stdio.h&gt;\nunion\n{\nint i;\nchar x[2];\n}a;\n\n\nvoid main()\n{\na.x[0] = 10; \na.x[1] = 1;\nprintf(&quot;%d&quot;,a.i);\n}\n答案： 266 ( 低位低地址，高位高地址，内存占用情况是 Ox010A ）\n</code></pre>\n<p>b)</p>\n<pre><code class=\"c++\">main() \n     { \n          union{                   /* 定义一个联合 */ \n               int i; \n               struct{             /* 在联合中定义一个结构 */ \n                    char first; \n                    char second; \n               }half; \n          }number; \n          number.i=0x4241;         /* 联合成员赋值 */ \n          printf(&quot;%c%cn&quot;, number.half.first, mumber.half.second); \n          number.half.first=&#39;a&#39;;   /* 联合中结构成员赋值 */ \n          number.half.second=&#39;b&#39;; \n          printf(&quot;%xn&quot;, number.i); \n          getch(); \n     } \n</code></pre>\n<p>答案： AB   (0x41 对应 ‘A’, 是低位； Ox42 对应 ‘B’, 是高位）</p>\n<pre><code>   6261 (number.i 和 number.half 共用一块地址空间）\n</code></pre><ol start=\"18\">\n<li>关联、聚合 (Aggregation) 以及组合(Composition) 的区别？</li>\n</ol>\n<p>涉及到 UML 中的一些概念：关联是表示两个类的一般性联系，比如 “ 学生 ” 和 “ 老师 ” 就是一种关联关系；聚合表示 has-a 的关系，是一种相对松散的关系，聚合类不需要对被聚合类负责，如下图所示，用空的菱形表示聚合关系：从实现的角度讲，聚合可以表示为 :</p>\n<p>class A {…}  class B { A* a; …..}</p>\n<p>而组合表示 contains-a 的关系，关联性强于聚合：组合类与被组合类有相同的生命周期，组合类要对被组合类负责，采用实心的菱形表示组合关系：实现的形式是 :</p>\n<p>class A{…} class B{ A a; …}</p>\n<p>参考文章： <a href=\"http://www.cnitblog.com/Lily/archive/2006/02/23/6860.html\" target=\"_blank\" rel=\"noopener\">http://www.cnitblog.com/Lily/archive/2006/02/23/6860.html</a></p>\n<pre><code>      http://www.vckbase.com/document/viewdoc/?id=422\n</code></pre><ol start=\"19\">\n<li><p>面向对象的三个基本特征，并简单叙述之？</p>\n</li>\n<li><p>封装：将客观事物抽象成类，每个类对自身的数据和方法实行 protection(private, protected,public)</p>\n</li>\n<li><p>继承：广义的继承有三种实现形式：实现继承（指使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后到子类实现）。前两种（类继承）和后一种（对象组合 =&gt; 接口继承以及纯虚函数）构成了功能复用的两种方式。</p>\n</li>\n<li><p>多态：是将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。</p>\n</li>\n<li><p>重载（ overload) 和重写 (overried ，有的书也叫做 “ 覆盖 ” ）的区别？</p>\n</li>\n</ol>\n<p>常考的题目。从定义上来说：</p>\n<p>重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。</p>\n<p>重写：是指子类重新定义父类虚函数的方法。</p>\n<p>从实现原理上来说：</p>\n<p>重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数： function func(p:integer):integer; 和 function func(p:string):integer; 。 那么编译器做过修饰后的函数名称可能是这样的： int_func 、 str_func 。对于这两个函数的调用，在编译器间就已经确定了，是 静态 的。也就是说， 它们的地址在编译期就绑定了（早绑定）， 因此， 重载和多态无关 ！</p>\n<p>重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针， 动态的调用 属于子类的该函数，这样的函 数调用在编译期间是无法确定的 （调用的子类的虚函数的地址无法给出）。因此， 这样的函数地址是在运行期绑定的（晚绑定）。</p>\n<hr>\n<p>##21. 多态的作用？</p>\n<p>主要是两个：</p>\n<ol>\n<li><p>隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；</p>\n</li>\n<li><p>接口重用：为了类在继承和派生的时候 ，保证使用家族中任一类的实例的某一属性时的正确调用 。</p>\n</li>\n</ol>\n<hr>\n<p>##22.Ado 与 Ado.net 的相同与不同？</p>\n<p>除了“能够让应用程序处理存储于 DBMS 中的数据“这一基本相似点外，两者没有太多共同之处。但是 Ado使用 OLE DB 接口并基于微软的 COM 技术，而 ADO.NET 拥有自己的 ADO.NET 接口并且基于微软的 .NET 体系架构。众所周知 .NET 体系不同于 COM 体系， ADO.NET 接口也就完全不同于 ADO 和 OLE DB 接口，这也就是说 ADO.NET 和 ADO 是两种数据访问方式。 ADO.net 提供对 XML 的支持。</p>\n<hr>\n<p>##23.New delete 与 malloc free 的联系与区别 ?</p>\n<p>答案：都是在堆 (heap) 上进行动态的内存操作。用 malloc 函数需要指定内存分配的字节数并且不能初始化对象， new 会自动调用对象的构造函数。 delete 会调用对象的 destructor ，而 free 不会调用对象的 destructor.</p>\n<hr>\n<p>##24.#define DOUBLE(x) x+x ， i = 5*DOUBLE(5) ； i是多少？</p>\n<p>答案： i 为 30 。</p>\n<hr>\n<p>##25. 有哪几种情况只能用 intialization list 而不能用assignment?</p>\n<p>答案：当类中含有 const 、 reference 成员变量；基类的构造函数都需要初始化表。</p>\n<hr>\n<p>##26. C++ 是不是类型安全的？</p>\n<p>答案：不是。两个不同类型的指针之间可以强制转换（用 reinterpret cast) 。 C# 是类型安全的。</p>\n<hr>\n<p>##27. main 函数执行以前，还会执行什么代码？</p>\n<p>答案：全局对象的构造函数会在 main 函数之前执行。</p>\n<hr>\n<p>##28.  描述内存分配方式以及它们的区别 ?</p>\n<p>1 ） 从静态存储区域分配 。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如 全局变量， static 变量 。<br>2 ） 在栈上创建 。在执行函数时， 函数内局部变量的存储单元都可以在栈上创建 ，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。<br>3 ） 从堆上分配 ， 亦称动态内存分配 。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。</p>\n<hr>\n<p>##29.struct 和 class 的区别</p>\n<p>答案： struct 的成员默认是公有的，而类的成员默认是私有的。 struct 和 class 在其他方面是功能相当的。从感情上讲，大多数的开发者感到类和结构有很大的差别。感觉上结构仅仅象一堆缺乏封装和功能的开放的内存位，而类就象活的并且可靠的社会成员，它有智能服务，有牢固的封装屏障和一个良好定义的接口。既然大多数人都这么认为，那么只有在你的类有很少的方法并且有公有数据（这种事情在良好设计的系统中是存在的 ! ）时，你也许应该使用 struct 关键字，否则，你应该使用 class 关键字。  </p>\n<hr>\n<p>##30. 当一个类 A 中没有任何成员变量与成员函数 , 这时sizeof(A) 的值是多少？</p>\n<p>答案：如果不是零，请解释一下编译器为什么没有让它为零。（ Autodesk ）肯定不是零。举个反例，如果是零的话，声明一个 class A[10] 对象数组，而每一个对象占用的空间是零，这时就没办法区分 A[0],A[1] …了。</p>\n<hr>\n<p>##31. 在 8086 汇编下，逻辑地址和物理地址是怎样转换的？（ Intel ）</p>\n<p>答案：通用寄存器给出的地址，是段内偏移地址，相应段寄存器地址 *10H+ 通用寄存器内地址，就得到了真正要访问的地址。</p>\n<hr>\n<p>##32.  比较 C++ 中的 4 种类型转换方式？</p>\n<p>请参考： <a href=\"http://blog.csdn.net/wfwd/archive/2006/05/30/763785.aspx\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/wfwd/archive/2006/05/30/763785.aspx</a> ，重点是 static_cast, dynamic_cast和 reinterpret_cast 的区别和应用。</p>\n<p>dynamic_casts 在帮助你浏览继承层次上是有限制的。它不能被用于缺乏虚函数的类型上，它被用于安全地沿着类的继承关系向下进行类型转换。如你想在没有继承关系的类型中进行转换，你可能想到 static_cast</p>\n<hr>\n<p>##33. 分别写出 BOOL,int,float, 指针类型的变量 a与“零”的比较语句。</p>\n<p>答案：<br>BOOL :    if ( !a ) or if(a)<br>int :     if ( a == 0)<br>float :   const EXPRESSION EXP = 0.000001<br>          if ( a &lt; EXP &amp;&amp; a &gt;-EXP)<br>pointer : if ( a != NULL) or if(a == NULL)</p>\n<hr>\n<p>##34. 请说出 const 与 #define 相比，有何优点？</p>\n<p>答案：</p>\n<p>Const 作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被 Const 修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。</p>\n<p>1 ） const 常量有数据类型，而宏常量没有数据类型 。编译器可以对前者进行类型 安全检查 。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。<br>      2 ） 有些集成化的调试工具可以对 const 常量进行调试 ，但是不能对宏常量进行调试。</p>\n<hr>\n<p>##35. 简述数组与指针的区别？</p>\n<p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。<br>(1) 修改内容上的差别<br>char a[] = “ hello ” ;<br>a[0] = ‘ X ’ ;<br>char <em>p = “ world ” ; // 注意 p 指向常量字符串<br>p[0] = ‘ X ’ ; // 编译器不能发现该错误，运行时错误<br>(2) 用运算符 sizeof 可以计算出数组的容量（字节数）。 sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是 p 所指的内存容量 。 C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。 注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。<br>char a[] = “hello world”;<br>char </em>p = a;<br>cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节<br>cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节<br>计算数组和指针的内存容量<br>void Func(char a[100])<br>{<br>cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是 100 字节<br>}</p>\n<hr>\n<p>##36. 类成员函数的重载、覆盖和隐藏区别？</p>\n<p>答案： a. 成员函数被重载的特征：<br>（ 1 ）相同的范围（在同一个类中）；<br>（ 2 ）函数名字相同；<br>（ 3 ）参数不同；<br>（ 4 ） virtual 关键字可有可无。<br>b. 覆盖是指派生类函数覆盖基类函数，特征是：<br>（ 1 ）不同的范围（分别位于派生类与基类）；<br>（ 2 ）函数名字相同；<br>（ 3 ）参数相同；<br>（ 4 ）基类函数必须有 virtual 关键字。<br>  c. “隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：<br>（ 1 ）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载混淆）。<br>（ 2 ）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）</p>\n<hr>\n<p>##37. 求出两个数中的较大这</p>\n<p>There are two int variables: a and b, don ’ t use “ if ” , “ ? : ” , “ switch ” or other judgement statements, find out the biggest one of the two numbers.</p>\n<p>答案： ( ( a + b ) + abs( a - b ) ) / 2</p>\n<hr>\n<p>##38. 如何打印出当前源文件的文件名以及源文件的当前行号？</p>\n<p>答案：<br>cout &lt;&lt; <strong>FILE</strong> ;<br>cout&lt;&lt;<strong>LINE</strong> ;<br><strong>FILE</strong> 和 <strong>LINE</strong> 是系统预定义宏，这种宏并不是在某个文件中定义的，而是由编译器定义的。</p>\n<hr>\n<p>##39. main 主函数执行完毕后，是否可能会再执行一段代码，给出说明？</p>\n<p>答案：可以，可以用 _onexit 注册一个函数，它会在 main 之后执行 int fn1(void), fn2(void), fn3(void), fn4 (void);</p>\n<pre><code class=\"c++\">void main( void )\n{\nString str(&quot;zhanglin&quot;);\n_onexit( fn1 );\n_onexit( fn2 );\n_onexit( fn3 );\n_onexit( fn4 );\nprintf( &quot;This is executed first.n&quot; );\n}\nint fn1()\n{\nprintf( &quot;next.n&quot; );\nreturn 0;\n}\nint fn2()\n{\nprintf( &quot;executed &quot; );\nreturn 0;\n}\nint fn3()\n{\nprintf( &quot;is &quot; );\nreturn 0;\n}\nint fn4()\n{\nprintf( &quot;This &quot; );\nreturn 0;\n}\n</code></pre>\n<p>The _onexit function is passed the address of a function (func) to be called when the program terminates normally. Successive calls to _onexit create a register of functions that are executed in LIFO (last-in-first-out) order. The functions passed to _onexit cannot take parameters.</p>\n<hr>\n<p>##40. 如何判断一段程序是由 C 编译程序还是由 C++ 编译程序编译的？</p>\n<p>答案： </p>\n<p>#ifdef __cplusplus<br>cout&lt;&lt;”c++”;</p>\n<p>#else<br>cout&lt;&lt;”c”;</p>\n<p>#endif</p>\n<hr>\n<p>##41. 文件中有一组整数，要求排序后输出到另一个文件中</p>\n<p>答案：</p>\n<pre><code class=\"c++\">＃ i nclude&lt;iostream&gt;\n\n＃ i nclude&lt;fstream&gt;\n\nusing namespace std;\n\n\nvoid Order(vector&lt;int&gt;&amp; data) //bubble sort\n{\nint count = data.size() ;\nint tag = false ; // 设置是否需要继续冒泡的标志位 \nfor ( int i = 0 ; i &lt; count ; i++)\n{\nfor ( int j = 0 ; j &lt; count - i - 1 ; j++)\n{\nif ( data[j] &gt; data[j+1])\n{\ntag = true ;\nint temp = data[j] ;\ndata[j] = data[j+1] ;\ndata[j+1] = temp ;\n}\n}\nif ( !tag )\nbreak ;\n}\n}\n\n\nvoid main( void )\n{\nvector&lt;int&gt;data;\nifstream in(&quot;c:/data.txt&quot;);\nif ( !in)\n{\ncout&lt;&lt;&quot;file error!&quot;;\nexit(1);\n}\nint temp;\nwhile (!in.eof())\n{\nin&gt;&gt;temp;\ndata.push_back(temp);\n}\nin.close(); // 关闭输入文件流 \nOrder(data);\nofstream out(&quot;c:/result.txt&quot;);\nif ( !out)\n{\ncout&lt;&lt;&quot;file error!&quot;;\nexit(1);\n}\nfor ( i = 0 ; i &lt; data.size() ; i++)\nout&lt;&lt;data[i]&lt;&lt;&quot; &quot;;\nout.close(); // 关闭输出文件流 \n}\n</code></pre>\n<hr>\n<p>##42. 链表题：一个链表的结点结构</p>\n<pre><code class=\"c++\">struct Node\n{\nint data ;\nNode *next ;\n};\ntypedef struct Node Node ;\n\n\n(1) 已知链表的头结点 head, 写一个函数把这个链表逆序 ( Intel)\n\nNode * ReverseList(Node *head) // 链表逆序 \n{\nif ( head == NULL || head-&gt;next == NULL )\nreturn head;\nNode *p1 = head ;\nNode *p2 = p1-&gt;next ;\nNode *p3 = p2-&gt;next ;\np1-&gt;next = NULL ;\nwhile ( p3 != NULL )\n{\np2-&gt;next = p1 ;\np1 = p2 ;\np2 = p3 ;\np3 = p3-&gt;next ;\n}\np2-&gt;next = p1 ;\nhead = p2 ;\nreturn head ;\n}\n(2) 已知两个链表 head1 和 head2 各自有序，请把它们合并成一个链表依然有序。 ( 保留所有结点，即便大小相同） \nNode * Merge(Node *head1 , Node *head2)\n{\nif ( head1 == NULL)\nreturn head2 ;\nif ( head2 == NULL)\nreturn head1 ;\nNode *head = NULL ;\nNode *p1 = NULL;\nNode *p2 = NULL;\nif ( head1-&gt;data &lt; head2-&gt;data )\n{\nhead = head1 ;\np1 = head1-&gt;next;\np2 = head2 ;\n}\nelse\n{\nhead = head2 ;\np2 = head2-&gt;next ;\np1 = head1 ;\n}\nNode *pcurrent = head ;\nwhile ( p1 != NULL &amp;&amp; p2 != NULL)\n{\nif ( p1-&gt;data &lt;= p2-&gt;data )\n{\npcurrent-&gt;next = p1 ;\npcurrent = p1 ;\np1 = p1-&gt;next ;\n}\nelse\n{\npcurrent-&gt;next = p2 ;\npcurrent = p2 ;\np2 = p2-&gt;next ;\n}\n}\nif ( p1 != NULL )\npcurrent-&gt;next = p1 ;\nif ( p2 != NULL )\npcurrent-&gt;next = p2 ;\nreturn head ;\n}\n(3) 已知两个链表 head1 和 head2 各自有序，请把它们合并成一个链表依然有序，这次要求用递归方法进行。(Autodesk)\n答案： \nNode * MergeRecursive(Node *head1 , Node *head2)\n{\nif ( head1 == NULL )\nreturn head2 ;\nif ( head2 == NULL)\nreturn head1 ;\nNode *head = NULL ;\nif ( head1-&gt;data &lt; head2-&gt;data )\n{\nhead = head1 ;\nhead-&gt;next = MergeRecursive(head1-&gt;next,head2);\n}\nelse\n{\nhead = head2 ;\nhead-&gt;next = MergeRecursive(head1,head2-&gt;next);\n}\nreturn head ;\n</code></pre>\n<hr>\n<p>##41. 分析一下这段程序的输出 (Autodesk)<br>class B<br>{<br>public:<br>B()<br>{<br>cout&lt;&lt;”default constructor”&lt;&lt;endl;<br>}<br>~B()<br>{<br>cout&lt;&lt;”destructed”&lt;&lt;endl;<br>}<br>B(int i):data(i)    //B(int) works as a converter ( int -&gt; instance of  B)<br>{<br>cout&lt;&lt;”constructed by parameter “ &lt;&lt; data &lt;&lt;endl;<br>}<br>private:<br>int data;<br>};</p>\n<p>B Play( B b)<br>{<br>return b ;<br>}</p>\n<p>(1)                                            results:<br>int main(int argc, char* argv[])      constructed by parameter 5<br>{                                     destructed  B(5) 形参析构<br>B t1 = Play(5); B t2 = Play(t1);   　 destructed  t1 形参析构<br>return 0; 　　　　　　　　　　　　　　 destructed  t2 　注意顺序！<br>}                                     destructed  t1</p>\n<p>(2)                                   results:<br>int main(int argc, char* argv[])      constructed by parameter 5<br>{                                     destructed  B(5) 形参析构<br>B t1 = Play(5); B t2 = Play(10);   　 constructed by parameter 10<br>return 0; 　　　　　　　　　　　　　　 destructed  B(10) 形参析构<br>}                                     destructed  t2 　注意顺序！</p>\n<pre><code>                                  destructed  t1\n</code></pre><pre><code>\n---\n\n\n##43. 写一个函数找出一个整数数组中，第二大的数 （microsoft ）\n\n答案： \n```c++\nconst int MINNUMBER = -32767 ;\nint find_sec_max( int data[] , int count)\n{\nint maxnumber = data[0] ;\nint sec_max = MINNUMBER ;\nfor ( int i = 1 ; i &lt; count ; i++)\n{\nif ( data[i] &gt; maxnumber )\n{\nsec_max = maxnumber ;\nmaxnumber = data[i] ;\n}\nelse\n{\nif ( data[i] &gt; sec_max )\nsec_max = data[i] ;\n}\n}\nreturn sec_max ;\n}\n</code></pre><p>##44. 写一个在一个字符串 (n) 中寻找一个子串 (m) 第一个位置的函数。</p>\n<p>KMP 算法效率最好，时间复杂度是Ｏ (n+m), 详见： <a href=\"http://www.zhanglihai.com/blog/c_335_kmp.html\" target=\"_blank\" rel=\"noopener\">http://www.zhanglihai.com/blog/c_335_kmp.html</a></p>\n<hr>\n<p>##46. 多重继承的内存分配问题：</p>\n<p>比如有 class A : public class B, public class C {} 那么 A 的内存结构大致是怎么样的？<br>这个是 compiler-dependent 的 , 不同的实现其细节可能不同。如果不考虑有虚函数、虚继承的话就相当简单；否则的话，相当复杂。可以参考《深入探索 C++ 对象模型》，或者：<br><a href=\"http://blog.csdn.net/rainlight/archive/2006/03/03/614792.aspx\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/rainlight/archive/2006/03/03/614792.aspx</a><br><a href=\"http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dnarvc/html/jangrayhood.asp\" target=\"_blank\" rel=\"noopener\">http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/dnarvc/html/jangrayhood.asp</a></p>\n<hr>\n<p>##47. 如何判断一个单链表是有环的？（注意不能用标志位，最多只能用两个额外指针）</p>\n<pre><code class=\"c++\">struct node { char val; node* next;}\nbool check(const node* head) {} //return false : 无环； true: 有环一种 O （ n ）的办法就是（搞两个指针，一个每次递增一步，一个每次递增两步，如果有环的话两者必然重合，反之亦然）： \nbool check(const node* head)\n{\n    if(head==NULL)  return false;\n    node *low=head, *fast=head-&gt;next;\n    while(fast!=NULL &amp;&amp; fast-&gt;next!=NULL)\n    {\n        low=low-&gt;next;\n        fast=fast-&gt;next-&gt;next;\n        if(low==fast) return true;\n    }\n    return false;\n}\n\n\n</code></pre>\n<hr>\n<p>##48. 指针找错题</p>\n<p>分析这些面试题，本身包含很强的趣味性 ; 而作为一名研发人员，通过对这些面试题的深入剖析则可进一步增强自身的内功。<br>　　 2. 找错题 试题 1 ：<br>以下是引用片段：<br>void test1()  // 数组越界<br>　　 {<br>　　 char string[10];<br>　　 char<em> str1 = “0123456789”;<br>　　 strcpy( string, str1 );<br>　　 }<br>　　试题 2 ：　<br>以下是引用片段：<br>　 void test2()<br>　　 {<br>　　 char string[10], str1[10];<br>　　 int i;<br>　　 for(i=0; i&lt;10; i++)<br>　　 {<br>　　 str1= ‘a’;<br>　　 }<br>　　 strcpy( string, str1 );<br>　　 }<br>　　试题 3 ：　　<br>以下是引用片段：<br>void test3(char</em> str1)<br>　　 {<br>　　 char string[10];<br>　　 if( strlen( str1 ) &lt;= 10 )<br>　　 {<br>　　 strcpy( string, str1 );<br>　　 }<br>　　 }<br>　　解答：<br>　　试题 1 字符串 str1 需要 11 个字节才能存放下 ( 包括末尾的 ’/0’) ，而 string 只有 10 个字节的空间， strcpy会导致数组越界 ; 对试题 2 ，如果面试者指出字符数组 str1 不能在数组内结束可以给 3 分 ; 如果面试者指出strcpy(string,str1) 调用使得从 str1 内存起复制到 string 内存起所复制的字节数具有不确定性可以给 7 分，在此基础上指出库函数 strcpy 工作方式的给 10 分 ;<br>对试题 3 ， if(strlen(str1) &lt;= 10) 应改为 if(strlen(str1) &lt;10) ，因为 strlen 的结果未统计 ’/0’ 所占用的 1 个字节。剖析：考查对基本功的掌握<br>　　 (1) 字符串以 ’/0’ 结尾 ;<br>　　 (2) 对数组越界把握的敏感度 ;<br>　　 (3) 库函数 strcpy 的工作方式，</p>\n<hr>\n<p>##49. 如果编写一个标准 strcpy 函数</p>\n<p>总分值为 10 ，下面给出几个不同得分的答案： 2 分 以下是引用片段：<br>void strcpy( char <em>strDest, char </em>strSrc )<br>　　 {<br>　　 while( (<em>strDest++ = </em> strSrc++) != ‘/0’ );<br>　　 }<br>　　 4 分　以下是引用片段：<br>　 void strcpy( char <em>strDest, const char </em>strSrc )<br>　　 // 将源字符串加 const ，表明其为输入参数，加 2 分<br>　　 {<br>　　 while( (<em>strDest++ = </em> strSrc++) != ‘/0’ );<br>　　 }<br>　　 7 分 以下是引用片段：<br>void strcpy(char <em>strDest, const char </em>strSrc)<br>　　 {<br>　　 // 对源地址和目的地址加非 0 断言，加 3 分<br>　　 assert( (strDest != NULL) &amp;&amp;(strSrc != NULL) );<br>　　 while( (<em>strDest++ = </em> strSrc++) != ‘/0’ );<br>　　 }<br>　　 10 分 以下是引用片段：<br>// 为了实现链式操作，将目的地址返回，加 3 分 !<br>　　 char <em> strcpy( char </em>strDest, const char <em>strSrc )<br>　　 {<br>　　 assert( (strDest != NULL) &amp;&amp;(strSrc != NULL) );<br>　　 char </em>address = strDest;<br>　　 while( (<em>strDest++ = </em> strSrc++) != ‘/0’ );<br>　　 return address;<br>　　 }<br>　　从 2 分到 10 分的几个答案我们可以清楚的看到，小小的 strcpy 竟然暗藏着这么多玄机，真不是盖的 ! 需要多么扎实的基本功才能写一个完美的 strcpy 啊 !<br>　　 (4) 对 strlen 的掌握，它没有包括字符串末尾的 ‘/0’ 。<br>　　读者看了不同分值的 strcpy 版本，应该也可以写出一个 10 分的 strlen 函数了，完美的版本为： int strlen( const char <em>str ) // 输入参数 const 　以下是引用片段：<br>　 {<br>　　 assert( strt != NULL ); // 断言字符串地址非 0<br>　　 int len=0; // 注，一定要初始化。<br>　　 while( (</em>str++) != ‘/0’ )<br>　　 {<br>　　 len++;<br>　　 }<br>　　 return len;<br>　　 }<br>　　试题 4 ：以下是引用片段：<br>void GetMemory( char <em>p )<br>　　 {<br>　　 p = (char </em>) malloc( 100 );<br>　　 }<br>　　 void Test( void )<br>　　 {<br>　　 char <em>str = NULL;<br>　　 GetMemory( str );<br>　　 strcpy( str, “hello world” );<br>　　 printf( str );<br>　　 }<br>　　试题 5 ：　<br>以下是引用片段：<br>char </em>GetMemory( void )<br>　　 {<br>　　 char p[] = “hello world”;<br>　　 return p;<br>　　 }<br>　　 void Test( void )<br>　　 {<br>　　 char <em>str = NULL;<br>　　 str = GetMemory();<br>　　 printf( str );<br>　　 }<br>　　试题 6 ：以下是引用片段：<br>void GetMemory( char **p, int num )<br>　　 {\n　　 </em>p = (char <em>) malloc( num );<br>　　 }<br>　　 void Test( void )<br>　　 {<br>　　 char </em>str = NULL;<br>　　 GetMemory( &amp;str, 100 );<br>　　 strcpy( str, “hello” );<br>　　 printf( str );<br>　　 }<br>　　试题 7 ：以下是引用片段：<br>　 void Test( void )<br>　　 {<br>　　 char <em>str = (char </em>) malloc( 100 );<br>　　 strcpy( str, “hello” );<br>　　 free( str );<br>　　 … // 省略的其它语句<br>　　 }<br>　　解答：试题 4 传入中 GetMemory( char <em>p ) 函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的值，执行完<br>　　 char </em>str = NULL;<br>　　 GetMemory( str );<br>　　后的 str 仍然为 NULL; 试题 5 中<br>　　 char p[] = “hello world”;<br>　　 return p;<br>　　的 p[] 数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。<br>　　试题 6 的 GetMemory 避免了试题 4 的问题，传入 GetMemory 的参数为字符串指针的指针，但是在GetMemory 中执行申请内存及赋值语句 tiffanybracelets<br>　　 <em>p = (char </em>) malloc( num );<br>　　后未判断内存是否申请成功，应加上：<br>　　 if ( *p == NULL )<br>　　 {<br>　　 …// 进行申请内存失败处理 </p>\n<p>　　 }<br>　　试题 7 存在与试题 6 同样的问题，在执行<br>　　 char <em>str = (char </em>) malloc(100);<br>　　后未进行内存是否申请成功的判断 ; 另外，在 free(str) 后未置 str 为空，导致可能变成一个 “ 野 ” 指针，应加上：<br>　　 str = NULL;<br>　　试题 6 的 Test 函数中也未对 malloc 的内存进行释放。<br>　　剖析：<br>　　试题 4 ～ 7 考查面试者对内存操作的理解程度，基本功扎实的面试者一般都能正确的回答其中 50~60 的错误。但是要完全解答正确，却也绝非易事。</p>\n<p>软件开发网 <a href=\"http://www.mscto.com\" target=\"_blank\" rel=\"noopener\">www.mscto.com</a><br>　　对内存操作的考查主要集中在：<br>　　 (1) 指针的理解 ;<br>　　 (2) 变量的生存期及作用范围 ;<br>　　 (3) 良好的动态内存申请和释放习惯。<br>　　再看看下面的一段程序有什么错误：　　<br>以下是引用片段：<br>swap( int<em> p1,int</em> p2 )<br>　　 {<br>　　 int <em>p;\n　　 </em>p = <em>p1;\n　　 </em>p1 = <em>p2;\n　　 </em>p2 = <em>p;<br>　　 }<br>　　在 swap 函数中， p 是一个 “ 野 ” 指针，有可能指向系统区，导致程序运行的崩溃。在 VC++ 中 DEBUG 运行时提示错误 “Access Violation” 。该程序应该改为<br>以下是引用片段：<br>swap( int</em> p1,int<em> p2 )<br>　　 {<br>　　 int p;<br>　　 p = </em>p1;<br>　　 <em>p1 = </em>p2;<br>　　 *p2 = p;<br>　　 }</p>\n<hr>\n<p>##50.String 的具体实现</p>\n<p>已知 String 类定义如下： </p>\n<p>class String<br>{<br>public:<br>String(const char <em>str = NULL); // 通用构造函数<br>String(const String &amp;another); // 拷贝构造函数<br>~ String(); // 析构函数<br>String &amp; operater =(const String &amp;rhs); // 赋值函数<br>private:<br>char </em>m_data; // 用于保存字符串<br>};</p>\n<p>尝试写出类的成员函数实现。 </p>\n<p>答案：<br>String::String(const char *str)<br>{<br>if ( str == NULL ) //strlen 在参数为 NULL 时会抛异常才会有这步判断<br>{<br>m_data = new char[1] ;<br>m_data[0] = ‘/0’ ;<br>}<br>else<br>{<br>m_data = new char[strlen(str) + 1];<br>strcpy(m_data,str);<br>}</p>\n<p>} </p>\n<p>String::String(const String &amp;another)</p>\n<p>  {<br>m_data = new char[strlen(another.m_data) + 1];<br>strcpy(m_data,other.m_data);<br>}</p>\n<p>String&amp; String::operator =(const String &amp;rhs)<br>{<br>if ( this == &amp;rhs)<br>return <em>this ;<br>delete []m_data; // 删除原来的数据，新开一块内存<br>m_data = new char[strlen(rhs.m_data) + 1];<br>strcpy(m_data,rhs.m_data);<br>return </em>this ;<br>}</p>\n<p>String::~String()<br>{<br>delete []m_data ;<br>}</p>\n<hr>\n<p>##51.h 头文件中的 ifndef/define/endif 的作用？</p>\n<p>答：防止该头文件被重复引用。</p>\n<hr>\n<p>##52. ＃ i nclude&lt;file.h&gt; 与 ＃ i nclude “file.h” 的区别？</p>\n<p>答：前者是从 Standard Library 的路径寻找和引用 file.h ，而后者是从当前工作路径搜寻并引用 file.h 。 </p>\n<ol start=\"53\">\n<li>在 C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C” ？</li>\n</ol>\n<p>C++ 语言支持函数重载， C 语言不支持函数重载。 C++ 提供了 C 连接交换指定符号 extern “C”</p>\n<p>解决名字匹配问题。</p>\n<p>首先，作为 extern 是 C/C++ 语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。 </p>\n<p>通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字 extern 声明。例如，如果模块B 欲引用该模块 A 中定义的全局变量和函数时只需包含模块 A 的头文件即可。这样，模块 B 中调用模块 A 中的函数时，在编译阶段，模块 B 虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块 A 编译生成的目标代码中找到此函数 </p>\n<p>extern “C” 是连接申明 (linkage declaration), 被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和连接的 ,来看看 C++ 中对类似 C 的函数是怎样编译的： </p>\n<p>作为一种面向对象的语言， C++ 支持函数重载，而过程式语言 C 则不支持。函数被 C++ 编译后在符号库中的名字与 C 语言的不同。例如，假设某个函数的原型为： </p>\n<p>void foo( int x, int y );\n　　 </p>\n<p>该函数被 C 编译器编译后在符号库中的名字为 _foo ，而 C++ 编译器则会产生像 _foo_int_int 之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为 “mangled name” ）。 </p>\n<p>_foo_int_int 这样的名字包含了函数名、函数参数数量及类型信息， C++ 就是靠这种机制来实现函数重载的。例如，在 C++ 中，函数 void foo( int x, int y ) 与 void foo( int x, float y ) 编译生成的符号是不相同的，后者为_foo_int_float 。 </p>\n<p>同样地， C++ 中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以 “.” 来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。 </p>\n<p>未加 extern “C” 声明时的连接方式 </p>\n<p>假设在 C++ 中，模块 A 的头文件如下： </p>\n<p>// 模块 A 头文件　 moduleA.h</p>\n<p>#ifndef MODULE_A_H</p>\n<p>#define MODULE_A_H<br>int foo( int x, int y );</p>\n<p>#endif 　　 </p>\n<p>在模块 B 中引用该函数： </p>\n<p>// 模块 B 实现文件　 moduleB.cpp<br>＃ i nclude “moduleA.h”<br>foo(2,3);</p>\n<p>加 extern “C” 声明后的编译和连接方式 </p>\n<p>加 extern “C” 声明后，模块 A 的头文件变为： </p>\n<p>// 模块 A 头文件　 moduleA.h</p>\n<p>#ifndef MODULE_A_H</p>\n<p>#define MODULE_A_H<br>extern “C” int foo( int x, int y );</p>\n<p>#endif 　　 </p>\n<p>在模块 B 的实现文件中仍然调用 foo( 2,3 ) ，其结果是：<br>（ 1 ）模块 A 编译生成 foo 的目标代码时，没有对其名字进行特殊处理，采用了 C 语言的方式； </p>\n<p>（ 2 ）连接器在为模块 B 的目标代码寻找 foo(2,3) 调用时，寻找的是未经修改的符号名 _foo 。 </p>\n<p>如果在模块 A 中函数声明了 foo 为 extern “C” 类型，而模块 B 中包含的是 extern int foo( int x, int y ) ，则模块 B找不到模块 A 中的函数；反之亦然。 </p>\n<p>所以，可以用一句话概括 extern “C” 这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）：实现 C++ 与 C 及其它语言的混合编程。　　 </p>\n<p>明白了 C++ 中 extern “C” 的设立动机，我们下面来具体分析 extern “C” 通常的使用技巧： </p>\n<p>extern “C” 的惯用法 </p>\n<p>（ 1 ）在 C++ 中引用 C 语言中的函数和变量，在包含 C 语言头文件（假设为 cExample.h ）时，需进行下列处理： </p>\n<p>extern “C”<br>{<br>＃ i nclude “cExample.h”<br>}</p>\n<p>而在 C 语言的头文件中，对其外部函数只能指定为 extern 类型， C 语言中不支持 extern “C” 声明，在 .c 文件中包含了 extern “C” 时会出现编译语法错误。 </p>\n<p>C++ 引用 C 函数例子工程中包含的三个文件的源代码如下： </p>\n<p>/<em> c 语言头文件： cExample.h </em>/</p>\n<p>#ifndef C_EXAMPLE_H</p>\n<p>#define C_EXAMPLE_H<br>extern int add(int x,int y);</p>\n<p>#endif</p>\n<p>/<em> c 语言实现文件： cExample.c </em>/<br>＃ i nclude “cExample.h”<br>int add( int x, int y )<br>{<br>return x + y;<br>}</p>\n<p>// c++ 实现文件，调用 add ： cppFile.cpp<br>extern “C”<br>{<br>＃ i nclude “cExample.h”<br>}<br>int main(int argc, char* argv[])<br>{<br>add(2,3);<br>return 0;<br>}</p>\n<p>如果 C++ 调用一个 C 语言编写的 .DLL 时，当包括 .DLL 的头文件或声明接口函数时，应加 extern “C” { 　 } 。 </p>\n<p>（ 2 ）在 C 中引用 C++ 语言中的函数和变量时， C++ 的头文件需添加 extern “C” ，但是在 C 语言中不能直接引用声明了 extern “C” 的该头文件，应该仅将 C 文件中将 C++ 中定义的 extern “C” 函数声明为 extern 类型。 </p>\n<p>C 引用 C++ 函数例子工程中包含的三个文件的源代码如下： </p>\n<p>//C++ 头文件 cppExample.h</p>\n<p>#ifndef CPP_EXAMPLE_H</p>\n<p>#define CPP_EXAMPLE_H<br>extern “C” int add( int x, int y );</p>\n<p>#endif</p>\n<p>//C++ 实现文件 cppExample.cpp<br>＃ i nclude “cppExample.h”<br>int add( int x, int y )<br>{<br>return x + y;<br>}</p>\n<p>/<em> C 实现文件 cFile.c<br>/</em> 这样会编译出错：＃ i nclude “cExample.h” */</p>\n<p>int main( int argc, char* argv[] )<br>{<br>add( 2, 3 );<br>return 0;<br>}</p>\n<p>15 题目的解答请参考《 C++ 中 extern “C” 含义深层探索》注解：</p>\n<p>几道 c 笔试题 ( 含参考答案 )</p>\n<ol>\n<li>What is displayed when f() is called given the code:<br>class Number {<br>public:<br>string type; </li>\n</ol>\n<p>Number(): type( “ void ” ) { }<br>explicit Number(short) : type( “ short ” ) { }<br>Number(int) : type( “ int ” ) { }<br>};<br>void Show(const Number&amp; n) { cout &lt;&lt; n.type; }<br>void f()<br>{<br>short s = 42;<br>Show(s);<br>}<br>a) void<br>b) short<br>c) int<br>d) None of the above</p>\n<ol start=\"2\">\n<li>Which is the correct output for the following code<br>double dArray[2] = {4, 8}, <em>p, </em>q;<br>p = &amp;dArray[0];<br>q = p + 1;<br>cout &lt;&lt; q – p &lt;&lt; endl;<br>cout &lt;&lt; (int)q - (int)p &lt;&lt; endl;<br>a) 1 and 8<br>b) 8 and 4<br>c) 4 and 8<br>d) 8 and 1</li>\n</ol>\n<p>第一个选 C ；<br>虽然传入的是 short 类型，但是 short 类型的构造函数被生命被 explicit ，也就是只能显示类型转换，不能使用隐式类型转换。<br>第二个选 A ；<br>第一个是指针加减，按照的是指向地址类型的加减，只跟类型位置有关， q 和 p 指向的数据类型以实际数据类型来算差一个位置，因此是 1 。而第二个加减是实际指针值得加减，在内存中一个 double 类型占据 8 个字节，因此是 8</p>\n<p>54.Sony 笔试题</p>\n<p>　　 1 ．完成下列程序<br>　　 <em> \n　　 </em>.<em>. \n　　 </em>..<em>..</em>..<br>　　 <em>…</em>…<em>…</em>…<br>　　 <em>….</em>….<em>….</em>….<em>…. \n　　 </em>…..<em>…..</em>…..<em>…..</em>…..<em>….. \n　　 </em>……<em>……</em>……<em>……</em>……<em>……</em>……<br>　　 <em>…….</em>…….<em>…….</em>…….<em>…….</em>…….<em>…….</em>…….<br>　　 #include<br>　　 #define N 8<br>　　 int main()<br>　　 {<br>　　 int i;<br>　　 int j;<br>　　 int k;<br>　　 ———————————————————<br>　　 | |<br>　　 | |<br>　　 | |<br>　　 ———————————————————<br>　　 return 0;<br>　　 }<br>　　 2 ．完成程序，实现对数组的降序排序<br>　　 #include<br>　　 void sort( );<br>　　 int main()<br>　　 {<br>　　 int array[]={45 ， 56 ， 76 ， 234 ， 1 ， 34 ， 23 ， 2 ， 3} ； // 数字任 // 意给出<br>　　 sort( );<br>　　 return 0;<br>　　 }<br>　　 void sort( )<br>　　 {<br>　　 <strong><strong><strong><strong><strong><strong><strong><strong>____</strong></strong></strong></strong></strong></strong></strong></strong><br>　　 | |<br>　　 | |<br>　　 |—————————————————–|<br>　　 }<br>　　 3 ．费波那其数列， 1 ， 1 ， 2 ， 3 ， 5 ……编写程序求第十项。可以用递归，也可以用其<br>他方法，但要说明你选择的理由。<br>　　 #include<br>　　 int Pheponatch(int);<br>　　 int main()<br>　　 {<br>　　 printf(“The 10th is %d”,Pheponatch(10));<br>　　 return 0;<br>　　 }<br>　　 int Pheponatch(int N)<br>　　 {<br>　　 ——————————–<br>　　 | |<br>　　 | |<br>　　 ——————————–<br>　　 }<br>　　 4 ．下列程序运行时会崩溃，请找出错误并改正，并且说明原因。<br>　　 #include<br>　　 #include<br>　　 typedef struct{<br>　　 TNode<em> left;<br>　　 TNode</em> right;<br>　　 int value;<br>　　 } TNode;<br>　　 TNode<em> root=NULL;<br>　　 void append(int N);<br>　　 int main()<br>　　 {<br>　　 append(63);<br>　　 append(45);<br>　　 append(32);<br>　　 append(77);<br>　　 append(96);<br>　　 append(21);<br>　　 append(17); // Again, 数字任意给出<br>　　 }<br>　　 void append(int N)<br>　　 {<br>　　 TNode</em> NewNode=(TNode *)malloc(sizeof(TNode));<br>　　 NewNode-&gt;value=N; </p>\n<p>　　 if(root==NULL)<br>　　 {<br>　　 root=NewNode;<br>　　 return;<br>　　 }<br>　　 else<br>　　 {<br>　　 TNode* temp;<br>　　 temp=root; </p>\n<p>　　 while((N&gt;=temp.value &amp;&amp; temp.left!=NULL) || (N !=NULL<br>　　 ))<br>　　 {<br>　　 while(N&gt;=temp.value &amp;&amp; temp.left!=NULL)<br>　　 temp=temp.left;<br>　　 while(N 　　 temp=temp.right;<br>　　 }<br>　　 if(N&gt;=temp.value)<br>　　 temp.left=NewNode;<br>　　 else<br>　　 temp.right=NewNode;<br>　　 return;<br>　　 }<br>　　 } </p>\n<p>※ 来源 : ·哈工大紫丁香 <a href=\"http://bbs.hit.edu.cn\" target=\"_blank\" rel=\"noopener\">http://bbs.hit.edu.cn</a> · [FROM:219.217.233.47] </p>\n<p>────────────────────────────────────────<br>mengfd (Icebreaker) 于 (Sun Oct 23 14:59:59 2005) 说道 :</p>\n<p>55 请你分别画出 OSI 的七层网络结构图和 TCP/IP 的五层结构图。</p>\n<p>应用层：为应用程序提供服务</p>\n<p>表示层：处理在两个通信系统中交换信息的表示方式</p>\n<p>会话层：负责维护两个结点间会话连接的建立、管理和终止，以及数据交换</p>\n<p>传输层：向用户提供可靠的端到端服务。 UDP TCP 协议。</p>\n<p>网络层：通过路由选择算法为分组通过通信子网选择最适当的路径，以及实现拥塞控制、网络互联等功能。数据传输单元是分组。 IP 地址，路由器， IP 协议。</p>\n<p>数据链路层：在物理层提供的服务基础上，数据链路层在通信的实体间建立数据链路连接，传输一帧为单位的数据包（，并采用差错控制与流量控制方法，使有差错的物理线路变成无差错的数据链路。）</p>\n<p>物理层：传输比特流。传输单元是比特。调制解调器。</p>\n<p>TCP/IP详解学习笔记(1)-基本概念</p>\n<p>56 请你详细地解释一下 IP 协议的定义，在哪个层上面？主要有什么作用？ TCP 与 UDP 呢 ？</p>\n<p>网络层。</p>\n<ol start=\"57\">\n<li>请问交换机和路由器各自的实现原理是什么？分别在哪个层次上面实现的？</li>\n</ol>\n<p>交换机：数据链路层。路由器：网络层。</p>\n<ol start=\"58\">\n<li>全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的 ？</li>\n</ol>\n<p>59.8086 是多少位的系统？在数据总线上是怎么实现的？ </p>\n<p>8086 微处理器共有 4 个 16 位的段寄存器，在寻址内存单元时，用它们直接或间接地存放段地址。</p>\n<p>　　代码段寄存器 CS ：存放当前执行的程序的段地址。</p>\n<p>　　数据段寄存器 DS ：存放当前执行的程序所用操作数的段地址。</p>\n<p>　　堆栈段寄存器 SS ：存放当前执行的程序所用堆栈的段地址。</p>\n<p>　　附加段寄存器 ES ：存放当前执行程序中一个辅助数据段的段地址。</p>\n<p>由 cs:ip 构成指令地址， ss:sp 构成堆栈的栈顶地址指针。 DS 和 ES 用作数据段和附加段的段地址（段起始地址或段值）</p>\n<p>8086 ／ 8088 微处理器的存储器管理</p>\n<ol>\n<li><p>地址线（码）与寻址范围： N 条地址线      寻址范围 =2N</p>\n<p>2.8086 有 20 地址线      寻址范围为 1MB  由 00000H ～ FFFFFH</p>\n</li>\n<li><p>8086 微处理器是一个 16 位结构，用户可用的寄存器均为 16 位：寻址 64KB</p>\n</li>\n<li><p>8086 ／ 8088 采用分段的方法对存储器进行管理。具体做法是：把 1MB 的存储器空间分成若干段，每段容量为 64KB ，每段存储器的起始地址必须是一个能被 16 整除的地址码，即在 20 位的二进制地址码中最低 4 位必须是 “0” 。每个段首地址的高 16 位二进制代码就是该段的段号 ( 称段基地址 ) 或简称段地址，段号保存在段寄存器中。我们可对段寄存器设置不同的值来使微处理器的存储器访问指向不同的段。</p>\n</li>\n<li><p>段内的某个存储单元相对于该段段首地址的差值，称为段内偏移地址 ( 也叫偏移量 ) 用 16 位二进制代码表示。</p>\n</li>\n<li><p>物理地址是由 8086 ／ 8088 芯片地址引线送出的 20 位地址码，它用来参加存储器的地址译码，最终读／写所访问的一个特定的存储单元。</p>\n</li>\n<li><p>逻辑地址由某段的段地址和段内偏移地址 ( 也叫偏移量 ) 两部分所组成。写成：</p>\n<p>段地址：偏移地址 ( 例如， 1234H ： 0088H) 。</p>\n</li>\n<li><p>在硬件上起作用的是物理地址，物理地址＝段基地址 ×10H 十偏移地址</p>\n</li>\n</ol>\n<p>联想笔试题<br>　　 1 ．设计函数 int atoi(char *s) 。<br>　　 2 ． int i=(j=4,k=8,l=16,m=32); printf( “ %d ” , i); 输出是多少？ </p>\n<ol start=\"60\">\n<li>解释局部变量、全局变量和静态变量的含义。</li>\n</ol>\n<p>　　 4 ．解释堆和栈的区别。</p>\n<ol start=\"61\">\n<li>论述含参数的宏与函数的优缺点。 </li>\n</ol>\n<p>普天 C++ 笔试题<br>　　 1 ．实现双向链表删除一个节点 P ，在节点 P 后插入一个节点，写出这两个函数。<br>　　 2 ．写一个函数，将其中的 /t 都转换成 4 个空格。</p>\n<p>61.Windows 程序的入口是哪里？写出 Windows 消息机制的流程。 </p>\n<p>4 ．如何定义和实现一个类的成员函数为回调函数？</p>\n<p>62.C++ 里面是不是所有的动作都是 main() 引起的？如果不是，请举例。 \n　　</p>\n<p>6 ． C++ 里面如何声明 const void f(void) 函数为 C 程序中的库函数？<br>　　 7 ．下列哪两个是等同的<br>　　 int b;<br>　　 A const int<em> a = &b;<br>　　 B const</em> int a = &b;<br>　　 C const int<em> const a = &b;<br>　　 D int const</em> const a = &b;<br>　　 8 ．内联函数在编译时是否做参数类型检查？<br>　　 void g(base &amp; b){<br>　　 b.play;<br>　　 }<br>　　 void main(){<br>　　 son s;<br>　　 g(s);<br>　　 return;<br>　　 } </p>\n<p>※ 来源 : ·哈工大紫丁香 <a href=\"http://bbs.hit.edu.cn\" target=\"_blank\" rel=\"noopener\">http://bbs.hit.edu.cn</a> · [FROM:219.217.233.47] </p>\n<p>────────────────────────────────────────<br>mengfd (Icebreaker) 于 (Sun Oct 23 15:00:14 2005) 说道 : </p>\n<p>大唐电信<br>　　 DTT 笔试题<br>　　考试时间一小时，第一部分是填空和选择：<br>　　 1 ．数列 6 ， 10 ， 18 ， 32 ，“？”，问“？”是几？<br>　　 2 ．某人出 70 买进一个 x ， 80 卖出， 90 买回， 100 卖出，这桩买卖怎么样？<br>　　 3 ．月球绕地球一圈，至少要多少时间？<br>　　 4 ． 7 个人用 7 小时挖了 7 米 的沟，以同样的速度在 50 小时挖 50 米 的沟要多少人？<br>　　 5 ．鱼头长 9 ，鱼尾等于鱼头加半个鱼身，鱼身等于鱼头加鱼尾，问鱼全长多少？<br>　　 6 ．一个小姐买了一块手表，回家发现手表比她家的表慢了两分钟，晚上看新闻的时候<br>又发现她家的表比新闻里的时间慢了两分钟，则 。<br>　　 A 手表和新闻里的时间一样<br>　　 B 手表比新闻里的时间慢<br>　　 C 手表比新闻里的时间快<br>　　 7 ．王先生看到一则招聘启事，发现两个公司除了以下条件不同外，其他条件都相同 </p>\n<p>　　 A 半年年薪 50 万，每半年涨 5 万<br>　　 B 一年年薪 100 万，每一年涨 20 万<br>　　王先生想去一家待遇比较优厚的公司，他会去哪家？<br>　　 10 ．问哪个袋子里有金子？<br>　　 A 袋子上的标签是这样写的： B 袋子上的话是对的，金子在 A 袋子。<br>　　 B 袋子上的标签是这样写的： A 袋子上的话是错的，金子在 A 袋子里。<br>　　 11 ． 3 个人住酒店 30 块钱，经理找回 5 块钱，服务生从中藏了 2 块钱，找给每人 1 块钱，<br>3 ×（ 101 ） +2=29 ，问这是怎么回事？<br>　　 12 ．三篇写作，均为书信形式。<br>　　（ 1 ）一片中文的祝贺信，祝贺某男当了某公司 xx<br>　　（ 2 ）两篇英文的，一是说有事不能应邀，派别人去；另一篇是讨债的， 7 天不给钱就<br>走人（主要考 business letter 格式）。<br>　　大唐面试试题<br>　　 1 ．什么是中断？中断发生时 CPU 做什么工作？<br>　　 2 ． CPU 在上电后，进入操作系统的 main() 之前必须做什么工作？<br>　　 3 ．简述 ISO OSI 的物理层 Layer1 ，链路层 Layer2 ，网络层 Layer3 的任务。<br>　　 4 ．有线电话和无线电话有何区别？无线电话特别需要注意的是什么？ \n　　</p>\n<ol start=\"63\">\n<li>软件开发五个主要 step 是什么？</li>\n</ol>\n<p>　　 6 ．你在开发软件的时候，这 5 个 step 分别占用的时间百分比是多少？<br>　　 7 ． makefile 文件的作用是什么？<br>　　 8 ． UNIX 显示文件夹中，文件名的命令是什么？能使文件内容显示在屏幕的命令是什么<br>？<br>　　 9 ．（选做）手机用户在从一个基站漫游到另一个基站的过程中，都会发生什么 ? </p>\n<p>※ 来源 : ·哈工大紫丁香 <a href=\"http://bbs.hit.edu.cn\" target=\"_blank\" rel=\"noopener\">http://bbs.hit.edu.cn</a> · [FROM:219.217.233.47] </p>\n<p>────────────────────────────────────────<br>mengfd (Icebreaker) 于 (Sun Oct 23 15:01:22 2005) 说道 : </p>\n<p>网通笔试题<br>　　选择题（每题 5 分，只有一个正确答案）<br>　　 1 ．中国 1 号信令协议属于 的协议。<br>　　 A ccs B cas C ip D atm<br>　　 2 ． isdnpri 协议全称是 。<br>　　 A 综合业务模拟网基速协议<br>　　 B 综合业务模拟网模拟协议<br>　　 C 综合业务数字网基率协议<br>　　 D 综合业务数字网基次协议<br>　　 3 ．路由协议中， 协议是用距离作为向量的。<br>　　 A ospf B bgp C is-is D rip<br>　　 4 ．中国智能网中， ssp 与 scp 间最上层的 ss7 协议是 。<br>　　 A incs B is41b C is41c D inap<br>　　 5 ． dtmf 全称是 。<br>　　 A 双音多频 B 多音双频 C 多音三频 D 三音多频<br>　　 6 ．计算机的基本组成部分中，不包含下面设备的是 。<br>　　 A cpu B 输入设备 C 存储器 D 接口<br>　　 7 ．脉冲编码调制的简称是 。<br>　　 A pcm B pam C (delta)M D atm<br>　　 8 ．普通电话线接口专业称呼是 。<br>　　 A rj11 B rj45 C rs232 D bnc<br>　　 9 ．现有的公共数据网都采用 。<br>　　 A 电路交换技术 B 报文交换技术<br>　　 C 语音插空 D 分组交换<br>　　 10 ． ss7 协议中的制止市忙消息简写为 。<br>　　 A stb B slb C sub D spb<br>　　简答题（每题 10 分）<br>　　 1 ．简述普通电话与 IP 电话的区别。<br>　　 2 ．简述随路信令与公路信令的根本区别。<br>　　 3 ．说明掩码的主要作用。<br>　　 4 ． ss7 协议中，有三大要素决定其具体定位，哪三大要素？<br>　　 5 ．描述 ss7 的基本通话过程。<br>　　 6 ．简述通信网的组成结构。<br>　　 7 ．面向连接与面向非连接各有何利弊？<br>　　 8 ．写出爱尔兰的基本计算公式。<br>　　 9 ．数据网主要有哪些设备？<br>　　 10 ．中国一号协议是如何在被叫号码中插入主叫号码的？ </p>\n<p>东信笔试题目<br>　　笔试： 30 分钟。<br>　　 1 ．压控振荡器的英文缩写。<br>　　 2 ．动态随机存储器的英文缩写。<br>　　 3 ．选择电阻时要考虑什么？<br>　　 4 ．单片机上电后没有运转，首先要检查什么？<br>　　 5 ．计算机的基本组成部分及其各自的作用。<br>　　 6 ．怎样用 D 触发器、与或非门组成二分频电路？</p>\n<p>64.static 有什么用途？（请至少说明两种）</p>\n<p>答 、 1. 限制变量的作用域 ( 文件级的 ) 。</p>\n<ol start=\"2\">\n<li>设置变量的存储域 ( 全局数据区 ) 。</li>\n</ol>\n<ol start=\"65\">\n<li>引用与指针有什么区别？</li>\n</ol>\n<p>答 、 1) 引用必须被初始化，指针不必。</p>\n<p>2) 引用初始化以后不能被改变，指针可以改变所指的对象。</p>\n<p>3) 不存在指向空值的引用，但是存在指向空值的指针。</p>\n<ol start=\"66\">\n<li>描述实时系统的基本特性</li>\n</ol>\n<p>答 、在特定时间内完成特定的任务，实时性与可靠性。</p>\n<ol start=\"67\">\n<li>全局变量和局部变量在内存中是否有区别？如果有，是什么区别？</li>\n</ol>\n<p>答 、全局变量储存在静态数据区，局部变量在堆栈中。</p>\n<ol start=\"68\">\n<li>什么是平衡二叉树？</li>\n</ol>\n<p>答 、左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于 1 。</p>\n<ol start=\"69\">\n<li>堆栈溢出一般是由什么原因导致的？</li>\n</ol>\n<p>答 、 1. 没有回收垃圾资源</p>\n<pre><code>     2. 层次太深的递归调用      \n</code></pre><ol start=\"70\">\n<li>什么函数不能声明为虚函数？</li>\n</ol>\n<p>答 、 constructor</p>\n<pre><code>   Deconstructor 可以声明为虚函数。\n\n   系统为一个空类创建的成员函数有那些。\n</code></pre><ol start=\"71\">\n<li>冒泡排序算法的时间复杂度是什么？</li>\n</ol>\n<p>答 、 O(n^2)</p>\n<ol start=\"72\">\n<li>写出 float x 与“零值”比较的 if 语句。</li>\n</ol>\n<p>答 、 if(x&gt;0.000001&amp;&amp;x&lt;-0.000001)</p>\n<p>73.Internet 采用哪种网络协议？该协议的主要层次结构？</p>\n<p>答 、 tcp/ip 应用层 / 传输层 / 网络层 / 数据链路层 / 物理层</p>\n<p>74.Internet 物理地址和 IP 地址转换采用什么协议？</p>\n<p>答 、 ARP (Address Resolution Protocol) （地址解析协议）</p>\n<p>75.IP 地址的编码分为哪俩部分？</p>\n<p>答 、 IP 地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与之后才能区分哪些是网络位哪些是主机位。</p>\n<ol start=\"76\">\n<li>用户输入 M,N 值，从 1 至 N 开始顺序循环数数，每数到 M 输出该数值，直至全部输出。写出 C 程序。</li>\n</ol>\n<p>答 、循环链表，用取余操作做</p>\n<ol start=\"77\">\n<li>不能做 switch() 的参数类型是：</li>\n</ol>\n<p>答 、 switch 的参数不能为实型。</p>\n<p>华为</p>\n<ol start=\"78\">\n<li>局部变量能否和全局变量重名？</li>\n</ol>\n<p>答、能，局部会屏蔽全局。要用全局变量，需要使用 “::”</p>\n<p>局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内</p>\n<ol start=\"79\">\n<li>如何引用一个已经定义过的全局变量？</li>\n</ol>\n<p>答 、可以用引用头文件的方式，也可以用 extern 关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用 extern 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错</p>\n<ol start=\"80\">\n<li>全局变量可不可以定义在可被多个 .C 文件包含的头文件中？为什么？</li>\n</ol>\n<p>答 、可以，在不同的 C 文件中以 static 形式来声明同名全局变量。</p>\n<p>可以在不同的 C 文件中声明同名的全局变量，前提是其中只能有一个 C 文件中对此变量赋初值，此时连接不会出错</p>\n<ol start=\"81\">\n<li>语句 for( ； 1 ； ) 有什么问题？它是什么意思？</li>\n</ol>\n<p>答 、和 while(1) 相同。</p>\n<p>82.do …… while 和 while …… do 有什么区别？</p>\n<p>答 、前一个循环一遍再判断，后一个判断以后再循环</p>\n<ol start=\"83\">\n<li>请写出下列代码的输出内容</li>\n</ol>\n<p>#i nclude</p>\n<p>main()</p>\n<p>{</p>\n<p>int a,b,c,d;</p>\n<p>a=10;</p>\n<p>b=a++;</p>\n<p>c=++a;</p>\n<p>d=10*a++;</p>\n<p>printf(“b ， c ， d ： %d ， %d ， %d” ， b ， c ， d ） ;</p>\n<p>return 0;</p>\n<p>}</p>\n<p>答 、 10 ， 12 ， 120</p>\n<p>84.statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数</p>\n<p>static 全局变量与普通的全局变量有什么区别？ static 局部变量和普通局部变量有什么区别？ static 函数与普通函数有什么区别？</p>\n<p>答 、全局变量 ( 外部变量 ) 的说明之前再冠以 static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。</p>\n<p>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。</p>\n<p>static 函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数 (static) ，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件</p>\n<p>static 全局变量与普通的全局变量有什么区别： static 全局变量只初使化一次，防止在其他文件单元中被引用 ;</p>\n<p>static 局部变量和普通局部变量有什么区别： static 局部变量只被初始化一次，下一次依据上一次结果值；</p>\n<p>static 函数与普通函数有什么区别： static 函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</p>\n<p>程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。</p>\n<ol start=\"85\">\n<li>设有以下说明和定义：</li>\n</ol>\n<p>typedef union {long i; int k[5]; char c;} DATE;</p>\n<p>struct data { int cat; DATE cow; double dog;} too;</p>\n<p>DATE max;</p>\n<p>则语句 printf(“%d”,sizeof(struct date)+sizeof(max)); 的执行结果是？</p>\n<p>答 、结果是： <strong>_52__</strong> 。 DATE 是一个 union, 变量公用空间 . 里面最大的变量类型是 int[5], 占用 20 个字节. 所以它的大小是 20</p>\n<p>data 是一个 struct, 每个变量分开占用空间 . 依次为 int4 + DATE20 + double8 = 32.</p>\n<p>所以结果是 20 + 32 = 52.</p>\n<p>当然 … 在某些 16 位编辑器下 , int 可能是 2 字节 , 那么结果是 int2 + DATE10 + double8 = 20</p>\n<p>86.-1,2,7,28,,126 请问 28 和 126 中间那个数是什么？为什么？</p>\n<p>答 、应该是 4^3-1=63</p>\n<p>规律是 n^3-1( 当 n 为偶数 0 ， 2 ， 4)</p>\n<p>n^3+1( 当 n 为奇数 1 ， 3 ， 5)</p>\n<ol start=\"87\">\n<li>用两个栈实现一个队列的功能？要求给出算法和思路！</li>\n</ol>\n<p>答 、设 2 个栈为 A,B, 一开始均为空 .</p>\n<p>入队 :</p>\n<p>将新元素 push 入栈 A;</p>\n<p>出队 :</p>\n<p>(1) 判断栈 B 是否为空；</p>\n<p>(2) 如果不为空，则将栈 A 中所有元素依次 pop 出并 push 到栈 B ；</p>\n<p>(3) 将栈 B 的栈顶元素 pop 出；</p>\n<p>这样实现的队列入队和出队的平摊复杂度都还是 O(1), 比上面的几种方法要好。</p>\n<ol start=\"88\">\n<li>在 c 语言库函数中将一个字符转换成整型的函数是atool() 吗，这个函数的原型是什么？</li>\n</ol>\n<p>答 、函数名 : atol</p>\n<p>功 能 : 把字符串转换成长整型数</p>\n<p>用 法 : long atol(const char *nptr);</p>\n<p>程序例 :</p>\n<p>＃ include</p>\n<p>＃ include</p>\n<p>int main(void)</p>\n<p>{</p>\n<pre><code>long l;\n\nchar *str = &quot;98765432&quot;;\n\nl = atol(lstr);\n\nprintf(&quot;string = %s integer = %ld/n&quot;, str, l);\n\nreturn(0);\n</code></pre><p>}</p>\n<ol start=\"89\">\n<li>对于一个频繁使用的短小函数 , 在 C 语言中应用什么实现 , 在 C++ 中应用什么实现 ?</li>\n</ol>\n<p>答 、 c 用宏定义， c++ 用 inline</p>\n<ol start=\"90\">\n<li>用预处理指令 #define 声明一个常数，用以表明 1年中有多少秒（忽略闰年问题）</li>\n</ol>\n<p>#define SECONDS_PER_YEAR (60 <em> 60 </em> 24 * 365)UL</p>\n<p>我在这想看到几件事情：</p>\n<p>1). #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）</p>\n<p>2). 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。</p>\n<p>3). 意识到这个表达式将使一个 16 位机的整型数溢出 - 因此要用到长整型符号 L, 告诉编译器这个常数是的长整型数。</p>\n<p>4). 如果你在你的表达式中用到 UL （表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。</p>\n<ol start=\"91\">\n<li>写一个“标准”宏 MIN ，这个宏输入两个参数并返回较小的一个。</li>\n</ol>\n<p>#define MIN(A,B) ((A) &lt;= (B) (A) : (B))</p>\n<p>这个测试是为下面的目的而设的：</p>\n<p>1). 标识 #define 在宏中应用的基本知识。这是很重要的，因为直到嵌入 (inline) 操作符变为标准 C 的一部分，宏是方便产生嵌入代码的唯一方法，</p>\n<p>对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。</p>\n<p>2). 三重条件操作符的知识。这个操作符存在 C 语言中的原因是它使得编译器能产生比 if-then-else 更优化的代码，了解这个用法是很重要的。</p>\n<p>3). 懂得在宏中小心地把参数用括号括起来</p>\n<p>4). 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？</p>\n<p>least = MIN(*p++, b);</p>\n<ol start=\"92\">\n<li>预处理器标识 #error 的目的是什么？</li>\n</ol>\n<p>如果你不知道答案，请看参考文献 1 。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读 C 语言课本的附录去找出象这种</p>\n<p>问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。</p>\n<p>死循环（ Infinite loops ）</p>\n<ol start=\"93\">\n<li>嵌入式系统中经常要用到无限循环，你怎么样用 C编写死循环呢？</li>\n</ol>\n<p>这个问题用几个解决方案。我首选的方案是：</p>\n<p>while(1)</p>\n<p>{</p>\n<p>}</p>\n<p>一些程序员更喜欢如下方案：</p>\n<p>for(;;)</p>\n<p>{</p>\n<p>}</p>\n<p>这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的</p>\n<p>基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。</p>\n<p>第三个方案是用 goto</p>\n<p>Loop :</p>\n<p>…</p>\n<p>goto Loop;</p>\n<p>应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN 程序员。</p>\n<p>数据声明（ Data declarations ）</p>\n<ol start=\"94\">\n<li>用变量 a 给出下面的定义</li>\n</ol>\n<p>a) 一个整型数（ An integer ）</p>\n<p>b) 一个指向整型数的指针（ A pointer to an integer ）</p>\n<p>c) 一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an integer ）</p>\n<p>d) 一个有 10 个整型数的数组（ An array of 10 integers ）</p>\n<p>e) 一个有 10 个指针的数组，该指针是指向一个整型数的（ An array of 10 pointers to integers ）</p>\n<p>f) 一个指向有 10 个整型数数组的指针（ A pointer to an array of 10 integers ）</p>\n<p>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（ A pointer to a function that takes an integer as an argument and returns an integer ）</p>\n<p>h) 一个有 10 个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer</p>\n<p>argument and return an integer ）</p>\n<p>答案是：</p>\n<p>a) int a; // An integer</p>\n<p>b) int *a; // A pointer to an integer</p>\n<p>c) int **a; // A pointer to a pointer to an integer</p>\n<p>d) int a[10]; // An array of 10 integers</p>\n<p>e) int *a[10]; // An array of 10 pointers to integers</p>\n<p>f) int (*a)[10]; // A pointer to an array of 10 integers</p>\n<p>g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer</p>\n<p>h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer</p>\n<p>人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。</p>\n<p>但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道</p>\n<p>所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？</p>\n<p>Static</p>\n<ol start=\"95\">\n<li>关键字 static 的作用是什么？</li>\n</ol>\n<p>这个简单的问题很少有人能回答完全。在 C 语言中，关键字 static 有三个明显的作用：</p>\n<p>1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。</p>\n<p>2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。</p>\n<p>3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。</p>\n<p>大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数</p>\n<p>据和代码范围的好处和重要性。</p>\n<p>Const</p>\n<ol start=\"96\">\n<li>关键字 const 是什么含意？</li>\n</ol>\n<p>我只要一听到被面试者说：“ const 意味着常数”，我就知道我正在和一个业余者打交道。去年 Dan Saks 已经在他的文章里完全概括了 const 的所有用法，因此 ESP( 译者： Embedded Systems Programming) 的每一位读者应该非常熟悉 const 能做什么和不能做什么 . 如果你从没有读到那篇文章，只要能说出 const 意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下 Saks 的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？</p>\n<p>const int a;</p>\n<p>int const a;</p>\n<p>const int *a;</p>\n<p>int * const a;</p>\n<p>int const * a const;</p>\n<p>前两个的作用是一样， a 是一个常整型数。第三个意味着 a 是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思 a 是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着 a 是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const ，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字 const 呢？我也如下的几下理由：</p>\n<p>1). 关键字 const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用 const 的程序员很少会留下的垃圾让别人来清理的。）</p>\n<p>2). 通过给优化器一些附加的信息，使用关键字 const 也许能产生更紧凑的代码。</p>\n<p>3). 合理地使用关键字 const 可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少 bug 的出现。</p>\n<p>Volatile</p>\n<ol start=\"97\">\n<li>关键字 volatile 有什么含意 并给出三个不同的例子。</li>\n</ol>\n<p>一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是 volatile 变量的几个例子：</p>\n<p>1). 并行设备的硬件寄存器（如：状态寄存器）</p>\n<p>2). 一个中断服务子程序中会访问到的非自动变量 (Non-automatic variables)</p>\n<p>3). 多线程应用中被几个任务共享的变量</p>\n<p>回答不出这个问题的人是不会被雇佣的。我认为这是区分 C 程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、 RTOS 等等打交道，所用这些都要求 volatile 变量。不懂得 volatile 内容将会带来灾难。</p>\n<p>假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得 volatile 完全的重要性。</p>\n<p>1). 一个参数既可以是 const 还可以是 volatile 吗？解释为什么。</p>\n<p>2). 一个指针可以是 volatile 吗？解释为什么。</p>\n<p>3). 下面的函数有什么错误：</p>\n<p>int square(volatile int *ptr)</p>\n<p>{</p>\n<p>return <em>ptr </em> *ptr;</p>\n<p>}</p>\n<p>下面是答案：</p>\n<p>1). 是的。一个例子是只读的状态寄存器。它是 volatile 因为它可能被意想不到地改变。它是 const 因为程序不应该试图去修改它。</p>\n<p>2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个 buffer 的指针时。</p>\n<p>3). 这段代码的有个恶作剧。这段代码的目的是用来返指针 <em>ptr 指向值的平方，但是，由于 </em>ptr 指向一个 volatile型参数，编译器将产生类似下面的代码：</p>\n<p>int square(volatile int *ptr)</p>\n<p>{</p>\n<p>int a,b;</p>\n<p>a = *ptr;</p>\n<p>b = *ptr;</p>\n<p>return a * b;</p>\n<p>}</p>\n<p>由于 *ptr 的值可能被意想不到地该变，因此 a 和 b 可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：</p>\n<p>long square(volatile int *ptr)</p>\n<p>{</p>\n<p>int a;</p>\n<p>a = *ptr;</p>\n<p>return a * a;</p>\n<p>}</p>\n<p>位操作（ Bit manipulation ）</p>\n<ol start=\"98\">\n<li>下面的代码输出是什么，为什么？</li>\n</ol>\n<p>void foo(void)</p>\n<p>{</p>\n<p>unsigned int a = 6;</p>\n<p>int b = -20;</p>\n<p>(a+b &gt; 6) puts(“&gt; 6”) : puts(“&lt;= 6”);</p>\n<p>}</p>\n<p>这个问题测试你是否懂得 C 语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是“ &gt;6 ”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此 -20 变成了一个非常大的正整数，所以该表达式计算出的结果大于 6 。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。</p>\n<p>99.C 语言同意一些令人震惊的结构 , 下面的结构是合法的吗，如果是它做些什么？</p>\n<p>int a = 5, b = 7, c;</p>\n<p>c = a+++b;</p>\n<p>这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：</p>\n<p>c = a++ + b;</p>\n<p>因此 , 这段代码持行后 a = 6, b = 7, c = 12 。</p>\n<p>如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是 : 这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题</p>\n<p>今天早上的面试题 9 道，比较难，</p>\n<ol start=\"100\">\n<li>线形表 a 、 b 为两个有序升序的线形表，编写一程序，使两个有序线形表合并成一个有序升序线形表 h；</li>\n</ol>\n<p>答案在 请化大学 严锐敏《数据结构第二版》第二章例题，数据结构当中，这个叫做：两路归并排序</p>\n<p>Linklist <em>unio(Linklist </em>p,Linklist *q){</p>\n<p>linklist <em>R,</em>pa,<em>qa,</em>ra;</p>\n<p>pa=p;</p>\n<p>qa=q;</p>\n<p>R=ra=p;</p>\n<p>while(pa-&gt;next!=NULL&amp;&amp;qa-&gt;next!=NULL){</p>\n<p>if(pa-&gt;data&gt;qa-&gt;data){</p>\n<p>ra-&gt;next=qa;</p>\n<p>qa=qa-&gt;next;</p>\n<p>}</p>\n<p>else{</p>\n<p>ra-&gt;next=pa;</p>\n<p>pa=pa-&gt;next;</p>\n<p>}</p>\n<p>}</p>\n<p>if(pa-&gt;next!=NULL)</p>\n<p>ra-&gt;next=pa;</p>\n<p>if(qa-&gt;next!=NULL)</p>\n<p>ra-&gt;next==qa;</p>\n<p>return R;</p>\n<p>}</p>\n<ol start=\"101\">\n<li>用递归算法判断数组 a[N] 是否为一个递增数组。</li>\n</ol>\n<p>递归的方法，记录当前最大的，并且判断当前的是否比这个还大，大则继续，否则返回 false 结束：</p>\n<p>bool fun( int a[], int n )</p>\n<p>{</p>\n<p>if( n= =1 )</p>\n<p>return true;</p>\n<p>if( n= =2 )</p>\n<p>return a[n-1] &gt;= a[n-2];</p>\n<p>return fun( a,n-1) &amp;&amp; ( a[n-1] &gt;= a[n-2] );</p>\n<p>}</p>\n<ol start=\"102\">\n<li>编写算法，从 10 亿个浮点数当中，选出其中最大的 10000 个。</li>\n</ol>\n<p>用外部排序，在《数据结构》书上有《计算方法导论》在找到第 n 大的数的算法上加工</p>\n<ol start=\"103\">\n<li>编写一 unix 程序，防止僵尸进程的出现 .</li>\n</ol>\n<p>同学的 4 道面试题，应聘的职位是搜索引擎工程师，后两道超级难，（希望大家多给一些算发）</p>\n<ol>\n<li>给两个数组和他们的大小，还有一动态开辟的内存，求交集，把交集放到动态内存 dongtai ，并且返回交集个数</li>\n</ol>\n<p>long jiaoji(long<em> a[],long b[],long</em> alength,long blength,long* dongtai[])</p>\n<ol start=\"2\">\n<li>单连表的建立，把 ‘a’–’z’26 个字母插入到连表中，并且倒叙，还要打印！</li>\n</ol>\n<p>方法 1 ：</p>\n<p>typedef struct val</p>\n<p>{   int date_1;</p>\n<pre><code>struct val *next;\n</code></pre><p>}*p;</p>\n<p>void main(void)</p>\n<p>{   char c;</p>\n<pre><code>for(c=122;c&gt;=97;c--)\n\n   { p.date=c;\n\n      p=p-&gt;next;\n\n    }\n\n\n\np.next=NULL;\n</code></pre><p>}</p>\n<p>}</p>\n<p>方法 2 ：</p>\n<p>node *p = NULL;</p>\n<p>node *q = NULL;</p>\n<p>node <em>head = (node</em>)malloc(sizeof(node));</p>\n<p>head-&gt;data = ‘ ‘;head-&gt;next=NULL;</p>\n<p>node <em>first = (node</em>)malloc(sizeof(node));</p>\n<p>first-&gt;data = ‘a’;first-&gt;next=NULL;head-&gt;next = first;</p>\n<p>p = first;</p>\n<p>int longth = ‘z’ - ‘b’;</p>\n<p>int i=0;</p>\n<p>while ( i&lt;=longth )</p>\n<p>{</p>\n<p>node <em>temp = (node</em>)malloc(sizeof(node));</p>\n<p>temp-&gt;data = ‘b’+i;temp-&gt;next=NULL;q=temp;</p>\n<p>head-&gt;next = temp; temp-&gt;next=p;p=q;</p>\n<p>i++;</p>\n<p>}</p>\n<p>print(head);</p>\n<ol start=\"104\">\n<li>可怕的题目终于来了</li>\n</ol>\n<p>象搜索的输入信息是一个字符串，统计 300 万输入信息中的最热门的前十条，我们每次输入的一个字符串为不超过 255byte, 内存使用只有 1G ,</p>\n<p>请描述思想，写出算发（ c 语言），空间和时间复杂度，</p>\n<ol start=\"7\">\n<li>国内的一些帖吧，如 baidu, 有几十万个主题，假设每一个主题都有上亿的跟帖子，怎么样设计这个系统速度最好，请描述思想，写出算发（ c 语言），空间和时间复杂度，</li>\n</ol>\n<p>#include   string.h</p>\n<p>main(void)</p>\n<p>{   char   *src=”hello,world”;</p>\n<pre><code>char   *dest=NULL;\n\ndest=(char    *)malloc(strlen(src));\n\nint   len=strlen(str);\n\nchar   *d=dest;\n\nchar   *s=src[len];\n\nwhile(len--!=0)\n\n  d++=s--;\n\nprintf(&quot;%s&quot;,dest);\n</code></pre><p>}</p>\n<p>找出错误！！</p>\n<p>#include   “string.h”</p>\n<p>#include “stdio.h”</p>\n<p>#include “malloc.h”</p>\n<p>main(void)</p>\n<p>{  </p>\n<p>char   *src=”hello,world”;</p>\n<pre><code>char   *dest=NULL;\n\ndest=(char   *)malloc(sizeof(char)*(strlen(src)+1));\n\nint   len=strlen(src);\n\nchar   *d=dest;\n\nchar   *s=src+len-1;\n\nwhile(len--!=0)\n\n  *d++=*s--;\n</code></pre><p>*d=’/0’;</p>\n<pre><code>printf(&quot;%s&quot;,dest);\n</code></pre><p>}</p>\n<ol start=\"105\">\n<li>判断字符串是否为回文</li>\n</ol>\n<p>bool IsSymmetry(const char * p)</p>\n<pre><code> {\n\n     assert(p!=NULL);\n\n     const char * q=p;      \n\n     int len=0;\n\n     while (*q++!=&#39;/0&#39; )\n\n     {\n\n          len++;\n\n     }       \n\n     bool bSign=true ;\n\n     q=p+len-1;\n\n     if (0&lt;len)\n\n     {\n\n          for (int i=0;i&lt;len/2;i++)\n\n          {\n\n               if (*p++!=*q--){ bSign=false ;break ;};\n\n          }\n\n     }\n\n     if (bSign==true )\n\n     {\n\n          printf(&quot;Yes!/n&quot; );\n\n     }\n\n     else\n\n     {\n\n          printf(&quot;No!/n&quot; );\n\n     }\n\n     return bSign;\n\n }\n</code></pre><p>107.ASDL 使用的是什么协议？并进行简单描述？</p>\n<p>108.Static 作用是什么</p>\n<p>首先 static 的最主要功能是隐藏，其次因为 static 变量存放在静态存储区，所以它具备持久性和默认值 0 。</p>\n<ol start=\"109\">\n<li>什么是预编译 , 何时需要预编译 ?</li>\n</ol>\n<p>预编译又称为预处理 , 是做些代码文本的替换工作。处理 # 开头的指令 , 比如拷贝 #include 包含的文件代码，#define 宏定义的替换 , 条件编译等，就是为编译做的预备工作的阶段，主要处理 # 开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。</p>\n<p>c 编译系统在对程序进行通常的编译之前，先进行预处理。 c 提供的预处理功能主要有以下三种： 1 ）宏定义　2 ）文件包含　 3 ）条件编译</p>\n<p>１、总是使用不经常改动的大型代码体。<br>２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。</p>\n<ol start=\"110\">\n<li>进程和线程的区别</li>\n</ol>\n<p>什么是进程（ Process ）：普通的解释就是，进程是程序的一次执行，而什么是线程（ Thread ），线程可以理解为进程中的执行的一段程序片段。在一个多任务环境中下面的概念可以帮助我们理解两者间的差别： </p>\n<p>进程间是独立的，这表现在内存空间，上下文环境；线程运行在进程空间内。 一般来讲（不使用特殊技术）进程是无法突破进程边界存取其他进程内的存储空间；而线程由于处于进程空间内，所以同一进程所产生的线程共享同一内存空间。 同一进程中的两段代码不能够同时执行，除非引入线程。线程是属于进程的，当进程退出时该进程所产生的线程都会被强制退出并清除。线程占用的资源要少于进程所占用的资源。 进程和线程都可以有优先级。在线程系统中进程也是一个线程。可以将进程理解为一个程序的第一个线程。</p>\n<p>线程是指进程内的一个执行单元 , 也是进程内的可调度实体 . 与进程的区别 :<br>(1) 地址空间 : 进程内的一个执行单元 ; 进程至少有一个线程 ; 它们共享进程的地址空间 ; 而进程有自己独立的地址空间 ;<br>(2) 进程是资源分配和拥有的单位 , 同一个进程内的线程共享进程的资源<br>(3) 线程是处理器调度的基本单位 , 但进程不是 .<br>(4) 二者均可并发执行 .</p>\n<ol start=\"111\">\n<li>插入排序和</li>\n</ol>\n<p>插入排序基本思想：（假定从大到小排序）依次从后面拿一个数和前面已经排好序的数进行比较，比较的过程是从已经排好序的数中最后一个数开始比较，如果比这个数，继续往前面比较，直到找到比它大的数，然后就放在它的后面，如果一直没有找到，肯定这个数已经比较到了第一个数，那就放到第一个数的前面。那么一般情况下，对于采用插入排序法去排序的一组数，可以先选 取第一个数做为已经排好序的一组数。然后把第二个放到正确位置。</p>\n<p>选择排序 (Selection Sort) 是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素 ,存放到排序序列的起始位置 , 然后 , 再从剩余未排序元素中继续寻找最小元素 , 然后放到排序序列末尾。以此类推, 直到所有元素均排序完毕。</p>\n<ol start=\"112\">\n<li>运算符优先级问题</li>\n</ol>\n<p>能正确表示 a 和 b 同时为正或同时为负的逻辑表达式是 (D ) 。</p>\n<p>sssA 、 (a&gt;=0||b&gt;=0) ＆＆ (a&lt;0||b&lt;0)<br>B 、 (a&gt;=0 ＆＆ b&gt;=0)&amp;&amp;(a&lt;0&amp; ＆ b&lt;0)<br>C 、 (a+b&gt;0) ＆＆ (a+b&lt;=0)<br>D 、 a*b&gt;0</p>\n<p>以下关于运算符优先顺序的描述中正确的是 (C) 。<br>A 、关系运算符 &lt; 算术运算符 &lt; 赋值运算符 &lt; 逻辑与运算符<br>B 、逻辑与运算符 &lt; 关系运算符 &lt; 算术运算符 &lt; 赋值运算符<br>C 、赋值运算符 &lt; 逻辑与运算符 &lt; 关系运算符 &lt; 算术运算符<br>D 、算术运算符 &lt; 关系运算符 &lt; 赋值运算符 &lt; 逻辑与运算符</p>\n<ol start=\"113\">\n<li>字符串倒序</li>\n</ol>\n<p>写一个函数将 “tom is cat” 倒序打印出来，即 “cat is tom”</p>\n<p>//a.ch</p>\n<p>#define SPACE ‘ ‘</p>\n<p>#define ENDL ‘/0’</p>\n<p>char<em> str = “Tom is cat”; // 字符串<br>char</em> p1 = str+strlen(str)-1;<br>char* p2 = p1; // 开始时， p1,p2 都指向字符串结尾处<br>char t=0; // 临时变量，用来保存被临时替换为 ENDL 的字符</p>\n<p>while(str!=p1–)<br>{<br>  if(SPACE!=<em>p1){<br>     for(p2=p1+1;SPACE!=</em>p1; p1–, t=<em>p2, </em>p2=ENDL);</p>\n<pre><code> // p1+1 指向单词的第一个字母 ,p2 指向单词的结尾 , 此时输出这个单词 \n            printf(&quot;%s &quot;,p1+1);\n            *p2=t;\n            p2=p1;\n     }\n</code></pre><p>}</p>\n<p>Output:<br>cat is Tom</p>\n<hr>\n<p>1) 写一个递归函数将内存中的字符串翻转 “abc”-&gt;”cba”<br>2) 写一个函数将 “tom is cat” 将内存中的字符串翻转，即 “cat is tomm” </p>\n<p>#include &lt;stdio.h&gt;</p>\n<p>#define SPACE ‘ ‘</p>\n<p>#define ENDL ‘/0’<br>char* s = “The quick brown fox jumps over the lazy dog”;</p>\n<p>void str_reverse(char<em> p1,char</em> p2){<br>      if(p1==p2)return;<br>    <em>p1 = (</em>p1)+(<em>p2);\n    </em>p2 = (<em>p1)-(</em>p2);<br>    <em>p1 = (</em>p1)-(*p2);<br>      if(p1==p2-1)return;<br>      else str_reverse(++p1,–p2);<br>}</p>\n<p>void str_word_reverse(char<em> str){<br>      char </em>q1=str, <em>q2=str, </em>t;</p>\n<pre><code>  while(*q1==SPACE)q1++;\n  if(*q1==ENDL)return; //!\n  else q2=q1+1;\n\n  while( (*q2!=SPACE) &amp;&amp; (*q2!=ENDL) )q2++;\n\n t=q2--; \nstr_reverse(q1,q2);\n\n  if(*t==ENDL)return;\n  else str_word_reverse(t);\n</code></pre><p>}</p>\n<p>int<br>main(int a ,char** b)<br>{<br>    printf(“%s/n”,s);<br>    str_reverse(s,s+strlen(s)-1);<br>    printf(“%s/n”,s);<br>    str_word_reverse(s);<br>    printf(“%s/n”,s);<br>           return 0;<br>}</p>\n<p>Output:</p>\n<p>The quick brown fox jumps over the lazy dog<br>god yzal eht revo spmuj xof nworb kciuq ehT<br>dog lazy the over jumps fox brown quick The</p>\n<hr>\n<p>今天同学又问一道题 , 和上面有些类似，但是要求更严格了一些：<br>写一个递归函数将内存中的字符串翻转 “abc”-&gt;”cba”, 并且函数原型已确定： void reverse(char* p)</p>\n<p>其实，要求越多，思路越确定，我的解如下： </p>\n<p>#include &lt;stdio.h&gt;</p>\n<p>#include &lt;string.h&gt;<br>char* s = “0123456789”;</p>\n<p>#define ENDL ‘/0’<br>void reverse(char<em> p){<br>       // 这是这种方法的关键，使用 static 为的是能用 str_reverse 的思路，但是不好<br>       static char</em> x=0;<br>       if(x==0)x=p;<br>       char<em> q = x+strlen(p)-1;<br>       if(p==q)return;\n       </em>q=(<em>p)^(</em>q);<br>       <em>p=(</em>p)^(<em>q);\n       </em>q =(<em>p)^(</em>q);<br>       if(q==p+1)return;<br>       reverse(++p);<br>}</p>\n<p>// 这种方法就直观多了，但是当字符串很长的时候就很低效<br>void reverse2(char<em> p){<br>       if(</em>(p+1)==ENDL)return;<br>       for(char<em> o=p+strlen(p)-1,char t=</em>o;o!=p;o–)<br>          <em>o=</em>(o-1);<br>       *p=t;<br>       reverse2(p+1);<br>}</p>\n<p>int main(int c,char** argv){<br>       reverse2(s);<br>       printf(“%s/n”,s);<br>       return 0;<br>}</p>\n<ol start=\"114\">\n<li>交换两个数的宏定义</li>\n</ol>\n<p>交换两个参数值的 宏定义 为： . #define SWAP (a,b) (a)=(a)+(b);(b)=(a)-(b);(a)=(a)-(b);</p>\n<p>115.Itearator 各指针的区别</p>\n<p>游标和指针</p>\n<p>我说过游标是指针，但不仅仅是指针。游标和指针很像，功能很像指针，但是实际上，游标是通过重载一元的 ”*”和 ”-&gt;” 来从容器中间接地返回一个值。将这些值存储在容器中并不是一个好主意，因为每当一个新值添加到容器中或者有一个值从容器中删除，这些值就会失效。在某种程度上，游标可以看作是句柄（ handle ）。通常情况下游标（ iterator ）的类型可以有所变化，这样容器也会有几种不同方式的转变：</p>\n<p>iterator—— 对于除了 vector 以外的其他任何容器，你可以通过这种游标在一次操作中在容器中朝向前的方向走一步。这意味着对于这种游标你只能使用 “++” 操作符。而不能使用 “–” 或 “+=” 操作符。而对于 vector 这一种容器，你可以使用 “+=” 、 “—” 、 “++” 、 “-=” 中的任何一种操作符和 “&lt;” 、 “&lt;=” 、 “&gt;” 、 “&gt;=” 、 “==” 、 “!=” 等比较运算符。</p>\n<ol start=\"116\">\n<li>C++ 中的 class 和 struct 的区别</li>\n</ol>\n<p>从语法上，在 C++ 中（只讨论 C++ 中）。 class 和 struct 做类型定义时只有两点区别：<br>（一）默认继承权限。如果不明确指定，来自 class 的继承按照 private 继承处理，来自 struct 的继承按照 public继承处理；<br>（二）成员的默认访问权限。 class 的成员默认是 private 权限， struct 默认是 public 权限。<br>除了这两点， class 和 struct 基本就是一个东西。语法上没有任何其它区别。</p>\n<p>不能因为学过 C 就总觉得连 C++ 中 struct 和 class 都区别很大，下面列举的说明可能比较无聊，因为 struct 和class 本来就是基本一样的东西，无需多说。但这些说明可能有助于澄清一些常见的关于 struct 和 class 的错误认识：<br>（ 1 ）都可以有成员函数；包括各类构造函数，析构函数，重载的运算符，友元类，友元结构，友元函数，虚函数，纯虚函数，静态函数；<br>（ 2 ）都可以有一大堆 public/private/protected 修饰符在里边；<br>（ 3 ）虽然这种风格不再被提倡，但语法上二者都可以使用大括号的方式初始化：</p>\n<p>A a = {1, 2, 3}; 不管 A 是个 struct 还是个 class ，前提是这个类 / 结构足够简单，比如所有的成员都是 public的，所有的成员都是简单类型，没有显式声明的构造函数。<br>（ 4 ）都可以进行复杂的继承甚至多重继承，一个 struct 可以继承自一个 class ，反之亦可；一个 struct 可以同时继承 5 个 class 和 5 个 struct ，虽然这样做不太好。<br>（ 5 ）如果说 class 的设计需要注意 OO 的原则和风格，那么没任何理由说设计 struct 就不需要注意。 </p>\n<h2 id=\"（-6-）再次说明，以上所有说法都是指在-C-语言中，至于在-C-里的情况，-C-里是根本没有-“class”-，而-C-的struct-从根本上也只是个包装数据的语法机制。\"><a href=\"#（-6-）再次说明，以上所有说法都是指在-C-语言中，至于在-C-里的情况，-C-里是根本没有-“class”-，而-C-的struct-从根本上也只是个包装数据的语法机制。\" class=\"headerlink\" title=\"（ 6 ）再次说明，以上所有说法都是指在 C++ 语言中，至于在 C 里的情况， C 里是根本没有 “class” ，而 C 的struct 从根本上也只是个包装数据的语法机制。 \"></a>（ 6 ）再次说明，以上所有说法都是指在 C++ 语言中，至于在 C 里的情况， C 里是根本没有 “class” ，而 C 的struct 从根本上也只是个包装数据的语法机制。 </h2><p>最后，作为语言的两个关键字，除去定义类型时有上述区别之外，另外还有一点点： “class” 这个关键字还用于定义模板参数，就像 “typename” 。但关键字 “struct” 不用于定义模板参数。</p>\n<p>关于使用大括号初始化</p>\n<p>　　 class 和 struct 如果定义了构造函数的话，都不能用大括号进行初始化</p>\n<p>　　如果没有定义构造函数， struct 可以用大括号初始化。</p>\n<p>　　如果没有定义构造函数，且所有成员变量全是 public 的话，可以用大括号初始化。</p>\n<p>　　关于默认访问权限</p>\n<p>　　 class 中默认的成员访问权限是 private 的，而 struct 中则是 public 的。</p>\n<p>　　关于继承方式</p>\n<p>　　 class 继承默认是 private 继承，而 struct 继承默认是 public 继承。</p>\n<p>　　关于模版</p>\n<p>　　在模版中，类型参数前面可以使用 class 或 typename ，如果使用 struct ，则含义不同， struct 后面跟的是“non-type template parameter” ，而 class 或 typename 后面跟的是类型参数。</p>\n<p>class 中有个默认的 this 指针， struct 没有<br>不同点：构造函数，析构函数  this  指针</p>\n<ol start=\"117\">\n<li>有关重载函数</li>\n</ol>\n<p>返回值类型不同构不成重载<br>参数参数顺序不同能构成重载</p>\n<p>c++ 函数同名不同返回值不算重载！函数重载是忽略返回值类型的。 </p>\n<hr>\n<p>成员函数被重载的特征有：<br>1) 相同的范围（在同一个类中）；<br>2) 函数名字相同；<br>3) 参数不同；<br>4) virtual 关键字可有可无。</p>\n<p>5) 成员函数中 有无 const ( 函数后面 ) 也可判断是否重载</p>\n<ol start=\"118\">\n<li>数据库与 T-SQL 语言 </li>\n</ol>\n<p>关系数据库是表的集合，它是由一个或多个关系模式定义。 SQL 语言中的数据定义功能包括对数据库、基本表、视图、索引的定义。</p>\n<ol start=\"119\">\n<li>关系模型的基本概念 </li>\n</ol>\n<p>  关系数据库以关系模型为基础，它有以下三部分组成：<br>    ● 数据结构 —— 模型所操作的对象、类型的集合<br>    ● 完整性规则 —— 保证数据有效、正确的约束条件<br>    ● 数据操作 —— 对模型对象所允许执行的操作方式<br>    关系（ Relation ）是一个由行和列组成的二维表格，表中的每一行是一条记录（ Record ），每一列是记录的一个字段（ Field ）。表中的每一条记录必须是互斥的，字段的值必须具有原子性。 </p>\n<p>120.SQL 语言概述</p>\n<pre><code>SQL （结构化查询语言）是关系数据库语言的一种国际标准，它是一种非过程化的语言。通过编写 SQL ，我们可以实现对关系数据库的全部操作。 \n● 数据定义语言（ DDL ） —— 建立和管理数据库对象 \n● 数据操纵语言（ DML ） —— 用来查询与更新数据 \n● 数据控制语言（ DCL ） —— 控制数据的安全性\n</code></pre><p>起来是一个很简单的问题，每一个使用过 RDBMS 的人都会有一个概念。</p>\n<p>事务处理系统的典型特点是具备 ACID 特征。 ACID 指的是 Atomic （原子的）、 Consistent （一致的）、Isolated （隔离的）以及 Durable （持续的），它们代表着事务处理应该具备的四个特征：</p>\n<p>原子性：组成事务处理的语句形成了一个逻辑单元，不能只执行其中的一部分</p>\n<p>一致性：在事务处理执行之前和之后，数据是一致的。</p>\n<p>隔离性：一个事务处理对另一个事务处理没有影响。</p>\n<p>持续性：当事务处理成功执行到结束的时候，其效果在数据库中被永久纪录下来。</p>\n<p>121.C 语言中结构化程序设计的三种基本控制结构</p>\n<p>顺序结构<br>选择结构<br>循环结构</p>\n<p>122.CVS 是什么</p>\n<p>cvs （ Concurrent Version System ） 是一个版本控制系统。使用它，可以记录下你的源文件的历史。 </p>\n<p>例如，修改软件时可能会不知不觉混进一些 bug ，而且可能过了很久你才会察觉到它们的存在。有了 cvs ，你可以很容易地恢复旧版本，并从中看出到底是哪个修改导致了这个 bug 。有时这是很有用的。 </p>\n<p>CVS 服务器端对每个文件维护着一个修订号 , 每次对文件的更新，都会使得文件的修订号加 1 。在客户端中也对每个文件维护着一个修订号 ,CVS 通过这两个修订号的关系，来进行 Update,Commit 和发现冲突等操作操作</p>\n<ol start=\"123\">\n<li>三种基本的数据模型</li>\n</ol>\n<p>按照数据结构类型的不同，将数据模型划分为层次模型、网状模型和关系模型。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjmren4ki0001ntnbbilee5pu","category_id":"cjmren4kn0003ntnbpm5ec6bt","_id":"cjmren4kr0006ntnb01mov7bk"},{"post_id":"cjmren4kp0004ntnbqy2n7trx","category_id":"cjmren4kq0005ntnbtzjclkzu","_id":"cjmren4ks0007ntnbzay94dk9"},{"post_id":"cjmren4lw000entnbpv54phw8","category_id":"cjmren4lt000cntnbufzuqfgc","_id":"cjmren4m1000jntnbukg1m92f"},{"post_id":"cjmren4lr000antnbnuross5e","category_id":"cjmren4lt000cntnbufzuqfgc","_id":"cjmren4m3000mntnb7xa05j5f"},{"post_id":"cjmren4ls000bntnb3asqrn05","category_id":"cjmren4lt000cntnbufzuqfgc","_id":"cjmren4m4000pntnbucutrhrv"},{"post_id":"cjmren4lu000dntnb26hnbsav","category_id":"cjmren4lt000cntnbufzuqfgc","_id":"cjmren4m6000sntnbeq7bonim"},{"post_id":"cjmren4m4000qntnbtb2jvgrg","category_id":"cjmren4m4000ontnbkpvjwmo2","_id":"cjmren4m8000wntnb44dofn33"},{"post_id":"cjmren4lx000fntnbmrozbwu6","category_id":"cjmren4m4000ontnbkpvjwmo2","_id":"cjmren4ma000zntnb8c3cggbu"},{"post_id":"cjmren4m0000hntnbz9fv2inv","category_id":"cjmren4m4000ontnbkpvjwmo2","_id":"cjmren4mb0012ntnbxfyl24tv"},{"post_id":"cjmren4m1000intnbbhmu5luc","category_id":"cjmren4m4000ontnbkpvjwmo2","_id":"cjmren4md0016ntnbn57ul83a"},{"post_id":"cjmren4m2000lntnbbkf7k1li","category_id":"cjmren4m4000ontnbkpvjwmo2","_id":"cjmren4mi001antnbkfy6s5rz"},{"post_id":"cjmren4m3000nntnb4v12d779","category_id":"cjmren4m4000ontnbkpvjwmo2","_id":"cjmren4mk001dntnbvrc1fx7i"},{"post_id":"cjmren4m5000rntnbhdlzlbq6","category_id":"cjmren4mi0019ntnbr3zkkl9l","_id":"cjmren4mm001intnb0ot2p79f"},{"post_id":"cjmren4m7000untnblyykao53","category_id":"cjmren4mi0019ntnbr3zkkl9l","_id":"cjmren4mo001lntnbmze8c4rd"},{"post_id":"cjmren4m8000vntnbu6uza3mz","category_id":"cjmren4ml001hntnbp86w2owe","_id":"cjmren4mq001qntnbz4khzr93"},{"post_id":"cjmren4m9000yntnbi71wmxot","category_id":"cjmren4ml001hntnbp86w2owe","_id":"cjmren4mr001untnbzfnajkv0"},{"post_id":"cjmren4ma0010ntnb8dqcbvk5","category_id":"cjmren4ml001hntnbp86w2owe","_id":"cjmren4mt001yntnbocrfyhnq"},{"post_id":"cjmren4mb0013ntnbmlsw514q","category_id":"cjmren4ml001hntnbp86w2owe","_id":"cjmren4mv0022ntnbjwpdh04q"},{"post_id":"cjmren4mc0014ntnbjd6jjucr","category_id":"cjmren4ml001hntnbp86w2owe","_id":"cjmren4mx0026ntnbh3b417fu"},{"post_id":"cjmren4me0017ntnbhkhyszs3","category_id":"cjmren4ml001hntnbp86w2owe","_id":"cjmren4mz002antnb5v847b2j"},{"post_id":"cjmren4mh0018ntnbnmti58g4","category_id":"cjmren4ml001hntnbp86w2owe","_id":"cjmren4n1002entnbz2nd045d"},{"post_id":"cjmren4mi001bntnbskl8povh","category_id":"cjmren4ml001hntnbp86w2owe","_id":"cjmren4n3002hntnbfxk14fm3"},{"post_id":"cjmren4mj001cntnb0ll5lmqq","category_id":"cjmren4n1002dntnbdg1tcvbb","_id":"cjmren4n5002nntnbjxzo32dk"},{"post_id":"cjmren4mk001fntnb6ct1twrv","category_id":"cjmren4n1002dntnbdg1tcvbb","_id":"cjmren4n7002rntnbsvccqwt4"},{"post_id":"cjmren4ml001gntnbdt0ffvck","category_id":"cjmren4n1002dntnbdg1tcvbb","_id":"cjmren4n9002vntnbcl7zpufm"},{"post_id":"cjmren4mm001jntnbzft1zj8r","category_id":"cjmren4n1002dntnbdg1tcvbb","_id":"cjmren4nb002yntnbyhb25dla"},{"post_id":"cjmren4mn001kntnbhqibz2vc","category_id":"cjmren4n9002untnb5zbuslc5","_id":"cjmren4nd0033ntnb8djashnq"},{"post_id":"cjmren4mo001nntnbtu2gehrx","category_id":"cjmren4n9002untnb5zbuslc5","_id":"cjmren4nf0037ntnbvo5shhcm"},{"post_id":"cjmren4mp001ontnbbpshvpvt","category_id":"cjmren4n9002untnb5zbuslc5","_id":"cjmren4nh003bntnb7ldagg79"},{"post_id":"cjmren4mq001rntnbioh7wvza","category_id":"cjmren4n9002untnb5zbuslc5","_id":"cjmren4nj003fntnb85rm2uop"},{"post_id":"cjmren4mr001sntnbh3dfy0hx","category_id":"cjmren4n9002untnb5zbuslc5","_id":"cjmren4nm003jntnbsy4fshc3"},{"post_id":"cjmren4ms001vntnbv3wiao5i","category_id":"cjmren4n9002untnb5zbuslc5","_id":"cjmren4no003nntnbde2q0xe6"},{"post_id":"cjmren4ms001wntnb0sutndtt","category_id":"cjmren4n9002untnb5zbuslc5","_id":"cjmren4ns003rntnb4ayv8svg"},{"post_id":"cjmren4mt001zntnb5309m8ru","category_id":"cjmren4n9002untnb5zbuslc5","_id":"cjmren4nv003untnbbwh7u0fe"},{"post_id":"cjmren4mu0020ntnb7517wcna","category_id":"cjmren4ns003qntnbr9910jwy","_id":"cjmren4nx003yntnbjbuk72xe"},{"post_id":"cjmren4mv0023ntnb059tvmoj","category_id":"cjmren4n9002untnb5zbuslc5","_id":"cjmren4nx0040ntnbit2c7wuo"},{"post_id":"cjmren4mw0024ntnb06abteil","category_id":"cjmren4n9002untnb5zbuslc5","_id":"cjmren4ny0042ntnbttyuocsj"},{"post_id":"cjmren4mx0027ntnbxmz4854j","category_id":"cjmren4n9002untnb5zbuslc5","_id":"cjmren4ny0044ntnb8rizklfe"},{"post_id":"cjmren4my0028ntnboylfkl13","category_id":"cjmren4n9002untnb5zbuslc5","_id":"cjmren4nz0046ntnbvxrahqm4"},{"post_id":"cjmren4mz002bntnb83iua28o","category_id":"cjmren4n9002untnb5zbuslc5","_id":"cjmren4o00048ntnbddq2wsfd"},{"post_id":"cjmren4n0002cntnby8e5tmsz","category_id":"cjmren4n9002untnb5zbuslc5","_id":"cjmren4o00049ntnbwqh2lw1r"},{"post_id":"cjmren4n1002fntnbu5pdm2lr","category_id":"cjmren4o00047ntnbbtoikehg","_id":"cjmren4o1004cntnbyajeq1jr"},{"post_id":"cjmren4n2002gntnb26fmh806","category_id":"cjmren4o00047ntnbbtoikehg","_id":"cjmren4o1004dntnb2fpkr1f6"},{"post_id":"cjmren4n3002intnbw7609353","category_id":"cjmren4o1004bntnbipn4punl","_id":"cjmren4o2004gntnb3fgn8hqd"},{"post_id":"cjmren4n4002kntnbnbq3ao6s","category_id":"cjmren4o1004bntnbipn4punl","_id":"cjmren4o2004intnbr7wo234y"},{"post_id":"cjmren4n5002lntnbl02y53dq","category_id":"cjmren4o1004bntnbipn4punl","_id":"cjmren4o3004kntnbvq1hcj3l"},{"post_id":"cjmren4n6002ontnb6yj8huwo","category_id":"cjmren4o1004bntnbipn4punl","_id":"cjmren4o4004mntnbl4ihs4k1"},{"post_id":"cjmren4n7002pntnb7shu6uea","category_id":"cjmren4o1004bntnbipn4punl","_id":"cjmren4o4004ontnbji3jb8vj"},{"post_id":"cjmren4n8002sntnbevhotovo","category_id":"cjmren4o1004bntnbipn4punl","_id":"cjmren4o5004qntnbapk8aang"},{"post_id":"cjmren4n9002tntnbtm58v298","category_id":"cjmren4o1004bntnbipn4punl","_id":"cjmren4o5004sntnb78kfp4ud"},{"post_id":"cjmren4na002wntnbpxnrrvok","category_id":"cjmren4o1004bntnbipn4punl","_id":"cjmren4o6004untnbp9j1ou7i"},{"post_id":"cjmren4na002xntnbpxw81wnh","category_id":"cjmren4o1004bntnbipn4punl","_id":"cjmren4o6004wntnbm8z0wxqh"},{"post_id":"cjmren4nc0030ntnbgj3i6grc","category_id":"cjmren4o1004bntnbipn4punl","_id":"cjmren4o7004yntnbnyvyo0jp"},{"post_id":"cjmren4nc0031ntnbuflp886o","category_id":"cjmren4o1004bntnbipn4punl","_id":"cjmren4o7004zntnbdm8axpbf"},{"post_id":"cjmren4ne0034ntnbqh23kvzo","category_id":"cjmren4o7004xntnbi4nomcmb","_id":"cjmren4o80051ntnblurrvi7o"},{"post_id":"cjmren4ne0035ntnbin9q6kpa","category_id":"cjmren4o70050ntnbsp0wr6fq","_id":"cjmren4o80054ntnbv2moebpz"},{"post_id":"cjmren4ng0038ntnbf4v4k9qy","category_id":"cjmren4o70050ntnbsp0wr6fq","_id":"cjmren4o90056ntnbeixtnb8l"},{"post_id":"cjmren4ng0039ntnb49fmmud1","category_id":"cjmren4o70050ntnbsp0wr6fq","_id":"cjmren4oa0058ntnbtazsp4uf"},{"post_id":"cjmren4ni003cntnbjt0rmxlo","category_id":"cjmren4o70050ntnbsp0wr6fq","_id":"cjmren4oa005antnbnipjxhoi"},{"post_id":"cjmren4ni003dntnb7zy37d4n","category_id":"cjmren4o70050ntnbsp0wr6fq","_id":"cjmren4ob005cntnb1auf4sie"},{"post_id":"cjmren4nk003gntnb9qcw32po","category_id":"cjmren4o70050ntnbsp0wr6fq","_id":"cjmren4ob005dntnbzket7b8b"},{"post_id":"cjmren4nl003hntnb11zhf5hp","category_id":"cjmren4oa005bntnb7bkpsmdk","_id":"cjmren4od005gntnbghgvnbi8"},{"post_id":"cjmren4nm003kntnb8il7cjqq","category_id":"cjmren4oa005bntnb7bkpsmdk","_id":"cjmren4od005intnbat0vquhl"},{"post_id":"cjmren4nn003lntnb8r2wqs3z","category_id":"cjmren4oa005bntnb7bkpsmdk","_id":"cjmren4od005jntnbh8gzyxrj"},{"post_id":"cjmren4no003ontnbm1ea20bb","category_id":"cjmren4od005hntnbqd6y5nud","_id":"cjmren4oe005mntnbi2a77pln"},{"post_id":"cjmren4nr003pntnbhkerhd72","category_id":"cjmren4od005hntnbqd6y5nud","_id":"cjmren4of005ontnbf7mnlmnt"},{"post_id":"cjmren4nt003sntnbt9g13rg4","category_id":"cjmren4od005hntnbqd6y5nud","_id":"cjmren4of005pntnb47zsus8l"},{"post_id":"cjmren4nu003tntnb7uqzbn8s","category_id":"cjmren4of005nntnb6oi7e8ra","_id":"cjmren4og005rntnb9sc4urc9"},{"post_id":"cjmren4nv003wntnb3s28nga2","category_id":"cjmren4of005nntnb6oi7e8ra","_id":"cjmren4og005sntnbngj6muli"},{"post_id":"cjmren4oj005tntnb2uapfyzv","category_id":"cjmren4o7004xntnbi4nomcmb","_id":"cjmren4ok005untnbivddpek7"},{"post_id":"cjmren4oq005vntnb8i5vx6fd","category_id":"cjmren4lt000cntnbufzuqfgc","_id":"cjmren4or005wntnbgzh8omiy"},{"post_id":"cjmren4os005xntnbzqdrapz2","category_id":"cjmren4o1004bntnbipn4punl","_id":"cjmren4ou005zntnb28h3zcw5"},{"post_id":"cjmren4ot005yntnbyatzaiwf","category_id":"cjmren4o1004bntnbipn4punl","_id":"cjmren4ou0060ntnb9rtyoehm"},{"post_id":"cjmren4ox0061ntnbfoblm73x","category_id":"cjmren4m4000ontnbkpvjwmo2","_id":"cjmren4oz0062ntnbbzxmtshn"}],"PostTag":[],"Tag":[]}}