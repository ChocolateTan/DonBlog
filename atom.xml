<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Don Blog</title>
  
  
  <link href="/DonBlog/atom.xml" rel="self"/>
  
  <link href="https://chocolatetan.github.io/DonBlog/"/>
  <updated>2018-10-02T08:50:28.955Z</updated>
  <id>https://chocolatetan.github.io/DonBlog/</id>
  
  <author>
    <name>Don Tam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/hello-world/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/hello-world/</id>
    <published>2018-10-02T08:50:28.955Z</published>
    <updated>2018-10-02T08:50:28.955Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android音频开发</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/android/androidyin-pin-kai-fa/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/android/androidyin-pin-kai-fa/</id>
    <published>2018-10-02T08:50:28.954Z</published>
    <updated>2018-10-02T08:50:28.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android音频开发"><a href="#Android音频开发" class="headerlink" title="Android音频开发"></a>Android音频开发</h2><h3 id="Android音频简介"><a href="#Android音频简介" class="headerlink" title="Android音频简介"></a>Android音频简介</h3><p>更加详尽的参考：</p><p> <a href="http://www.jianshu.com/p/2cb75a71009f" target="_blank" rel="noopener">http://www.jianshu.com/p/2cb75a71009f</a></p><p> <a href="http://blog.csdn.net/cjh_android/article/details/51341004" target="_blank" rel="noopener">http://blog.csdn.net/cjh_android/article/details/51341004</a></p><p> 其他下载网站：<a href="https://www.xiph.org/downloads/" target="_blank" rel="noopener">https://www.xiph.org/downloads/</a></p><h4 id="AudioRecord"><a href="#AudioRecord" class="headerlink" title="AudioRecord"></a><strong>AudioRecord</strong></h4><p>主要是实现边录边播（AudioRecord+AudioTrack）以及对音频的实时处理（如会说话的汤姆猫、语音）</p><p>优点：语音的实时处理，可以用代码实现各种音频的封装</p><p>缺点：输出是PCM语音数据，如果保存成音频文件，是不能够被播放器播放的，所以必须先写代码实现数据编码以及压缩</p><p>示例：</p><p>使用AudioRecord类录音，并实现WAV格式封装。录音20s，输出的音频文件大概为3.5M左右（已写测试代码）</p><h4 id="MediaRecorder"><a href="#MediaRecorder" class="headerlink" title="MediaRecorder"></a><strong>MediaRecorder</strong></h4><p>已经集成了录音、编码、压缩等，支持少量的录音音频格式，大概有.aac（API = 16） .amr .3gp</p><p>优点：大部分以及集成，直接调用相关接口即可，代码量小</p><p>缺点：无法实时处理音频；输出的音频格式不是很多，例如没有输出mp3格式文件</p><p>示例：</p><p>使用MediaRecorder类录音，输出amr格式文件。录音20s，输出的音频文件大概为33K（已写测试代码）</p><h4 id="音频格式比较"><a href="#音频格式比较" class="headerlink" title="音频格式比较"></a><strong>音频格式比较</strong></h4><p>WAV格式：录音质量高，但是压缩率小，文件大</p><p>AAC格式：相对于mp3，AAC格式的音质更佳，文件更小；有损压缩；一般苹果或者Android SDK4.1.2（API 16）及以上版本支持播放</p><p>AMR格式：压缩比比较大，但相对其他的压缩格式质量比较差，多用于人声，通话录音</p><p>至于常用的mp3格式，使用MediaRecorder没有该视频格式输出。一些人的做法是使用AudioRecord录音，然后编码成wav格式，再转换成mp3格式</p><hr><h3 id="Android关于MediaRecorder开发"><a href="#Android关于MediaRecorder开发" class="headerlink" title="Android关于MediaRecorder开发"></a>Android关于MediaRecorder开发</h3><p>采用频率（the sampling rate）：模拟信息转成数字信号的采样率。</p><p>采样位数：8位 或者 16位 去存储每一次的采样结果。</p><p>声道数：单声道，立体声道。</p><p>比特率（Bit rate ）/位率：声音中的比特率是指将模拟声音信号转换成数字声音信号后，单位时间内的二进制数据量，是间接衡量音频质量的一个指标。</p><p>比特率(bps) = 采样频率（HZ）采样位数（Bit）声道数</p><pre><code class="java">setAudioEncodingBitRateMediaRecorder recorder = new MediaRecorder();recorder.setAudioSource(MediaRecorder.AudioSource.MIC);if (Build.VERSION.SDK_INT &gt;= 10) {    recorder.setAudioSamplingRate(44100);    recorder.setAudioEncodingBitRate(96000);    recorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);    recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);} else {    // older version of Android, use crappy sounding voice codec    recorder.setAudioSamplingRate(8000);    recorder.setAudioEncodingBitRate(12200);    recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);    recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);}recorder.setOutputFile(file.getAbsolutePath());try {    recorder.prepare();} catch (IOException e) {    throw new RuntimeException(e);}</code></pre><p>setAudioEncodingBitRate</p><p>这个方法，声音会变得奇怪，类似回音之类，这个参数会影响输出文件的效果，尽量按照bit rate设置。</p><p>setAudioSamplingRate</p><p>一般参数为44100 16000 11025，这个影响文件采集效果，直接影响录音质量和文件大小。</p><hr><h3 id="Android关于AudioRecorder开发"><a href="#Android关于AudioRecorder开发" class="headerlink" title="Android关于AudioRecorder开发"></a>Android关于AudioRecorder开发</h3><blockquote><p>参考：<a href="http://www.cnblogs.com/tyjsjl/p/3695122.html" target="_blank" rel="noopener">http://www.cnblogs.com/tyjsjl/p/3695122.html</a></p></blockquote><hr><h3 id="使用FFmpeg"><a href="#使用FFmpeg" class="headerlink" title="使用FFmpeg"></a>使用FFmpeg</h3><blockquote><p>项目地址：<a href="https://github.com/WritingMinds/ffmpeg-android-java" target="_blank" rel="noopener">https://github.com/WritingMinds/ffmpeg-android-java</a></p></blockquote><hr><h3 id="MediaRecorder和AudioRecorder获取分贝"><a href="#MediaRecorder和AudioRecorder获取分贝" class="headerlink" title="MediaRecorder和AudioRecorder获取分贝"></a>MediaRecorder和AudioRecorder获取分贝</h3><p>在使用AudioRecorder的时候读取流计算分贝必须要用short[]类型计算</p><blockquote><p><a href="http://blog.csdn.net/sno_guo/article/details/42428587" target="_blank" rel="noopener">http://blog.csdn.net/sno_guo/article/details/42428587</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="Android" scheme="https://chocolatetan.github.io/DonBlog/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>ReactNative ImageView</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/ReactNative/javascriptimageview/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/ReactNative/javascriptimageview/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.950Z</updated>
    
    <content type="html"><![CDATA[<p>创建一个ViewManager的子类。</p><p>实现createViewInstance方法。</p><p>导出视图的属性设置器：使用@ReactProp（或@ReactPropGroup）注解。</p><p>把这个视图管理类注册到应用程序包的createViewManagers里。</p><p>实现JavaScript模块。</p><pre><code class="java">public class ReactImageManager extends SimpleViewManager&lt;ReactImageView&gt; {  public static final String REACT_CLASS = &quot;RCTImageView&quot;;  @Override  public String getName() {    return REACT_CLASS;  }  @Override  public ReactImageView createViewInstance(ThemedReactContext context) {    return new ReactImageView(context, Fresco.newDraweeControllerBuilder(), mCallerContext);  }</code></pre><p>导出给JavaScript使用的属性，需要申明带有<code>@ReactProp</code>（或<code>@ReactPropGroup</code>）注解的设置方法.</p><p>方法的第一个参数是要修改属性的视图实例，第二个参数是要设置的属性值</p><p>方法的返回值类型必须为<code>void</code></p><p>声明为<code>public</code></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="ReactNative" scheme="https://chocolatetan.github.io/DonBlog/categories/ReactNative/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ Format的用法总结</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/C++/CPPFormat%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/C++/CPPFormat的用法总结/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Format的用法总结"><a href="#C-Format的用法总结" class="headerlink" title="C++ Format的用法总结"></a>C++ Format的用法总结</h1><p>##函数声明<br>  function Format(const Format: string; const Args: array of const): string; overload; </p><p>##函数功能<br>  事实上Format方法有两个种形式，另外一种是三个参数的，主要区别在于它是线程安全的， 但并不多用，所以这里只对第一个介绍。Format参数是一个格式字符串，用于格式化Args里面的值的。Args是一个变体数组，即它里面可以有多个参数，而且每个参数可以不同。 例如： </p><pre><code class="c++">Format(&quot;my name is %6s&quot;,&quot;wind&quot;);   返回的是：my name is wind </code></pre><p>##函数参数<br>  Format里面可以写普通的字符串，比如”my name is” ，但有些格式指令字符具有特殊意义，比如”%6s”<br>  格式指令具有以下的形式： “%” [index “:”] [“-“] [width] [“.” prec] type<br>  它是以”%”开始,而以type结束，type表示一个具体的类型。中间是用来格式化type类型的指令字符，是可选的。各个参数的含义与用途如下；   [type]<br>type参数可选的类型有d，u，f，e，g，n，m，p，s，x. </p><p>(1) d 十进制数，表示一个整型值，u 和d一样是整型值，但它是无符号的，而如果它对应的值是负的，则返回时是一个2的32次方减去这个负数的绝对值 。</p><p>例如：</p><p><code>Format(&quot;this is %u&quot;,-2);</code>   </p><p>返回的是：</p><p><code>this is 4294967294</code></p><p>(2)f 对应浮点数 </p><p>(3)e科学表示法，对应整型数和浮点数<br>例如：</p><p><code>Format(&quot;this is %e&quot;,-2.22);</code>  </p><p>返回的是：</p><p><code>this is -2.220000E+000</code></p><p>(4)g 这个只能对应浮点型，且它会将值中多余的数去掉<br>例如：</p><p><code>Format(&quot;this is %g&quot;,02.200);</code> </p><p>返回的是：</p><p><code>this is 2.2</code></p><p>(5)n 只能对应浮点型，将值转化为号码的形式，看一个例子就明白了   </p><p>例如：</p><p><code>Format(&quot;this is %n&quot;,4552.2176);</code>  </p><p>返回的是：</p><p><code>this is 4,552.22</code></p><p>注意：一是，只表示到小数后两位;二是，即使小数没有被截断，它也不会也像整数部分一样有逗号来分开的 </p><p>(6)m 钱币类型，但关于货币类型有更好的格式化方法，这里只是简单的格式化，另外它只对应于浮点值<br>  例如：</p><pre><code class="c++">Format(&quot;this is %m&quot;,9552.21); </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="cpp" scheme="https://chocolatetan.github.io/DonBlog/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ \#pragma once与 \#ifndef的区别</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/C++/CPPpragmaonce%E4%B8%8Eifndef%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/C++/CPPpragmaonce与ifndef的区别/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-pragma-once与-ifndef的区别"><a href="#C-pragma-once与-ifndef的区别" class="headerlink" title="C++ #pragma once与 #ifndef的区别"></a>C++ #pragma once与 #ifndef的区别</h1><p>#pragma once与 #ifndef的区别</p><p>为了避免同一个文件被include多次</p><pre><code class="c++">#ifndef方式#pragma once方式</code></pre><p>在能够支持这两种方式的编译器上，二者并没有太大的区别，但是两者仍然还是有一些细微的区别。<br>方式一：</p><pre><code class="c++">#ifndef __SOMEFILE_H__#define __SOMEFILE_H__... ... // 一些声明语句#endif方式二：#pragma once... ... // 一些声明语句</code></pre><p>#ifndef的方式依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。当然，缺点就是如果不同头文件的宏名不小心“撞车”，可能就会导致头文件明明存在，编译器却硬说找不到声明的状况</p><p>#pragma once则由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。带来的好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，重复包含更容易被发现并修正。</p><p>方式一由语言支持所以移植性好，方式二 可以避免名字冲突</p><blockquote><p>来源：</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="cpp" scheme="https://chocolatetan.github.io/DonBlog/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 处理 JSON 数据交换格式</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/C++/CPP%E5%A4%84%E7%90%86JSON%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%A0%BC%E5%BC%8F/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/C++/CPP处理JSON数据交换格式/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-处理-JSON-数据交换格式"><a href="#C-处理-JSON-数据交换格式" class="headerlink" title="C++ 处理 JSON 数据交换格式"></a>C++ 处理 JSON 数据交换格式</h1><hr><p>使用 C++ 处理 JSON 数据交换格式</p><hr><p>##一、摘要<br>JSON 的全称为：JavaScript Object Notation，顾名思义，JSON 是用于标记 Javascript 对象的，JSON 官方的解释为：JSON 是一种轻量级的数据传输格式。<br>本文并不详细介绍 JSON 本身的细节，旨在讨论如何使用 C++ 语言来处理 JSON。关于 JSON更具体的信息，可参见 JSON 官网：<a href="http://www.json.org。" target="_blank" rel="noopener">http://www.json.org。</a></p><hr><p>##二、本文选择处理 JSON的 C++ 库<br>本文选择一个第三方库 jsoncpp 来解析 JSON。jsoncpp 是比较出名的 C++ JSON 解析库。在 JSON官网也是首推的。<br>下载地址为：<a href="http://sourceforge.net/projects/jsoncpp。本文使用的" target="_blank" rel="noopener">http://sourceforge.net/projects/jsoncpp。本文使用的</a> jsoncpp 版本为：0.5.0。</p><hr><p>##三、jsoncpp 在 Windows 下的编译<br>要使用第三方源码库，第一步少不了的就是编译，将源码文件编译成我们方便使用的动态链接库、静态链接库或者静态导入库[1]。<br>jsconcpp 进行 JSON 解析的源码文件分布在 include/json、src/lib_json 下。其实 jsoncpp 源码并不多，为了方便产品管理，此处没必要将其编译为动态链接库或者静态导入库，所以我们选择使用静态链接库[2]。<br>jsoncpp 已经处理的很完善了，所有编译选项都已经配置好，打开makefiles/vs71/jsoncpp.sln 便可以开始编译（默认是使用 VS2003 编译器的，打开时直接按照 VS2005 提示转换即可）。</p><hr><p>##四、jsoncpp 使用详解<br>jsoncpp 主要包含三种类型的 class：Value、Reader、Writer。jsoncpp 中所有对象、类名都在namespace Json 中，包含 json.h 即可。</p><p>Json::Value 只能处理 ANSI 类型的字符串，如果 C++ 程序是用 Unicode 编码的，最好加一个 Adapt类来适配。</p><p>###1、Value<br>Json::Value 是jsoncpp 中最基本、最重要的类，用于表示各种类型的对象，jsoncpp 支持的对象类型可见 Json::ValueType 枚举值。<br>可如下是用 Json::Value 类：</p><pre><code class="c++">Json::Value json_temp;      // 临时对象，供如下代码使用json_temp[&quot;name&quot;] = Json::Value(&quot;huchao&quot;);json_temp[&quot;age&quot;] = Json::Value(26);Json::Value root;  // 表示整个 json 对象root[&quot;key_string&quot;] = Json::Value(&quot;value_string&quot;);         // 新建一个 Key（名为：key_string），赋予字符串值：&quot;value_string&quot;。root[&quot;key_number&quot;] = Json::Value(12345);            // 新建一个 Key（名为：key_number），赋予数值：12345。root[&quot;key_boolean&quot;] = Json::Value(false);              // 新建一个 Key（名为：key_boolean），赋予bool值：false。root[&quot;key_double&quot;] = Json::Value(12.345);            // 新建一个 Key（名为：key_double），赋予 double值：12.345。root[&quot;key_object&quot;] = Json_temp;                           // 新建一个 Key（名为：key_object），赋予json::Value 对象值。root[&quot;key_array&quot;].append(&quot;array_string&quot;);             // 新建一个 Key（名为：key_array），类型为数组，对第一个元素赋值为字符串：&quot;array_string&quot;。root[&quot;key_array&quot;].append(1234);                           // 为数组 key_array 赋值，对第二个元素赋值为：1234。Json::ValueType type = root.type();// 获得 root 的类型，此处为 objectValue 类型。</code></pre><p>注：跟C++ 不同，JavaScript 数组可以为任意类型的值，所以 jsoncpp 也可以。<br>    如上几个用法已经可以满足绝大部分 json 应用了，当然 jsoncpp 还有一些其他同能，比如说设置注释、比较 json 大小、交换 json 对象等，都很容易使用，大家自己尝试吧。</p><p>###2、Writer<br>如上说了 Json::Value 的使用方式，现在到了该查看刚才赋值内容的时候了，查看 json 内容，使用 Writer 类即可。<br>Jsoncpp 的 Json::Writer 类是一个纯虚类，并不能直接使用。在此我们使用 Json::Writer 的子类：Json::FastWriter、Json::StyledWriter、Json::StyledStreamWriter。<br>顾名思义，用 Json::FastWriter 来处理 json 应该是最快的，下面我们来试试。</p><pre><code class="c++">Json::FastWriter fast_writer;std::cout &lt;&lt; fast_writer.write(root) &lt;&lt; std::endl;</code></pre><p>输出结果为：</p><pre><code class="json">{&quot;key_array&quot;:[&quot;array_string&quot;,1234],&quot;key_boolean&quot;:false,&quot;key_double&quot;:12.3450,&quot;key_number&quot;:12345,&quot;key_object&quot;:{&quot;age&quot;:26,&quot;name&quot;:&quot;huchao&quot;},&quot;key_string&quot;:&quot;value_string&quot;}</code></pre><p>再次顾名思义，用 Json::StyledWriter 是格式化后的 json，下面我们来看看 Json::StyledWriter 是怎样格式化的。</p><pre><code class="c++">Json::StyledWriter styled_writer;std::cout &lt;&lt; styled_writer.write(root) &lt;&lt; std::endl;</code></pre><p>输出结果为：</p><pre><code class="json">{   &quot;key_array&quot; : [ &quot;array_string&quot;, 1234 ],   &quot;key_boolean&quot; : false,   &quot;key_double&quot; : 12.3450,   &quot;key_number&quot; : 12345,   &quot;key_object&quot; : {      &quot;age&quot; : 26,      &quot;name&quot; : &quot;huchao&quot;   },   &quot;key_string&quot; : &quot;value_string&quot;}</code></pre><p>###3、Reader<br>Json::Reader 是用于读取的，说的确切点，是用于将字符串转换为 Json::Value 对象的，下面我们来看个简单的例子。</p><pre><code class="c++">  Json::Reader reader;  Json::Value json_object;  const char* json_document = &quot;{/&quot;age/&quot; : 26,/&quot;name/&quot; : /&quot;huchao/&quot;}&quot;;  if (!reader.parse(json_document, json_object))    return 0;  std::cout &lt;&lt; json_object[&quot;name&quot;] &lt;&lt; std::endl;  std::cout &lt;&lt; json_object[&quot;age&quot;] &lt;&lt; std::endl;</code></pre><p>输出结果为：</p><pre><code class="json">&quot;huchao&quot;</code></pre><p>可见，上述代码已经解析出了 json 字符串。</p><blockquote><p>[1]：使用第三方源码最简单的方法是直接将文件加入工程，但这样不利于源码、软件产品管理，对于一般软件开发来说，不建议使用。</p></blockquote><blockquote><p>[2]：如果真需要编译成动态链接库、静态导入库的话，可以使用 VS 新建一个工程属性，然后在Project –&gt; Properties中进行相应的设置即可。</p><p>来源：<br>[1]: <a href="http://blog.csdn.net/xt_xiaotian/article/details/5648388" target="_blank" rel="noopener">http://blog.csdn.net/xt_xiaotian/article/details/5648388</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="cpp" scheme="https://chocolatetan.github.io/DonBlog/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>C++的list和vector有什么区别</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/C++/CPP%E7%9A%84list%E5%92%8Cvector%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/C++/CPP的list和vector有什么区别/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-的list和vector有什么区别"><a href="#C-的list和vector有什么区别" class="headerlink" title="C++的list和vector有什么区别"></a>C++的list和vector有什么区别</h1><hr><p>总结：list链结构存储 vector是连续内存空间存储，当后者内存空间不够会影响效率<br>前者由于是链结构，遍历时会影响搜索效率，但很好支持插入删除的操作</p><p>vector和数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随机存取（即使用[]操作符访问其中的元素），但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝（复杂度是O(n)），另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。</p><p>list是由数据结构中的双向链表实现的，因此它的内存空间可以是不连续的。因此只能通过指针来进行数据的访问，这个特点使得它的随机存取变的非常没有效率，需要遍历中间的元素，搜索复杂度O(n)，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。<br>由于list和vector上面的这些区别，因此list::iterator与vector::iterator也有一些不同。请看下面的例子：</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;using namespace std;int main( void ){        vector&lt;int&gt; v;         list&lt;int&gt; l;        for (int i=0; i&lt;8; i++)     //往v和l中分别添加元素        {                v.push_back(i);                l.push_back(i);        }        cout &lt;&lt; &quot;v[2] = &quot; &lt;&lt; v[2] &lt;&lt; endl;        //cout &lt;&lt; &quot;l[2] = &quot; &lt;&lt; l[2] &lt;&lt; endl;       //编译错误,list没有重载[]        cout &lt;&lt; (v.begin() &lt; v.end()) &lt;&lt; endl;        //cout &lt;&lt; (l.begin() &lt; l.end()) &lt;&lt; endl;   //编译错误,list::iterator没有重载&lt;或&gt;        cout &lt;&lt; *(v.begin() + 1) &lt;&lt; endl;        vector&lt;int&gt;::iterator itv = v.begin();        list&lt;int&gt;::iterator itl = l.begin();        itv = itv + 2;        //itl = itl + 2;                  //编译错误,list::iterator没有重载+        itl++;itl++;                    //list::iterator中重载了++，只能使用++进行迭代访问。        cout &lt;&lt; *itv &lt;&lt; endl;        cout &lt;&lt; *itl &lt;&lt; endl;        return 0;}</code></pre><p>由于vector拥有一段连续的内存空间，能非常好的支持随机存取，因此vector<int>::iterator支持“+”、“+=”、“&lt;”等操作符。<br>而list的内存空间可以是不连续，它不支持随机访问，因此list<int>::iterator则不支持“+”、“+=”、“&lt;”等操作符运算，因此代码20、26行会有编译错误。只能使用“++”进行迭代，例如代码27行，使用两次itl++来移动itl。还有list也不支持[]运算符，因此代码18行出现编译错误。总之，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector；如果需要大量的插入和删除，而不关心随即存取，则应使用list。</int></int></p><p>答案： vector拥有一段连续的内存空间，因此支持随机存取，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector。list拥有一段不连续的内存空间，因此支持随机存取，如果需要大量的插入和删除，而不关心随即存取，则应使用list。</p><blockquote><p>来源：<br>[1]: <a href="http://genwoxuevc.blog.51cto.com/1852984/503337" target="_blank" rel="noopener">http://genwoxuevc.blog.51cto.com/1852984/503337</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="cpp" scheme="https://chocolatetan.github.io/DonBlog/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>C++识别不同的运行平台linux和win32</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/C++/CPP%E8%AF%86%E5%88%AB%E4%B8%8D%E5%90%8C%E7%9A%84%E8%BF%90%E8%A1%8C%E5%B9%B3%E5%8F%B0linux%E5%92%8Cwin32/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/C++/CPP识别不同的运行平台linux和win32/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-08T03:40:40.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-识别不同的运行平台linux和win32"><a href="#C-识别不同的运行平台linux和win32" class="headerlink" title="C++识别不同的运行平台linux和win32"></a>C++识别不同的运行平台linux和win32</h1><p><img src="/DonBlog/2018/10/02/C++/CPP识别不同的运行平台linux和win32/79341078.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="cpp" scheme="https://chocolatetan.github.io/DonBlog/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>UTF-8带签名和无签名的区别</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/C++/UTF-8%E5%B8%A6%E7%AD%BE%E5%90%8D%E5%92%8C%E6%97%A0%E7%AD%BE%E5%90%8D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/C++/UTF-8带签名和无签名的区别/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UTF-8带签名和无签名的区别"><a href="#UTF-8带签名和无签名的区别" class="headerlink" title="UTF-8带签名和无签名的区别"></a>UTF-8带签名和无签名的区别</h1><p>在VS中编码保存时，文件编码的选择里的UTF-8有带签名和无签名2种，那么到底有什么区别呢？<br>带签名即文件头含BOM信息，不带则没有。<br>带了的好处是，只要支持多编码的编辑器都能正确识别出文件编码。<br>不带的话，就不一定了，就有可能识别错别。<br>总之呢，这个BOM信息也就那么三字节，没必要省这么一点点空间，要用UFT-8就选带签名，这样就不会错了。</p><p>另外，VS2008似乎不能设置默认的编码格式，中文版的默认编码格式是gb2312，英文版的是utf-8。如果要想保存成其他的编码格式，可以在“文件”-〉“高级保存选项”中更改</p><blockquote><p>来源：<br>[1]: <a href="http://blog.csdn.net/crystal_ooo/article/details/8077141" target="_blank" rel="noopener">http://blog.csdn.net/crystal_ooo/article/details/8077141</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="cpp" scheme="https://chocolatetan.github.io/DonBlog/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>C#不重复启动窗口</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/CShape/CShape%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%90%AF%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/CShape/CShape不重复启动窗口/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-不重复启动窗口"><a href="#C-不重复启动窗口" class="headerlink" title="C#不重复启动窗口"></a>C#不重复启动窗口</h1><p>只启动一个窗体,如果再次启动则激活该窗体 </p><pre><code class="c#">using System;using System.Collections.Generic;using System.Windows.Forms;using System.Diagnostics;using System.Runtime.InteropServices;namespace TEST{    static class Program    {        /// &lt;summary&gt;        /// 应用程序的主入口点。        /// &lt;/summary&gt;        [DllImport(&quot;User32.dll&quot;)]        private static extern bool ShowWindowAsync(IntPtr hWnd, int cmdShow);        [DllImport(&quot;User32.dll&quot;)]        private static extern bool SetForegroundWindow(IntPtr hWnd);        private const int WS_SHOWNORMAL = 1;        [STAThread]        static void Main()        {            //得到正在运行的例程            Process instance = RunningInstance();            if (instance == null)            {                //如果没有其它例程，就新建一个窗体                Application.EnableVisualStyles();                Application.SetCompatibleTextRenderingDefault(false);                Application.Run(new Form1());            }            else            {                //处理发现的例程                HandleRunningInstance(instance);            }        }        /// &lt;summary&gt;        /// 得到正在运行的进程        /// &lt;/summary&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public static Process RunningInstance()        {            Process current = Process.GetCurrentProcess();            Process[] processes = Process.GetProcessesByName(current.ProcessName);            //遍历正在有相同名字运行的进程            foreach (Process process in processes)            {                //忽略现有的进程                if (process.Id != current.Id)                {                    //确保进程从EXE文件运行                    if (process.MainModule.FileName == current.MainModule.FileName)                    {                        // 返回另一个进程实例                        return process;                    }                }            }            //没有其它的进程，返回Null            return null;        }        /// &lt;summary&gt;        /// 处理正在运行的进程,也就是将其激活        /// &lt;/summary&gt;        /// &lt;param name=&quot;instance&quot;&gt;要处理的进程&lt;/param&gt;        public static void HandleRunningInstance(Process instance)        {            //确保窗口没有被最小化或最大化            ShowWindowAsync(instance.MainWindowHandle, WS_SHOWNORMAL);            //设置真实进程为foreground window            SetForegroundWindow(instance.MainWindowHandle);        }    }}</code></pre><blockquote><p>来源：<br>[1]: <a href="http://blog.csdn.net/xiefuzhen/article/details/4095683" target="_blank" rel="noopener">http://blog.csdn.net/xiefuzhen/article/details/4095683</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="CShape" scheme="https://chocolatetan.github.io/DonBlog/categories/CShape/"/>
    
    
  </entry>
  
  <entry>
    <title>C#使用Mutex实现程序单实例运行</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/CShape/CShape%E4%BD%BF%E7%94%A8Mutex%E5%AE%9E%E7%8E%B0%E7%A8%8B%E5%BA%8F%E5%8D%95%E5%AE%9E%E4%BE%8B%E8%BF%90%E8%A1%8C/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/CShape/CShape使用Mutex实现程序单实例运行/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-使用Mutex实现程序单实例运行"><a href="#C-使用Mutex实现程序单实例运行" class="headerlink" title="C#使用Mutex实现程序单实例运行"></a>C#使用Mutex实现程序单实例运行</h1><p>大家在开发程序的时候，有时需要限制程序，只能同时运行一个实例，实现此功能，对于VB.NET是非常容易的，只要指定一个属性即可，但是C#实现起来，就稍微繁琐了。<br>C#实现单实例运行的方法，也有多种，比如利用 Process 查找进程的方式，利用 API findwindow 查找窗体的方式，还有就是 利用 Mutex 原子操作，上面几种方法中， 综合考虑利用 Mutex 的方式是较好的选择。<br>下面给出使用 Mutex 实现单实例运行的例子：<br>C# 中，找到 program.cs ，这里面的 </p><pre><code class="c#">[STAThread]staticvoid Main(){    //……}</code></pre><p>是程序运行的入口点，默认情况下，里面的代码大致如下： </p><pre><code class="c#">[STAThread]static void Main(){    Application.EnableVisualStyles();    Application.SetCompatibleTextRenderingDefault(false);    Application.Run(new Form1());}</code></pre><p>复制代码<br>加入单实例限制后的代码如下： </p><pre><code class="c#">[STAThread]static void Main(){    bool isAppRunning = false;    System.Threading.Mutex mutex = new System.Threading.Mutex(        true,        System.Diagnostics.Process.GetCurrentProcess().ProcessName,        out isAppRunning);    if (!isAppRunning)    {        MessageBox.Show(&quot;本程序已经在运行了，请不要重复运行！&quot;);        Environment.Exit(1);    }    else    {        Application.EnableVisualStyles();        Application.SetCompatibleTextRenderingDefault(false);        Application.Run(new Form1());    }}</code></pre><p>另一个利用Mutex实现互斥的类</p><pre><code class="c#">using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading ; namespace 多线程 {     class Mutex互斥类     {         public static void Main()         {             //Mutex互斥类主要特点就是进程间共享，进程间互相排斥，抢锁,用名称做标识。             bool createdNew ;             Mutex mutex = new Mutex( false , &quot;Aladdin&quot; , out createdNew ) ;             if( mutex.WaitOne(1000,false ) )             {                 try                 {                     Console.WriteLine( &quot;正常启动。。。。。&quot; ) ;                     Console.ReadLine() ;                 }                 finally                 {                     mutex.ReleaseMutex() ;                 }             }             else             {                 Console.WriteLine( &quot;你已经启动了一个了，不要再闹了&quot; ) ;                 Console.Read() ;             }             //注，如果单纯判断一个互斥线程是不是已经存在，可以直接用createdNew out参数来判断         }     } }</code></pre><blockquote><p>来源：<br>[1]: <a href="http://hi.baidu.com/szhesh/item/c3c28b27ebf5423394f62b01" target="_blank" rel="noopener">http://hi.baidu.com/szhesh/item/c3c28b27ebf5423394f62b01</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="CShape" scheme="https://chocolatetan.github.io/DonBlog/categories/CShape/"/>
    
    
  </entry>
  
  <entry>
    <title>iis发布含有视频的网站</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/CShape/iis%E5%8F%91%E5%B8%83%E5%90%AB%E6%9C%89%E8%A7%86%E9%A2%91%E7%9A%84%E7%BD%91%E7%AB%99/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/CShape/iis发布含有视频的网站/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iis发布含有视频的网站"><a href="#iis发布含有视频的网站" class="headerlink" title="iis发布含有视频的网站"></a>iis发布含有视频的网站</h1><p>win2003下<br>打开IIS，然后在 mypc（本地计算机） 上面点击右键属性（很多帮助文件都没有说这一点，很多人以为是在站点上面点击右键，却发现找不到MIME类型，其中mypc是你的计算机名）<br>图片点击可在新窗口打开查看<br>然后点击“MIME类型”，接着点击新建，<br>flv格式是加入关联扩展名：.flv，内容类型：application/octet-stream<br>f4v格式是扩展名：.f4v，内容类型：application/octet-stream<br>mp4格式是扩展名：.mp4，内容类型：video/mp4<br>要注意的是，内容类型并不是跟扩展名配套的，你起别的名称一要，只是做个说明而已<br>确定以后，服务器就可以支持FLV,f4v,mp4视频播放了，如果依然不可以的话，可以尝试重新启动IIS！<br>win7的iis里<br>默认支持flv文件 调用使用时路径用绝对路径就可以了，比如你的视频在video/a.flv的，请直接用/video/a.flv，如果需要支持f4v,mp4请参考2003的设置</p><p> <img src="/DonBlog/2018/10/02/CShape/iis发布含有视频的网站/image001.jpg" alt=""></p><p>转载:ckplayer.com</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="CShape" scheme="https://chocolatetan.github.io/DonBlog/categories/CShape/"/>
    
    
  </entry>
  
  <entry>
    <title>vs发布网站中 &quot;允许更新此预编译站点&quot;和网站安全、首次速度的关系</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/CShape/vs%E5%8F%91%E5%B8%83%E7%BD%91%E7%AB%99%E4%B8%AD%E5%85%81%E8%AE%B8%E6%9B%B4%E6%96%B0%E6%AD%A4%E9%A2%84%E7%BC%96%E8%AF%91%E7%AB%99%E7%82%B9%E5%92%8C%E7%BD%91%E7%AB%99%E5%AE%89%E5%85%A8%E9%A6%96%E6%AC%A1%E9%80%9F%E5%BA%A6%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/CShape/vs发布网站中允许更新此预编译站点和网站安全首次速度的关系/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vs发布网站中-“允许更新此预编译站点”和网站安全、首次速度的关系"><a href="#vs发布网站中-“允许更新此预编译站点”和网站安全、首次速度的关系" class="headerlink" title="vs发布网站中 “允许更新此预编译站点”和网站安全、首次速度的关系"></a>vs发布网站中 “允许更新此预编译站点”和网站安全、首次速度的关系</h1><p>对于使用VS2008（包括vs2005,vs2010）开发的网站，想要发布后上传到网站空间中，是否理解了：“允许更新此预编译站点”？下边详细介绍了它的区别：</p><p>“生成 ”→“发布网站 ”；弹出对话框！</p><p>在打开的对话框中，有一个选项是至关重要的，那就是“允许更新此预编译站点 ”；</p><p>“允许更新此预编译站点”这一项，默认情况下，前面是打上一个√的，至于要不要打上一个√，是可选的，那么，打勾与不打勾，有何区别呢？</p><p>也许大家都曾经发布过net网站，一般情况下，网站项目中的所有CS文件，会自动生成一个DLL动态链接库，这就能够很好的保护网站的源代码，因为代码一般都是放在CS文件里面的，既然都生成了DLL文件，那么，上传到虚拟空间，别人就不能打开来看了！</p><p>但是，其它的文件，诸如ashx、aspx等文件，里面原来有什么，就是什么，别人可以打开这些文件来查看，尽管别人看不见CS代码，但是仍然能够看见ASPX文件里面的HTML代码或部分服务器控件及相关的属性；</p><p>还有，ashx这样的文件，就相当于一个cs文件，里面的代码也是能够看见的。</p><p>因此，cs文件倒是安全了，但是网站中的ASPX、asxh等文件，是不安全的；对于整个网站而言，只有局部的安全，而没有整体的安全。</p><p>那么，到底有没有一种办法，让上传到虚拟空间的网站文件，都安全呢？方法是有的，通过“允许更新此预编译站点”这一项前面的√，就能实现；</p><p>①给“允许更新此预编译站点”打√</p><p>如果您给此项打勾，然后发布网站，那么，结果是这样的，整个网站文件，除了所有的CS文件编译成为一个DLL文件之外，其它的文件，和原来的没有任何变化，里面是什么，还是什么，只要别人通过记事本一打开，里面的代码、HTML代码等，都可以让别人一览无余。</p><p>除此之外，通过此种方式发布的网站，当用户第一次访问某个页面的时候，需要经过编译，查找BUG，之后，如果没有任何错误，才能正常访问，因此，速度会变得比较慢。(第二次、第三次……访问，速度就正常了)</p><p>②取消“允许更新此预编译站点”前面的√</p><p>如果您在发布网站的时候，取消了“允许更新此预编译站点”前面的勾，那么，结果是这样的：</p><p>１、网站里面的所有CS文件，都被编译成为一个DLL文件；</p><p>２、除了cs文件，其它的文件，诸如ASPX、ASHX等文件，也一同被编译起来，每个文件都在BIN目录里面生成一个对应的*.compiled文件；<br>允许更新此预编译站点DLL</p><p>之后，如果您通过记事本查看ASPX、ASHX等文件，里面不会看到任何的代码，就连HTML代码标记都看不见，打开这样的文件，里面只有一行文字，内容为“这是预编译工具生成的标记文件，不应被删除!”<br>允许更新此预编译站点ASPX</p><p>但是，网站的访问却是正常的，不会出现任何不良的问题。</p><p>所以呢，使用这种方式发布网站，什么文件都不能通过记事本打开，里面显示的都是一行文字，因此，网站文件就非常安全了。</p><p>此外，通过此种方法发布的网站，所有内容都编译好了，打开的速度是很快的。</p><blockquote><p>来源：<br>[1]:<a href="http://www.camnpr.com/archives/640.html" target="_blank" rel="noopener">http://www.camnpr.com/archives/640.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="CShape" scheme="https://chocolatetan.github.io/DonBlog/categories/CShape/"/>
    
    
  </entry>
  
  <entry>
    <title>Hadoop筆記</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/Hadoop/MacHadoop%E5%AE%89%E8%A3%9D/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/Hadoop/MacHadoop安裝/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.943Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mac-Hadoop筆記"><a href="#Mac-Hadoop筆記" class="headerlink" title="Mac Hadoop筆記"></a>Mac Hadoop筆記</h3><p><a href="http://www.linuxidc.com\/Linux\/2016-10\/136188.htm" target="_blank" rel="noopener">www.linuxidc.com\/Linux\/2016-10\/136188.htm</a></p><p>mac 启动sshd</p><p>sudo launchctl load -w \/System\/Library\/LaunchDaemons\/ssh.plist</p><p>查看启动</p><p>sudo launchctl list | grep ssh</p><p>输出- 0 com.openssh.sshd 表示启动成功</p><p>停止sshd服务</p><p>sudo launchctl unload -w \/System\/Library\/LaunchDaemons\/ssh.plist</p><p>命令查找java home</p><p>\/usr\/libexec\/java_home</p><ol><li>sudo .\/configure</li><li>sudo make</li><li>sudo make check</li><li>sudo make install</li><li>protoc –version</li></ol><h3 id="mvn"><a href="#mvn" class="headerlink" title="mvn"></a>mvn</h3><p>打包：mvn package</p><p>编译：mvn compile</p><p>编译测试程序：mvn test-compile</p><p>清空：mvn clean</p><p>运行测试：mvn test</p><p>生成站点目录: mvn site</p><p>生成站点目录并发布：mvn site-deploy</p><p>安装当前工程的输出文件到本地仓库: mvn install</p><p>mvn compile：编译源代码,生成对应的CLASS文件，执行流程可见流程如图3</p><p>mvn test-compile：编译<strong><a href="http://lib.csdn.net/base/softwaretest" title="软件测试知识库" target="_blank" rel="noopener">测试</a></strong>代码,生成对应的CLASS文件，执行流程可见流程如图3</p><p>mvn test：运行测试,生成对应的CLASS文件，执行流程可见流程如图3</p><p>mvn package：打包,生成JAR文件，只能本程序用，或者拷贝到其它项目使用，执行流程可见流程如图3</p><p>mvn install ：打包,生成JAR文件，并在本地仓库生成JAR和POM文件，供其它Maven项目共享,，执行流程可见流程如图3；</p><p>mvn clean ：清除产生的项目</p><ul><li>$ mvn -version</li><li>$ mvn clean</li><li>$ mvn install -DskipTests</li><li>$ mvn compile -DskipTests</li><li>$ mvn package -DskipTests</li><li>$ mvn package -Pdist -DskipTests -Dtar</li></ul><p>mvn package -Pdist,native,docs,src -DskipTests -Dtar</p><h3 id="Mac系统的环境变量，加载顺序为："><a href="#Mac系统的环境变量，加载顺序为：" class="headerlink" title="Mac系统的环境变量，加载顺序为："></a>Mac系统的环境变量，加载顺序为：</h3><p>\/etc\/profile \/etc\/paths ~\/.bash_profile ~\/.bash_login ~\/.profile ~\/.bashrc</p><h3 id="Mac命令"><a href="#Mac命令" class="headerlink" title="Mac命令"></a>Mac命令</h3><p>rm -r -f 文件夹名</p><h3 id="Hadoop-localhost"><a href="#Hadoop-localhost" class="headerlink" title="Hadoop localhost"></a>Hadoop localhost</h3><p>http:\/\/localhost:9870\/</p><p>http:\/\/localhost:8088\/cluster</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="Hadoop" scheme="https://chocolatetan.github.io/DonBlog/categories/Hadoop/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac安装protobuf</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/Hadoop/macbian-yi-hadoop/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/Hadoop/macbian-yi-hadoop/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mac安装protobuf"><a href="#Mac安装protobuf" class="headerlink" title="Mac安装protobuf"></a>Mac安装protobuf</h3><p>编译 Hadoop需要使用protobuf2.5.0</p><blockquote><p>参考：<a href="http://www.jianshu.com/p/8e88c3ef47b3" target="_blank" rel="noopener">http://www.jianshu.com/p/8e88c3ef47b3</a></p></blockquote><pre><code>tar -zxf  protobuf-2.6.1.tar.gz./configure --prefix=/Users/don/tool/protobuf  这个目录记得更改为自己的//make clean//不使用这个有可能会出现找不到protobuf/lib/libprotobuf.9.dylibmakemake installvi ~/.bash_profile//输入内容export PROTOBUF=/Users/don/tool/protobufexport PATH=$PROTOBUF/bin:$PATHsource ~/.bash_profileprotoc --version</code></pre><pre><code>mvn package -e -X -Pdist,native -DskipTests -Dtar</code></pre><p>编译错误</p><pre><code>[ERROR] Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:1.7:run (make) on project hadoop-pipes: An Ant BuildException has occured: exec returned: 1[ERROR] around Ant part ...&lt;exec failonerror=&quot;true&quot; dir=&quot;/Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/native&quot; executable=&quot;cmake&quot;&gt;... @ 5:131 in /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml[ERROR] -&gt; [Help 1]org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:1.7:run (make) on project hadoop-pipes: An Ant BuildException has occured: exec returned: 1around Ant part ...&lt;exec failonerror=&quot;true&quot; dir=&quot;/Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/native&quot; executable=&quot;cmake&quot;&gt;... @ 5:131 in /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:212)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116)    at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80)    at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)    at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307)    at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193)    at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106)    at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863)    at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288)    at org.apache.maven.cli.MavenCli.main(MavenCli.java:199)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke(Method.java:498)    at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)    at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)    at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)Caused by: org.apache.maven.plugin.MojoExecutionException: An Ant BuildException has occured: exec returned: 1around Ant part ...&lt;exec failonerror=&quot;true&quot; dir=&quot;/Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/native&quot; executable=&quot;cmake&quot;&gt;... @ 5:131 in /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml    at org.apache.maven.plugin.antrun.AntRunMojo.execute(AntRunMojo.java:355)    at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)    at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207)    ... 20 moreCaused by: /Users/don/Downloads/hadoop-2.7.3-src/hadoop-tools/hadoop-pipes/target/antrun/build-main.xml:5: exec returned: 1    at org.apache.tools.ant.taskdefs.ExecTask.runExecute(ExecTask.java:646)    at org.apache.tools.ant.taskdefs.ExecTask.runExec(ExecTask.java:672)    at org.apache.tools.ant.taskdefs.ExecTask.execute(ExecTask.java:498)    at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)    at sun.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke(Method.java:498)    at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)    at org.apache.tools.ant.Task.perform(Task.java:348)    at org.apache.tools.ant.Target.execute(Target.java:390)    at org.apache.tools.ant.Target.performTasks(Target.java:411)    at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)    at org.apache.tools.ant.Project.executeTarget(Project.java:1368)    at org.apache.maven.plugin.antrun.AntRunMojo.execute(AntRunMojo.java:327)    ... 22 more[ERROR] [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException[ERROR] [ERROR] After correcting the problems, you can resume the build with the command[ERROR]   mvn &lt;goals&gt; -rf :hadoop-pipes</code></pre><p>检查提示中对应的buil-main.xml文件，找到该exec语句，在控制台中尝试执行</p><pre><code>cmake /Users/lishengda/Downloads/hadoop-2.7.0-src/hadoop-tools/hadoop-pipes/src/ -DJVM_ARCH_DATA_MODEL=64</code></pre><pre><code>-- The C compiler identification is AppleClang 8.1.0.8020038-- The CXX compiler identification is AppleClang 8.1.0.8020038-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc -- works-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Detecting C compile features-- Detecting C compile features - done-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++ -- works-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Detecting CXX compile features-- Detecting CXX compile features - doneCMake Error at /usr/local/Cellar/cmake/3.7.2/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:138 (message):  Could NOT find OpenSSL, try to set the path to OpenSSL root folder in the  system variable OPENSSL_ROOT_DIR (missing: OPENSSL_INCLUDE_DIR)Call Stack (most recent call first):  /usr/local/Cellar/cmake/3.7.2/share/cmake/Modules/FindPackageHandleStandardArgs.cmake:378 (_FPHSA_FAILURE_MESSAGE)  /usr/local/Cellar/cmake/3.7.2/share/cmake/Modules/FindOpenSSL.cmake:385 (find_package_handle_standard_args)  CMakeLists.txt:20 (find_package)-- Configuring incomplete, errors occurred!</code></pre><p>提示显示没找到openssl,需要添加环境变量，于是添加</p><p>命令行执行：vim ~/.bash_profile</p><p>在打开的文件中添加如下两行（具体vim怎么用请另行查询）</p><p>export OPENSSL_ROOT_DIR=/usr/local/Cellar/openssl/1.0.2j</p><p>export OPENSSL_INCLUDE_DIR=/usr/local/Cellar/openssl/1.0.2j/include</p><p>退出后执行source ~/.bash_profile使之生效</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="Hadoop" scheme="https://chocolatetan.github.io/DonBlog/categories/Hadoop/"/>
    
    
  </entry>
  
  <entry>
    <title>从0开始PHP</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/PHP/cong_0_kai_shi_php/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/PHP/cong_0_kai_shi_php/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从0开始PHP"><a href="#从0开始PHP" class="headerlink" title="从0开始PHP"></a>从0开始PHP</h1><p>山寨一个网站</p><p>##1.山寨网站<br><a href="http://cinephilia.net/" target="_blank" rel="noopener">cinephilia谜影</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="php" scheme="https://chocolatetan.github.io/DonBlog/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>Laravel</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/PHP/laravel/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/PHP/laravel/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.947Z</updated>
    
    <content type="html"><![CDATA[<h3 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h3><p>參數按照順序與名稱無關</p><pre><code class="php">Route::get(&#39;posts/{post}/comments/{comment}&#39;, function ($postId, $commentId) {    //});</code></pre><h3 id="可選參數"><a href="#可選參數" class="headerlink" title="可選參數"></a>可選參數</h3><pre><code class="php">Route::get(&#39;user/{name?}&#39;, function ($name = null) {    return $name;});Route::get(&#39;user/{name?}&#39;, function ($name = &#39;John&#39;) {    return $name;});</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="php" scheme="https://chocolatetan.github.io/DonBlog/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP 常用</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/PHP/php_chang_yong/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/PHP/php_chang_yong/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP-常用"><a href="#PHP-常用" class="headerlink" title="PHP 常用"></a>PHP 常用</h1>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="php" scheme="https://chocolatetan.github.io/DonBlog/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP判断为空</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/PHP/phppan_duan_wei_kong/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/PHP/phppan_duan_wei_kong/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP判断为空"><a href="#PHP判断为空" class="headerlink" title="PHP判断为空"></a>PHP判断为空</h1>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="php" scheme="https://chocolatetan.github.io/DonBlog/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>Java生态</title>
    <link href="https://chocolatetan.github.io/DonBlog/2018/10/02/Java/Java%E7%94%9F%E6%80%81/"/>
    <id>https://chocolatetan.github.io/DonBlog/2018/10/02/Java/Java生态/</id>
    <published>2018-10-02T01:09:09.000Z</published>
    <updated>2018-10-02T08:50:28.945Z</updated>
    
    <content type="html"><![CDATA[<p>Java、JDBC、SQL、HTML、DIV+CSS、JavaScript、JQuery、DOM、JQuery EasyUI、Servlet、JSP、Cookie、Session、AJAX、JSON、反射、注解、多线程、线程池、SoftReference、WeakReference、EL表达式、正则表达式、MD5、BASE64、DES、AES、序列化、泛型等技术Spring、SpringMVC、MVC架构XML、DOM4J、HTML5、Socket、ECharts、POI、FreeMarker、页面静态化、iText、WebService、Quartz、IO、HttpClient、JSONP、JavaBean、RESTFul、AOP、SQL语句、JMS、缓存、消息队列、集合、HTTP协议MongoDB、Redis、Memcached 都是NoSQL序列 Redis、Memcached，现在Redis很火Oracle、MySQL，互联网公司Oracle很少用，除非政府、银行等等会用到，一般互联网公司都是MySQL 数据库连接池工具：C3P0、DBCP、Druid （知道怎么样使用就可以）搜索引擎或者框架： Lucene、Solr、Elasticsearch , 目前Elasticsearch 比较火，Solr和Elasticsearch 都是基于LuceneIK中文分词器：会和 搜索引擎或者框架 整合，Struts2、SpringMVC，现在很多互联网公司都使用SpringMVC，但是，还有很多公司使用 Struts2Hibernate、MyBatis、iBatis，现在互联网公司都是用MyBatis（MyBatis的前身是iBatis），还有部分公司使用Hibernate、反射和注解（Annotation）、泛型 是Java领域的非常重要的技术，几乎所有框架都离不开反射和注解， 例如：Spring消息队列框架：ActiveMQ、ZeroMQ、RabbitMQ、RocketMQ， RabbitMQ 会用得稍微多一点Java领域常用的JSON框架： Jackson、FastJson、Gson 现在比较火的技术：微服务、面向服务（SOA）微服务:Spring Boot SOA：Dubbo（阿里开源），DubboX（当当网团队维护Dubbo的一个版本），还有360的，微博的MySQL集群：主从复制、一主多从，多主多从MySQL的中间件：MyCat， MyCat可以很简单地实现读写分离，分库分表（横向和纵向拆分）服务器或者服务器容器：Tomcat RPCNetty：Java领域当前最牛逼、最火爆 高性能网络通信框架， Dubbo底层、Hadoop、Spark、Storm等等大数据分布式框架或者平台，都是使用Netty实现网络通信分布式：把一个单一的系统拆成多个独立的服务或者微服务，实现分布式框架FastDFS：是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，目前主要用于图片存储比较多</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="Java" scheme="https://chocolatetan.github.io/DonBlog/categories/Java/"/>
    
    
  </entry>
  
</feed>
